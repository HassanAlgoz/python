[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "مقدمة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-نبرمج",
    "href": "index.html#لماذا-نبرمج",
    "title": "البايثونية",
    "section": "لماذا نبرمج؟",
    "text": "لماذا نبرمج؟\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nثم أدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة التخزين.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة ويشغِّل هذه الإلكترونيات المجهرية لتحقيق مقصوده منها.\nثم الفعل؛ بإرسال إشارات عبر منافذ الأجهزة المتصلة به حتى تتحول المعالجة الدقيقة لنتيجة ظاهرة جلية. فتنطبع صورة على الشاشة لنراها، وتصدر ذبذبة هوائية نسمعها، وإشارات متتابعة لحركة مفاصل ذراع آلية .. أو إلى آلة منطقية أخرى متصلة بالشبكة العالمية.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لمن-هذا-الكتاب",
    "href": "index.html#لمن-هذا-الكتاب",
    "title": "البايثونية",
    "section": "لمن هذا الكتاب؟",
    "text": "لمن هذا الكتاب؟\nبدأت بوادر تأليف هذا الكتاب أثناء تدريسي البرمجة بلغة بايثون لخريجي التخصصات التقنية تمهيدًا لهم للدخول في علوم البيانات والذكاء الاصطناعي. فأردت أن أضع مادة جامعة شاملة لأهم مفاهيم البرمجة في مستوى تطبيقي مناسبٍ لذلك الغرض؛ فلا ينزل إلى التفاصيل الدقيقة التي لا يحتاج إليها.\nثم أعدت النظر فيه فراعيت أصحاب التخصصات غير التقنية إذْ لم أغرِق في التفاصيل الرياضية ولا الحاسوبية الدقيقة.\n\nفمن أراد أن يبدأ في البرمجة فليبدأ بهذا الكتاب؛ فالمواضيع منظمة بشكل منطقي وعملي مع مسائل نافعة للمبرمج تقترب في كل مرة من الواقع أكثر فأكثر.\nومن أراد مرجِعًا لمواضيع البرمجة بلغة بايثون فهذا الكتاب صديقه؛ فالكتاب مقسَّم بحسب الموضوعات وكل موضوعٍ مقسَّم كذلك لتسهيل الوصول إلى أي مفهوم. كما تستطيع استعمال خاصيَّة البحث.\nوهو كذلك معينٌ لمن أراد تدريس البرمجة منطلقًا من لغة بايثون؛ فقد جمعتُ فيه ما تفرَّق ونظمتُه بعد نظرٍ في عدة مؤلفات مماثلة، وعلى ما رأيتُ أنه أنفع للمتعلم، وأضفتُ بعض الأقسام المتممة لما رأيت أنه ناقص بدونها.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#أهداف-الكتاب",
    "href": "index.html#أهداف-الكتاب",
    "title": "البايثونية",
    "section": "أهداف الكتاب",
    "text": "أهداف الكتاب\n\nاستيعاب ماهية البرمجة، ومعرفة إمكانياتها وحدودها\nإكساب مهارة التعبير الخوارزمي بلغة بايثون\nامتلاك القدرة على فتح مكتبات برمجية بايثونية والاستفادة من النتاج المعرفي البرمجي المتراكم في بناء تطبيقات مفيدة",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-وقع-الاختيار-على-لغة-بايثون",
    "href": "index.html#لماذا-وقع-الاختيار-على-لغة-بايثون",
    "title": "البايثونية",
    "section": "لماذا وقع الاختيار على لغة بايثون؟",
    "text": "لماذا وقع الاختيار على لغة بايثون؟\nصممت بايثون لتكون عالية المستوى: أي مجردة عن كثير من التفاصيل الحاسوبية التي لا يهتم لها غير المختص. وهذا جلعها سهلة: ففي البداية يحس المتعلم أنه يتعلم لغة إنجليزية بقواعد معيَّنة. فزادت المكتبات البرمجية (وهي ما يتشاركه المجتمع من قطع برمجية) وتضافرت الجهود وتنوَّعت المجالات بشكل كبير جدًّا، حتى لا يكاد يوجد مجال إلا ودخلته بايثون.\n\nمجالات لغة بايثون\nإذا نظرنا في إحصاء JetBrains 2023 نجد مجالات استعمال لغة بايثون:\n\n\n\nبم تستعمل لغة بايثون؟\n\n\n\n47% تحليل البيانات\n42% تعلم الآلة (الذكاء الاصطناعي)\n39% تطوير المواقع\n31% برمجة كاسحات المواقع (التي تجمع البيانات)\n30% أتمتة إدارة الأنظمة والبنية التحتية التقنية\n26% أتمتة اختبار البرمجيات\n23% أغراض تعليمية\n22% صناعة برمجيات أوليَّة (أي لسهولتها)\n\nوانظر إحصاء JetBrains 2024 لمقارنة بايثون مع غيرها من اللغات، حيث يظهر في الجدول التالي توزيع استعمال المبرمجين للغات في مختلف المجالات. ويظهر لنا أن بايثون هي أكثر اللغات انتشارًا بين المجالات التقنية؛ فتعلمها يعطيك أوسع فرصة في المجالات:\n\n\n\nتوزيع استعمال اللغات بحسب المجالات التقنية في 2024\n\n\nومن الشركات التقنية التي قامت على بايثون: Instagram، Spotify, Reddit, Netflix, Dropbox, Quora, Pintrest.\nوالمجتمعات البرمجية في بايثون كثيرة ومتعددة في اهتماماتها. منها على سبيل المثال:\n\n\n🌐 تطوير مواقع الشبكة\n\nDjango - لبناء مواقع متصلة بقواعد بيانات\nFastAPI - حديث وسريع لبناء واجهات برمجية على الشبكة\n\n\n\n📊 تحليل البيانات وتصويرها\n\nPandas - لتحليل البيانات المرصوصة\nstatsmodels - للنماذج الإحصائية\nSeaborn - لتصوير البيانات الإحصائية على أساس Matplotlib.\nmatplotlib - مكتبة شاملة لإنشاء تصورات ثابتة ومتحركة وتفاعلية.\nSelenium لتصفح المواقع بشكل آلي وسحب البيانات منها\n\n\n\n📊📊📊 البيانات الضخمة\n\nمعالجة البيانات المتدفقة بسرعة وكفاءة عالية: Dask و Ray.\nأتمتة عمليات البيانات: Airflow, Dagster و Prefect\n\n\n\n🤖 الذكاء الاصطناعي وتعلم الآلة\n\nscikit-learn - لاكتشاف الأنماط والتنبؤ (تعلم الآلة)\nPyTorch - بناء وتدريب نماذج التعلم العميق\nKeras - بناء وتدريب نماذج التعلم العميق\nHugging Face - اختيار وتدريب نماذج التعلم العميق\n\n\n\n🖼️ معالجة الصور\n\nPillow\nScikit-image\nOpenCV\nManim - تصوير الرياضيات: أسسها 3Brown1Blue ليستعملها في مقاطعه التعليمية على اليوتيوب.\n\n\n\n📐 التحليل الرياضي\n\nSciPy - خوارزميات أساسية في الحوسبة العلمية\nsympy - للرياضيات الرمزية.\nPySR - الانحدار الرمزي.\ncvxPy - التحسين (Convex Optimization)\nFEniCS - حل المعادلات التفاضلية الجزئية (PDEs) باستخدام طريقة العناصر المحدودة (FEM)\nigraph - الترابطات والشبكات\npython-control - أنظمة التحكم\n\n\n\n🧪 الكيمياء\n\nCantera\nMDAnalysis\nRDKit\nPyBaMM\n\n\n\n⚛️ الحوسبة الكمومية\n\nPennyLane\nQiskit\n\n\n\n🧠 علم النفس\n\nPsychoPy\n\n\n\n🧬 المعلوماتية الحيوية\n\nBioPython\nScikit-Bio\nPyEnsembl\nETE\n\n\n\n🗻 علوم الأرض\n\nPangeo\nSimpeg\nObsPy\nFatiando a Terra\n\n\n\n🔭 علم الفلك\n\nAstroPy\nSunPy\nSpacePy",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#بايثون-وحدها-لا-تكفي",
    "href": "index.html#بايثون-وحدها-لا-تكفي",
    "title": "البايثونية",
    "section": "بايثون وحدها لا تكفي",
    "text": "بايثون وحدها لا تكفي\nوالواقع أن ليسَ ثمة لغة واحدة تحقق كل متطلبات بناء التطبيق؛ بل يغلب على المشاريع البرمجية تعدد اللغات فيها، وإن كانت مشاريع فردية صغيرة. وإن من منافع التعلم بالطريقة الصحيحة؛ أن تعلُّمَك للغة الثانية يصبح أسهل؛ فقد تختلف أساليب التعبير بين لغة وأخرى، إلا أن المفاهيم مشتركة.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#تعريب-المصطلح",
    "href": "index.html#تعريب-المصطلح",
    "title": "البايثونية",
    "section": "تعريب المصطلح",
    "text": "تعريب المصطلح\nلعل وصف المفاهيم باللغة الأم أقرب للطبع، وأمكن في الذهن وأوعى، وأسهل في التقليب والانتقاد، وأوسع في الاختراع والإبداع. فالمفاهيم لا تتعلق باللغة التي كتبت بحروفها ابتداءً. فالمعنى شيء، واللغة شيء ثاني. بل إنَّ علامة العلم أن تحسن التعبير عنه. فليس بينك وبين المفهوم حاجز اللغة، ولا هالة المصطلح.\nويموت المصطلح وإن كان مُثبتًا في قواميس الدنيا؛ إذا لم يتداوله أهله. فإنَّ الأذن تستغرب غير المتداوَل من الكلام، كالطعم الجديد على اللسان؛ فإذا اعتاده استساغه. وقد تجد ذلك فيما شَاعَ ودَرَج كالجوال والسيارة، والكهرباء والطيارة.\nوالمصطلح العلمي له من اللغة معنىً يتأثر بالسياق الذي يُستعمل فيه، وكذلك يتأثر بالمصطلحات المحيطة به. فإذا ما جُرِّد المصطلح عن قصته، ولم يُعرَف أصله؛ فقد يتسرع المرءُ بالحكم على عدم مناسبته.\nولا يُفهم مما سبق أن المصطلح الإنجليزي مُهمَل؛ بل نضرب بالحجر عصفورين. إذْ لا بد لك من إتقان اللغة الإنجليزية لتستقي من تلك المنابع.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "إعداد بيئة التطوير",
    "section": "",
    "text": "تابع المقطعين التاليين حيث نشرح كيفية تنزيل وتثبيت مفسر لغة بايثون بالتفصيل:\n\n\n\n\nثم بيئة التطوير (Development Environment) وهي الأدوات البرمجية الأساسية والمساعدة في كتابة النص البرمجي وتنفيذه واختباره وتصحيحه وما إلى ذلك.\nأما محرر النص البرمجي (Code Editor) فسنختار Visual Studio Code التابع لشركة مايكروسوفت، وهو مختلف عن Visual Studio.\n\nوهو مفتوح المصدر (أي: يمكن الاطلاع على نصه البرمجي).\nويستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024 وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن.\nوتُعنى الشركة بدعمه وصيانته باستمرار وتطويره، كما يساهم فيه آخرون من خارج الشركة لكوْنه مفتوح المصدر.\nوتم تصميمه كي يقبل الزيادات واللواحق البرمجية ليختار كل مبرمج ما يناسبه من الأدوات حسب احتياجاته.\n\nموقع المحرر: https://code.visualstudio.com/\nولتشغيل القطع البرمجية راجع هذا الرابط: https://code.visualstudio.com/docs/python/run.\nشاهد هذا المقطع لإتمام إعداد بيئة التطوير:",
    "crumbs": [
      "إعداد بيئة التطوير"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/01_instructions.html",
    "href": "chapters/00_rewrite/01_instructions.html",
    "title": "1  النص البرمجي",
    "section": "",
    "text": "الاسم\nيتألف النص البرمجي من قِطَع هي عبارة عن جُمَل متتابعة تعبِّر عن أوامِر يفسرها الحاسب وينفذها.\nفمثلاً هذا الأمر، يحسب ناتج جمع العددين ويطبعه على الشاشة:\nوتتتابع الأوامر سطرًا بعد سطر:\nوتَتَّبِعُ لغات البرمجة بما فيها لغة بايثون قَواعِدَ نَحْوِيَّة صارمة حتى لا يشتبه عليه تفسيرها عند تحويلها لتعليمات مفصَّلة على لغة المنطق الرقمي للآلات المكون منها الحاسب لتنفذها.\nفلا يجوز أن تقول مثلاً:\nلأن هذا ليس من لغة بايثون. والغرض من تحديد اللغة تقليل الاحتمال، مما يجعل التفسير أسرع، ويجعل التعبير أدقَّ في إصابة المقصود؛ وهذا دأب الرياضيين.\nيحتاج المبرمج للإشارة لبعض القيَم بأسماء تدل على معناها، وهذا مثال على أربعة أوامر نشرحها بمحاذاة النص بعد علامة (#) التي تجعل ما بعدها تعليقًا لا تضر قراءته إذْ لا يتم تفسيره:\nmoney = 10000      # تعيين قيمة للمتغير\nzakat = money / 40 # تعيين حاصل نتيجة العملية للمتغير الآخر\nprint(zakat)       # طباعة النتيجة\n\n250.0\nفالمُتَغَيِّر (Variable) هو ما أُسنِدَ إليه قيمة (Value)، أو تعبير (Expression) يؤول إلى قيمة.\nولدينا في المثال السابق:\nويجوز أن يكون المتغير من حرفٍ واحد، ووجب التنبيه إلى أن علامة = تسمى عامل التعيين (Assignment Operator)، وليست علامة المساواة كما نستعملها في الرياضيات. فمعنى ذلك أن التعيين اللاحق ناسخٌ لما قبله:\nx = 10\nx = 20\nprint(x)\n\n20\nلاحظ أن القيمة الظاهر في الطباعة هي للتعيين التالي وليس الأول.\nبينما يمتنع هذا في الرياضيات أصلاً.\nوقد تستعمل الجُمَل لاسم المتغيِّر، لكن يجب فصلها بالشرطة السفلية (_) حتى لا يشتبه على المفسر أنها شيء منفصل:\nseconds_in_a_minute = 60\nseconds_in_an_hour = seconds_in_a_minute * 60\nseconds_in_a_day = seconds_in_an_hour * 24\nseconds_in_a_week = seconds_in_a_day * 7\n\nprint(seconds_in_a_week)\n\n604800\nويجوز أن يتعدد طرفا التعيين\nx, y, z = 5, 10, 20\nprint(y)\n\n10\nويجوز أن يتكرر عامل التعيين اختصارًا:\nx = y = 10\nprint(x, y)\n\n10 10",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>النص البرمجي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/01_instructions.html#الاسم",
    "href": "chapters/00_rewrite/01_instructions.html#الاسم",
    "title": "1  النص البرمجي",
    "section": "",
    "text": "المتغير money وقد أسندنا إليه قيمة: 10000\nالمتغير zakat وقد أسندنا إليه التعبير: money / 40 الذي يؤول إلى القيمة؛ وهي: 250",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>النص البرمجي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/01_instructions.html#العامل",
    "href": "chapters/00_rewrite/01_instructions.html#العامل",
    "title": "1  النص البرمجي",
    "section": "العامل",
    "text": "العامل\nومن العوامل (Operators):\n\nعامل الجمع: + (Addition)\nعامل الطرح: - (Subtraction)\nعامل الضرب: * (Multiplication)\nعامل القسمة: / (Division)\nعامل باقي القسمة: % (Modulus)\nعامل الأُس: ** (Exponentiation)\n\nفتجري على الأعداد على النحو التالي:\n\nx = 10\ny = 2\n\nprint(x + y)  # الجمع\nprint(x - y)  # الطرح\nprint(x * y)  # الضرب\nprint(x / y)  # القسمة\nprint(x % y)  # باقي القسمة\nprint(x ** y) # الأس\n\n12\n8\n20\n5.0\n0\n100\n\n\nوتكون عملية المساواة بعامله ==، بخلاف التعيين = وناتجها يكون إما نعم (True) أو لا (False). على النحو التالي:\n\nx = 5\ny = 10\nprint(x == 5)\n\nTrue\n\n\nوتستعمل في الجُمَل الشرطية، وسيأتي الحديث عنها إن شاء الله.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>النص البرمجي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/01_instructions.html#النوع",
    "href": "chapters/00_rewrite/01_instructions.html#النوع",
    "title": "1  النص البرمجي",
    "section": "النوع",
    "text": "النوع\nولكل قيمة نوع (Type) يحدد ما يجري عليه من العوامل وما يمتنع.\n\n\n\n\n\n\nنصيحة\n\n\n\nمن أهم المهارات التي تجب على المبرمج: معرفة نوع كل قيمة يتعامل معها.\n\n\nوإذا قُلنا إن نوعَ المتغير الفلاني كذا فإن ذلك تجوُّز، لأننا في الواقع نقصد نوع قيمة المتغير.\nومن الأنواع في لغة بايثون التي من صنف العدد (Number):\n\nالعدد الصحيح؛ ويرمز له بالكلمة int (تعني: Integer). ويستعمل في الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك.\nالعدد ذي الفاصلة العائمة (يقابل العدد العشري)؛ ويرمز له بالكلمة float (تعني: Floating Point). ويستعمل في تمثيل الكميات كالمال، والمسافة، والوقت، ونحو ذلك.\n\nفإذا تأمَّلت النص التالي وجدت جميع هذه القيَم من نوع العدد الصحيح (int):\n\nage = 20\nlevel = 3\nindex = -2\nstart = 0\n\nأما التالي فهو من نوع العدد ذي الفاصلة العائمة (float) إذ يوجد فيه الفاصلة العشرية:\n\ndistance = 100.0\nprice = 10.5\ntime = 1.5\ntemperature = 36.6\ndifference = 0.001\n\nومن أكثر الأنواع استعمالاً في بايثون؛ النص (str)؛ وهو سلسلة من الأحرف . ويُعرَفُ بعلامتي التنصيص سواء المفردة (') أو المزدوجة (\") على النحو التالي:\n\nname = 'Adam'\ncity = \"Al-Madinah\"\n\nفيجوز دمج النصوص بعلامة الجمع كالتالي:\n\nsentence = \"hello, I am \" + name + \" and I live in \" + city\nprint(sentence)\n\nhello, I am Adam and I live in Al-Madinah\n\n\nلاحظ أن كلمة name وكلمة city كلاهم خارج التنصيص؛ لذا فهما يشيران إلى المتغيرين الذين تم تعريفها سابقًا.\nلكن يمتنع الجمع بين النص والعدد. فلو حاولت تشغيل التالي فستظهر لك رسالة خطأ:\n\nsentence = name + \" is \" + age + \" years old\"\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 sentence = name + \" is \" + age + \" years old\"\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nولحل المشكلة السابقة، يجب أولاً تحويل نوع العدد إلى نوع النص باستعمال الدالة str(x) على النحو التالي:\n\nsentence = name + \" is \" + str(age) + \" years old\"\nprint(sentence)\n\nAdam is 20 years old\n\n\nولمعرفة نوع المتغير، نستعمل الدالة type(x) بتمرير القيمة أو المتغير عوضًا عنها.\n\nprint(type(5))\nprint(type(5.0))\nprint(type(\"Hello\"))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\nتأمل ناتج عمليات طباعة النوع لكل من المتغيرات السابقة:\n\nprint(type(age))\nprint(type(distance))\nprint(type(name))\nprint(type(city))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'str'&gt;\n\n\nوكثيرًا ستضطر إلى معرفة نوع المتغير الذي تتعامل معه. فبعض محررات النص البرمجي تُظهر لك النوع بمجرد تحليق المؤشر على اسم المتغير.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>النص البرمجي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/01_instructions.html#الإدخال",
    "href": "chapters/00_rewrite/01_instructions.html#الإدخال",
    "title": "1  النص البرمجي",
    "section": "الإدخال",
    "text": "الإدخال\nيستمعل أمر الإدخال (input(message)) للحصول على قيمة من المستخدم. وتفسر هذه القيمة على أنها سلسلة من الأحرف؛ أي: أنها من نوع النص (str)، ولو كان المستخدم أدخل عددًا، فإنه سيفسر على أنه حروف العدد وليس قيمةً من نوع العدد.\nتأمل المثال التالي:\nmsg = \"Enter your age: \"\nage = input(msg)\nprint(age, type(age))\nيتم تنفيذ هذه التعليمات على النحو التالي:\n\nتعيين القيمة النصيَّة للمتغير msg\nتعيين حاصل القيمة المدخلة من المستخدم للمتغير age\n\nهذا يعني أن البرنامج سيتوقف، ليظهر للمستخدم السؤال Enter your age: (إذا كنت في محرر VS Code فسيظهر في الأعلى)\nثم إذا أدخل المستخدم فيه شيئًا ثم ضغط على زر Enter فسيتم تخزين القيمة المدخلة في المتغير age لكن كقيمة نصية\n\nلإثبات أن ما تم إدخاله نص؛ نقوم بطباعة قيمة المتغير ثم نوعه\n\nوالآن لدينا خياران في تحويل قيمة المتغير النصيَّة إلى قيمة عددية، وذلك أننا عرفنا نوعين من الأعداد: الصحيح (int) والعشري (float). وكلاهما يتم تحويلهما باستعمال الدالة int(x) أو float(x) على النحو التالي:\n\nx = int(age)\nprint(x, type(x))\n\ny = float(age)\nprint(y, type(y))\n\n20 &lt;class 'int'&gt;\n20.0 &lt;class 'float'&gt;\n\n\nوعادةً ما نحتاج لمثل هذا التحويل عند قراءة بيانات من الخارج، فتنبه!\nولتثبيت الفكرة، نضرب مثالاً واضحًا بمتغيرين أحدهما عددي والآخر نصي:\n\nx = 10\ny = \"10\"\n\nفلو حاولت خطأً (وهذا يقع كثيرًا) الجمع بينهما فستظهر لك رسالة خطأ:\n\nprint(x + y)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 print(x + y)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nولو كانا كلاهما من النوع النصي، فإن نتيجة الجمع ستكون بدمج النصين لا بجمع العددين. تأمل المثال التالي:\n\nx = \"10\"\ny = \"20\"\n\nprint(x + y)\n\n1020\n\n\nوهذا وإن لم يظهر برسالة خطأ فإنه ليس مقصودنا؛ لذلك فهو خطأ منطقي وإن كان من حيث البنية اللغوية صحيحًا.\nفيجب استعمال التحويل اللازم في مثل هذه الحالات إن كان القصد أن يكون المتغير من النوع العددي.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>النص البرمجي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/02_control_flow.html",
    "href": "chapters/00_rewrite/02_control_flow.html",
    "title": "2  توالي الأوامر",
    "section": "",
    "text": "القيمة المنطقية\nيُرى التدفق (Flow) المستمر في النظام الميكانيكي للسيارة ليبقيها سائرة بفعل الوقود. كما يُرى في حركة الطاحونة المائية حيث يدفعها جريان النهر فيحركها معه. ويُرى أيضًا في شراع السفينة حيث تضرب فيه الرياح. والكهرباء مثلها تيار يسري في أنبوبة المصباح ليبقيه منيرًا، أو في نظام التكييف ليبقي الجو باردًا.\nوأصل المنطق الرقمي (Digital Logic) تيارات كهربائية لها تردد ينبض بسرعة فائقة لما تلتقطه عين الإنسان. فإذا نظرت للإشارة علمت أننا تحكمنا في سرعة هذا التردد بحيث تصبح ألوان الإشارة تتبدل وتنطفئ وتُشعَل بتوقيتٍ مضبوط. لكنها مع ذلك ليسَت خوارزميَّة. لأنها أشبَهُ بالكُرة التي تُدفعُ من أعلى مُنحَدَرٍ فتتدحرجُ بفعل الجاذبية. إذْ تعملُ الإشارة بوتيرة معلومة وتدور وتدور مادامت الكهرباء تنبض فيها.\nولا يكاد يخلو برنامج مفيد من اتخاذ قرارات مغايرة بناءً على اختلاف الظروف المكانية والزمانية والواقعية. فلو كان نظام التحكُّم في التقاطُع المروري يراعي حركة السيْر بحيث يُقدِّم ويؤخِّر في توقيت فتح إشاراته لتحقيق أعلى كم من العبور للسيارات؛ فإننا نسميها إشارة ذكيَّة (Smart). وهذه خوارزمية.\nومن أمثلة ذلك:\nويتم ذلك بأوامر التحكم في سير الأوامر (Control-flow) وهي جُمَل شرطيَّة ينبني عليها اختيار الأمر التالي. فإن الأوامِر في المنطق الرقمي تنتظم في ثلاثة صوَر:\nوإذا استُعمِلَت هذه لتحقيق غاية محددة بعدد محدود من الخطوات، صار اسمها خوارزمية (Algorithm).\nفإن جملة التعيين التالية تكتُب قيمة 20 في نفس المحلّ الذي كتبت عليه جملة التعيين الأولى 10. لذا ظهرت النتيجة: 20.\nويتم اختيار أحد طريقين في سيْر الأوامِر بحسب ناتج تعبير منطقي (bool)؛ وهي أحد اثنين:\nومن العبارات المنطقية في بايثون، حاصل عوامل المقارنة كما في المثال:\na = 10\nb = 5\n\nprint(a == b)   # يساوي\nprint(a != b)   # لا يساوي\nprint(a &gt; b)    # أكبر من\nprint(a &lt; b)    # أصغر من \nprint(a &gt;= b)   # أكبر من أو يساوي\nprint(a &lt;= b)   # أصغر من أو يساوي\n\nFalse\nTrue\nTrue\nFalse\nTrue\nFalse\nتذكر: أن لكل قيمة نوعًا. فإذا وضعت المتغير في دالة type(x) لمعرفة النوع، فإنك ستعرف أن مثل هذه التعبيرات نوعها منطقي (bool). مثال:\nprint(type(8 == 5))\n\n&lt;class 'bool'&gt;\nويمكن المقارنة بين النصوص كذلك، ونتيجة ذلك قيمة من النوع المنطقي أيضًا؛ لأن المقارنة تعبير منطقي:\nprint(\"Hello\" == \"Hello\") # يجب أن تتطابق جميع الحروف\nprint(\"a\" == \"A\")         # حالة الحرف مهمة\n\nTrue\nFalse\nولاحظ أن النص والعدد -لاختلاف نوعيهما- يكون حاصل المساواة بينهما لا (False):\nprint(10 == \"10\")\n\nFalse\nلكن بايثون تتجوَّز في المساواة بين الأنواع المختلفة التي من صنف العدد، فالمطابقة بين العدد الصحيح (int) وذي الفاصلة العائمة (float) جائزة في بايثون:\nprint(10 == 10.0)\n\nTrue",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/02_control_flow.html#القيمة-المنطقية",
    "href": "chapters/00_rewrite/02_control_flow.html#القيمة-المنطقية",
    "title": "2  توالي الأوامر",
    "section": "",
    "text": "نعم: True؛ ويقال أيضًا: صحيح أو مطابق أو ثابت\nلا: False؛ ويقال أيضًا خاطئ أو مخالف أو منتفي",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/02_control_flow.html#التخيير",
    "href": "chapters/00_rewrite/02_control_flow.html#التخيير",
    "title": "2  توالي الأوامر",
    "section": "التخيير",
    "text": "التخيير\nيتم التخيير المذكور آنفًا بالجملة الشرطية:\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\n\nفتبدأ الجملة الشرطية بكلمة if (إذا) ويليها التعبير المنطقي (كما سبق بيانه)\n\nفيكون ما يندرج تحتها (بالمسافة) الأوامر المتعلقة بنفاذ الشرط (True). فإن انتفى الشرط (False) فإن بايثون تتخطى هذه الأوامر وتقفز لما بعدها.\n\n\nوبالمثال يتضح المقال:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if cond}} -- False --&gt; X[\"Outside\"]\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n\n  style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ncond = False\nif cond:\n    print('Inside')\nprint('Outside')\n\nOutside\n\n\n\n\nلاحظ أن الشرط منتفٍ، لذلك كان حاصل النص السابق تخطي ما بداخل الجملة الشرطية، وطباعة Outside فقط.\n\nتنبيه: محاذاة المسافات\nلاحظ أن المسافة البادئة (Indentation) (أي: المسافات من بداية السطر حتى يُدرج الكلام أسفل كلمة if) في القطعة البرمجية أعلاه ليست لمجرد تسهيل القراءة، بل تُفسَّرُ الجُملةُ أنها في الداخل أو الخارج بناءً على وجودها وعدمها. فهي التي تضع الحدود حول المشروط. ويجب أن تكون محاذية فإذا كان مقدارها 4 مسافات أو 2 أو أكثر، فوجب أن تكون جميع الجُمَل بنفس المقدار. وهذا ما نسميه المحاذاة.\nلاحظ: أن خلو الشرط من جُمَل مشروطة به يُفرِز تنبيهًا للمبرمج عند تفسير النص البرمجي:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    Y[\"Inside\"] --&gt; X[\"Outside\"]\n    style IF fill:#fc0000, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[8], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل النص البرمجي بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n    \n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\n\n\nيؤدي النص البرمجي السابق إلى خطأ منطقي (لا نحوي) لن يظهر أبدًا كخطأ ولن يوقف البرنامج!\n\n\n\n\n\n\nملاحظة\n\n\n\nلا تنسَ أن المحاذاة في بايثون هي أساسية لتفسير النص البرمجي.\n\n\n\n\nالتخيير الحصري\nلجعل التخيير بين أمرين بحيث لو حصل أحدهما لا يحصل الآخر، فإننا نتبع الشرط الأوَّل بكلمة وإلا (else)، على النحو التالي:\nif &lt;boolean expression&gt;:\n    &lt;code_1&gt;\nelse:\n    &lt;code_2&gt;\nمثلاً، تريد أن تظهر رسالة خطأ لو لم تطابق كلمة المرور:\n\ninput_password = hash(\"abc123\")\nstored_password = hash(\"fuda$(#*(lm\")\n\nis_match = input_password == stored_password\n\nif is_match:\n    msg = \"Welcome\"\nelse:\n    msg = \"Try Again\"\n\nprint(msg)\n\nTry Again\n\n\nوهذه الشجرة توضح تسلسل التنفيذ الإجرائي لها:\n\n\n\n\n\nflowchart TD\n    IF{{if is_match}}\n    IF -- False --&gt; D[\"msg = 'Try Again'\"]\n    IF -- True --&gt; C[\"msg = 'Welcome'\"]\n    D --&gt; E[\"print(msg)\"]\n    C --&gt; E[\"print(msg)\"]\n\n    style IF fill:#82aeff, stroke:#333;\n    linkStyle 0 color:red;\n\n\n\n\n\n\nولاحظ أن print(msg) غير مشروطة، لذلك فإنها مع نفوذ الشرط أو عدمه يتم تنفيذها.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/02_control_flow.html#الجبر-المنطقي",
    "href": "chapters/00_rewrite/02_control_flow.html#الجبر-المنطقي",
    "title": "2  توالي الأوامر",
    "section": "الجبر المنطقي",
    "text": "الجبر المنطقي\nوالنوع الثنائي (bool) الذي ينحصر في قيمتين فقط هو أصل المنطق الرقمي المعروف بالأصفار والآحاد. حيث نشأ علم الجبر المنطقي (Algebraic Logic) من قبل عالم الرياضيات جورج بول الذي وضع أسسه في كتابه: “قوانين الفكر” (The Laws of Thought) في عام 1854.\n\n\n\n\n\n\nملاحظة\n\n\n\nومن بديع صنع الله سبحانه وتعالى، أن هذه العمليات الثلاثة بها تتكون جميع المعالجات التي تصير في كل جهاز حاسب بلا استثناء!\n\n\nوإذا كان جبر الأعداد يكون بالمعادلات التي هي مقابلات تمثل قيَم عددية، وبينها عوامل الجمع والضرب والقسمة والطرح والأس ونحو ذلك؛ فإن الجبر المنطقي يكون بمعادلات تمثل مقابلات لقيم منطقية (صفر أو واحد)، بينها العوامل الأساسية الثلاثة التالية (ويمثل الصفر المنطقي بكلمة False والواحد المنطقي بكلمة True):\nالعامل الأول: العكس (not). مثاله:\n\na = 10 &gt; 5  # تعيين لحاصل تعبير منطقي للمتغير\nb = not a   # عكس القيمة المنطقية التي في المتغير الأول\nprint(b)    # طباعة\n\nFalse\n\n\nالعامل الثاني: الجمع (and). مثاله:\n\na = True\nb = False\nprint(a and b)\n\nFalse\n\n\nالعامل الثالث: الخيار (or). مثاله:\n\na = True\nb = False\nprint(a or b)\n\nTrue\n\n\nوقد وضعت الجمع والخيار في جدولٍ واحد فيه جميع الاحتمالات بينهما ليسهل استيعابه:\n\n\n\n\na\nb\na and b\na or b\n\n\n\n\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n\n\n1\n0\n0\n1\n\n\n1\n1\n1\n1\n\n\n\n\n\nمآل العبارات المنطقية في الجملة الشرطية\nعلى سبيل المثال:\n\nage = 20\nweight = 50\n\nif age &gt; 18 and weight &gt; 45:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nيؤول طرفا العامل and لقيمة منطقية هكذا:\n\nage &gt; 18 تؤول إلى True لأن age=20 وهو أكبر من 18\nweight &gt; 45 تؤول إلى True لأن weight=50 وهو أكبر من 45\nفتكون الجملة إذًا: True and True وهي تؤول إلى True\n\nوهذه الشجرة تمثل تسلسل تفسير العبارات المنطقية في الجملة الشرطية، لتؤول إلى نعم أو لا (True أو False):\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{and} -- True --&gt; RESULT\n  middle_left{\"&gt;\"} -- True --&gt; ROOT\n  middle_right{\"&gt;\"} -- True --&gt; ROOT\n  left_left[age] -- \"20\" --&gt; middle_left\n  left_right[18] -- \"18\" --&gt; middle_left\n  right_left[weight] -- \"50\" --&gt; middle_right\n  right_right[45] -- \"45\" --&gt; middle_right\n\n\n\n\n\n\n\n\nتستعمل الأقواس (()) لتجميع الشروط لإيقاع الترتيب المنطقي المراد:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\nage &lt; 16 تؤول إلى False لأن age=16 ليست أصغر من 16\ntemperature &lt; 20 تؤول إلى True لأن temperature=15 أصغر من 20 فعلاً\nnot is_wearing_coat تؤول إلى False لأن is_wearing_coat=True وهي عكسها\nإذًا الجملة بين القوسين (temperature &lt; 20 and not is_wearing_coat) تؤول إلى True and False وهي تؤول إلى False\nإذًا الجملة age &lt; 16 or (False) تؤول إلى False or False وهي تؤول إلى False\n\nوهذه الشجرة تمثل تسلسل تفسير العبارات المنطقية في الجملة الشرطية:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{or} -- False --&gt; RESULT\n  middle_left{\"&lt;\"} -- False --&gt; ROOT\n  middle_right{and} -- False --&gt; ROOT\n  left_left[age] -- \"16\" --&gt; middle_left\n  left_right[16] -- \"16\" --&gt; middle_left\n  right_middle{\"&lt;\"} -- True --&gt; middle_right\n  right_not{not} -- False --&gt; middle_right\n  right_temp[temperature] -- \"15\" --&gt; right_middle\n  right_val[20] -- \"20\" --&gt; right_middle\n  right_coat[is_wearing_coat] -- True --&gt; right_not\n\n\n\n\n\n\n\n\n\nتسمية العبارات المنطقية\nويجوز تسمية العباراة المنطقية وتعيين قيمتها لمتغيرات لبيان موقعها في سياق الجملة الشرطية:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\n\nif is_minor or (is_cold and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\nومن فوائد تعيين العبارة المنطقية لمتغير: إمكانية استعماله في أكثر من موضع.\n\n\nتسلسل المقارنات\nوتفهم بايثون المقارنات المتسلسلة. فعبارة x &lt; y &lt;= z تكافئ x &lt; y and y &lt;= z:\n\nlow = 10\nhigh = 20\nx = 15\n\n(low &lt; x &lt; high) == (low &lt; x and x &lt; high)\n\nTrue",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/02_control_flow.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/00_rewrite/02_control_flow.html#الجملة-الشرطية-المتكاملة",
    "title": "2  توالي الأوامر",
    "section": "الجملة الشرطية المتكاملة",
    "text": "الجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية:\nif &lt;boolean expression&gt;:\n    &lt;code_1&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code_2&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code_3&gt;\nelse:\n    &lt;code_4&gt;\n\nأما جملة إذا (if) فقد سبق بيانها\nوأما جملة وإلا فإن (elif) فلا يتم تنفيذها إلا عند تخلُّف الشرط السابق لها. وقد تتعدد (كما في المثال)\nوأما جملة وإلا الأخيرة (else) فلا يتم تنفيذها إلا عند تخلف جميع الشروط السابقة لها.\n\nونؤكد أن الجمل الشرطية اللاحقة بعد إذا (if) الأولى؛ كل واحدة منها مرتبطة بانتفاء ما قبلها. وهذا ما يوضحه الرسم الشجري التالي:\n\n\n\n\n\nflowchart TD\n    IF1{{if}}\n    IF1 -- False --&gt; ELIF1{{elif}}\n    IF1 -- True --&gt; code_1\n    ELIF1 -- False --&gt; ELIF2{{elif}}\n    ELIF1 -- True --&gt; code_2\n    ELIF2 -- False --&gt; ELSE{{else}}\n    ELIF2 -- True --&gt; code_3\n    ELSE --&gt; code_4\n\n    style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,2,4 color:red;\n\n\n\n\n\n\n\nجرب\nاستكشف المنطق التالي بتغيير قيمة x كل مرة للتبع ما يحصل في كل مرة:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSet to zero\nAlways: 0\n\n\nوهذه الشجرة توضح تسلسل التنفيذ الإجرائي لها:\n\n\n\n\n\nflowchart TD\n    IF{{if x &lt; 0}}\n    IF -- False --&gt; ELIF{{elif x == 0}}\n    IF -- True --&gt; S1[x = 0] --&gt; S2[\"Set to zero\"]\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; S3[x = 1] --&gt; S4[\"Single\"]\n    ELSE --&gt; S5[\"More\"]\n\n    Always[Always: x]\n    S2 --&gt; Always\n    S4 --&gt; Always\n    S5 --&gt; Always\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,3 color:red;\n\n\n\n\n\n\nوهذا تصوير لسير الإجراءات لنفس النص البرمجي. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الإجراءية:\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.\nللمزيد تابع الملحق بالجملة الشرطية المتكاملة.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html",
    "href": "chapters/00_rewrite/03_functions.html",
    "title": "3  الدالة",
    "section": "",
    "text": "إنشاء دالة\nوالدالة (Function) قطعة نص برمجيّ لها اسم. وتسمى أيضًا الإجراء (Procedure). وهي من أقوى المركبات البرمجية التي تتم بها الخوارزميات.\nخذ على سبيل المثال وحدة الرياضيات (math) التي يتم الاستفادة منها بعد جملة الاستيراد (import) على النحو التالي:\nفالعالم بالرياضيات برمج هذه الدوال وأعطاها اسما، فنستطيع استعمالها في حل المسائل الرياضية:\nولولا مفهوم تخزين الأوامر وتسميتها، للزم أن نكتب الأوامر البرمجية التي تؤدي هذه الحسابات في كل مرة نريدها. وهذا يتعذر علينا لا لأنها خطوات كثيرة فحسب بل لأنها ليست بسيطة بحيث يتقنها كل مبرمج أصلاً.\nوقد تحتوي الوحدات على مسميات، كالثابت \\(\\pi\\) الذي يستعمل في علم المثلثات:\nتسمى النقطة (.) عامل إسناد (Dot Operator) في نحو العبارة math.pi أو عبارة math.sin(A)؛ وتفسرها بايثون أنها إشارة للمسمى المتضمن في الوحدة المسنَد إليها. سواءٌ كان ذلك دالة أو متغيرًا.\nويجدر بالذكر أن بعض الدوال في لغة بايثون لا نحتاج فيها لإسنادها لوحدةٍ ما؛ فهي مبنيَّة (Built-in)، نحو: print()، بل ولا تحتاج إلى التصريح باستيرادها بجملة (import). ومثال ذلك أيضًا round() لتقريب العدد. ولم يتبيَّن لي وجه الفرق بين ما جُعِلَ مبنيًّا في وحدة أو مبنيًّا عائمًا.\nويُمكن إشاعة المسميات المتضمَّنة في وِحدةٍ ما بجملة الاستيراد المبتدأة بمِن (from) بحيث لا نحتاج لإسنادها في كل مرة، وذلك يتم هذا النحو:\nويُمكِن استيراد الكُلّ بعلامة النجمة (*)، على هذا النحو:\nتنبيه: استيراد الكل (*) قد يتعارض مع مسمياتنا فيما بعد، ويصعب أن نعرف ذلك بسهولة، لذلك يجب أن يستعمل بحذر!\nوالمكتبة (Library) اسمٌ يطلق على مجموعة الوحدات.\nوللاطلاع على الوحدات المدمجة (Built-in Modules) في لغة بايثون، يمكن الرجوع إلى صفحات بايثون المرجعية للمكتبة الأساسية (Standard Library) https://docs.python.org/3/library. حيث تجد -مثلاً-:\nوهذه كلها يمكن استيرادها ثم استعمالها لأنها من ضمن بايثون نفسها، فلا تحتاج إلى تنزيل وتثبيت.\nأسباب إنشاء الإجراء:\nونمثل بتعريف الإجراء هذا:\ndef calculate_bmi(weight, height):\n    sq = height ** 2\n    bmi = weight / sq\n    return round(bmi, 2)\nويبتدأ تعريفه بكلمة def (تعني: Define)، ويليها اسمه، ويليه بين القوسين: معطياته: (weight, height). ويلي ذلك علامة الابتداء (:)، ونسرد بعدها جسده؛ وهي الأوامِر التي تعالج هذه المعطيات. ويختص الإجراء بجملة الرجوع (return x) التي تعود بالنتيجة x للمكان الذي استُدعيَ منه الإجراء.\nثم يحصل الاستدعاء (Call) بذكر اسم الإجراء مع عامل الاستدعاء (Call Operator) وهما القوسان بعده () وهما كالظرف تُمَرر إليه المعطيات فيهما.\nresult = calculate_bmi(70, 1.80)\nprint(result)\n\n21.6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html#إنشاء-دالة",
    "href": "chapters/00_rewrite/03_functions.html#إنشاء-دالة",
    "title": "3  الدالة",
    "section": "",
    "text": "التكرار: إذا وجدت أنك تكرر نفس القطعة البرمجية مرارًا\nالتعقيد: إذا كانت العملية تحتاج لكد الذهن أو لمعرفة لا تتوفر عند الجميع\nالقابلية للتركيب: إذا كانت القطعة ككل ذات وظيفة واضحة ومحددة، ورأيت أنها تنسجم مع غيرها من القطع إذا وضعت لها اسمًا",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html#تعيين-معطيات-الإجراء-بالاسم",
    "href": "chapters/00_rewrite/03_functions.html#تعيين-معطيات-الإجراء-بالاسم",
    "title": "3  الدالة",
    "section": "تعيين معطيات الإجراء بالاسم",
    "text": "تعيين معطيات الإجراء بالاسم\nويجوز تعيين المعطى بالاسم لا بالموضع:\n\nresult = calculate_bmi(height=1.80, weight=70)\nprint(result)\n\n21.6\n\n\nولاحظ أننا قلبنا الترتيب لنبين أنه ليس بلازمٍ إذا تمَّ التعيين بالاسم.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html#المعرفات-في-الإجراء-لا-تتسرب-إلى-الخارج",
    "href": "chapters/00_rewrite/03_functions.html#المعرفات-في-الإجراء-لا-تتسرب-إلى-الخارج",
    "title": "3  الدالة",
    "section": "المعرفات في الإجراء لا تتسرب إلى الخارج",
    "text": "المعرفات في الإجراء لا تتسرب إلى الخارج\nومن خصائص الإجراء أن أي اسم يتم تعريفه داخل الإجراء فإنه معروفٌ في نطاقه وليس يتسرب العلم به إلى الخارج.\nفنتوقع وقوع خطأ هنا لأن bmi غير معرَّفة في الخارج:\n\nprint(bmi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 print(bmi)\n\nNameError: name 'bmi' is not defined\n\n\n\nتقول رسالة الخطأ (السطر الأخير) أن المتغير bmi غير معرَّف. وهذا منطقي لأن النطاق الخارجي لا يعلم ما تكنه النطاقات الداخلية الخاصة بالإجراءات. وهو أمر مطلوب جدًّا ومرغوب في البرمجة. وذلك يعني أننا لن نتعب كثيرًا في اختيار الأسماء داخل كل إجراء، مخافة التعارض.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html#دالة-قوة-كلمة-المرور",
    "href": "chapters/00_rewrite/03_functions.html#دالة-قوة-كلمة-المرور",
    "title": "3  الدالة",
    "section": "دالة: قوة كلمة المرور",
    "text": "دالة: قوة كلمة المرور\nوإليك مثالاً آخر لدالة تتحقق من قوة كلمة المرور:\n\ndef check_password_stength(password):\n    if len(password) &lt; 8:\n        return \"Weak\"\n    elif len(password) &lt; 12:\n        return \"Medium\"\n    else:\n        return \"Strong\"\n\nلاحظ أننا استعملنا الدالة المبنية len() لحساب عدد الأحرف في النص.\nثم نستعمل دالتنا:\n\nprint(check_password_stength(\"1234\"))\nprint(check_password_stength(\"1234567890\"))\nprint(check_password_stength(\"12345678901234567890\"))\n\nWeak\nMedium\nStrong",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html#دالة-حساب-المسافة-المستقيمة-بين-نقطتين",
    "href": "chapters/00_rewrite/03_functions.html#دالة-حساب-المسافة-المستقيمة-بين-نقطتين",
    "title": "3  الدالة",
    "section": "دالة: حساب المسافة المستقيمة بين نقطتين",
    "text": "دالة: حساب المسافة المستقيمة بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nونكتبها في بايثون هكذا كدالة:\n\nimport math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\nثم نستعملها:\n\nprint(distance(0, 0, 3, 4))\nprint(distance(x1=1, y1=1, x2=-2, y2=-2)) # أو بتعيين المعطيات بالاسم\n\n5.0\n4.242640687119285",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html#الإجراء-المتسلسل",
    "href": "chapters/00_rewrite/03_functions.html#الإجراء-المتسلسل",
    "title": "3  الدالة",
    "section": "الإجراء المتسلسل",
    "text": "الإجراء المتسلسل\nالإجراء المتسلسل (Recursive Function): هو إجراء يطلب نفسه؛ بشكل مباشر أو غير مباشر. وحتى يكون مثمرًا: يجب أن تؤول سلسلة الطلبات هذه إلى جملة تُنهي التسلسل.\n\nمثال: المضروب\nفمثلا: تعرف الرياضيات مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots(1)\n\\]\nفهي عملية ضرب لكل عدد مع الذي قبله حتى ينتهي للواحد. ونمثل هنا لمضروب العدد 5:\n\\[\n!5 = (5)(4)(3)(2)(1) = 120\n\\]\nولك أن تصف نفس العملية هكذا:\n\\[\n!n = n !(n-1)\n\\]\nأي أن مضروب العدد هو ضربُ هذا العدد في مضروب العدد الذي قبله. وذلك يتسلسل على النحو التالي:\n\\[\n\\begin{align*}\n!5 &= (5)!(4) \\\\\n   &= (5)(4!(3)) \\\\\n   &= (5)(4(3!(2))) \\\\\n   &= (5)(4(3(2!(1)))) \\\\\n   &= (5)(4(3(2(1)))) \\\\\n   &= (5)(4)(3)(2)(1) \\\\\n   &= 120\n\\end{align*}\n\\]\nإذاً نعرِّف المعادلة في بايثون هكذا:\n\ndef factorial(n):\n    # Recursive case (تسلسل)\n    if n &gt; 0:\n        recursive_result = factorial(n - 1)\n        return n * recursive_result\n    # Terminal case (نهاية)\n    return 1\n\nfactorial(5)\n\n120\n\n\nحيث لدينا حالتان:\n\nعندما تكون n &gt; 0 يتم الطلب الذاتي : recursive_result = factorial(n - 1) إذْ هي جملة متسلسلة تكدِّس طلبات فوق طلبات؛ لكنها تؤول في النهاية إلى الجملة التي تُنهي التسلسل\nreturn 1 هي الجملة التي تنهي التسلسل\n\nوهنا قطعة نص برمجي نستعملها لتصور تسلسل الطلبات:\n\n\nالكود\ndef factorial(n, depth=0):\n\n    # Recursive case (تسلسل)\n    print(f\"{'  ' * depth}Call factorial({n})\")\n    if n &gt; 0:\n        result = n * factorial(n - 1, depth + 1)\n        print(f\"{'  ' * depth}Return {result} from factorial({n})\")\n        return result\n    \n    # Terminal case (نهاية)\n    print(f\"{'  ' * depth}Return 1 from factorial({n})\")\n    return 1\n\nfactorial(5)\n\n\nCall factorial(5)\n  Call factorial(4)\n    Call factorial(3)\n      Call factorial(2)\n        Call factorial(1)\n          Call factorial(0)\n          Return 1 from factorial(0)\n        Return 1 from factorial(1)\n      Return 2 from factorial(2)\n    Return 6 from factorial(3)\n  Return 24 from factorial(4)\nReturn 120 from factorial(5)\n\n\n120\n\n\n\nفكل طلب يُنشأ له ظرف تنفيذ جديد تكون بالنسبة له قيمة n هي المعيَّنة له وقت النداء.\nوهكذا يتم تكديس الطلبات حتى ينتهي التسلسل عند الطلب factorial(0) الذي يؤول لنتيجة مباشرة: return 1 فيخلَّى هذا الظرف من الذاكرة وتعود نتيجته إلى الظرف المباشر الذي استدعاه وهو ظرف factorial(1).\nفتتعين القيمة recursive_result = 1 وينتقل إلى الجملة التي بعدها وهي جملة الرجوع بنتيجة return n * recursive_result وهُما معيَّنان، أي تكون الجملة في واقع الظرف: return 1 * 1.\nوهذه النتيجة تعود للظرف الذي استدعاه وهو factorial(2) … إلخ.\n\nطلب الإجراء المتسلسل يؤدي إلى ظروف متداخلة تؤول إلى ظرف واحد في النهاية.\nيستعمل الإجراء المتسلسل وكذلك هياكل البيانات المتسلسلة بشكل كبير في الخوارزميات الفعالة.\nيسهل كتابة بعض الخوارزميات باستعمال الإجراء المتسلسل. لكن قد تكون (أحياًنا) أقل أداءً من استعمال الحلقات.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/03_functions.html#صورة-البرنامج-كسلسلة-استدعاءات-متراكمة",
    "href": "chapters/00_rewrite/03_functions.html#صورة-البرنامج-كسلسلة-استدعاءات-متراكمة",
    "title": "3  الدالة",
    "section": "صورة البرنامج كسلسلة استدعاءات متراكمة",
    "text": "صورة البرنامج كسلسلة استدعاءات متراكمة\nغالبًا ما تفكك المهمة الكبيرة إلى خطوات جزئية على شكل إجراءات منفصلة، ويتم استدعاؤها وربط نتائجها في الإجراء الأوَّل (main()). لذلك نتصوَّر أن البرنامج عبارة عن سلسلة من الاستدعاءات، التي قد تتضمن في طيها استدعاءات أخرى فتتراكم.\n\ndef main():\n    p1()\n    print(\"middle\")\n    p2()\n    print(\"finish\")\n\ndef p1():\n    p1_1()\n    p1_2()\n\ndef p2():\n    p2_1()\n\n\ndef p1_1():\n    print(\"one-one\")\n\ndef p1_2():\n    print(\"one-two\")\n\n\ndef p2_1():\n    print(\"two-one\")\n\nmain()\n\none-one\none-two\nmiddle\ntwo-one\nfinish\n\n\nلاحظ أننا نصوِّر كومة الاستدعاءات (Call Stack) بمرور الوقت من اليسار إلى اليمين، بحيث كلما ازداد عرض الطبقة كان ذلك دليلاً على قضاء وقت أكثر في تنفيذ تلك الجزئية، مما يساعدنا في معرفة الأجزاء التي تحتاج لتسريع في البرنامج حتى يكون في المحصلة سريعاً.\n\n\n\nكومة استدعاءات البرنامج السابق\n\n\n\n\n\n\n\n\nملاحظة\n\n\n\nتوجد مكتبة خارجية لعرض كومة الاستدعاءات حقيقة وهي: SnakeViz وهي تتطلب معرفة بـ cprofile. ويُعرف ذلك بالرسم اللهبي (Flamegraph).\n\n\nفأي إجراء يتم تعريفه؛ كالمتغير الذي يتم تعريفه: هو نص برمجي محفوظ ينتظر الاستدعاء حتى يحضر في ذاكرة البرنامج في ظرف تنفيذي ويتم تشغيله بعوامل معيَّنة. ثم يعود إلى الإجراء الذي استدعاه، وهكذا دواليك. لذا فإننا إن لم نشغيل الإجراء الأوَّل main فإن البرنامج وإن كان يحفظ هذه الإجراءات إلا أنها تحتاج إلى الاستدعاء لتعمل.\nللمزيد راجع ملحق الدالة.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html",
    "href": "chapters/00_rewrite/04_sequences.html",
    "title": "4  التسلسل",
    "section": "",
    "text": "التعيين النسبي\nلنفترض أننا نريد حساب مجموع عدد صفحات القراءة خلال الأسبوع. فنجعل لكل يوم متغيرًا تحفظ فيه عدد الصفحات التي قرأناها في ذلك اليوم.\nثم نريد جمع ذلك كله، لمعرفة مجموع الصفحات خلال الأسبوع\nونريد أن نعرف المعدَّل اليومي، وذلك بقسمة المجموع على عدد الأيام:\nفهنا تبيَّن لنا أمران:\nحسنًا لو أردنا أن نعرف المعدل اليومي خلال الشهر؟ ماذا لو قلنا خلال السنة؟ الأمر سيطول كثيرًا.\nوهذا النمط في البرمجة هو: عرض مجموع بيانات على إجراء واحدة تلو الأخرى من أولها إلى آخرها. وتعبر بايثون عن القائمة (list) التي هي سلسلة بيانات، بالقوسين المربعين [] على النحو التالي:\nفنوظفهما لمقصدنا كالتالي:\nحسنًا ماذا لو أردنا تعريف الدالة sum(list) والدالة len(list) بأنفسنا؟ فكيف ستبدوا؟\nوجب علينا أولاً أن نرجع إلى جملة التعيين (Assignment) التي عرفناها في الفصل الأوَّل. تذكر أن علامة = هي جملة تعيين وليست مساواةً كما في الرياضيات. فالتعيين اللاحق ناسخٌ لأي تعيين يسبقه.\nx = 10\nx = 20\nprint(x)\n\n20\nولك أيضًا أن تستعملها لزيادة المتغير أو إنقاصه، وهو ما يسمى التعيين النسبي:\nx = 100\nx = x + 100\nx = x - 50\nx = x * 2\nx = x / 4\nprint(x)\n\n75.0\nولنفهم ذلك نتصوَّر أن المتغير في الطرف الأيمَن يتم التعويض عنه بقيمته، ثم يتم حساب العمليَّة (100 + 100) ثم يتم التعيين فتنتقل النتيجة من الطرف الأمين إلى x في الطرف الأيسر. فأصبحت قيمة x بعد السطر الثاني: 200.\nثم سطر الطرح: ننظر أوَّلاً للطرف الأيمن فنعوِّض المتغير x بقيمتها 200 ثم نُجري العملية: (200 - 50) ثم يتم تعيين حاصل ذلك بموجب علامة التعيين = للطرف الأيسر: x. فتصبح قيمة x بعد السطر الثالث: 150.\nوقل مثل ذلك في الضرب والقسمة.\nوتعبِّر بايثون للتعين النسبي (Augmented Assignment) باختصار هكذا:\nx = 100\nx += 100\nx -= 50\nx *= 2\nx /= 4\nprint(x)\n\n75.0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#الكر",
    "href": "chapters/00_rewrite/04_sequences.html#الكر",
    "title": "4  التسلسل",
    "section": "الكر",
    "text": "الكر\nنعود إلى مسألتنا وهي تعريف إجراء يحسب مجموع الأعداد. لمعرفة كيفية ذلك؛ فإن بايثون تعبِّر عن آليَّة العبور على العناصر بجملة الكر (Iteration) وتبدأ بكلمة for وذلك على النحو التالي (وسنجعلها في إجراء):\n\ndef sum2(numbers):\n  total = 0\n  for x in numbers:\n    total += x\n  return total\n\nلاحظ أننا استعملنا اسمًا لا يتعارض مع الاسم الموجود. والمتغير total في هذا السياق يسمى المُراكِم (Accumulator) إذْ يُستعمَل لتحصيل القيمة النهائية خطوة بعد خطوة. وأما جملة الكر (for x in numbers) فإنها تمرُّ على عناصر المجموعة numbers، فتقرأ أول واحدٍ فيها فتسميه x ثم تنفذ ما وضعنا في جسدها. ثم تأخذ الثاني فتفعل مثل ذلك. ثم تأخذ الثالث فتفعل مثل ذلك. وهلم جرا .. حتى تمر على آخر عنصر. وأما جملة الرجوع return total فهي التي ترجع بقيمة المتغير الذي فيه النتيجة.\nثم نستعمل هذا الإجراء:\n\nz = sum2(days)\nprint(z)\n\n105\n\n\nوأما إجراء العد len() فعلى هذا النحو:\n\ndef len2(numbers):\n  count = 0\n  for _ in numbers:\n    count += 1\n  return count\n\nولاحظ أننا وضعنا _ بدلاً من x لأنه لا تهمنا قيمة أي عنصر في المجموعة. فهدفنا مجرد العد من الأول إلى الأخير.\nونستعمل هذا الإجراء:\n\ny = len2(days)\nprint(y)\n\n7\n\n\nوالآن نستطيع أن نركب هذين الإجرائين لمعرفة المعدَّل، وسنعرف إجراءً له:\n\ndef mean(numbers):\n  return sum2(numbers) / len2(numbers)\n\nونستعمل هذا الإجراء:\n\nm = mean(days)\nprint(m)\n\n15.0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#الإشارة",
    "href": "chapters/00_rewrite/04_sequences.html#الإشارة",
    "title": "4  التسلسل",
    "section": "الإشارة",
    "text": "الإشارة\nإننا بالتعبير بالقوسين المربعين [] اختصرنا كثيرًا من التكرار في الكتابة. لكن لو سئلت كيف تقرأ قيمة اليوم الأخير؟ أو كيف تقرأ قيمة اليوم الأوَّل؟ فقد كان الجواب عن ذلك باستعمال اسم المتغير: day1 و day7 على النحو التالي:\n\nprint(day1)\nprint(day7)\n\n10\n5\n\n\nوهذا يمكن التعبير عنه بعامل الإشارة [i]، حيث تكون الإشارة نسبةً إلى بداية التسلسل. فالعنصر الأوَّل هو [0] والعنصر الثاني هو [1] وهلمَّ جرا. فتقول:\n\nprint(days[0])\nprint(days[6])\n\n10\n5\n\n\nوتستطيع أن تعرف اليوم الأخير، بعد العناصر بالإجراء len() ثم تطرح منه 1 وتجعل النتيجة في عامل الإشارة [i] كالتالي:\n\ni = len(days) - 1\nprint(days[i])\n\n5\n\n\nوحتى لا يطول ذلك، فإن بايثون تعبر عنه باختصار بالإشارة بالسالب هكذا [-1] كالتالي:\n\nprint(days[-1])\n\n5",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#قائمة-طويلة",
    "href": "chapters/00_rewrite/04_sequences.html#قائمة-طويلة",
    "title": "4  التسلسل",
    "section": "قائمة طويلة",
    "text": "قائمة طويلة\nوتخيل أن هذه البيانات استمرَّت شهرًا فيه أربعة أسابيع، هكذا:\n\ndays = [\n  10, 15, 10, 30, 40, 20,  8,\n  30, 20, 15, 50, 30,  5, 10,\n   5, 45, 20, 10,  5, 40, 30,\n   7, 15, 10, 30, 40, 20,  9,\n]\n\nوأما جعلها في أربعة أسطر، فإنه من قبيل الترتيب، ولا يؤثر في معناها بالنسبة لبايثون. فلو أردت عددها فسترى أنها \\(7 \\times 4 = 28\\) عنصرًا:\n\nprint(len(days))\n\n28\n\n\nوكذلك الأول والثاني والثالث، والأخير والذي قبله والذي قبله:\n\nprint(days[0])\nprint(days[1])\nprint(days[2])\nprint(days[-1])\nprint(days[-2])\nprint(days[-3])\n\n10\n15\n10\n9\n20\n40\n\n\nوالأوسَط:\n\nmid = len(days) // 2\nprint(days[mid])\n\n5",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#إجراء-الحساب-على-بعض-القائمة",
    "href": "chapters/00_rewrite/04_sequences.html#إجراء-الحساب-على-بعض-القائمة",
    "title": "4  التسلسل",
    "section": "إجراء الحساب على بعض القائمة",
    "text": "إجراء الحساب على بعض القائمة\nهب أننا نريد أن نحسب مجموع ما قرأناه في آخر يومين من كل أسبوع. ونريد أن نعرف في كل كرة موضعنا من التسلسل حتى نعرف هل نحن في وسط الأسبوع أم في آخره.\nتزودنا بايثون بدالة النطاق range(start, stop, step) وبالاستعمال تتضح:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nوهذه معناها:\n\nالبداية هي 0\nالنهاية هي 10\nالخطوة هي 2\n\nوهذا يعني أننا نبدأ من 0 ونصل إلى 10 بخطوة مقدارها 2، فنحصل على الأعداد: 0, 2, 4, 6, 8. ولاحظ أن النهاية غير مشمولة.\nوإذا مررنا معطيين، فإنهما يفسرنا على أنهما البداية والنهاية، والقيمة الافتراضية للخطوة هي 1:\n\nfor i in range(1, 10):\n  print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nوإذا كان المعطى واحدًا؛ فإنه يفسَّر بأنه النهاية، والقيمة الافتراضية للبداية هي 0:\n\nfor i in range(10):\n  print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nوالآن نستعمل النطاق لتوليد الأرقام بحيث تكون النهاية هي عدد الأيام، فيحصل لنا هذا الكر:\n\nfor i in range(len(days)):\n  print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\nفأما نهاية الأسبوع الأوَّل فهي 5 و 6\nوأما نهاية الأسبوع الثاني فهي 12 و 13\nوأما نهاية الأسبوع الثالث فهي 19 و 20\nوأما نهاية الأسبوع الرابع فهي 26 و 27\n\nفنستطيع أن نقول:\n\ntotal = 0\nfor i in range(len(days)):\n  if i == 5 or i == 6 or i == 12 or i == 13 or i == 19 or i == 20 or i == 26 or i == 27:\n    total += days[i]\nprint(total)\n\n142\n\n\nوهذه الطريقة طويلة. وتوجد طريقة أفضل من هذه باستعمال الحسابات المقاسية.\nالحسابيات المقاسية (Modular Arithmetic) تتحرك فيه الأرقام بالجمع والضرب ونحوه بحيث تلتف الأرقام حول بعضها البعض عند الوصول إلى قيمة معينة، تسمى القياس (Modulus).\n\n\n\nنستعمل في ساعة الحائط القياس 12 في حساب الوقت\n\n\nوهذه العملية التي تراها في الصورة، نعبر عنها في بايثون بباقي القسمة % من حاصل زيادة المدة إلى الساعة:\n\n(9 + 4) % 12\n\n1\n\n\nوها نحن نعود إلى المسألة الأصلية ونستعمل باقي القسمة بحيث تكون الدوْرة سبعة أيام للأسبوع، فتصير الأرقام بعد 4 هما فقط 5 و 6 ثم ترجع إلى 0 وهكذا تدور:\n\n\n\nاستعمال القياس 7 لأيام الأسبوع\n\n\n\ntotal = 0\nfor i in range(len(days)):\n  if i % 7 &gt; 4:\n    total += days[i]\nprint(total)\n\n142",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#الشريحة",
    "href": "chapters/00_rewrite/04_sequences.html#الشريحة",
    "title": "4  التسلسل",
    "section": "الشريحة",
    "text": "الشريحة\nوإذا أردنا حساب مجموع الأسابيع على حدة، فإننا نحتاج لاستخراج العناصر السبعة الأولى فقط. وهذا يحصل بعامل الإشارة وتمرير قيمة شريحة (slice ويعبر عنها بالنطقتين الرأسيتين :)، وذلك على هذا النحو:\n\nweek1 = days[0:7]\nprint(week1)\n\n[10, 15, 10, 30, 40, 20, 8]\n\n\nولاحظ أن النهاية لا تشمل العنصر رقم 7 وإنما غايتها العنصر رقم 6.\nوإذا كانت البداية من 0 فكتابتها وعدمه واحدة:\n\nweek1 = days[:7]\nprint(week1)\n\n[10, 15, 10, 30, 40, 20, 8]\n\n\nوكذلك الأسبوع الثاني والثالث والرابع:\n\nweek2 = days[7:14]\nweek3 = days[14:21]\nweek4 = days[21:28]\n\nprint(week1, '--&gt;', sum(week1))\nprint(week2, '--&gt;', sum(week2))\nprint(week3, '--&gt;', sum(week3))\nprint(week4, '--&gt;', sum(week4))\n\n[10, 15, 10, 30, 40, 20, 8] --&gt; 133\n[30, 20, 15, 50, 30, 5, 10] --&gt; 160\n[5, 45, 20, 10, 5, 40, 30] --&gt; 155\n[7, 15, 10, 30, 40, 20, 9] --&gt; 131\n\n\nفإذا كانت القائمة فيها عدة أشهر، فإن هذا أيضًا سيطول. ويمكننا هنا أن نستعمل النطاق لتوليد الأرقام بسبع خطوات بينها، واستعمال الشريحة من الخطوة التي نكون فيها سبعًا إلى الأمام. وذلك على النحو التالي:\n\nfor i in range(0, len(days), 7):\n  print(sum(days[i:i+7]))\n\n133\n160\n155\n131\n\n\nفإذا أردت لكل أن تحسب مجموع القراءة بين اليومين الأخيرين لكل أسبوع على حدة فهكذا:\n\nfor i in range(0, len(days), 7):\n  print(sum(days[i+5:i+7]))\n\n28\n15\n70\n29",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#الجدول-السلاسل-المتقابلة",
    "href": "chapters/00_rewrite/04_sequences.html#الجدول-السلاسل-المتقابلة",
    "title": "4  التسلسل",
    "section": "الجدول: السلاسل المتقابلة",
    "text": "الجدول: السلاسل المتقابلة\nومن أنماط المجموعات: القوائم المرتبطة عناصرها ببعض. وهي الجداول (Tables).\nافترض أن لديك قائمة بالمصروفات (expenses) والإيرادات (revenues) لكل رُبع من السنة، وتريد حساب صافي الربح (net) لكل ربع على حدة، ثم جمعها لتحصل على الربح الإجمالي للسنة.\n\nrevenues = [52000, 51000, 48000, 50000]\nexpenses = [46800, 45900, 43200, 47000]\nnet      = [    0,     0,     0,     0]\n\nفإننا نستعمل نفس الرقم (i) للإشارة هنا وهنا أثناء الكر، حتى نجري الحساب على القيَم المتقابلة، ونضع ناتج ذلك في موضعٍ يقابلهما في سلسلة ثالثة (net)، وذلك على النحو التالي:\n\nfor i in range(len(revenues)):\n    net[i] = revenues[i] - expenses[i]\n\nprint('quarterly net:', net)\nprint('   annual net:', sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100\n\n\nولاحظ أن جملة التعيين net[i] = ... تحلُّ محلَّ الصفر الذي كان فيه.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#التصفية",
    "href": "chapters/00_rewrite/04_sequences.html#التصفية",
    "title": "4  التسلسل",
    "section": "التصفية",
    "text": "التصفية\nوقد تكون بيانات المصروفات والإيرادات مسجَّلة في سلسلة واحدة بالقيَم الموجبة والسالبة. ونريد فصلها لمجموعتين، لنحسب متوسط هذه ومتوسط هذه على حدة. وهذا النمط يتكرر كثيرًا وهو التصفية (Filtering): وهي استخراج العناصر بحسب معيارٍ.\nتصور أن لدينا قائمة من الأرقام الموجبة والسالبة في مجموعة واحدة، ونريد فصلها لمجموعتين:\n\ntransactions = [1200, -500, 300, -200, 450, -1000, 800]\n\nتقبل المجموعة إضافة العنصر إليها بالإجراء .append() المُسنَد إليها:\n\nrevenues = []\nexpenses = []\n\nfor x in transactions:\n    if x &gt;= 0:\n        revenues.append(x)\n    else:\n        expenses.append(x)\n\nprint('average revenues:', sum(revenues) / len(revenues))\nprint('average expenses:', sum(expenses) / len(expenses))\n\naverage revenues: 687.5\naverage expenses: -566.6666666666666",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#الأكبر-والأصغر",
    "href": "chapters/00_rewrite/04_sequences.html#الأكبر-والأصغر",
    "title": "4  التسلسل",
    "section": "الأكبر والأصغر",
    "text": "الأكبر والأصغر\nفإذا أردت معرفةَ أكبرها وأصغرها، فقد تستعمل الدالتين: max() و min()، على النحو التالي:\n\nprint(min(revenues), max(revenues))\nprint(min(expenses), max(expenses))\n\n300 1200\n-1000 -200",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/04_sequences.html#الترتيب",
    "href": "chapters/00_rewrite/04_sequences.html#الترتيب",
    "title": "4  التسلسل",
    "section": "الترتيب",
    "text": "الترتيب\nوإذا أردت عرضها مرتبةً من الأصغر إلى الأكبر، فتستعمل دالَّة الترتيب sorted()، على النحو التالي:\n\nprint('  sorted:', sorted(revenues))\nprint('unsorted:', revenues)\n\n  sorted: [300, 450, 800, 1200]\nunsorted: [1200, 300, 450, 800]\n\n\nوإذا أردتها بالعكس، فتغير المُعطى (reverse) من قيمته الإفتراضيَّة False إلى القيمة True، على النحو التالي:\n\nprint('  sorted:', sorted(revenues, reverse=True))\nprint('unsorted:', revenues)\n\n  sorted: [1200, 800, 450, 300]\nunsorted: [1200, 300, 450, 800]\n\n\nللمزيد راجع ملحق القائمة.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/05_computer_and_world.html",
    "href": "chapters/00_rewrite/05_computer_and_world.html",
    "title": "5  الحاسب والعالم",
    "section": "",
    "text": "أجهزة الإدخال والإخراج (I/O Devices)\nرغم تعقيد الحواسيب اليوم، إلا أنها ترجع إلى معمارية فون نويمان (بالإنجليزية: Von Neumann architecture) وهي مجموعة من القواعد الأساسية وضعها العالم الرياضي جون فون نويمان ومعاونوه عام 1945م -وتُستعمل حتى الأن- في تصميم الحاسبات.\nيصور هذا النموذج الحاسب بمكونين رأيسيين:\nالمكون الأوَّل: وحدة المعالجة المركزية (Central Processing Unit - CPU) وهي التي تعبَّأ فيها البرمجيَّة مترجمةً، فتتشكَّل الدوائر الكهربائيَّة فيها وتعمَل عملها الذي نرى نتيجته. وتتكون من شيئين:\nالأول: وحدة التحكم (Control Unit) وهي التي تتحكم في سيْر العمليات:\nالثاني: وحدة الحساب والمنطق (Arithmetic and Logic Unit - ALU) تنفذ تعليمات المنطق الرقمي كالجمع والطرح والمقارنة والرجوع ونحو ذلك.\nفالعمليات على نوعين:\nعمليات حساب (Computation): عمليات تنفذها وحدة المعالجة المركزية (CPU). وذلك مثل الجمع والطرح، وفصل النصوص ودمجها، والشرط والتكرار، ونحو ذلك.\nوعمليات إدخال وإخراج (I/O): عمليات تنفذها الأجهزة المرتبطة به؛ بناءً على طلبه.\nالمكوِّن الثاني: ذاكرة الوصول العشوائي (Random Access Memory - RAM) التي تحمل البرنامج المترجَم ليتمَّ إدخاله لوحدة المعالجة، وكذلك:\nفكل اسم عرَّفته في النص البرمجي، سواءٌ كان متغيرًا أو إجراءً= فإنَّه مما يُحفظ في هذه الذاكرة أثناء عمل البرنامج.\nوقد اصطلح الناس على الاختصار I/O إشارة إلى الإنجليزية Input/Output لهذين الأمرين. فمن ذلك:\nالمخزن (Storage): مثل القرص الصلب (HDD)، وقرص الحالة الصلبة (SSD). ومهمتها حفظ المعلومات المكتوبة لديها على المدى البعيد، والقدرة على استرجاعها متى طلبها المعالج.\nوأما منفذ الشبكة (Network): فعن طريقه تدخل وتخرج المعلومات من وإلى الأجهزة الأخرى المتصلة بالشبكة. وهذا عامٌّ سواءً في الشبكة السلكية (Ethernet) أو الشبكة اللاسلكية (WiFi) أو حتى البلوتوث (Bluetooth) والاتصال قريب المدى (NFC).\nومن الأجهزة ما وظفيته الإدخال فقط: كلوحة المفاتيح (Keyboard)، والمؤشر (Mouse)، والكاميرا، ولاقط الصوت. ومنها: أجهزة استشعار: الحرارة والرطوبة والبعد والميل والاهتزاز والحركة …إلخ.\nومن الأجهزة ما وظفيته الإخراج فقط: كالشاشة ،والطابعة ،والسماعات. ومنه: أجهزة تحريك: المفتاح والماطور والصمام …إلخ.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحاسب والعالم</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/05_computer_and_world.html#أجهزة-الإدخال-والإخراج-io-devices",
    "href": "chapters/00_rewrite/05_computer_and_world.html#أجهزة-الإدخال-والإخراج-io-devices",
    "title": "5  الحاسب والعالم",
    "section": "",
    "text": "ملاحظة\n\n\n\nلا يكون البرنامج مفيدًا إلا بمنفذ يُخرج فيه نتائجه. ولا يكون مستجيبًا إلا بمنفذٍ تدخل منه المعطيات إليه.\n\n\n\n\n\n\n\n\n\n\nأمثلة لأجهزة الإدخال والإخراج (I/O Devices)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحاسب والعالم</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/05_computer_and_world.html#التحكم",
    "href": "chapters/00_rewrite/05_computer_and_world.html#التحكم",
    "title": "5  الحاسب والعالم",
    "section": "التحكم",
    "text": "التحكم\nولا تقتصر نتائج المعالجة على الأجهزة التي عادة ما تتصل بالحاسب الشخصي، بل الأمر أوسع من هذا. فإن التحكُّم في الأجهزة المعقَّدة مثل الروبوتات هو من هذا القبيل أيضًا. وهذا يشمل أيضًا الأذرعة الآلية في المصانع مثلاً كما هو موضَّح في الصورة.\n\n\n\nالمصدر: www.kuka.com\n\n\nتبيَّن لنا أن الجهاز لا يكون مفيدًا إلا باتصاله بالعالَم المحيط به. وذلك يكون بأجهزة الإدخال للنظر في معطياته، وبأجهزة الإخراج للتأثير فيه. والمعالجةُ هي محوَر ذلك كله.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحاسب والعالم</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html",
    "href": "chapters/00_rewrite/06_text_files.html",
    "title": "6  الملفات النصية",
    "section": "",
    "text": "حقيقة النص\nلم يقتصر عمل الحاسب على العمليات الحسابية بين الأرقام فحسب، بل امتدَّ ليصل إلى معالجة النصوص (Text Processing) التي تأتي بأشكال مختلفة منها: محادثات وسائل التواصل الاجتماعي، ورسائل البريد الإلكتروني، ومقالات وكتب وموسوعات وصفحات ومواقع الشبكة.\nفأوجه معالجة النصوص الحرة كثيرة منها: الفهرسة والعد والتصنيف والترتيب لتسهيل البحث والاسترجاع. وكذلك التعديل بالاستبدال، والتصحيح التلقائي، والرسم؛ سواءٌ على الشاشة أو في الطباعة.\nوتوجد ثلاثة طرق لإنشاء النص في بايثون:\nعلى سبيل المثال:\nتأمل إنشاء هذا النص الذي يبتدئ في السطر الأول ويمتد لأربعة أسطر:\nيتم تمثيل النص في بايثون بالنوع str (من String وتعني خيط) وهو سلسلة رموز (وهي التي نضعها بين علامتي التنصيص \"\") لكن الذي يحصل في الواقع أن مفسِّر لغة بايثون يترجمها إلى أرقام تقابلها في جدول الترميز العالمي Unicode لتكون قيمة المتغيِّر في الحقيقة.\nيحوي هذا الجدول رموز لجميع اللغات البشرية ابتداءً بالإنجليزية واللاتينية، ثم اللغات الأخرى كالعربية والعبرية والصينية واليابانية والكورية وبقية لغات العالم. بالإضافة إلى علامات الترقيم الخاصة بكل لغة، ورموز الأرقام. وفوق ذلك الرسوم التي تجدها في المحادثات ومواقع التواصل مثل: 🤗💡🔍📐 وما أشبهها.\nلاحظ في النص البرمجي أن الدالة chr(i) تحوِّل الرقم i إلى رمز Unicode المقابل له. ونحن نستعملها في حلقة لكر الأرقام من 32 إلى 127 ونقسمها لمجموعات بحيث يكون كل سطر فيه مجموعة من الحروف:\nfor i in range(32, 127):\n    if i in [48, 58, 65, 91, 97, 123]:\n        print()\n    print(chr(i), end=' ')\n\n  ! \" # $ % & ' ( ) * + , - . / \n0 1 2 3 4 5 6 7 8 9 \n: ; &lt; = &gt; ? @ \nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n[ \\ ] ^ _ ` \na b c d e f g h i j k l m n o p q r s t u v w x y z \n{ | } ~\nولو أردت العكس: أن تعرف ما هو الرقم للرمز، فإنك تستعمل دالة ord(c) على النحو التالي:\nprint(ord(\"A\"), ord(\"Z\"), ord(\"a\"), ord(\"z\"), ord(\"0\"), ord(\"9\"))\nprint(ord(\"!\"), ord(\"?\"), ord(\".\"), ord(\",\"), ord(\":\"), ord(\";\"))\nprint(ord(\"ب\"), ord(\"ي\"), ord(\"ة\"))\nprint(ord(\"😄\"), ord(\"🚀\"))\n\n65 90 97 122 48 57\n33 63 46 44 58 59\n1576 1610 1577\n128516 128640\nلذلك فإن المقارنة بين السلاسل النصيَّة هي في الحقيقة مقارنة بأرقامها. فالحرف الصغير والحرف الكبير رقمان مختلفان:\nprint(\"A\" == \"a\")\n\nFalse\nوالحاصل في الواقع هو أن بايثون تقارنها بعد التحويل إلى الأرقام:\nprint(ord(\"A\"), ord(\"a\"))\nprint(ord(\"A\") == ord(\"a\"))\n\n65 97\nFalse\nلذلك لا تعجب من أن الحرف الكبير أصغر من الصغير بهذا الاعتبار؛ وذلك: لأنه يأتي قبله في جدول الترميز العالمي، فرقمه أقل من رقم الصغير:\nprint(\"A\" &gt; \"a\")\n\nFalse\nوالسبب في ابتدائنا من 32 هو أن الأرقام التي قبل ذلك تسىمى أحرف تحكم (Control Characters). بل إن رقم 32 نفسه هو حرف تحكُّم وظيفته تحريك رأس الكتابة بمقدار خطوة واحدة لتكوين مسافة.\nprint(chr(32) == \" \")\nprint(ord(\" \") == 32)\n\nTrue\nTrue\nوهو من أحرف الفراغات (Whitespace Characters)، ويهمنا منها:\nولاحظ أن الشرطة مع الحرف، يفسران كرقم واحد، وإنما وُضِعَت لها رموز لكثرة استعمالها، ويمكننا معرفة الأرقام الدالة على كل من هذه الرموز هكذا:\nprint(ord(\" \"), ord(\"\\t\"), ord(\"\\n\"))\n\n32 9 10\nونحن في كل مرة نستعمل إجراء الطباعة: print() فالقيمة الافتراضيَّة للمعطى end='\\n'، وهذا يعني أن الطباعة يتبعها علامة الانتقال لسطر جديد. فإذا أردت أن تكون الطباعة بلا سطرٍ جديد، بل تكون مثلاً، مسافة، فإننا نعيِّن قيمة المعطى عند الاستدعاء:\nprint(\"Hello\", end=\" \")\nprint(\"World\")\n\nHello World\nوبهذا تبيَّن لك كيف كانت جملة الكر تطبع الحروف بالنسق الذي أردناه لها.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#حقيقة-النص",
    "href": "chapters/00_rewrite/06_text_files.html#حقيقة-النص",
    "title": "6  الملفات النصية",
    "section": "",
    "text": "المسافة (Space): \" \" ويعني الانتقال بمقدار خطوة واحدة لإحداث فراغ بين الكلمات\nالسطر (Line Feed): \"\\n\" ويعني الانتقال للسطر التالي\nالبادئة (Tab): \"\\t\" وهي التي تكون في بداية الفقرة، أو التي تكون بين الأعمدة في تنسيق الجداو. وقد نستعملها في كتابة بايثون للمحاذاة",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#إخراج-النص",
    "href": "chapters/00_rewrite/06_text_files.html#إخراج-النص",
    "title": "6  الملفات النصية",
    "section": "إخراج النص",
    "text": "إخراج النص\nكثيرًا ما نحتاج لصياغة البيانات بقالب معيَّن، حتى يُرسَل ويفسَّر في الجهة المقابلة من برنامج آخر باعتبار نفس القالب، فتسهل قراءته بهذا الوجه.\nومن ذلك مثلاً رسائل البريد الإلكتروني حيث تكتب:\n\nemail_template = \"\"\"Assalamu Alaikum {candidate_name},\n\nWe're pleased to invite you for an interview for the {job_title} position.\n\nDetails:\n\n- Date: {interview_date}\n- Time: {interview_time} {time_zone}\n- Method: {interview_method}\n\nPlease confirm your availability by {rsvp_date}.\n\nWe look forward to speaking with you, Insha'Allah!\n\nWith sincere regards,\nThe {company_name} Hiring Team\n\"\"\"\n\nوعملية الضرب تنتج تكرارًا للنص:\n\nprint('-' * 10)\nprint('=' * 10)\nprint('*' * 10)\n\n----------\n==========\n**********\n\n\nفنستطيع أن نطرِّز الرسالة به:\n\ndecor = \"=\" * 80\nemail_template = decor + \"\\n\" + email_template + \"\\n\" + decor\n\nفهذا القالب يُمكن ملؤه بحسب المرسل والمرسل إليه، وذلك على النحو التالي:\n\nfilled_email = email_template.format(\n    company_name=\"Tech Solutions Inc.\",\n    job_title=\"Software Engineer\",\n    candidate_name=\"Adam Ben Saad\",\n    interview_date=\"July 15, 2045\",\n    interview_time=\"10:00 AM\",\n    time_zone=\"GMT+3\",\n    interview_method=\"Online video call\",\n    rsvp_date=\"July 10, 2045\"\n)\n\nفإذا ما طبعنا هذا النص فسيظهر أن المتغير الآن يحتفظ بنسخة تمَّ تعبئة القالب فيه بالقيَم المعطاة:\n\nprint(filled_email)\n\n================================================================================\nAssalamu Alaikum Adam Ben Saad,\n\nWe're pleased to invite you for an interview for the Software Engineer position.\n\nDetails:\n\n- Date: July 15, 2045\n- Time: 10:00 AM GMT+3\n- Method: Online video call\n\nPlease confirm your availability by July 10, 2045.\n\nWe look forward to speaking with you, Insha'Allah!\n\nWith sincere regards,\nThe Tech Solutions Inc. Hiring Team\n\n================================================================================",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#كتابة-النص",
    "href": "chapters/00_rewrite/06_text_files.html#كتابة-النص",
    "title": "6  الملفات النصية",
    "section": "كتابة النص",
    "text": "كتابة النص\nوتتم كتابة النص في الملفات باستعمال الإجراء write() على النحو التالي:\n\nfile = open('email.txt', 'w')\nfile.write(filled_email)\nfile.close()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#إدخال-النص",
    "href": "chapters/00_rewrite/06_text_files.html#إدخال-النص",
    "title": "6  الملفات النصية",
    "section": "إدخال النص",
    "text": "إدخال النص\nوالغالب أن وجود النص في البرنامج يكون ناتجًا عن قراءة ملف نصي بالإجراء open() أي: في نفس المجلد الذي يوجد فيه البرنامج:\n\nfile = open('email.txt')\ncontent = file.read()\nfile.close()\nprint(content)\n\n================================================================================\nAssalamu Alaikum Adam Ben Saad,\n\nWe're pleased to invite you for an interview for the Software Engineer position.\n\nDetails:\n\n- Date: July 15, 2045\n- Time: 10:00 AM GMT+3\n- Method: Online video call\n\nPlease confirm your availability by July 10, 2045.\n\nWe look forward to speaking with you, Insha'Allah!\n\nWith sincere regards,\nThe Tech Solutions Inc. Hiring Team\n\n================================================================================\n\n\nوإذا كان الملف في مسارٍ آخر وأردنا قراءته، فوجب تعيين المسار بحسبه.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#السياق",
    "href": "chapters/00_rewrite/06_text_files.html#السياق",
    "title": "6  الملفات النصية",
    "section": "السياق",
    "text": "السياق\nوهنا إشارة إلى أن عملية فتح الملف open() يجب أن تتبع بعملية .close() لإغلاقه. وهذا النمط يتكرر كثيرًا. ولذلك جعلت بايثون لهذا النمط كلمة with بحيث يتم الإغلاق بعند انتهاء جسد السياق:\n\nwith open('email.txt') as file:\n    content = file.read()\nprint(content)\n\n================================================================================\nAssalamu Alaikum Adam Ben Saad,\n\nWe're pleased to invite you for an interview for the Software Engineer position.\n\nDetails:\n\n- Date: July 15, 2045\n- Time: 10:00 AM GMT+3\n- Method: Online video call\n\nPlease confirm your availability by July 10, 2045.\n\nWe look forward to speaking with you, Insha'Allah!\n\nWith sincere regards,\nThe Tech Solutions Inc. Hiring Team\n\n================================================================================",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#استخراج-القيم-من-النص",
    "href": "chapters/00_rewrite/06_text_files.html#استخراج-القيم-من-النص",
    "title": "6  الملفات النصية",
    "section": "استخراج القيَم من النص",
    "text": "استخراج القيَم من النص\nمن أهم عمليات النصوص، استخراج المعلومات منها، فمثلاً، نريد استخراج:\n\nتاريخ المقابلة\nالوقت\nوطريقة المقابلة\n\nوإذا لاحظنا هذه الرسالة، فإنها تعلمنا بأن أحد القوالب التي قد تستعمل هي:\n- Date: {interview_date}\n- Time: {interview_time} {time_zone}\n- Method: {interview_method}\nفلو سردنا سطور النص بحث عن هذه الكلمات، فإننا سنحقق مرادنا في استخراج القيمة، وهي الطرف الأيمن من ذلك النص. ويمكننا استعمال الدالة .splitlines() لتحويل النص إلى قائمة من النصوص، بحيث يكون كل عنصرٍ فيها سطرًا من النص.\n\nlines = content.splitlines()\nprint(len(lines))\n\n19\n\n\nثم نكرها ونبحث عن الأنماط التي نريد، ولاحظ أننا نستعمل الإجراء .split() لفصل النص إلى قائمة عند الفاصل الذي نريده، وهو النقطات الرأسيتان (:) حتى يكون فيه جزءان، فنأخذ الجزء الثاني [1] منها وهو القيمة. ونستعمل الإجراء .strip() لإزالة الفراغات المتبقية من النص (المسافات الزوائد في البداية والنهاية).\n\nfor line in lines:\n    if \"Date:\" in line:\n        date = line.split(\":\")[1].strip()\n    elif \"Time:\" in line:\n        time = line.split(\":\")[1].strip()\n    elif \"Method:\" in line:\n        method = line.split(\":\")[1].strip()\n\nprint(\"time =\", time)\nprint(\"date =\", date)\nprint(\"method =\", method)\n\ntime = 10\ndate = July 15, 2045\nmethod = Online video call\n\n\nويُراجع باب التعبير النمطي.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#النص-نوع-ما-لا-نوع-له",
    "href": "chapters/00_rewrite/06_text_files.html#النص-نوع-ما-لا-نوع-له",
    "title": "6  الملفات النصية",
    "section": "النص نوع ما لا نوع له",
    "text": "النص نوع ما لا نوع له\nتذكر: النص نوع ما لا نوع له.\nإذا أردت أن تحفظ نتائج المعالجة في ملف ليستقر في جهازك، فإنه يجب أن تحوِّل النص إلى قيمة عددية، وإلا ستفشل الكتابة كما في هذا المثال\n\nnumbers = [1000, 500, 250, 750]\ntotal = sum(numbers)\n\n\nwith open('output.txt', 'w') as file:\n    file.write(total)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[22], line 2\n      1 with open('output.txt', 'w') as file:\n----&gt; 2     file.write(total)\n\nTypeError: write() argument must be str, not int\n\n\n\nويحصل تحويل العدد إلى نص باستعمال الدالة str(i):\n\ncontent = str(total)\nwith open('output.txt', 'w') as file:\n    file.write(content)\n\nفإن الملف وقت القراءة يُقرأ كنص؛ أي كسلسلة من الأحرف، ولذلك يجب تحويله إلى قيمة عددية، وإلا ستفشل العمليات إن ظننت أنها عددية، مثلما يفشل هذا المثال:\n\nwith open('output.txt') as file:\n    content = file.read()\n\n\nprint(content + 2500)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 print(content + 2500)\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nويحصل تحويل النص إلى عددية باستعمال الدالة int(s) أو float(s):\n\ntotal = int(content)\nprint(total + 2500)\n\n5000",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/06_text_files.html#صياغة-البيانات-في-قوالب-جيسون-json",
    "href": "chapters/00_rewrite/06_text_files.html#صياغة-البيانات-في-قوالب-جيسون-json",
    "title": "6  الملفات النصية",
    "section": "صياغة البيانات في قوالب جيسون (JSON)",
    "text": "صياغة البيانات في قوالب جيسون (JSON)\nوكما أن القالب المستعمل في الرسالة البريدية صالح لقراءة البشر، فكذلك البرمجيات تستعمل قوالب للتواصل فيما بينها، وكذلك تستعمل لتخزين المعلومات وقراءتها لاحقًا. ومن أشهرها قالب JSON لأنه بسيط جدًّا؛ فما هو إلا أزواج من المفاتيح والقيَم المقابلة لها (بعد النقطيتن الرأسيتين). وهي تشبه إلى حد كبير ما يسمى القاموس (dict) في بايثون. وسنبيِّنُه إن شاء الله.\nفمن المكتبة الأساسية نستورِد وحدة json لصياغة البيانات من شكلها البايثوني إلى هذه الصيغة ثم كتابتها، أو لتحويلها من صيغتها تلك إلى القيمة البايثونية المقابلة لها.\n\nimport json\n\ntransactions = [1200, -500, 300, -200, 450, -1000, 800]\n\nwith open('transactions.json', 'w') as file:\n    json.dump(transactions, file)\n\nوعند القراءة نستعمل الإجراء json.load() لتحويل تلك الصياغة النصيَّة إلى قائمة بايثونية:\n\nwith open('transactions.json') as file:\n    transactions = json.load(file)\nprint(sum(transactions))\n\n1050\n\n\nوأما إذا كانت قيَمًا متعددة، فالأفضل وضعها في قاموس (dict) بحيث تكون أسماء المتغيرات مفاتيح (Keys)، وتكون قيمها قيَمًا لها (Values). ثم تُصاغ بصيغة JSON وتُحفظ في ملف:\n\ndata = {\n    \"expenses\": [1200, 300, 450, 800],\n    \"revenues\": [-500, -200, -1000],\n}\n\nwith open('data.json', 'w') as file:\n    json.dump(data, file)\n\nثم يمكن قراءتُها:\n\nwith open('data.json') as file:\n    data = json.load(file)\nprint(data)\n\n{'expenses': [1200, 300, 450, 800], 'revenues': [-500, -200, -1000]}\n\n\nوكذلك يمكن استخراج القيمة منها، بالاسم الذي حُفِظَ به أولاً في القاموس:\n\nrevenues = data[\"revenues\"]\nprint(sum(revenues) / len(revenues))\n\nexpenses = data[\"expenses\"]\nprint(sum(expenses) / len(expenses))\n\n-566.6666666666666\n687.5\n\n\nوقد تكون البيانات متضمنة بعضها في بعض، كتفضيلات المستخدم (user):\n\nuser = {\n    \"name\": \"Adam\",\n    \"language\": \"Arabic\",\n    \"phone\": \"966xxxxxxxxx\",\n    \"last_updated\": \"2021-09-01\",\n    \"age\": 25,\n    \"notifications\": {\n        \"email\": \"monthly\",\n        \"sms\": \"weekly\",\n        \"push\": \"daily\"\n    },\n    \"emails\": [\"example1@domain.com\", \"example2@domain.com\"]\n}\n\nفالمفتاح (Key) عادةً ما يكون نصًّا كما ترى. وأما القيمة (Value) فقد تكون نصًّا أو عددًا أو قائمة أو حتى قاموسًا!\nوللوصول إلى قيمة مضمَّنة، قد تكتب:\n\na = user['notifications']\nprint(a)\n\n{'email': 'monthly', 'sms': 'weekly', 'push': 'daily'}\n\n\n\nb = a['sms']\nprint(b)\n\nweekly\n\n\nوذلك أن نوع قيمة المتغير a هو قاموس:\n\ntype(a)\n\ndict\n\n\nأو تأتي بها مرة واحدة:\n\nc = user['notifications']['sms']\nprint(c)\n\nweekly\n\n\nوكذا الأمر في الوصول للقائمة المضمَّنة (emails) كما يلي:\n\ne = user['emails']\nprint(e)\n\n['example1@domain.com', 'example2@domain.com']\n\n\nثم الوصول إلى عنصرٍ من هذه القائمة:\n\nprint(e[0])\n\nexample1@domain.com\n\n\nوذلك أن نوع قيمة المتغير c هو قائمة:\n\ntype(e)\n\nlist\n\n\nأو الوصول إليها مرة واحدة:\n\nf = user['emails'][0]\nprint(f)\n\nexample1@domain.com\n\n\nومن الأنماط المستعملة بكثرة: استعمال القواميس كعناصر لقائمة. ولذلك وجب علينا التدرب على قراءتها.\nفمثلاً هذه قائمة يحتوي كل عنصرٍ منها على قاموس لبيانات مُرَشَّح للتوظيف، ونريد أن نستخلص خبراتهم المهنية منها:\n\ndata = [\n    {\n        'name': 'Ahmad Hamada',\n        'experiences': [\n            {\n                'company': 'Geo Space',\n                'start': '2038-01-01',\n                'end': '2039-01-01',\n                'role': 'Junior Software Engineer',\n            },\n            {\n                'company': 'Space Roots',\n                'start': '2039-01-01',\n                'end': '2041-01-01',\n                'role': 'Senior Software Engineer',\n            },\n        ],\n    },\n    {\n        'name': 'Belal Banana',\n        'experiences': [\n            {\n                'company': 'Banana Tech',\n                'start': '2041-01-01',\n                'end': '2042-01-01',\n                'role': 'Smoothie Operator',\n            },\n            {\n                'company': 'BugSquash Labs',\n                'start': '2042-02-01',\n                'end': '2043-08-01',\n                'role': 'Code Pest Control Specialist',\n            },\n            {\n                'company': 'Caffeinated Circuits Inc.',\n                'start': '2043-09-01',\n                'end': '2045-05-01',\n                'role': 'Espresso-Driven Engineer',\n            }\n        ]\n    },\n]\n\nولنفترض أننا نريد آخر وظيفة شغلها المرشح الثاني، فإننا نكتبها في بايثون بهذا الشكل:\n\ndata[1]['experiences'][-1]['role']\n\n'Espresso-Driven Engineer'\n\n\nوبايثون تقيِّمها (أي: تحسبها أو تفسِّرها) من اليسار إلى اليمين، على النحو التالي:\nمن المتغير data أريد العنصر الثاني، ومنه أريد مقابل المفتاح experiences، ومنه أريد العنصر الأخير، ومنه أريد مقابل المفتاح role.\nوقد يكون فصلها أوضَح هكذا:\n\nمن المتغير data (هو قائمة)\nمنه: العنصر الثاني (1) (هو قاموس)\nمنه: مقابل المفتاح experiences (هو قائمة)\nمنه: العنصر الأخير (هو قاموس)\nمنه: مقابل المفتاح role (هو نص)\n\nفإذا أردت أن تقرأها بالعكس من اليمين إلى اليسار، فتقول:\n\nمقابل المفتاح role\nفي العنصر الأخير من\nمقابل المفتاح experiences\nفي العنصر الثاني (1) من\nالمتغير data\n\nوتقول أيضًا: أريد وظيفةَ آخر خبرات الثاني من المرشحين.\n\n\n\n\n\n\nنصيحة\n\n\n\nقراءة صيَغ الوصول هي من مهارات المبرمج الذي يحتاجها كثيرًا.\n\n\nويُحفظ هذا النص في ملف data.json بالصيغة التالية:\n\nwith open('data.json', 'w') as file:\n    json.dump(data, file)\n\nثم يقرأ لاحقًا:\n\nwith open('data.json') as file:\n    data = json.load(file)\nprint(data[0]['name'])\n\nAhmad Hamada",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الملفات النصية</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html",
    "href": "chapters/00_rewrite/07_regex.html",
    "title": "7  التعبير النمطي",
    "section": "",
    "text": "فئة الأحرف\nتستعمل التعبيرات النمطية لاستخراج البيانات من النصوص. على سبيل المثال، هذا سجل تمارين فيه في كل سطر نوع من أنواع التمارين وعدد الجلسات ومرات التكرار، لكنها غير مرتبة. فأحيانًا يكون الاسم في البداية، وأحيانا في الأخير … وهكذا.\nالتعبير النمطي (Regular Expression): طريقة لتحديد نمط من الرموز. والغرض منه: البحث عن هذا النمط في نص ما. وله في بايثون مكتبتان:\nوسيكون حديثنا في هذا الباب عن المكتبة re. فنقوم باستيرادها كغيرها:\nوتستعمل الأحرف لتحديد النمط، ولذلك فإن بعضها له دلالة خاصة دون غيره.\nالأحرف الخاصة (meta-characters): هي أحرف ذات دلالة معيَّنة غير ما تبدو؛ وهي:\nسنبدأ أولاً بشرح محدد فئة الأحرف [ ] (Character Class) ويعمل كالآتي:\nوبهذا تعرف دلالة:\nتأمل المثال التالي:\ntext = \"I am 21 years old\"\npattern = \"[0-9][0-9]\"\nmatch = re.search(pattern, text)\nprint(match)\n\n&lt;re.Match object; span=(5, 7), match='21'&gt;\nولاستخراج النص المطابق نستعمل الفعل match.group() هكذا:\nif match:\n    print(match.group())\n\n21",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#فئة-الأحرف",
    "href": "chapters/00_rewrite/07_regex.html#فئة-الأحرف",
    "title": "7  التعبير النمطي",
    "section": "",
    "text": "[abc] يطابق a أو b أو c\n[^abc] يطابق أي حرف غير a أو b أو c\n[a-c] يطابق أي حرف من a إلى c: a أو b أو c\n[3-7] يطابق أي رقم من 3 إلى 7: 3 أو 4 أو 5 أو 6 أو 7\n[a-zA-Z] يطابق أي حرف صغير أو كبير من a إلى z أو A إلى Z\n[a-zA-Z0-9_] يطابق أي حرف صغير أو كبير أو رقم من a إلى z أو A إلى Z أو 0 إلى 9 أو _ (الشرطة السفلية)\n\n\n\nعلامة ^ في نحو: [^ فإنها تدل على عكس الفئة\nعلامة - في نحو: [a-b] فإنها تدل على الأحرف بين الحرفين (شاملة لهما)\n\n\n\n\nلاحظ أن النمط: [0-9][0-9] يطابق أي رقمين متتاليين من 0 إلى 9.\nويأتي الإجراء re.search للبحث داخل النص text عن النمط pattern؛ والنتيجة من النوع Match إذا وُجد النمط، وإلا فيكون None.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#فئات-لها-رمز",
    "href": "chapters/00_rewrite/07_regex.html#فئات-لها-رمز",
    "title": "7  التعبير النمطي",
    "section": "فئات لها رمز",
    "text": "فئات لها رمز\nينضم إلى الأحرف الآنف ذكرها:\n\n\n\\d وعكسها \\D\n\n\nيطابق أي رقم عشري؛ وهو مكافئ: [0-9].\n\n\n\\w وعكسها \\W\n\n\nيطابق الأحرف الأبجدية والأرقام والشرطة السفلية [a-zA-Z0-9_]. وبالنسبة لأنماط Unicode (str)، فإنه يطابق الأحرف الأبجدية الرقمية في Unicode (كما هو معرّف بواسطة str.isalnum())، بالإضافة إلى الشرطة السفلية _.\n\n\n\\s وعكسها \\S\n\n\nيطابق المسافات البيضاء؛ وهو مكافئ: [ \\t\\n\\r\\f\\v] (لاحظ وجود المسافة).\n\n\n\\b وعكسها \\B\n\n\nيطابق طرف كلمة\n\n\nولأن بايثون تعتبر علامة \\ في النصوص علامةً على أحرف خاصة (Escape Character) مثل:\n\n\\n للسطر الجديد\n\\t للمسافة البيضاء\n\\r للرجوع إلى البداية\n\\f للصفحة\n\\v للمسافة العمودية\n\nولتجنب التعارض بين حرف \\ المقصود في النص البايثوني المعروف، والاختصارات التي نريدها؛ فقد وضعت بايثون حرف r لتعطيل خصوصية الحرف \\ حتى تُكتَب الأنماط النصية بمى يسمى النص الخام (raw string) كما سيأتي.\n\nالأرقام\n\ntext = \"I am 21 years old\"\npattern = r\"\\d\\d\"\nmatch = re.search(pattern, text)\nif match:\n    print(match.group())\n\n21\n\n\n\n\n\n\n\n\nنصيحة\n\n\n\nدائمًا استعمل النص الخام (بالعلامة r) عند كتابة الأنماط.\n\n\n\n\nالحروف\nوأما لمطابقة الحروف فإننا قد نستعمل الاختصار \\w، والنمط التالي يقول: أي حرفين يتوسطهما حرف a مثل: cat أو bat أو rat. والخارج من هذا النمط هو كلمة: dog.\n\nanimals = [\n    \"cat\",\n    \"bat\",\n    \"dog\",\n    \"rat\",\n]\n\npattern = r\"\\wa\\w\"\n\nfor animal in animals:\n    match = re.search(pattern, animal)\n    if match:\n        print(match.group())\n\ncat\nbat\nrat\n\n\nلاحظ أن النمط \\wa\\w يتكون من ثلاثة أجزاء:\n\n\\w تطابق الأحرف الأبجدية والأرقام والشرطة السفلية\na تطابق الحرف a كما هو\n\\w تطابق الأحرف الأبجدية والأرقام والشرطة السفلية\n\n\n\nطرف الكلمة \\b\nيطابق الرمز \\b، وتستعمل للسياقات التي نريد فيها المطابقة الكليَّة للكلمة، لا أن تكون جُزءًا من كلمة أخرى.\n\ntext1 = \"My ear\"\ntext2 = \"I arrived early\"\ntext3 = \"This is the end of the year\"\n\nلاحظ في المثال التالي أن النمط لا يطابق إلا النص الأوَّل، وذلك لأنه يشترط أن تكون الكلمة ذات حافة في الأول وفي الأخير:\n\nentire = r\"\\b\" + \"ear\" + r\"\\b\"\nprint(re.search(entire, text1))\nprint(re.search(entire, text2))\nprint(re.search(entire, text3))\n\n&lt;re.Match object; span=(3, 6), match='ear'&gt;\nNone\nNone\n\n\nلاحظ في المثال التالي مطابقة الأول والثاني، لكوْن اشتراط الحافة في البداية فقط:\n\nstarts = r\"\\b\" + \"ear\"\nprint(re.search(starts, text1))\nprint(re.search(starts, text2))\nprint(re.search(starts, text3))\n\n&lt;re.Match object; span=(3, 6), match='ear'&gt;\n&lt;re.Match object; span=(10, 13), match='ear'&gt;\nNone\n\n\nوأما هذا المثال الأخير، فيطابق الأول والأخير، لكوْنهما ذوي حافة في النهاية:\n\nends   = \"ear\" + r\"\\b\"\nprint(re.search(ends, text1))\nprint(re.search(ends, text2))\nprint(re.search(ends, text3))\n\n&lt;re.Match object; span=(3, 6), match='ear'&gt;\nNone\n&lt;re.Match object; span=(24, 27), match='ear'&gt;",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#التكرار-والتحديد",
    "href": "chapters/00_rewrite/07_regex.html#التكرار-والتحديد",
    "title": "7  التعبير النمطي",
    "section": "التكرار والتحديد",
    "text": "التكرار والتحديد\nتستعمل علامات التكرار / المحددات الكمية (Quantifiers) لتعيين مرات التكرار من النمط السابق. وهي على النحو التالي:\n\n{3} ثلاث مرات بالضبط\n{2,4} من 2 إلى 4 مرات\n{3,} ثلاث مرات أو أكثر\n+ مرة أو أكثر\n* صفر أو أكثر\n? صفر أو مرة واحدة فقط\n\nولتحديد مجموعة من الأحرف ضمن النمط نستعمل القوسين الدائريين: ( ) حول النمط ليكون مجموعة مطابقة (Match Group).\nمثلاً، تريد مطابقة السعر في النصوص التالية:\n\nprices = [\n    \"it costs 123\",\n    \"I bought it for 12.3 last time\",\n    \"I paid 12.34 SAR for it\"\n]\n\nفتستعمل المنط التالي:\n\npattern = r\"\\d+(\\.\\d+)?\"\n\nويتكون من ثلاثة أجزاء:\n\n\\d+ ويتكون من جزئين:\n\n\\d رقم\n+ مرة أو أكثر\n\n(...)? ما بين القوسين: صفر أو مرة واحدة فقط\n\n\\. نحتاج علامة \\ لتعطيل خصوصية حرف النقطة ولولاه لدلت على مطابقة أي حرف\n\\d+ رقم، مرة أو أكثر\n\n\n\nfor p in prices:\n    match = re.search(pattern, p)\n    if match:\n        print('price:', match.group())\n\nprice: 123\nprice: 12.3\nprice: 12.34",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#المطابقة",
    "href": "chapters/00_rewrite/07_regex.html#المطابقة",
    "title": "7  التعبير النمطي",
    "section": "المطابقة",
    "text": "المطابقة\nتوجد في بايثون أربعة أفعال أساسية للمطابقة:\n\nre.match(pattern, string, flags=0) -&gt; Match | None\n\nمطابقة النمط في بداية السلسلة النصية.\n\nre.search(pattern, string, flags=0) -&gt; Match | None\n\nالبحث عن أول تطابق للنمط في السلسلة النصية.\n\nre.findall(pattern, string, flags=0) -&gt; list\n\nإنشاء قائمة من جميع التطابقات للنمط في السلسلة النصية.\n\nre.finditer(pattern, string, flags=0) -&gt; Iterator[Match[str]]\n\nإنشاء مكرر لجميع التطابقات للنمط في السلسلة النصية.\n\n\nفأما الشيء الناتج عن هذه المطابقة، وهو Match؛ فيتضمن أربعة صفات:\n\ngroup()\nstart()\nend()\nspan()\n\nوبالمثال يتضح المقال:\n\ntext = \"Pushups 20 reps 4 sets\"\n\npattern = r\"\\d+\"\n\nالأمر الأول: المطابقة بالفعل .match() تكون من بداية النص. وبالتالي فإنك لو طابقت على هذا النص كاملاً فلن تطابقها، مع أن المطابقة تنفع مع الرقم وحده. مطابقة على النص كاملاً:\n\nprint(re.match(pattern, text))\n\nNone\n\n\nمطابقة على الرقم وحده (متحققة):\n\nprint(re.match(pattern, \"20\"))\n\n&lt;re.Match object; span=(0, 2), match='20'&gt;\n\n\nلذلك نستعمل المطابقة بالفعل .search() للبحث عن النمط في أي موضع من النص:\n\nprint(re.search(pattern, text))\n\n&lt;re.Match object; span=(8, 10), match='20'&gt;\n\n\nويمكننا الوصول لصفات المطابقة:\n\nm = re.search(pattern, text)\nprint(m.group())\nprint(m.start(), m.end())\nprint(m.span())\n\n20\n8 10\n(8, 10)\n\n\nلكن المطابقة أتت بعدد واحد، وقصدنا أن نطابقهما كليهما: 20 و 4 في المثال. ولذلك نستعمل الإجراء .findall() على النحو التالي:\n\nol = re.findall(pattern, text)\nprint(ol)\n\n['20', '4']\n\n\nفإن أردت المطابقة (Match) (لا النص المطابَق)، فاستعمال الإجراء .finditer() على النحو التالي:\n\nit = re.finditer(pattern, text)\nfor m in it:\n    print(m)\n\n&lt;re.Match object; span=(8, 10), match='20'&gt;\n&lt;re.Match object; span=(16, 17), match='4'&gt;",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#ضبط-عملية-المطابقة",
    "href": "chapters/00_rewrite/07_regex.html#ضبط-عملية-المطابقة",
    "title": "7  التعبير النمطي",
    "section": "ضبط عملية المطابقة",
    "text": "ضبط عملية المطابقة\nتستعمل الأعلام لضبط التطابق من عدة وجوه:\n\n\n\nالعلم\nالمعنى\n\n\n\n\nASCII, A\nيجعل الرموز مثل \\w, \\b, \\s و \\d تطابق فقط الأحرف ASCII.\n\n\nDOTALL, S\nيجعل الرمز . يطابق أي حرف، بما في ذلك الأسطر الجديدة.\n\n\nIGNORECASE, I\nيجعل المطابقة غير حساسة لحالة الأحرف.\n\n\nLOCALE, L\nيجعل المطابقة تأخذ في الاعتبار الإعدادات المحلية.\n\n\nMULTILINE, M\nيتيح المطابقة متعددة الأسطر، مما يؤثر على الرموز ^ و $.\n\n\nVERBOSE, X (لـ “الموسعة”)\nيتيح كتابة تعبيرات نمطية منظمة بشكل أوضح وأسهل للفهم.\n\n\n\nونمثل باستعمال العلم re.IGNORECASE إذْ نحتاج إليه في مطابقة الكلمات اللاتينية، لاحظ الفرق في المطابقتين:\n\ntext = \"She is she.\"\n\nfor m in re.finditer(r\"[a-z]+\", text):\n    print(m)\n\nprint()\n\nfor m in re.finditer(r\"[a-z]+\", text, re.IGNORECASE):\n    print(m)\n\n&lt;re.Match object; span=(1, 3), match='he'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n&lt;re.Match object; span=(0, 3), match='She'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n\nولاستعمال مجموعة أعلام فإننا ندمجه بعلامة | على النحو التالي:\nre.search(pattern, text, re.IGNORECASES | re.LOCALE)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#استخراج-المجموعات-من-النص",
    "href": "chapters/00_rewrite/07_regex.html#استخراج-المجموعات-من-النص",
    "title": "7  التعبير النمطي",
    "section": "استخراج المجموعات من النص",
    "text": "استخراج المجموعات من النص\nوتستعمل المحددات الكمية (َQuantifiers) لوصف التاريخ بأنه: أربعة أرقام ثم شرطة ثم رقمان ثم شرطة ثم رقمان. وأما الأقواس فلتقسيمها عند القراءة.\n\ntext = \"This dates back to 1970-06-29\"\npattern = r\"(\\d{4})-(\\d{2})-(\\d{2})\"\nmatch = re.search(pattern, text)\n\nif match:\n    print(match.group(0))\n    print(match.group(1))\n    print(match.group(2))\n    print(match.group(3))\n\n1970-06-29\n1970\n06\n29\n\n\nلاحظ أن المجموعة 0 تطابق الكُلّ. ولذلك فإننا عندما كنا نستعمل .group() من قبل، كان الأصل استخراج كل النص إذا طابق النمط. لكننا الآن نعلم أن 1 و 2 و 3 الآن تطابق أجزاءً في النمط نفسه بحسب الأقواس الموضوعة فيه.\nوهذا مثال آخر فيه تضمين قوسين داخل قوسين، وبه تتضح دلالة الأرقام المعطاة للإجراء .group(n) بوضوح:\n\ntext = \"20 Reps 4 Sets\"\n\nm = re.search(r\"((\\d+) Reps) ((\\d+) Sets)\", text)\nif m:\n    print(m.group(1))\n    print(m.group(2))\n    print(m.group(3))\n    print(m.group(4))\n\n20 Reps\n20\n4 Sets\n4\n\n\nوعليه فقِس.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#تسمية-المجموعات",
    "href": "chapters/00_rewrite/07_regex.html#تسمية-المجموعات",
    "title": "7  التعبير النمطي",
    "section": "تسمية المجموعات",
    "text": "تسمية المجموعات\nمن خصائص محرك مطابقة الأنماط في لغة بايثون خصوصًا؛ إمكانية تسمية المجموعات في النمط، ليتم استخراجها بالاسم. وتكون التسمية بعد القوس الأول هكذا: (?P&lt;name&gt;...) حيث تمثل الـ ... النمط النصي. وذلك على النحو التالي:\n\ntext = \"Muhammad AlKhwarizmi, Polymath\"\n\nm = re.search(r\"(?P&lt;first_name&gt;\\w+) (?P&lt;last_name&gt;\\w+), \\w+\", text)\nif m:\n    print(m.groupdict())\n    print(m.group('first_name'))\n    print(m.group('last_name'))\n\n{'first_name': 'Muhammad', 'last_name': 'AlKhwarizmi'}\nMuhammad\nAlKhwarizmi\n\n\nوكذلك يكون في المجموعات المضمنة:\n\ntext = \"20 Reps 4 Sets\"\n\nm = re.search(r\"((?P&lt;reps&gt;\\d+) Reps) ((?P&lt;sets&gt;\\d+) Sets)\", text)\nif m:\n    print(m.groupdict())\n    print(m.group('reps'))\n    print(m.group('sets'))\n\n{'reps': '20', 'sets': '4'}\n20\n4\n\n\nوهذا يسهِّلُ استخراج الأنماط كثيرًا من النصوص.\n\n\n\n\n\n\nملاحظة\n\n\n\nتسمية المجموعات هي خاصية لبايثون فقط، وليسَت من مواصفات التعبير النمطي بوجهٍ عام. وذلك يعني أنك قد لا تجدها في محركات أخرى كالمحررات التفاعلية الموجودة على الشبكة.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#تفسير-التعبير-النمطي-مرة-واحدة",
    "href": "chapters/00_rewrite/07_regex.html#تفسير-التعبير-النمطي-مرة-واحدة",
    "title": "7  التعبير النمطي",
    "section": "تفسير التعبير النمطي مرة واحدة",
    "text": "تفسير التعبير النمطي مرة واحدة\nقد استعملنا إجراءات المكتبة مباشرة في نحو: re.match() و re.search() وغيرها. فهي تأخذ النمط وتفسره ثم تنفذه بحزمة مكتوبة بلغة سي (C). فإذا كان النمط يستعمل كثيرًا فإن عملية التفسير تتم عدة مرات، وذلك هدر! ولتفسير النمط مرة واحدة ثم تطبيقه عدة مرات (من غير تكرار التفسير) نستعمل إجراء التفسير re.compile() على النحو التالي:\n\ntext1 = \"She is she.\"\ntext2 = \"They are they.\"\n\npatternc = re.compile(r\"[a-z]+\", re.IGNORECASE)\n\nfor m in patternc.finditer(text1):\n    print(m)\n\nprint()\n\nfor m in patternc.finditer(text2):\n    print(m)\n\n&lt;re.Match object; span=(0, 3), match='She'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n&lt;re.Match object; span=(0, 4), match='They'&gt;\n&lt;re.Match object; span=(5, 8), match='are'&gt;\n&lt;re.Match object; span=(9, 13), match='they'&gt;\n\n\nوحتى يتبين الفرق، قارنها مع القطعة التي لم نستعمل فيها التفسير المسبق؛ فهو يتكررفي كل مرة:\n\ntext1 = \"She is she.\"\ntext2 = \"They are they.\"\n\nfor m in re.finditer(r\"[a-z]+\", text1, re.IGNORECASE):\n    print(m)\n\nprint()\n\nfor m in re.finditer(r\"[a-z]+\", text2, re.IGNORECASE):\n    print(m)\n\n&lt;re.Match object; span=(0, 3), match='She'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n&lt;re.Match object; span=(0, 4), match='They'&gt;\n&lt;re.Match object; span=(5, 8), match='are'&gt;\n&lt;re.Match object; span=(9, 13), match='they'&gt;",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#تحرير-التعبيرات-النمطية",
    "href": "chapters/00_rewrite/07_regex.html#تحرير-التعبيرات-النمطية",
    "title": "7  التعبير النمطي",
    "section": "تحرير التعبيرات النمطية",
    "text": "تحرير التعبيرات النمطية\nننصح باستعمال أدوات تحرير التعبير النمطي مثل: regex101 فهي أفضل بكثير من كتابته دون أداة.\n\nفي القائمة الجانبية اختر نكهة (Flavour) Python\nفي الحقل الأول تكتب التعبير النمطي\nفي الصندوق الكبير تضع النص الذي تريد مطابقته\n\nوكذلك يوجد محرر آخر مثل regexr وفي القائمة الجانبية تجد Community Patterns حيث تجد فهرس لأنماط نصية شاركها المبرمجون الآخرون. أو في: regexHQ.\nوهكذا فإنك تعدل على النمط وتزيد في النصوص، حتى تصل إلى أفضل نمط لتنسخه وتضعه عندك في البرنامج.\nوهذا المحرر يستعمل نفس محرك: pythex.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#مصادر-أخرى-لتعلم-التعبيرات-النمطية",
    "href": "chapters/00_rewrite/07_regex.html#مصادر-أخرى-لتعلم-التعبيرات-النمطية",
    "title": "7  التعبير النمطي",
    "section": "مصادر أخرى لتعلم التعبيرات النمطية",
    "text": "مصادر أخرى لتعلم التعبيرات النمطية\n\nLearn Regex The Easy Way\n\nدروس تفاعلية لتعلم التعبيرات النمطية:\n\nRegexLearn\nRegexOne",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/07_regex.html#مسألة-ترتيب-سجل-التمارين-الملخبط",
    "href": "chapters/00_rewrite/07_regex.html#مسألة-ترتيب-سجل-التمارين-الملخبط",
    "title": "7  التعبير النمطي",
    "section": "مسألة: ترتيب سجل التمارين الملخبط",
    "text": "مسألة: ترتيب سجل التمارين الملخبط\nالمطلوب: استخرج من هذا النص التمارين، وعدد الجلسات. فإن كان التمرين فيه وزن فاستخرج الوزن واجعل وحدة القياس واحدة (إما بالكيل أو بالباوند).\nنص السجل:\n\ntext = \"\"\"\nPushups 30 reps 3 sets\n5 reps 2 sets Pullups\n2 Sets 15 Reps One-leg Squats\n4 sets 8 reps 22.5 lbs Dumbbell Rows\n4 sets 8 reps 15.25kg Dumbbell Rows\n\"\"\"",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html",
    "href": "chapters/00_rewrite/08_objects.html",
    "title": "8  الكائنات",
    "section": "",
    "text": "تعريف النوع\nرأينا فيما تقدَّم طريقةً لتبعيض مسارات البرنامج لأجزاء تعمل على معطيَات محددة (الدالة / الإجراء)، بحيث يُمكن استدعاؤها بمعطيات مختلفة، ومرات متعددة. وكل جزء منها فيه سير للأوامر من بدايته حتى أحد النهايات بجملة الرجوع (return).\nوالآن نتعرَّف على طريقة لتبعيض البرنامج إلى برامج جزئية؛ لها مساراتها وأيضًا متغيرتها الخاصَّة. وتسمى هذه البرمجة الكائنية (Object-oriented Programming - OOP) حيث يحتفظ كل كائن بأمرين:\nوبالمثال يتضح المقال.\nالقائمة (list) يتم إنشاؤها بالقوسين المربعين []، وهذا من اختصارات بايثون. والأصل أن الكائن يتمُّ إنشاؤه بذكر نوعه مع القوسين () ليتم استدعاء الإجراء المُنشئ للكائن، على هذا النحو:\nفأما حال القائمة:\nويُمكِنُ قراءة (Read) الحال بالإجراءات التالية:\nوأما الانتقال من حالٍ إلى حال، فيتم بأحد إجراءات الكتابة (Write):\nوكل ما سبق عمليَّات تمثَّل بإجراءات، لكنَّ قد يحلّ محل اسم الإجراء عامل يدلُّ عليه:\nوهذه الأسماء تهمُّنا عند تعريف أنواع بأنفسنا.\nتأمل المثال التالي:\nclass Counter:\n    def __init__(self, count):\n        self.count = count\n    \n    def increment(self, by=1):\n        self.count += by\nأما إجراء __init__ (بشرطتين قبل وشرطتين بعد __) يرمز للكلمة (Initialization) وتعنى الإنشاء؛ ويتم استدعاؤُها فوْر ذِكر اسم النوع كدالة لإنشائه في نحو: Counter(0).\nتتقدَّم self (نفس) كمعطى في الابتداء في جميع الأفعال؛ والإسنادُ إليها إسنادٌ لكائن مُضمَر أنشئ من هذا النوع.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#تعريف-النوع",
    "href": "chapters/00_rewrite/08_objects.html#تعريف-النوع",
    "title": "8  الكائنات",
    "section": "",
    "text": "نوع العداد\n\n\n\nالصنف (Class): Counter\nالخصائص (Properties): هي كل ما تم تعيينه وإسنادُه إلى self وهي هنا: count فقط\nالطرائق (Methods): وهي كل إجراء تم تعريفُه في داخل تعريف النوع، وهي هنا: increment فقط",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#إنشاء-الكائنات",
    "href": "chapters/00_rewrite/08_objects.html#إنشاء-الكائنات",
    "title": "8  الكائنات",
    "section": "إنشاء الكائنات",
    "text": "إنشاء الكائنات\nتتم كتابة اسم الصنف، ثم القوسان (عامل الاستدعاء) وبينهما المعطيات لطريقة الإنشاء __init__ على النحو التالي:\n\nc1 = Counter(10)\n\nوللوصول إلى خاصية أو طريقة ما فإننا نتسعمل عامل الوصول، النقطة (.) على النحو التالي:\n\nprint(c1.count)\nc1.increment(2)\nc1.increment(3)\nprint(c1.count)\n\n10\n15\n\n\nوهذا معيَّن آخر من نفس الصنف:\n\nc2 = Counter(0)\n\nوكل واحد منهما له حال خاصَّة به:\n\nprint(c1.count)\nprint(c2.count)\n\n15\n0",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#عوامل-الحاويات",
    "href": "chapters/00_rewrite/08_objects.html#عوامل-الحاويات",
    "title": "8  الكائنات",
    "section": "عوامل الحاويات",
    "text": "عوامل الحاويات\nوكي يتضح مفهوم الأصناف، فإننا سنمثل المجموعة الرياضية (Set) بأنفسنا، وإن كانت جودودة في بايثون أصلاً.\nتسمي بايثون الحروف والعلامات المستعملة مع أنواع الجموع: عوامل الحاوية (Container Operators).\nونمثل بتعريف صنف المجموعة الرياضية، حيث تقبل:\n\nالعد: len(s) يُسمَّى فعله: __len__\nالعضويَّة: x in s يُسمَّى فعله: __contains__\nالكر: for x in s يُسمَّى فعله: __iter__\nالحذف: .remove()\n\nومن سماتها أن العنصر فيها لا يتكرر.\nومن طرائقها: منطق المجموعة الرياضية.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#منطق-المجموعة-الرياضية",
    "href": "chapters/00_rewrite/08_objects.html#منطق-المجموعة-الرياضية",
    "title": "8  الكائنات",
    "section": "منطق المجموعة الرياضية",
    "text": "منطق المجموعة الرياضية\nالمجموعة في الرياضيات لها بعض المفاهيم المتعلقة بها وهي:\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل).\n\nوتمثلها بايثون باستعمال القوسين المعقوفين ({}) على هذا النحو:\n\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}\n\nوفيما يلي نشرح هذه العمليات، ثم ننتقل إلى كيفية تمثيل ذلك في بايثون.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#العمليات-على-المجموعات",
    "href": "chapters/00_rewrite/08_objects.html#العمليات-على-المجموعات",
    "title": "8  الكائنات",
    "section": "العمليات على المجموعات",
    "text": "العمليات على المجموعات\n\nالاتحاد\n\n\n\nاتحاد مجموعتين\n\n\n\nset1.union(set2)\n\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n\n\n\nالتقاطع\n\n\n\nتقاطع مجموعتين\n\n\n\nset1.intersection(set2)\n\n{4, 5}\n\n\n\n\nالفرق\n\n\n\nالفرق\n\n\n\nset1.difference(set2)\n\n{1, 2, 3}\n\n\n\nset2.difference(set1)\n\n{6, 7, 8}\n\n\n\n\nالفرق التماثلي\n\n\n\nالفرق التماثلي\n\n\n\nset1.symmetric_difference(set2)\n\n{1, 2, 3, 6, 7, 8}",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#العلاقات-بين-المجموعات",
    "href": "chapters/00_rewrite/08_objects.html#العلاقات-بين-المجموعات",
    "title": "8  الكائنات",
    "section": "العلاقات بين المجموعات",
    "text": "العلاقات بين المجموعات\n\nالجزئية والشمول\n\n\n\nالجزئية والشمول\n\n\n\nA = {1, 2, 3}\nB = {1, 2, 3, 4, 5, 6}\n\nوهذا مثال لاستعمالها كما في الجدول:\n\nprint(A.issubset(B))\nprint(B.issuperset(A))\n\nTrue\nTrue\n\n\n\n\nالانفصال\nوأما الانفصال، فهو عدم وجود أدنى تقاطع بين المجموعتين:\n\nC = {'Apple', 'Banana'}\nprint(C.isdisjoint(A))\nprint(C.isdisjoint(B))\n\nTrue\nTrue",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#تعريف-المجموعة-الرياضية",
    "href": "chapters/00_rewrite/08_objects.html#تعريف-المجموعة-الرياضية",
    "title": "8  الكائنات",
    "section": "تعريف المجموعة الرياضية",
    "text": "تعريف المجموعة الرياضية\nونعرف المجموعة الرياضيَّة (Set) بأنفسنا لغرض تعليمي وإن كانت نوعًا أصليًّا في بايثون اسمه (set). ولاحظ أن التمثيل الداخلي (Internal Representation) الذي سنعتمد عليه هو: القائمة (list) الممثلة بالمتغيِّر: self.elements.\n\nclass Set:\n    # طريقة الإنشاء\n    def __init__(self, elements):\n        self.elements = elements\n\n    # طريقة التمثيل\n    def __repr__(self):\n        return f\"Set({self.elements})\"\n    \n    # طريقة العد تمررها كما هي\n    def __len__(self):\n        return len(self.elements)\n    \n    # طريقة العضويَّة تمررها كما هي\n    def __contains__(self, x):\n        return x in self.elements\n    \n    # طريقة التكرار تمررها كما هي\n    def __iter__(self):\n        return iter(self.elements)\n    \n    # طريقة الإضافة تتحقق أولاً من عدم وجود العنصر\n    def add(self, x):\n        if x not in self.elements:\n            self.elements.append(x)\n    \n    # طريقة الحذف تتحقق أولاً من وجود العنصر\n    def remove(self, x):\n        if x in self.elements:\n            self.elements.remove(x)\n    \n    # طريفة الاتحاد\n    def union(self, other):\n        result = []\n        for x in self.elements + other.elements:\n            if x not in result:\n                result.append(x)\n        return Set(result)\n    \n    # طريقة التقاطع\n    def intersection(self, other):\n        result = []\n        for x in self.elements:\n            if x in other.elements:\n                result.append(x)\n        return Set(result)\n    \n    # طريقة الفرق\n    def difference(self, other):\n        result = []\n        for x in self.elements:\n            if x not in other.elements:\n                result.append(x)\n        return Set(result)\n    \n    # طريقة الفرق التماثلي\n    def symmetric_difference(self, other):\n        d1 = self.difference(other)\n        d2 = other.difference(self)\n        return d1.union(d2)\n    \n    # طريقة الانفصال\n    def isdisjoint(self, other):\n        return len(self.intersection(other)) == 0\n    \n    # طريقة الجزئية\n    def issubset(self, other):\n        for x in self.elements:\n            if x not in other.elements:\n                return False\n        return True\n    \n    # طريقة الشمول\n    def issuperset(self, other):\n        return other.issubset(self)\n\nولاحظ في المثال السابق عدة أمور:\nالطريقة (__repr__) تعني التمثيل (Representation)، وهي تظهر حين نعرض الكائن مثلاً بأمر الطباعة print().\nأن بعض الطرائق تغير التمثيل الداخلي (elements) مباشرةً، مثل: add و remove.\nوبعض الطرائق يُنشئ نُسخة جديدة منه، ويجري العمليَّة عليه، ثم يُنشئ كائن مجموعة (Set) ويمرر إليه هذا التمثيل ويرجع به: return Set(result). والفائدة من هذه الحركة: هي إمكانيَّة استعمال هذه الطرائق ضمن طرائق أخرى. كما ترى في .symmetric_difference() و .isdisjoint(). فلو لم نقم بهذه الحركة، لم يمكن ذلك.\nثم الإنشاء والاستعمال على النحو التالي:\n\ns1 = Set([1, 2, 3])\ns2 = Set([3, 4, 5])\n\n\nprint(s1.union(s2))\nprint(s1.intersection(s2))\nprint(s1.difference(s2))\nprint(s2.difference(s1))\nprint(s1.symmetric_difference(s2))\n\nSet([1, 2, 3, 4, 5])\nSet([3])\nSet([1, 2])\nSet([4, 5])\nSet([1, 2, 4, 5])\n\n\n\nprint(Set([1, 2]).isdisjoint(Set([3, 4])))\nprint(Set([1, 2]).issubset(Set([1, 2, 3])))\nprint(Set([1, 2, 3]).issuperset(Set([1, 2])))\n\nTrue\nTrue\nTrue",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#تحديد-عمل-العوامل",
    "href": "chapters/00_rewrite/08_objects.html#تحديد-عمل-العوامل",
    "title": "8  الكائنات",
    "section": "تحديد عمل العوامل",
    "text": "تحديد عمل العوامل\nتأمل التالي وتوقَّع النتيجة وعلل إجابتك. ما هي نتيجة:\nالقطعة الأولى:\n[1, 2, 3] + [4, 5, 6]\nالقطعة الثانية:\n[1, 2, 3] * [4, 5, 6]\nالقطعة الثالثة:\n[1, 2, 3] * 5\nالقطعة الرابعة:\n[1, 2, 3] - 3",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#عوامل-الأرقام",
    "href": "chapters/00_rewrite/08_objects.html#عوامل-الأرقام",
    "title": "8  الكائنات",
    "section": "عوامل الأرقام",
    "text": "عوامل الأرقام\nكل الذي سبق، قد تم تعريفه في بايثون لهذه الأنواع التي تراها بالتحديد عن طريق إجراءات مخصصة. وإليك هذا الجدول للعوامل المخصصة:\n\n\n\nمثال\nالإجراء\n\n\n\n\nself + other\n__add__\n\n\nself - other\n__sub__\n\n\nself * other\n__mul__\n\n\nself / other\n__truediv__\n\n\nself // other\n__floordiv__\n\n\nself % other\n__mod__\n\n\nself ** other\n__pow__\n\n\n\n(وانظر مرجع بايثون لمحاكاة العمليات الرقمية).\nفنستطيع تعريف نوع المتجَّه (Vector2D) على النحو التالي.\n\nclass Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"&lt;{self.x}, {self.y}&gt;\"\n    \n    def __add__(self, other):\n        return Vector2D(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Vector2D(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, other):\n        return Vector2D(self.x * other.x, self.y * other.y)\n\nوفي الجمع والطرح والضرب، يكون العائد متجهًا جديدًا هو حاصل العملية على أفراد العناصر المتقابلة بين المتجهين self و other. حيث يمثل الأوَّل (self) المتجَّه في الطرف الأيسر من العامل، والثاني (other) في الطرف الأيمن.\nوالآن يمكننا إنشاء متجهين ووضع العوامل بينهما:\n\nv1 = Vector2D(1, 2)\nv2 = Vector2D(3, 4)\n\nv1 + v2\n\n&lt;4, 6&gt;\n\n\n\nv1 - v2\n\n&lt;-2, -2&gt;\n\n\n\nv1 * v2\n\n&lt;3, 8&gt;\n\n\nماذا لو أردنا إضافة عمليات بين المتجه والعدد، نحو: v1 + 3? يتطلب ذلك إضافة شرط لفحص النوع، وهو isinstance كالتالي:\n\nclass Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x + other.x, self.y + other.y)\n        else:\n            return Vector2D(self.x + other, self.y + other)\n    \n    def __sub__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x - other.x, self.y - other.y)\n        else:\n            return Vector2D(self.x - other, self.y - other)\n    \n    def __mul__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x * other.x, self.y * other.y)\n        else:\n            return Vector2D(self.x * other, self.y * other)\n\nوهكذا يصبح التفاعل بين المتجَّه والعدد، وهما نوعان مختلفان (int و Vector):\n\nv1 = Vector2D(1, 2)\nv1 + 3\n\nVector(4, 5)\n\n\nلكن لاحظ أنك لو وضعت العدد أولاً فسيظهر خطأ:\n\n3 + v1\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[26], line 1\n----&gt; 1 3 + v1\n\nTypeError: unsupported operand type(s) for +: 'int' and 'Vector2D'\n\n\n\nهذا لأن عملية الجمع الآن لا تنظر في نوع العدد (int) ولا تجد فيه قبولاً للمتجه (فقد عرفناه للتو). ولحل هذه المشكلة توفر بايثون لكل فعل مخصص مقابل يبدأ بحرف r على النحو التالي:\n\n\n\nالعامل\nالإجراء\n\n\n\n\nother + self\n__radd__\n\n\nother - self\n__rsub__\n\n\nother * self\n__rmul__\n\n\n\nنعدل الإجراء بحيث نضيف إليه المقابل:\n\nclass Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x + other.x, self.y + other.y)\n        else:\n            return Vector2D(self.x + other, self.y + other)\n\n    def __radd__(self, other):\n        return self + other\n\nوالآن كلاهما يعمل بشكل صحيح:\n\nv1 = Vector2D(1, 2)\n3 + v1\n\nVector(4, 5)\n\n\n\nv1 + 3\n\nVector(4, 5)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/08_objects.html#التخصيص-بالوراثة",
    "href": "chapters/00_rewrite/08_objects.html#التخصيص-بالوراثة",
    "title": "8  الكائنات",
    "section": "التخصيص بالوراثة",
    "text": "التخصيص بالوراثة\nيُمكن جعل علاقة بين نوع ونوع. ومن ذلك الوراثة (Inheritence) وهي عمليَّة تخصيص (Sub-classing) بحيث يستمد النوع خصائصه وطرائقه من النوع الأعم.\nومثاله في بايثون أنواع الرقم:\n\n\n\n\n\nflowchart BT\n  Number[&lt;b&gt;رقم&lt;/b&gt;&lt;br&gt;Number]\n  Integral[&lt;b&gt;كامل&lt;/b&gt;&lt;br&gt;Integral]\n  Integral --&gt; Number\n  Real[&lt;b&gt;حقيقي&lt;/b&gt;&lt;br&gt;Real]\n  Real --&gt; Number\n  float[&lt;b&gt;عشري&lt;/b&gt;&lt;br&gt;float]\n  float --&gt; Real\n  Complex[&lt;b&gt;مركب&lt;/b&gt;&lt;br&gt;Complex]\n  Complex --&gt; Number\n  int[&lt;b&gt;صحيح&lt;/b&gt;&lt;br&gt;int]\n  int --&gt; Integral\n  bool[&lt;b&gt;منطقي&lt;/b&gt;&lt;br&gt;bool]\n  bool --&gt; Integral\n\n\n\n\n\n\nونمثل بمثال فتقول المربع نوع خاص من المستطيلات. وكذلك تقول: المستطيل نوع خاص من الأشكال. وبالتالي فإن علاقة المربَّع بالشكل هي علاقة تخصيص عام. على نحو هذا المثال:\n\nالشكل: ما كان له محيط\nوالمستطيل شكلٌ (إذًا له محيط) و فوق ذلك فإنه له: طولًا وعرضًا ومساحة\nووالمثلث شكلٌ (إذًا له محيط) و فوق ذلك فإنه له: ثلاثةَ أضلاعٍ ومساحة\nأما المربع فهو مستطيل (إذًا له محيط لأن المستطيل شكل، وله طول وعرض ومساحة): لكن عرضه وطوله متساويان\n\nوهذه شجرة التوارث للأنواع المذكورة:\n\n\n\n\n\nflowchart BT\n  Shape\n  Rectangle -- \"is a\" --&gt; Shape\n  Square -- \"is a\" --&gt; Rectangle\n  Triangle -- \"is a\" --&gt; Shape\n\n\n\n\n\n\nوهذا تعريف صنف الشكل:\n\nclass Shape:\n    def __init__(self, sides):\n        self.sides = sides\n    \n    @property\n    def perimeter(self):\n        return sum(self.sides)\n    \n    @property\n    def area(self):\n        pass\n\nلاحظ استعمال المعدِّل (Decorator) @property (يعني: خاصيَّة) وهي تجعل طريقة الوصول لا تحتاج إلى قوسي استدعاء (()) كما هو الأصل. فبمجرد كتابة .perimeter فإن الطريقة تعمل لتأتيك بالنتيجة، وكأنها متغير. وهذا يستعمل في طرائق القراءة عادة، لا في طرائق الكتابة.\nوالأمر الثاني هو استعمالنا كلمة pass وهي مثل الفراغ؛ ليس لها عمل إلا إقناع مفسر بايثون أننا لم نترك هذا المكان بالخطأ. والسبب في ترك هذه الطريقة فارغة هو أن الأنواع المستمدة ستجريها وإن كانت هنا مهملة. إذ ليس ثمة شيء هو شكلٌ فقط، ولذلك نعتبر هذا النوع، نوعًا مُجرَّدًا (Abstract)، إذ لن نستعمله مباشرةً أبدًا، بل سنخصصه أولاً. فأول نوع سيرث منه هو المستطيل (Rectangle).\nولاحظ في Rectangle استعمال الإجراء الخاص super() وهو يشير إلى الموروث Shape؛ فيصير معنى الجملة ( super().__init__()) وكوْنها في أوَّل سطرٍ من جملة إجراء الإنشاء: الإنشاء فوق الإنشاء الموروث.\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        super().__init__((width, height, width, height))\n    \n    @property\n    def width(self):\n        return self.sides[0]\n    \n    @property\n    def height(self):\n        return self.sides[1]\n    \n    @property\n    def area(self):\n        return self.width * self.height\n\nلاحظ القوسين الإضافيين حول المتغيرات المرسلة إلى الأب (super().__init__())، وهذا يعني أنها كلها ستعيَّن للمعطى الأوَّل كصفّ (tuple)، وهو نوع تسلسل مثل القائمة لكنه جامد لا يقبل التغيير.\nأما المربع، فهو نوعٌ خاص من المستطيل:\n\nclass Square(Rectangle):\n    def __init__(self, side):\n        super().__init__((side, side))\n\nوأما المثلث، فهو من الشكل:\n\nclass Triangle(Shape):\n    def __init__(self, a, b, c):\n        super().__init__((a, b, c))\n\n    @property\n    def a(self):\n        return self.sides[0]\n    \n    @property\n    def b(self):\n        return self.sides[1]\n    \n    @property\n    def c(self):\n        return self.sides[2]\n    \n    @property\n    def area(self):\n        s = self.perimeter / 2\n        return (s * (s - self.a) * (s - self.b) * (s - self.c))**0.5\n\nوالآن ستلاحظ إمكانية استعمال الشيئين المختلفين (المثلث والمستطيل) باعتبار المشترك بينهما (الشكل). ويتبين ذلك إذا كررنا عليهما في قائمة:\n\nt = Triangle(10, 10, 10)\nr = Rectangle(10, 20)\nshapes = [t, r]\n\nfor sh in shapes:\n    print(sh.__class__.__name__)\n    print(\"Perimeter:\", sh.perimeter)\n    print(\"Area:\", round(sh.area, 2))\n    print('='*40)\n\nTriangle\nPerimeter: 30\nArea: 43.3\n========================================\nRectangle\nPerimeter: 60\nArea: 200\n========================================\n\n\nواستعمال instance.__class__.__name__ يعطي اسم النوع الذي ينتمي إليه الشيء.\nلكنهما يفترقان في بعض الصفات إذ:\n\nالمستطيل له طول وعرض\nالمثلث له ثلاثة أضلاع\n\nويمكن فحص النوع باستعمال الإجراء isinstance(instance, class) لمعرفة ما إذا كان الشيء ينتمي إلى ذلك النوع أو لا.\n\nfor sh in shapes:\n    if isinstance(sh, Rectangle):\n        print(f\"Sides: width={sh.width}, height={sh.height}\")\n    elif isinstance(sh, Triangle):\n        print(f\"Sides: a={sh.a}, b={sh.b}, c={sh.c}\")\n\nSides: a=10, b=10, c=10\nSides: width=10, height=20\n\n\nوذلك ينطبق في تعريف الإجراءات. فإنك تستطيع تحديد النوع الأعم وتمرير النوع الأخص.\nفهو في التعريف عام:\n\ndef show(shape):\n    print(shape.__class__.__name__)\n    print(\"Perimeter:\", shape.perimeter)\n    print(\"Area:\", round(shape.area, 2))\n\nوفي التمرير خاص:\n\nx = Triangle(10, 10, 10)\nshow(x)\n\nTriangle\nPerimeter: 30\nArea: 43.3\n\n\n\ny = Rectangle(10, 20)\nshow(y)\n\nRectangle\nPerimeter: 60\nArea: 200\n\n\nللمزيد راجع ملحق البرمجة الكائنية.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>الكائنات</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html",
    "href": "chapters/00_rewrite/09_time.html",
    "title": "9  الوقت",
    "section": "",
    "text": "الوقت في الحاسب\nقال الثعالبي (350 هـ - 429 هـ):\nفكانوا يقسمون الوقت على ثنتي عشرة ساعة من وقت غروب الشمس تتلوها ثنتا عشرة ساعة من وقت طلوعها. فهي ساعات متغيرة؛ حيث تبلغ ساعة النهار في الصيف فوق ستين دقيقة معتدلة، وتقصر ساعة الليل. ويحصل العكس في الشتاء: حيث تبلغ ساعة الليل فوق الستين وتقصر ساعة النهار. أما عند اعتدال الشمس في أشهر معيَّنة في خط الاستواء فإن ساعات الليل والنهار متساوية. وهي ما تُقاسُ عليه الزيادة والنقص؛ فتسمى تلك الساعة ذات الستين دقيقة الساعة المعتدلة.\nوكان مما يُعرَف به الوقت: المِزْوَلَة (الجمع: مِزْوَلَات، مَزَاوِل) هي ساعة شمسية وأداة توقيت نهاري، تتكون من عدة نقاط وخطوط، رسمت على صفيحة عريضة، وفي وسطها عصا مستقيمة أفقية يتحدد الوقت من طول ظلها الناتج عن وقوع أشعة الشمس عليها، حيث تترك ظلا متحركا على النقاط والخطوط، وهي من أقدم آلات قياس الوقت.\nولحساب فترة زمنية (مؤقِّت) كانوا يقيسون بمقدار الشموع، فيقاس الوقت بالشمعة والاثنين والثلاثة. وكذلك يُقاس بمدة تسرب الماء أو الرمل من وعاءٍ فيه ثقب صغير أو مجرى ضيِّق.\nثم جاءت الساعات الميكانيكية الثابتة التي تعمل على اعتبار أن جميع الساعات 60 دقيقة. فهذه الساعة تعمل بوتيرة ثابتة لا تتغير شتاءً ولا صيْفًا، ولا نهارًا ولا ليلاً .. وظلت هي المتداولة في عصرنا اليوم.\nوقد مرَّ ضبط الساعة بأطوار من الدقة، فبدأت من الساعة المتأرجحة (1657) إلى الكرونومتر (1762) إلى مذبذب الكوارتز (1927) إلى الساعة الذرية (1949) إلى ساعة شعاع السيزيوم (1955) إلى ساعة نافورة السيزيوم (1993) إلى الساعة الضوئية (Optical Clock: 2006).\nيظهر وقت التقويم (Calendar Time) على هذا النحو:\nلكن تمثيل الزمن في الحاسب هو: عدد صحيح (int) ويمثِّل عدد الثواني من بزوغ فجر نظام يونكس (Unix Epoch) وهو تاريخ ووقت اعتباطي تمَّ وضعه على أن يكون:\nمثال: لنشير إلى سنة واحدة تمامًا بعد النقطة الصفرية، أي: الساعة 00:00:00 بتاريخ 1 يناير1971 ، فإن السنة الواحدة فيها 31,536,000 ثانية ، وبالتالي يكون هذا الرقم هو الذي يمثل ذلك الوقت.\nولو أردت الترجمة بالعكس، فتقول إن 1,000,000,000 ثانية منذ النقطة الصفرية يوافق 9 سبتمبر 2001 01:46:40 في وقت التقويم على منطقة UTC.\nمشكلة سنة 2038 تحصل في الأنظمة ذات 32-بت؛ إذْ عدد الثواني يصل إلى أقصى مداه عند نقطتين زمنيتين:\nوالحل في ذلك بسيط، وهو نقل البرنامج لنظام 64-بت.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#الوقت-في-الحاسب",
    "href": "chapters/00_rewrite/09_time.html#الوقت-في-الحاسب",
    "title": "9  الوقت",
    "section": "",
    "text": "التاريخ: 2024-11-25\nالساعات: 08:30:25\nالمنطقة الزمنية: GMT+3 (أي: ثلاث ساعات متقدِّمة عن جرينيتش)\n\n\n\nتاريخ: 1970-01-01\nالساعة: 00:00:00\nالمنطقة الزمنية: UTC التي هي GMT+0\n\n\n\n\n\nففي النزول تستطيع أن تصل إلى: 20:45:52 UTC بتاريخ 1901-12-13 (باختيار عدد سالب)\nوكذلك في الصعود؛ لا يمكن أن تتعدى: 03:14:07 UTC بتاريخ 2038-01-19",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#التوقيت-العالمي-والمناطق-الزمنية",
    "href": "chapters/00_rewrite/09_time.html#التوقيت-العالمي-والمناطق-الزمنية",
    "title": "9  الوقت",
    "section": "التوقيت العالمي والمناطق الزمنية",
    "text": "التوقيت العالمي والمناطق الزمنية\nظهر نظام التوقيت العالمي المنسق (UTC: Coordinated Universal Time) في عام 1967، لتسهيل التعامل بين الدول والتواصل عبر القارات. فهو نظام للوقت يعتمد على خطوط الطول الأرضية، تقسَّم فيه الجغرافيا لمناطق زمنية بحسب بعدها عن خط طول جرينيتش الذي يعتبر نقطة الصفر (UTC+00:00) أي: المرجِع: فما يكون شرقيَّها يكون الفارق فيه بالموجب، وما يكون غربيَّها يكون الفارق فيه بالسالب.\nوالمقصود بالتنسيق (في التوقيت العالمي) اعتبار الاختلاف اليسير بسبب الثواني الكبسية، فتعاد ضبط الأوقات لاعتبارها.\nوكل منطقة لها توقيت محلي تعتمده في معاملاتها اليومية فيما يتعلق بالوقت من تواصل وتنسيق ومواعيد ونحو ذلك. وفي الخريطة التالية نرى تقسيم المناطق الزمنية (Timezones) التي تنتمي إليها المناطق الجغرافية:\n\n\n\nخريطة تظهر تقسيم المناطق الزمنية على الجغرافيا\n\n\nلاحظ أولاً أن الخطوط ليست طوليَّة كما قد يسبق إلى الظن. فإذا تأملت الألوان رأيتها ليست مستقيمة ومستطيلة بل تتعرَّج بحسب حدود الدُّول في الغالب. ليس الوقت المحلي هو فقط زيادة أو نقص من الوقت العالمي .. بل هناك عدة اعتبارات للتحويل بينها:\n\nمناطق عريضة جغرافيًّا: كالصين التي تمتد لتغطي مجموعة خطوط طول إلا أنها تعتمد توقيتًا موحَّدًا.\nالتوقيت الصيفي: بعض المناطق الزمنية تقدِّم الوقت ساعة عند الربيع (أو نهاية الشتاء) ثُم تعيدُه في الخريف، وذلك لتنظيم جدوَل الناس بحيث يتعرضوا للشمس أكثر.\nقرارات سياسية: قررت بعض الدوَّل أن تغير زمن منطقتها في سنة من السنوات؛ فذلك يجب أن يؤخذ في عين الاعتبار عند حساب الأوقات قبل أو بعد هذه السنة لهذه الدُّوَل.\n\nنخلص من ذلك أن التعامل مع الوقت له اعتبارات كثيرة بسبب ظروف تاريخية وسياسية وليس خاضعًا لقوانين جغرافية أو فيزيائية علمية بحتة. ولذلك ظهرت قاعدة بيانات للمناطق الزمنية (بمجهود جماعي) تتضمن معلومات الدول بشكل يتم تحديثه بشكل مستمر لمتابعة هذه التغيرات، تسمَّى: (tz database).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#الوقت-في-بايثون",
    "href": "chapters/00_rewrite/09_time.html#الوقت-في-بايثون",
    "title": "9  الوقت",
    "section": "الوقت في بايثون",
    "text": "الوقت في بايثون\nتستعمل بايثون مجموعة كائنات للتعامل مع الوقت والتاريخ من حيث إجراء العلاقات والحسابات عليها.\nأولاً: datetime.date وهو تاريخ مثالي يفترض أن التقويم الغريغوري يمتد إلى ما لا نهاية في المستقبل والماضي (رغم أنه في الحقيقة حل مكان التاريخ الجولياني سنة 1582). خصائصه: السنة والشهر واليوم.\nثانيًا: datetime.time هو وقت مثالي يفترض 86,400 ثانية في اليوم (بدون ثوانٍ كبيسة). خصائصه: الساعة والدقيقة والثانية والميكروثانية وtzinfo (معلومات المنطقة الزمنية).\nثالثًا: datetime.datetime وهو التاريخ والوقت معًا؛ فلديه خصائص كلا الكائنين.\nرابعًا: datetime.timedelta وهو فترة زمنية. ولكننا سنستبدله بـ dateutil.relativedelta إذ هي كذلك فترة زمنية إلا أن نطاقها أوسع (تستوعب السنين والأشهر، وتعتبر السنوات الكبيسة في الحسبان).\nوحتى يكون مطابقًا للواقع؛ فلا بد من نسبة الوقت إلى منطقة زمنيَّة (كأن تقول الساعة 04:00:00 صباحًا بتوقيت UTC+03)؛ فهذا تسميه بايثون وقت واع (Aware)، وأما الوقت الذي لم تحدد منطقته الزمنية (كما لو قُلت في الساعة 04:00:00 صباحًا) فهذا غير منسوب لمنطقة زمنية وبالتالي فهو ساذج (Naive) على تعبيرهم.\nويرشدنا مرجع المكتبة للتوسع في استعمال قاعدة بيانات المناطق الزمنية، والقدرة على تفسير التواريخ والأوقات بمرونة لاستخدام مكتبة dateutil المتوفرة في قاعدة بيانات الحزم البايثونية PyPI.\nلتثبيت المكتبة نستعمل uv على النحو التالي:\nuv add python-dateutil\nالآن نستورد المكتبة الأساسية datetime ومكتبة dateutil:\n\nfrom datetime import date, time, datetime, timedelta\nfrom dateutil import tz\n\nنريد الآن معرفة الوقت العالمي والمحلي، وكذلك الوقت في القاهرة، وكذلك الوقت في لندن (هنا قائمة بالأسماء):\n\nprint(datetime.now(tz=tz.tzutc()))\nprint(datetime.now(tz=tz.tzlocal()))\nprint(datetime.now(tz=tz.gettz('Africa/Cairo')))\nprint(datetime.now(tz=tz.gettz('Europe/London')))\n\n2025-07-20 18:28:55.710458+00:00\n2025-07-20 18:28:55.711088+00:00\n2025-07-20 21:28:55.717819+03:00\n2025-07-20 19:28:55.719210+01:00\n\n\nلاحظ أن شكل الوقت كاملاً على النحو التالي:\n    2024-11-19 11:32:35.355104+03:00\n    YYYY-MM-DD HH:MM:SS.ssssss+HH:MM\nلاحظ أن الوقت منسَّق على هذا النحو:\n\nYYYY-MM-DD هو التاريخ (يبدأ بالسنة ثم الشهر ثم اليوم)\nHH:MM:SS.ssssss هو الوقت (بالساعات والدقائق والثواني والميكروثواني)\n+HH:MM هو الفرق (بالموجب + أو السالب -) بين الوقت المحلي لتلك المنطقة الزمنية والوقت العالمي المنسق (UTC) على خط جرينيتش وهي منطقة في لندن.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#التفسير-تحويل-النص-إلى-تاريخ-ووقت",
    "href": "chapters/00_rewrite/09_time.html#التفسير-تحويل-النص-إلى-تاريخ-ووقت",
    "title": "9  الوقت",
    "section": "التفسير: تحويل النص إلى تاريخ ووقت",
    "text": "التفسير: تحويل النص إلى تاريخ ووقت\nوتفسير الوقت أفضل بكثير في مكتبة dateutil بدلاً من استعمال المكتبة الأساسية datetime. وتكثر الحاجة لذلك عند استقبال معلومات من الشبكة أو من ملفات أو من المستخدمين:\n\nfrom dateutil.parser import parse\n\nهنا نحدد وقتًا افتراضيًّا عند القراءة، بحيث لو لم توجد المعلومة عند القراءة فإنها تستعمل القيم الابتدائية:\n\nDEFAULT = datetime(2003, 9, 25)\nparse(\"Thu Sep 25 10:36:28\", default=DEFAULT)\n\ndatetime.datetime(2003, 9, 25, 10, 36, 28)\n\n\nونرى في المثال التالي كيف أن المفسر يحاول معرفة المعلومات ولو كانت ناقصة:\n\nدون السنة\nدون الشهر\nدون الثواني\nدون اليوم\n\n\nprint(parse(\"Thu Sep 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36\", default=DEFAULT))\nprint(parse(\"10:36\", default=DEFAULT))\n\n2003-09-25 10:36:28\n2003-09-25 10:36:28\n2003-09-25 10:36:00\n2003-09-25 10:36:00",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#الحسابات-الزمنية",
    "href": "chapters/00_rewrite/09_time.html#الحسابات-الزمنية",
    "title": "9  الوقت",
    "section": "الحسابات الزمنية",
    "text": "الحسابات الزمنية\n\nfrom dateutil.relativedelta import relativedelta\n\n\nحساب الزمن المنقضي\n\ntoday = datetime.now(tz=tz.tzlocal())\nbirthday = datetime(1970, 1, 1, tzinfo=tz.tzlocal())\nage = relativedelta(today, birthday)\nprint(f'You are {age.years} years and {age.months} months old')\n\nYou are 55 years and 6 months old\n\n\n\n\nحساب الزمن لموعد\n\ntoday = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2045, 1, 15, tzinfo=tz.tzlocal())\ndiff = relativedelta(exam_date, today)\nprint(f'There are {diff.days} days and {diff.hours} hours remaining')\n\nThere are 25 days and 5 hours remaining\n\n\n\n\nمقارنة الوقت\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2044, 11, 19, hour=9, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif now &gt; exam_date:\n    print('The exam has passed')\nelif now &lt; exam_date:\n    print('The exam is coming')\n\nThe exam is coming\n\n\n\n\nمقارنة الفترة\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2044, 11, 19, hour=15, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif relativedelta(now, exam_date).hours &lt; 1:\n    print('Hurry up!')\nelif relativedelta(now, exam_date).hours &lt; 4:\n    print(f'Remember you have an exam today at {exam_date:%H:%M}')\nelse:\n    print(f'You have plenty of time to prepare for the exam')\n\nHurry up!\n\n\n\n\nالجمعة القادمة\nنستطيع استعمال الأسماء الدالة على أيام الأسبوع:\n\nSU: Sunday (الأحد)\nMO: Monday (الاثنين)\nTU: Tuesday (الثلاثاء)\nWE: Wednesday (الأربعاء)\nTH: Thursday (الخميس)\nFR: Friday (الجمعة)\nSA: Saturday (السبت)\n\n\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\nثم نستعملها في إجراءات المكتبة:\n\ntoday = datetime.now(tz=tz.tzlocal())\nnext_friday = today + relativedelta(days=+1, weekday=FR)\nprint(f'The next Friday is {next_friday:%Y-%m-%d}')\n\nThe next Friday is 2025-07-25\n\n\n\n\nالجمعة الفائتة\n\nlast_friday = today - relativedelta(days=+1, weekday=FR(-1))\nprint(f'The last Friday is {last_friday:%Y-%m-%d}')\n\nThe last Friday is 2025-07-18\n\n\n\n\nحساب الوقت باعتبار منطقتين زمنيتين\nلديك اجتماع في وقت محدد بتوقيت لندن، وتريد معرفة وقت الوصول بالطائرة إن كانت الرحلة تستغرق 4 ساعات والإقلاع من القاهرة في الساعة 01:00:00 صباحًا والوجهة لندن:\n\ndeparture_tz = tz.gettz('Africa/Cairo')\narrival_tz = tz.gettz('Europe/London')\n\ndeparture_time = datetime(2044, 11, 19, hour=1, tzinfo=departure_tz)\n\narrival_time = departure_time + relativedelta(hours=4)\n\nprint(f'You leave at {departure_time.astimezone(departure_tz)} in Cairo time')\nprint(f'You arrive at {arrival_time.astimezone(arrival_tz)} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz)} in Cairo time')\n\nYou leave at 2044-11-19 01:00:00+02:00 in Cairo time\nYou arrive at 2044-11-19 03:00:00+00:00 in London time\nwhich corresponds to 2044-11-19 05:00:00+02:00 in Cairo time",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#تنسيق-التاريخ-والوقت",
    "href": "chapters/00_rewrite/09_time.html#تنسيق-التاريخ-والوقت",
    "title": "9  الوقت",
    "section": "تنسيق التاريخ والوقت",
    "text": "تنسيق التاريخ والوقت\nوانظر الجدول لتنسيق مظهر التاريخ والوقت:\n\nprint(f'Departure time: {departure_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\nprint(f'Arrival time: {arrival_time.astimezone(arrival_tz):%d %b, %X %Z} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\n\nDeparture time: 19 Nov, 01:00:00 EET in Cairo time\nArrival time: 19 Nov, 03:00:00 GMT in London time\nwhich corresponds to 19 Nov, 05:00:00 EET in Cairo time",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#التكرار",
    "href": "chapters/00_rewrite/09_time.html#التكرار",
    "title": "9  الوقت",
    "section": "التكرار",
    "text": "التكرار\nتكرار التواريخ يتم في هذه المكتبة باستعمال rrule ويحدد على النحو التالي:\n\nfrom dateutil.rrule import rrule\nfrom dateutil.rrule import DAILY, WEEKLY, MONTHLY, YEARLY, HOURLY, MINUTELY, SECONDLY\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nيوم ويوم\nتكرار أوقات بأخذ يوم وترك يوم، ابتداءً من وقت معين في الساعة العاشرة صباحًا:\n\nlist(\n    rrule(DAILY, interval=2, count=10, dtstart=datetime(2044, 11, 19, hour=10))\n)\n\n[datetime.datetime(2044, 11, 19, 10, 0),\n datetime.datetime(2044, 11, 21, 10, 0),\n datetime.datetime(2044, 11, 23, 10, 0),\n datetime.datetime(2044, 11, 25, 10, 0),\n datetime.datetime(2044, 11, 27, 10, 0),\n datetime.datetime(2044, 11, 29, 10, 0),\n datetime.datetime(2044, 12, 1, 10, 0),\n datetime.datetime(2044, 12, 3, 10, 0),\n datetime.datetime(2044, 12, 5, 10, 0),\n datetime.datetime(2044, 12, 7, 10, 0)]\n\n\n\n\nأسبوعي\n\nlist(\n    rrule(WEEKLY, interval=1, count=4, dtstart=datetime(2044, 11, 19, hour=10))\n)\n\n[datetime.datetime(2044, 11, 19, 10, 0),\n datetime.datetime(2044, 11, 26, 10, 0),\n datetime.datetime(2044, 12, 3, 10, 0),\n datetime.datetime(2044, 12, 10, 10, 0)]\n\n\n\n\nشهريًّا إلى وقت محدد\n\nlist(\n    rrule(MONTHLY, interval=1,\n        dtstart=datetime(2044, 8, 1),\n        until=datetime(2045, 4, 1),\n    )\n)\n\n[datetime.datetime(2044, 8, 1, 0, 0),\n datetime.datetime(2044, 9, 1, 0, 0),\n datetime.datetime(2044, 10, 1, 0, 0),\n datetime.datetime(2044, 11, 1, 0, 0),\n datetime.datetime(2044, 12, 1, 0, 0),\n datetime.datetime(2045, 1, 1, 0, 0),\n datetime.datetime(2045, 2, 1, 0, 0),\n datetime.datetime(2045, 3, 1, 0, 0),\n datetime.datetime(2045, 4, 1, 0, 0)]\n\n\n\n\nكل 15 دقيقة لمدة 6 مرات\n\nlist(\n    rrule(MINUTELY, interval=15, count=6, dtstart=datetime(2044, 11, 19, hour=10))\n)\n\n[datetime.datetime(2044, 11, 19, 10, 0),\n datetime.datetime(2044, 11, 19, 10, 15),\n datetime.datetime(2044, 11, 19, 10, 30),\n datetime.datetime(2044, 11, 19, 10, 45),\n datetime.datetime(2044, 11, 19, 11, 0),\n datetime.datetime(2044, 11, 19, 11, 15)]\n\n\nوندعوك للاطلاع على المزيد من الأمثلة على مكتبة dateutil.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#معرفة-نصف-الليل-وأثلاثه",
    "href": "chapters/00_rewrite/09_time.html#معرفة-نصف-الليل-وأثلاثه",
    "title": "9  الوقت",
    "section": "معرفة نصف الليل وأثلاثه",
    "text": "معرفة نصف الليل وأثلاثه\nالليل يبدأ من غروب الشمس وينتهي بطلوع الفجر.\nفإذا كانت الشمس تغرب -مثلاً- في الثامنة مساءً والفجر يطلع في الخامسة صباحاً، فإن نصف الليل يكون عند الساعة الثانية عشر والنصف.\nوطريقة معرفة الثلث الأخير من الليل سهلة، وهي أن تقسم ساعات الليل من غروب الشمس إلى طلوع الفجر على ثلاثة، فآخر قسم هو ثلث الليل الأخير.\n\nfrom datetime import datetime\n\ndef get_night_times(sunset: datetime, sunrise: datetime):\n    \"\"\"Calculate midnight and start of last third of night.\"\"\"\n    night_duration = sunrise - sunset\n    midnight = sunset + (night_duration / 2)\n    first_third_end = sunset + (night_duration / 3)\n    last_third_start = sunrise - (night_duration / 3)\n    \n    print(night_duration.total_seconds() / 3600, \"طول الليل\")\n    print((86400 - night_duration.total_seconds()) / 3600, \"طول النهار\")\n\n    print(sunset.strftime('%I:%M %p'), \"غروب الشمس\")\n    print(first_third_end.strftime('%I:%M %p'), \"نهاية ثلث الليل الأول\")\n    print(midnight.strftime('%I:%M %p'), \"منتصف الليل\")\n    print(last_third_start.strftime('%I:%M %p'), \"بداية ثلث الليل الأخير\")\n    print(sunrise.strftime('%I:%M %p'), \"طلوع الفجر\")\n\nget_night_times(\n    sunset=datetime(2044, 1, 1, 20, 0),  # 8:00 PM\n    sunrise=datetime(2044, 1, 2, 5, 0)   # 5:00 AM\n)\n\n9.0 طول الليل\n15.0 طول النهار\n08:00 PM غروب الشمس\n11:00 PM نهاية ثلث الليل الأول\n12:30 AM منتصف الليل\n02:00 AM بداية ثلث الليل الأخير\n05:00 AM طلوع الفجر",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/09_time.html#التاريخ-الهجري-في-بايثون",
    "href": "chapters/00_rewrite/09_time.html#التاريخ-الهجري-في-بايثون",
    "title": "9  الوقت",
    "section": "التاريخ الهجري في بايثون",
    "text": "التاريخ الهجري في بايثون\nوأما التاريخ الهجري، فقد تجد له مكتبات خاصة في قاعدة بيانات الحزم البايثونية PyPI.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html",
    "href": "chapters/00_rewrite/10_errors.html",
    "title": "10  الخطأ",
    "section": "",
    "text": "أولاً: الخطأ النحوي\nالخطأ في البرمجيات على نوعين:\nفمن الخطأ الظاهر: الخطأ النحوي (Syntactic Error): وهو الخطأ في مبنى اللغة؛ أي: مخالفة قواعدها وقوانينها.\nمثال ذلك فقد النطقتين الرأسيتين (:) كفاصلة للجملة الشرطية.. كما سيظهر الخطأ الآن في هذه القطعة:\nif x &gt; 5\n    print(\"x\")\n\n\n  Cell In[1], line 1\n    if x &gt; 5\n            ^\nSyntaxError: expected ':'\nومنه أيضًا عدم تطابق المسافاة البادئة للجمل ضمن القطعة الواحدة:\nif True:\n    print(\"x\")\n     print('y')\n\n\n  Cell In[2], line 3\n    print('y')\n    ^\nIndentationError: unexpected indent",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#أولا-الخطأ-النحوي",
    "href": "chapters/00_rewrite/10_errors.html#أولا-الخطأ-النحوي",
    "title": "10  الخطأ",
    "section": "",
    "text": "ملاحظة\n\n\n\nكي تقرأ هذا الخطأ: انظر أولاً للسطر الأخير حيث كُتب SyntaxError فذاك نوع الخطأ. وكتب بعده تخصيص له، حيث قال: expected ':' .. أي: كان من المتوقع وجود : هنا. ثم انظر فوقه لتجد سهمًا صغيرًا يشير إلى المكان الذي يظن مفسر بايثون أن قد حصل فيه الخطأ الإملائي.\n\n\n\n\n\n\n\n\n\n\nملاحظة\n\n\n\nنوع هذا الخطأ هو IndentationError وهو نوع من الخطأ الإملائي.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#ثانيا-الخطأ-المنطقي",
    "href": "chapters/00_rewrite/10_errors.html#ثانيا-الخطأ-المنطقي",
    "title": "10  الخطأ",
    "section": "ثانياً: الخطأ المنطقي",
    "text": "ثانياً: الخطأ المنطقي\nوأما الخطأ الخفي فأساسه الخطأ المنطقي (Logical Error): وهو تعبيرٌ صحيحٌ نحويًّا لكنَّه لا يؤدي في الواقع إلى المقصود الذي أراده كاتبه منه. فالنية صحيحة لكن السهم أخطأ الهدف.\nومثال ذلك محاولة تفسير النص المكتوب بترميز مختلف عن الذي كُتِبَ به:\n\n\n\nبرنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات\n\n\nومنه أيضًا: أن يريد المبرمج استعمال دالَّة التربيع (Square) فظنَّها math.sqrt لكن هذه (Square Root) أي: الجذر التربيعي. والصحيح أن يختار: math.pow(4, 2) لرفع 4 للقوة 2.\n\nimport math\n\nsquare = math.sqrt(4)\n\nوكذلك المعروف باسم “خطأ الحافَّة” (Off-by-one error)، ويكاد أن يكون أشهر الأخطاء الخفية المنطقية في البرمجة.\nنشرحه بمثال: النية هنا هي طباعة الأرقام بالعكس من الرقم الأعلى (5) إلى (0) بما في ذلك (0)، ولكن الحلقة تتوقف عند (1). وذلك أن آلية عمل النطاق (range) عدم شمول النهاية.\n\nfor i in range(5, 0, -1):\n    print(i, end=' ')\n\n5 4 3 2 1 \n\n\nوالصحيح المطابق لنية الكاتب كان:\n\nfor i in range(5, -1, -1):\n    print(i, end=' ')\n\n5 4 3 2 1 0",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#الاحتراز-من-الخطأ-المنطقي",
    "href": "chapters/00_rewrite/10_errors.html#الاحتراز-من-الخطأ-المنطقي",
    "title": "10  الخطأ",
    "section": "الاحتراز من الخطأ المنطقي",
    "text": "الاحتراز من الخطأ المنطقي\nوهي التي نقصدها حين نقول: بَق (Bug) بمعنى: مشكلة في البرنامج. ويسمى البرنامج الذي يساعد في إصلاح المشاكل البرمجية: المدقق (Debugger). وتسمى وعملية البحث عنها وإصلاحها: التدقيق (Debugging).\n\n\n\nالأخطاء المنطقية صامتة\n\n\nالأخطاء المنطقية صامتة. إذ لا يكتشفها المترجم، وتتسبب في تصرف البرنامج بشكل غير صحيح. الأخطاء المنطقية هي الأصعب في التتبع والإصلاح لأنها ليست واضحة. يمكن أن تكون ناجمة عن:\n\nافتراضات غير صحيحة\nخطوات غير مؤديَّة للمقصود\n\nلكونها جملاً صحيحة في ذاتها؛ لا يستطيع البرنامج كشف هذه الأخطاء لوحده. بل يجب على من يُدركُ حقيقة المطلوب من البرنامج أن يتكفل بذلك. وهنا تكون الحاجة ماسَّة لجمل التوكيد: assert.\nوالتدقيق؛ إذْ أفضل طريقة لحل الأخطاء المنطقية هي تنفيذ القطعة البرمجية والنظر في الناتج، وتتبع المنطق مرة أخرى إلى النص البرمجي سطرًا بسطر. يمكنك استخدام عبارات الطباعة print لتصحيح الأخطاء وفهم تدفق البرنامج. وقد يكون الأفضل من ذلك استعمال المدقق (Debugger).\nومراجعة الأقران: بحيث يطلع على النص البرمجي شخص آخر، فإنه قد يرى منه ما تعذر عليك رؤيته. وقد يتم تنظيمه بين أعضاء الفريق الواحد بأحد برمجيات التعاون مثل: GitHub وGitLab وBitbucket وغيرها. لكن ليس شرطًا أن يكون بها حتى تستفيد منه.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#تجويد-العبارة",
    "href": "chapters/00_rewrite/10_errors.html#تجويد-العبارة",
    "title": "10  الخطأ",
    "section": "تجويد العبارة",
    "text": "تجويد العبارة\nومما يسهل الاحتراز من الأخطاء المنطقية: تجويد العبارة البرمجية.\nومن تجويد العبارة تسمية المتغيرات بما يدل على وظيفتها، مثل:\n\nrate = 50\nhours_per_day = 6\ndays = 5\npay = rate * hours_per_day * days\nprint(pay)\n\n1500\n\n\nوإن كان ليس من الخطأ النحوي كتابتها بطريقة مختلفة وبأسماء غير معبِّرة، إلا أنه فعلٌ غير مستحسن:\n\nr, hpd, d = 50, 6, 5\np = r * hpd * d\nprint(p)\n\n1500\n\n\nوفي هذا نصائح كثيرة، يراجع فيها دليل أسلوب الكتابة في بايثون.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#ثالثا-الخطأ-التشغيلي",
    "href": "chapters/00_rewrite/10_errors.html#ثالثا-الخطأ-التشغيلي",
    "title": "10  الخطأ",
    "section": "ثالثاً: الخطأ التشغيلي",
    "text": "ثالثاً: الخطأ التشغيلي\nومن الخطأ الظاهر: الخطأ التشغيلي (Runtime Error)؛ أي الذي يصادَف أثناء عمل البرنامج. ويعبَّر عنه في عدة لغات باسم الاستثناء (Exception).\nالاستثناء (Exception) هو إعلام بخروج البرنامج عن المسارات المعتادة إلى مسار لم تتم برمجته.\nمثال ذلك:\n\nأن يؤمَر بقراءة ملف .. والواقع أن هذا الملف غير موجود!\nأو أن يطلب من المستخدم رقمًا فيعطيه كلاماً!\nأو أن يطلب من الشبكة شيئًا .. فتنقطع الشبكة!\n\nفكل هذه تعتبر مسارات غير مثالية لكنها تحصل في ظروف واقعيَّة. فيجب كتابة قطع في البرنامج تتعامل معها. ولذا فإن بعض الممارسين لا يفضلون استعمال كلمة استثناء لأنَّ مثل ذلك يحصل كثيرًا فهو ليس خارجًا عن العادة؛ بل من الطبيعي أن يحصل ذلك في الواقع!\nولاحظ أننا في جميع الحالات السابقة نكشف الخطأ بفحص الحالة:\n\nفأمر قراءة الملف يتضمن التحقق من وجوده؛ فإن لم يوجَد فإن الإجراء يقوم برفع استثناء\nوأمر التحويل من النص إلى الرقم فيه أيضًا فحص للحروف التي في النص؛ فإن لم تكن قابلة للتحويل فإنه يرفع استثناء\nوطلب شيء من الشبكة يتضمن توقيتًا لو تعداه ولم تحصل النتيجة؛ فإنه يتوقع أن ذلك بسبب انقطاع الشبكة، فيرفع استثناء\n\nلكننا غالبًا ما كنا نتعامل مع إجراءات من مكتبات، وهي التي ترفع الاستثناءات.\nوقد يتبادر لذهنك أن الاستثناء ما هو إلا حالة تكون في جملة الرجوع return. فهذا المثال (وهو مثال غير صحيح) يوضِّح هذه الفكرة:\ndef some_function():\n    if some_condition:\n        return Exception(\"something went wrong\")\n    return \"everything is fine\"\nوهذا صحيح في لغات برمجة أخرى غير بايثون؛ مثل: جو (Go) ورَسْت (Rust) وغيرها. لكن بايثون تشبه في هذا الأمر جافا (Java) وجافاسكريبت (JavaScript)، حيث تسمى رمي (throw) وأما في بايثون فتسمى رفع (raise) الاستثناءات.\nوعملية الرفع (raise) مثل جملة الرجوع، إلا أنها تُجبِر الإجراء المستدعي على أحد خيارين:\n\nأن يتعامل مع الاستثناء المرفوع\nأن يكرر رفعه إلى من استدعاه هو\n\nأي أن هذه الآلية تجعل الاستثناء يرجع ويرجع إلى أن يصل لقطعة تتعامل معه، وإلا فإنه يخرج من البرنامج بالكلية فيتوقف. وهذه الحالة نسميها الانهيار (Crash)، وهي محمودة في الأغلب، إذْ قد يؤدي البرنامج إلى إيقاف الجهاز الذي يعمله عليه.\nوالشكل التالي يوضح أن الاستثناء يُرفع (raise) بعد التحقق (if) من حالة معيَّنة. فإن لم تحصل (False) هذه الحالة الخاطئة؛ فإن البرنامج يتم سيره:\n\n\n\nالاستثناء يُرفع (raise) بعد التحقق (if) من حالة معيَّنة\n\n\nوإليك تمثيل هذه الصورة بقطعة بايثون:\n\nsome_condition = True\n\ndef f4():\n    print('f4')\n\ndef f3():\n    print('f3:start')\n    if some_condition:\n        raise Exception(\"something went wrong\")\n    f4()            # &lt;-- لن يتم تنفيذ هذا السطر بسبب رفع الاستثناء\n    print('f3:end') # &lt;-- لن يتم تنفيذ هذا السطر بسبب رفع الاستثناء\n\ndef f2():\n    print('f2:start')\n    try:\n        f3()\n    except Exception as e:\n        print(\"Caught the exception:\", e)\n        print(\"dealing with it...\")\n        # ... some logic to deal with the error ...\n    print('f2:end')\n\ndef f1():\n    print('f1:start')\n    f2()\n    print('f1:end')\n\ndef main():\n    print(\"main:start\")\n    f1()\n    print(\"main:end\")\n\nmain()\n\nmain:start\nf1:start\nf2:start\nf3:start\nCaught the exception: something went wrong\ndealing with it...\nf2:end\nf1:end\nmain:end",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#كيف-نقرأ-رسالة-الخطأ",
    "href": "chapters/00_rewrite/10_errors.html#كيف-نقرأ-رسالة-الخطأ",
    "title": "10  الخطأ",
    "section": "كيف نقرأ رسالة الخطأ؟",
    "text": "كيف نقرأ رسالة الخطأ؟\nوغالبًا تظهر لك رسالة خطأ (كبيرة أحيانًا) وذلك يحصل حين يُترَك ولا يلتقط بجملة try-except إذْ أن بايثون في تلك الحالة تقوم بالآتي:\n\nوضع ملاحظات على سلسلة الاستدعاءات التي أدت إلى الخطأ\n\nاسم الملف\nرقم السطر مع سهم يشير إليه\n\nإيقاف البرنامج\nإظهار رسالة الخطأ\n\nفهذا نفس المثال، لكننا سنحذف try-catch لنترك الخطأ ليصعد إلى الأعلى:\n\nsome_condition = True\n\ndef f4():\n    print('f4')\n\ndef f3():\n    print('f3:start')\n    if some_condition:\n        raise Exception(\"something went wrong\")\n    f4()            # &lt;-- لن يتم تنفيذ هذا السطر بسبب رفع الاستثناء\n    print('f3:end') # &lt;-- لن يتم تنفيذ هذا السطر بسبب رفع الاستثناء\n\ndef f2():\n    print('f2:start')\n    f3()\n    print('f2:end')\n\ndef f1():\n    print('f1:start')\n    f2()\n    print('f1:end')\n\ndef main():\n    print(\"main:start\")\n    f1()\n    print(\"main:end\")\n\nmain()\n\nmain:start\nf1:start\nf2:start\nf3:start\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[9], line 28\n     25     f1()\n     26     print(\"main:end\")\n---&gt; 28 main()\n\nCell In[9], line 25, in main()\n     23 def main():\n     24     print(\"main:start\")\n---&gt; 25     f1()\n     26     print(\"main:end\")\n\nCell In[9], line 20, in f1()\n     18 def f1():\n     19     print('f1:start')\n---&gt; 20     f2()\n     21     print('f1:end')\n\nCell In[9], line 15, in f2()\n     13 def f2():\n     14     print('f2:start')\n---&gt; 15     f3()\n     16     print('f2:end')\n\nCell In[9], line 9, in f3()\n      7 print('f3:start')\n      8 if some_condition:\n----&gt; 9     raise Exception(\"something went wrong\")\n     10 f4()            # &lt;-- لن يتم تنفيذ هذا السطر بسبب رفع الاستثناء\n     11 print('f3:end')\n\nException: something went wrong\n\n\n\nفيما يلي نتأمل رسالة الخطأ التي ظهرت..\nفترى في أول قطعة الإجراء الذي بدأ ذلك التسلسل كله وهو main:\nException                                 Traceback (most recent call last)\nCell In[18], line 28\n     25     f1()\n     26     print(\"main:end\")\n---&gt; 28 main()\nثم بعد ذلك ترى كومة الاستدعاءات (Stack Trace) وفي أسفل ذلك كله، ترى السبب المباشر للخطأ:\nCell In[18], line 25, in main()\n     23 def main():\n     24     print(\"main:start\")\n---&gt; 25     f1()\n     26     print(\"main:end\")\n\nCell In[18], line 20, in f1()\n     18 def f1():\n     19     print('f1:start')\n---&gt; 20     f2()\n     21     print('f1:end')\n\nCell In[18], line 15, in f2()\n     13 def f2():\n     14     print('f2:start')\n---&gt; 15     f3()\n     16     print('f2:end')\n\nCell In[18], line 9, in f3()\n      7 print('f3:start')\n      8 if some_condition:\n----&gt; 9     raise Exception(\"something went wrong\")\n     10 f4()\n     11 print('f3:end')\nوأما السطر الأخير بعد ذلك كله، فإنه ملخص للخطأ، وهو أول ما يجب أن تقرأ:\n\nالنوع (مثل: Exception وهو أب جميع الأخطاء)\nالتفاصيل بلغة طبيعية (مثل: something went wrong)\n\nException: something went wrong",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#جملة-المحاولة-try-except",
    "href": "chapters/00_rewrite/10_errors.html#جملة-المحاولة-try-except",
    "title": "10  الخطأ",
    "section": "جملة المحاولة (try-except)",
    "text": "جملة المحاولة (try-except)\nتنفذ التعليمات في لغة البرمجة الأمرية (Imperative) كبايثون بحسب ترتيبها (من الأعلى إلى الأسفل). لكن عند حدوث خطأ، يتغيَّر سيْر الأوامر باستعمال جملة try-except. وشكل جملة التعامل مع الخطأ على هذا النحو:\n\nالمحاولة: try تتضمن الجملة التي نتوقع حدوث خطأٍ فيها\nحالة الخطأ: except Exception هي مثل if تنفذ ما تتضمنه إن كان الخطأ من نوع Excpetion (وهو أب جميع الأخطاء)\n\nأما e فهو المتغير الذي يمثِّل تفاصيل الاستثناء إن وجدت؛ وعادة ما يكون رسالة نصيَّة تلخص الخطأ\n\nحالة عدم الخطأ: else تعمل عند عدم الخطأ (وفي هذا المثال لن تعمل أبدًا لأننا نتوقع حدوث أي خطأ على الإطلاق)\nالتعقيب: finally وهي جُملة تعمل سواء وقع الخطأ أم لم يقع؛ لكنَّ بايثون تضمن عملها إن حصل خطأ أثناء التعامل مع الخطأ\n\ndef do_something():\n    print('before')\n    try:\n        # حاول تشغيل هذه القطعة\n    except Exception as e:\n        # إذا حدث خطأ من نوع Exception\n        # فشغل هذه القطعة\n    else:\n        # وإن لم يحصل فهذه القعطة\n    finally:\n        # وشغل هذه على أية حال\n        # سواءٌ حصل الخطأ أم لا\n        # وفائدتها أنها تعمل قبل رجوع الخطأ لموضع النداء\n    print('after')",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#أنواع-الاستثناء",
    "href": "chapters/00_rewrite/10_errors.html#أنواع-الاستثناء",
    "title": "10  الخطأ",
    "section": "أنواع الاستثناء",
    "text": "أنواع الاستثناء\nتم تعريف أنواع من الخطأ في بايثون متبوعة بكلمة Error (عُرفًا)، وذلك باعتبار حالات خطأ نمطية ومتكررة:\n\n1. SyntaxError\nالسبب: خطأ نحوي في صياغة اللغة:\n\nكلمة غير صحيحة: خطأ في الإملاء\nفي وضع كلمة صحيحة في غير سياقها\nمحاذاة غير متسقة (IndentationError)\n\nمثال:\n\nif x &gt; 5\n    print(\"x\")\n\n\n  Cell In[10], line 1\n    if x &gt; 5\n            ^\nSyntaxError: expected ':'\n\n\n\n\nالحل: اقرأ رسالة الخطأ وستدلُّك على السبب والموضع الذي حصل فيه الخطأ.\n\n\n\n\n\n\nملاحظة\n\n\n\nفي الواقع هذا ليس من الأخطاء التشغيلية، بل هو خطأ نحوي / إملائي. ويمكن ضبط المحرر كي يكشفها لك قبل تشغيل البرنامج أصلاً.\n\n\n\n\n2. TypeError\nالسبب:\n\nطلب فعل بعدد أكثر أو أقل من العوامل الواجبة (مثل: len(1, 2))\nطلب فعل بعوامل لا تطابق النوع المحدد في تعريفه (مثل: math.sqrt('nine') أو 5 + '5')\n\nالحل: الاحتراز بفحص النوع عن طريق الإجراء type() أو isinstance() أو بالتأكد من تحويل النوع مسبقًا.\nمثال:\na = 5\nb = input('Enter a number: ')\nresult = a + int(b)\n\n5 + '5'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 5 + '5'\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nستجد الخلاصة في السطر الأخير:\n\nنوع الخطأ: TypeError\nالتفصيل: نوع المعطيات لعملية الجمع (+) غير متوافقة؛ وهي: العدد (int) والنص (str). ولاحظ أنه ذكر نوع العدد (int) لأنه قبله في ترتيب الكتابة.\n\n\n\n\n\n\n\nملاحظة\n\n\n\nيمكن تفادي هذا النوع من الأخطاء باستعمال أدوات مثل mypy. لكن لا يتسع المقام لذكرها هنا.\n\n\n\n\n3. ValueError\nالسبب: أن يكون النوع صحيحًا (فلا يحصُل TypeError) لكن القيمة غير مقبولة.\n\nمثلاً: طلب فعل بقيمة نوعها عددي لكنَّها سالبة وهو لا يقبل إلا الموجبة. نحو: math.sqrt(-16) فالجذر التربيعي لا يقبل السالب.\n\nالحل: الاحتراز بفحص مدى القيمة قبل تنفيذ الأمر ، نحو:\nif x &gt;= 0:\n    math.sqrt(x)\nelse:\n    # do something else\n\n\n4. IndexError & 5. KeyError\nالسبب: الرقم الذي استعمل في عملية الإشارة list[index] (قائمة) أو dict[key] (قاموس) يشير لما هو خارج المجموعة. وهذا يؤدي إلى كوارث لو كان في لغة “غير آمنة” مثل سي (C) لأنها لا تتحقق من صحة المؤشر، إلا إذا فعلنا ذلك بأنفسنا. لكن في بايثون يتم كشف هذا الخطأ ورفعه حال وقوعه مباشرة، ونتعامل معه كاستثناء.\nنحو:\n\nmy_list = [10, 20, 30]\nidx = 3\n\n\nmy_list[idx]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 my_list[idx]\n\nIndexError: list index out of range\n\n\n\nالحل: بأن نحترز باشتراط كون المؤشر لا يتعدى العنصر الأخير\nif idx &lt; len(my_list):\n    value = my_list[idx]\nelse:\n    # do something else\nأو بالاستجابة للاستثناء المرفوع:\ntry:\n    value = my_list[idx]\nexcept IndexError:\n    # do something else\nوكذلك في القاموس، نحو:\n\nmy_dict = {'A': 10, 'B': 20, 'C': 30}\nkey = 'Z'\n\n\nvalue = my_dict[key]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[15], line 1\n----&gt; 1 value = my_dict[key]\n\nKeyError: 'Z'\n\n\n\nالحل: بالاحتراز بأن نشترط وجود المفتاح أصلاً في القاموس\nif key in my_dict:\n    value = my_dict[key]\nelse:\n    # do something else\nأو هكذا (تعيين قيمة افتراضية عند العدم):\nvalue = my_dict.get(key, 0)\nأو بالاستجابة للاستثناء المرفوع:\ntry:\n    value = my_dict[key]\nexcept KeyError:\n    # do something else\n\n\n6. AttributeError & 7. NameError\nالسبب: استعمال متغير أو فعل قبل تعريفه.\n\nفإن أسنِد إلى كائن؛ رُفِع AttributeError (مثل: a.x)\nوإلا رُفِع NameError (مثل: X)\n\n\na = 10\na + X\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[16], line 2\n      1 a = 10\n----&gt; 2 a + X\n\nNameError: name 'X' is not defined\n\n\n\n\nsome_function(55)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[17], line 1\n----&gt; 1 some_function(55)\n\nNameError: name 'some_function' is not defined\n\n\n\n\nclass A:\n    pass\n\na = A()\na.x\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[18], line 5\n      2     pass\n      4 a = A()\n----&gt; 5 a.x\n\nAttributeError: 'A' object has no attribute 'x'\n\n\n\n\na.do_something()\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[19], line 1\n----&gt; 1 a.do_something()\n\nAttributeError: 'A' object has no attribute 'do_something'\n\n\n\n\n\n8. ModuleNotFoundError\nالسبب: فشل جُملة الاستيراد import numpy\nالحل:\n\nتأكد من صحة الإملاء\nتأكد من تثبيت الوحدة في البيئة التي يعمل فيها البرنامج:\n\nإذا كنت تستعمل pip فالأمر: pip install numpy\nإذا كنت تستعمل uv فالأمر: uv add numpy (وهو الذي ننصح به)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#قراءة-تسلسل-الاستدعاءات-إلى-الخطأ",
    "href": "chapters/00_rewrite/10_errors.html#قراءة-تسلسل-الاستدعاءات-إلى-الخطأ",
    "title": "10  الخطأ",
    "section": "قراءة تسلسل الاستدعاءات إلى الخطأ",
    "text": "قراءة تسلسل الاستدعاءات إلى الخطأ",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#تعريف-أخطاء-جديدة",
    "href": "chapters/00_rewrite/10_errors.html#تعريف-أخطاء-جديدة",
    "title": "10  الخطأ",
    "section": "تعريف أخطاء جديدة",
    "text": "تعريف أخطاء جديدة\nتعريف الخطأ يكون بتعريف نوع جديد يرث من النوع Exception، وهذا ما يحققه السطر الأول بين القوسين. وتستطيع أن ترث ممن يرث، فتتكون لديك فروع من هذا الخطأ:\n\nclass ParentError(Exception):\n    pass\n\nclass XError(ParentError):\n    pass\n\nclass YError(ParentError):\n    pass\n\n\n\n\n\n\n\nflowchart TD\n    A[ParentError] --&gt; B[XError]\n    A --&gt; C[YError]\n\n\n\n\n\n\n\nوهذا الإجراء يحصل فيه الخطأ بطريقة مصطنعة لكنها توضح ما نريد، وهو الخطأ الفرعي XError الذي يرث من الخطأ الأصلي ParentError:\n\ndef do_something():\n    raise XError('Something went wrong')\n\nثم حين نفحص، نستطيع أن نطابق بالأصل أو الفرع:\n\ntry:\n    do_something()\nexcept ParentError as e:\n    print(\"caught you:\", e)\n\ncaught you: Something went wrong",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#الاحتراز-والاستجابة",
    "href": "chapters/00_rewrite/10_errors.html#الاحتراز-والاستجابة",
    "title": "10  الخطأ",
    "section": "الاحتراز والاستجابة",
    "text": "الاحتراز والاستجابة\nيهندس المبرمج الإجراءات بحيث تكون نتيجة كل واحدٍ منها مبنيًّا على معطياته المباشرة؛ بحيث لو تم تمرير نفس المعطيات فإن نفس النتائج تخرج. فأن تقليل العوامل المؤثرة في كل خطوة يجعل التحقق من صحتها أسهل. ثم يتم تركيب البرنامج بمجموعها لتعمل جميع العوامل؛ وحينها نكون أقدر على التركيب الصحيح.\nوذكرنا أن الإجراء له أحد أمرين لا ثالث لهما:\n\nالمعالجة: أن يتعامل مع الاستثناء المرفوع؛ وذلك إن كان سياق الإجراء يسوعبه؛ أي: أن يكون في وعي الإجراء (في معطياته ومتغيراته) ما يمكن به معالجته.\nالرفع: أن يكرر رفعه إلى من استدعاه هو؛ وذلك حين لا يكون في سياق الإجراء ما يمكن به معالجته فيرفعه (يرجع به) للإجراء المستدعي له (الذي هو أكثرُ وَعيًا منه) ليعالجه.\n\nوالرفع يتسلسل حتى يخرج من البرنامج؛ حيث يصل إلى الإنسان (سواءً المستفيد أو المبرمج): برسالة مفادها أمران:\n\nالعثور عليه\nالتعامل معه\n\nفأما حين يستوعبه السياق؛ فلدينا طريقتان لمعالجة الخطأ:\n\nالاحتراز: توقُّع حالات الخطأ والتحقق من عدمها قبل الإقدام على العملية.\nالاستجابة: ترك العملية لترجع بالخطأ؛ ثم نتعامل معه بحسبه.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#الفرق-بين-الاحتراز-والاستجابة",
    "href": "chapters/00_rewrite/10_errors.html#الفرق-بين-الاحتراز-والاستجابة",
    "title": "10  الخطأ",
    "section": "الفرق بين: الاحتراز والاستجابة",
    "text": "الفرق بين: الاحتراز والاستجابة\nهذا الإجراء مسؤول عن تهيئة البرنامج، ومن خطواته أنه يقرأ ملف الضبط المخصص custom_config.json. وفي هذه الحالة قد يحصل خطأ. إذْ قد لا يكون الملف موجودًا أصلا!\ndef initialize_program():\n    # ... code before\n    file = open('custom_config.json')\n    # ... code after\nففي هذه الحالة يحصل استثناء من نوع FileNotFoundError.\nفإذا اخترنا طريق الاحتراز فإننا أولاً نلتمس وجوده قبل فتحه. ونتعامل مع حالة الخطأ هذه (أي: عدمه)، بأن -مثلاً- نقرأ ملف الضبط الافتراضي default.json بدلاً من الملف المطلوب. والفرق بين هذا الملف والذي قبله أننا موقنون بوجوده، والأوَّل وجوده مظنون إذْ الذي يضعه هو المستخدم.\ndef initialize_program():\n    # ... code before\n    if os.path.exists('custom_config.json'):\n        file = open('custom_config.json')\n    else:\n        file = open('default.json')\n    # ... code after\nوقد تقول، حسنًا ماذا يكون لو عُدم ملف default.json أيضًا؟ فنقول: لا بأس أن يحصل خطأ يوقف البرنامج. إذْ ذاك يعتبر خطأ منطقيًّا يجب إصلاحه بإضافة الملف، وليس ثمة مجال لأن يصلحه النص البرمجي بنفسه .. وفي هذه الحالة؛ الأفضل أن نترك الخطأ ليتفاقم وينهار البرنامج فوْر وقوعه لنكتشفه ونصلحه.\nأما الاستجابة فتكون بجملة try-except على النحو التالي:\ndef initialize_program():\n    # ... code before\n    try:\n        file = open('custom_config.json')\n    except FileNotFoundError:\n        file = open('default.json')\n    # ... code after\nما هو الأفضل إذاً؟\nأما استعمال الاحتراز ففيه شك بوجود فجوة زمنية بين عمليتي الإدراك والفعل. فالحاسب تتوارد عليه البرمجيات، ولا يستأثر به برنامج واحد. فإذا تغيَّر الحال في هذه الفجوة الزمنية (بعد إدراك وجود الملف .. تم حذفه) فعاد بالنقض على صواب الإدراك؛ لذلك تكون الاستجابة أضمن من الاحتراز فيما هو عُرضة لحالة التسابق.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#الحالة-الأولى-أن-يستوعبه-السياق",
    "href": "chapters/00_rewrite/10_errors.html#الحالة-الأولى-أن-يستوعبه-السياق",
    "title": "10  الخطأ",
    "section": "الحالة الأولى: أن يستوعبه السياق",
    "text": "الحالة الأولى: أن يستوعبه السياق\n\nفإن كان خطأ جديدًا\nمثاله الاحتراز مما لو لم تكن إحدى الخصائص موجودة (خطأ جديد)، فيمكن تعيينها بقيمة ابتدائية (الحل)، ولا يلزمنا تصعيد الخطأ. فهنا ننظر في المفتاح language هل هو موجود في القاموس user .. فإن لم توجَد عيَّنا له قيمة افتراضية: ar وأكمل الإجراء سيره:\ndef save_user(user: dict):\n    if 'language' not in user:\n        user['language'] = 'ar'\n    # ... rest of the code\n    save_to_database(user)\nوبهذا يكون الإجراء قد تعامل مع الخطأ بنفسه.\n\n\nوإن كان خطًا مرفوعًا\nوقد مثلنا له بفتح الملف، ونمثل له بمثال آخر: وهو صعود خطأ من إجراء تحويل القيمة النصية الآتية من المستخدم (guess) إلى قيمة عدد صحيح (int)؛ فإننا نستجيب لحدوث الخطأ ValueError ونتعامل معه بإظهار رسالة تفيد المستخدم بمكمن الخطأ وكيفية إصلاحه من جهته: “القيمة ليست عددًا .. من فضلك أدخل قيمة عددية”.\n\ndef get_user_guess() -&gt; int:\n    print('Please enter a number')\n    guess = input()\n    try:\n        guess = int(guess)\n    except ValueError:\n        print(f'The value \"{guess}\" is not a number')\n        guess = get_user_guess() # recursive call\n    return guess\n\nوبهذا يكون الإجراء يصحح نفسه حتى يضمن عند الرجوع return guess أنه أتمَّ وظيفته بشكل صحيح.\n\n\nالحالة الثانية: ألا يستوعبه السياق\n\nفإن كان خطأ جديدًا\nفي هذا المثال نريد أن نُلزم كون وحدة القياس إحدى القيمتين: C (سيليلوز) أو F (فهرنهايت). وإلا فلا حيلة للإجراء أن يتمَّ وظيفته. لذا نرفع خطأ جديدًا بجملة الرفع raise على هذا النحو:\ndef convert_temperature(value: float, unit: str) -&gt; float:\n    if unit not in {'C', 'F'}:\n        raise ValueError(f\"Invalid unit: {unit}\")\n    \n    if unit == 'C':\n        return value * 9/5 + 32\n    elif unit == 'F':\n        return (value - 32) * 5/9\nلاحظ أننا اخترنا ValueError لما تقدَّم بيانه عن أن هذا النوع من الأخطاء هو لما يكون صحيح النوع (type) لكن خاطئ القيمة.\n\n\nوإن كان خطأً مرفوعًا\nفإن من الأخطاء ما يتعذر على البرنامج معالجته بنفسه:\n\nإذا كانت المشكلة بامتلاء الذاكرة في الجهاز (Out-of-Memory - OOM)؛ فإن البرنامج ليس له إلا أن يخرج برسالة للمستخدم أو المسؤول عن الجهاز .. وليس للبرنامج أن يتعرَّض للمساحة المخصصة لغيره من البرامج في الذاكرة ويتعدى عليها فيسمحها ليتمدد هو!\nأما إذا كانت المشكلة في تأخر الإجابة من الخادم مثلاً، فقد نعيد المحاول مرة أخرى بعد ثوانٍ، ونعيدها لعددٍ محدد من المرات، أملاً في الحصول على إجابة. ثم بعد ذلك لا يمكن إلا أن نظهر رسالة خطأ إن نفذت جميع المحاولات.\n\nففي هذا المثال عملية قسمة؛ ونتوقع بحسب معرفتنا الرياضية بإمكان حصول القسمة على صفر في (a / b)، فيرتفع بذلك خطأ اسمه ZeroDivisionError من تلك العملية. والحقيقة أننا في هذا السياق ليس لنا أن نعدِّل الرقم، بل نريد لمن استدعى الإجراء أن يعلم بالخطأ، ولسنا نريد إضافة معلومة أخرى فوق ذلك. لذا نسكت عنه (أي: لا نضع try-except) وهذا يجعله ينتقل مباشرة للإجراء المستدعي.\ndef divide_lists(list1: list, list2: list) -&gt; list:\n    \"\"\"Divide the elements of list1 by the elements of list2\n    :raises ZeroDivisionError: If the denominator `b` is zero.\n    \"\"\"\n    result = []\n    for a, b in zip(list1, list2):\n        result.append(a / b)\n    return result\nفالطريقة الصحيحة للتعامل مع مثل هذه الأخطاء، أن نتركها تصعد لوحدها، وندوِّن إمكان حصولها في شرح الإجراء (وهو النص الذي في أوَّل جسده).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/00_rewrite/10_errors.html#من-الخطأ-إلتقاط-جميع-الأخطاء",
    "href": "chapters/00_rewrite/10_errors.html#من-الخطأ-إلتقاط-جميع-الأخطاء",
    "title": "10  الخطأ",
    "section": "من الخطأ إلتقاط جميع الأخطاء",
    "text": "من الخطأ إلتقاط جميع الأخطاء\nمن الخطأ في المنطق البرمجي إلتقاط جميع الأخطاء في الإجراءات باستعمال except Exception وهو النوع الشامل لجميع الأخطاء. فهذه الطريقة لا تخبرنا بنوع الخطأ وبالتالي لا نتعامل معه بحسبه، وإنما غاية ما تحقق هو منع تصعيد الخطأ لأعلى طبقة، إذْ حين يحصل ذلك توقف بايثون البرنامج (وعندها تظهر سلسلة الاستدعاءات).\nلكن الحالة النادرة تكون في أطر العمل (Frameworks) إذْ يجوز ذلك في قطع النص البرمجي التي يُراد لها الاستمرار، وإن فشلَ شيئٌ فيها. مثلاً: لا تريد للخادم أن يتوقف تمامًا بمجرد حصول خطأ واحد في أحد خيوط التنفيذ الخاصة بخدمة أحد الطلبات. ففي مثل ذلك يسوغ استخدام except Exception الشاملة. انظر مثلاً قطعة النص البرمجي في إطار الويب فلاسك المسؤول عن استقبال الطلبات.\n\nالمراجع:\n\nMiguel Grinberg: The Ultimate Guide to Error Handling in Python",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html",
    "href": "chapters/02_numbers/problems.html",
    "title": "في الأرقام",
    "section": "",
    "text": "كم سيكون عمرك حين كذا؟",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-حين-كذا",
    "href": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-حين-كذا",
    "title": "في الأرقام",
    "section": "",
    "text": "عرف تاريخ الحدث المستقبلي بالسنوات: future_date\nعرف تاريخ اليوم: today\nعرف المتغير: age\nاحسب عمرك عند حصول الحدث: age_then\nاطبع النتيجة: print(age_then)",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الأجر",
    "href": "chapters/02_numbers/problems.html#حساب-الأجر",
    "title": "في الأرقام",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nعدد ساعات العمل: hours\nمعدل الأجر لكل ساعة: per_hour_rate\nاحسب الأجر الذي تستحقه بناءً على عدد الساعات ومعدل الأجر: gross_pay\nاطبع النتيجة: print(gross_pay)",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "في الأرقام",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nسرعة السيارة: speed\nالمسافة: distance\nاحسب الزمن المستغرق للوصول إلى المكان المعيَّن بناءً على السرعة والمسافة: time\nاطبع النتيجة: print(time)",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "في الأرقام",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\n\n\nمثلث\n\n\nباستخدام معادلة هيرون:\n\\[\n\\text{area} = \\sqrt{s (s - a) (s - b) (s - c)}  \n\\]\nحيث:\n\n\\(a\\), \\(b\\), \\(c\\) هي أطوال أضلاع المثلث\nنصف المحيط:\n\n\\[\ns = \\frac{a + b + c}{2}\n\\]\n\na = 3\nb = 4\nc = 5",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#نسبة-التغير",
    "href": "chapters/02_numbers/problems.html#نسبة-التغير",
    "title": "في الأرقام",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#التغير-النسبي",
    "href": "chapters/02_numbers/problems.html#التغير-النسبي",
    "title": "في الأرقام",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\nمساعدة: فكك العبارة واجعلها في متغيرات، وضع لكل أسبوعٍ متغيِّرًا يعتمد على الأسبوع الذي قبله.",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/problems.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "في الأرقام",
    "section": "الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "الفرق بين النوع العددي والنوع النصي للعدد\nإذا كان عندك هذه المتغيرات الثلاثة، فكيف تقيم عملية الجمع بالشكل الصحيح؟ (أولاً: استعمل type لمعرفة نوع كل متغير)\n\na = 4\nb = 3.14\nc = \"10\"",
    "crumbs": [
      "مسائل موضوعية",
      "في الأرقام"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html",
    "href": "chapters/02_numbers/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "كم سيكون عمرك حين كذا؟\nfuture_date = 2050\ntoday = 2024\nage = 20\nage_then = age + (future_date - today)\nprint('you will be', age_then, 'years old in', future_date)\n\nyou will be 46 years old in 2050",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "href": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "title": "حل المسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nhours = 40\nper_hour_rate = 10\ngross_pay = hours * per_hour_rate\nprint('you deserve:', gross_pay, 'SAR')\n\nyou deserve: 400 SAR",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "حل المسائل",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nspeed = 100\ndistance = 200\ntime = distance / speed\nprint('it will take you', time, 'hours to reach the destination')\n\nit will take you 2.0 hours to reach the destination",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "حل المسائل",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\nimport math\n\na = 3\nb = 4\nc = 5\n\ns = (a + b + c) / 2\narea = math.sqrt(s * (s - a) * (s - b) * (s - c))\nh = 2 * area / c\nprint('the height of the triangle is', h)\n\nthe height of the triangle is 2.4",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "href": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "title": "حل المسائل",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟\n\nold_expense = 1000\nnew_expense = 650\n\npercentage = (new_expense - old_expense) / old_expense\nprint(percentage * 100, '%')\n\n-35.0 %",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "href": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "title": "حل المسائل",
    "section": "الزيادة النسبية",
    "text": "الزيادة النسبية\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\n\nincrement = 1.10\n\nw1 = 20\nw2 = w1 * increment\nw3 = w2 * increment\nw4 = w3 * increment\n\nprint(round(w4, 1))\n\n26.6",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html",
    "href": "chapters/03_control_flow/problems.html",
    "title": "في الشرط والتكرار",
    "section": "",
    "text": "المحاذاة\nما هي المشكلة في هذه القطعة البرمجية؟ وكيف تحلها؟\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[1], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#تركيب-الشروط",
    "href": "chapters/03_control_flow/problems.html#تركيب-الشروط",
    "title": "في الشرط والتكرار",
    "section": "تركيب الشروط",
    "text": "تركيب الشروط\nاعكس هذه العبارة الشرطة المرسومة بكتابة القطعة البرمجية التي تمثلها:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{and} -- True --&gt; RESULT\n  middle_left{\"&gt;\"} -- True --&gt; ROOT\n  middle_right{\"&gt;\"} -- True --&gt; ROOT\n  left_left[age] -- \"20\" --&gt; middle_left\n  left_right[18] -- \"18\" --&gt; middle_left\n  right_left[weight] -- \"50\" --&gt; middle_right\n  right_right[45] -- \"45\" --&gt; middle_right",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#ارسم-الشجرة-الثائية",
    "href": "chapters/03_control_flow/problems.html#ارسم-الشجرة-الثائية",
    "title": "في الشرط والتكرار",
    "section": "ارسم الشجرة الثائية",
    "text": "ارسم الشجرة الثائية\nارسم الشجرة الثنائية للعبارة الشرطية في القطعة البرمجية التالية:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/03_control_flow/problems.html#الجملة-الشرطية-المتكاملة",
    "title": "في الشرط والتكرار",
    "section": "الجملة الشرطية المتكاملة",
    "text": "الجملة الشرطية المتكاملة\nما هو حاصل تنفيذ هذه القطعة (فقط بالنظر إليها يجب أن تعرف):\n\nx = 1\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSingle\nAlways: 1",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط",
    "title": "في الشرط والتكرار",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nكيف تكتب هذه الجملة بطريقة مختصرة؟\n\nspeed = 45\n\nif speed &gt; 50:\n  message = 'Too fast!'\nelse:\n  message = 'Okay'\n\nprint(message)\n\nOkay",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط-1",
    "href": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط-1",
    "title": "في الشرط والتكرار",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nوماذا عن هذه الجملة، كيف تكتبها مختصرة؟\n\ntemperature = 25\n\nif temperature &gt; 30:\n  comfort = 'Hot'\nelif temperature &gt; 15:\n  comfort = 'Comfortable'\nelse:\n  comfort = 'Cold'\n\nprint(comfort)\n\nComfortable",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "title": "في الشرط والتكرار",
    "section": "الوزن الطبيعي",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\n\n\n\nالتصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\nالمطلوب:\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية مضمنة تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة\n\nملاحظة: يجب أن تكون الجمل الشرطية تستعمل التضمين على النحو التالي:\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "title": "في الشرط والتكرار",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار",
    "href": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار",
    "title": "في الشرط والتكرار",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة البرمجية التالية بحلقة تكرار:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار-1",
    "href": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار-1",
    "title": "في الشرط والتكرار",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nوكذلك اكتب القطعة التالية بحلقة تكرار:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "href": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "title": "في الشرط والتكرار",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "href": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "title": "في الشرط والتكرار",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بمفتاح الدولة، مثلاً بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”",
    "crumbs": [
      "مسائل موضوعية",
      "في الشرط والتكرار"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html",
    "href": "chapters/03_control_flow/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\nالمطلوب:\nheight = 1.70\nweight = 95\nbmi = weight / height**2\n\nword = ''\ncategory = ''\n\nif bmi &lt; 18.5:\n    word = 'thin'\n    if bmi &lt; 16:\n        category = 'severe'\n    elif bmi &lt; 17:\n        category = 'moderate'\n    else:\n        category = 'mild'\nelif bmi &lt; 25:\n    word = 'normal'\nelse:\n    word = 'overweight'\n    if bmi &lt; 30:\n        category = 'class 1'\n    elif bmi &lt; 35:\n        category = 'class 2'\n    elif bmi &lt; 40:\n        category = 'class 3'\n    else:\n        category = 'class 4'\n\nprint(word, category)\n\noverweight class 2",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "title": "حل المسائل",
    "section": "",
    "text": "التصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\n\n\n\n\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\n\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "title": "حل المسائل",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة\n\nuser_input = input(\"Enter a number: \")\nn = int(user_input)\n\ntotal = 0\ni = 1\nwhile i &lt;= n:\n    total += i\n    i += 1\n\nprint('sum is:', total)",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار",
    "href": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار",
    "title": "حل المسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة البرمجية التالية بحلقة تكرار:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60\n\n\nالجواب:\n\nvalue = 15\nincrease = 5\nweeks = 10\n\ni = 0\nwhile i &lt; weeks:\n    value += increase\n    print(value, end=' ')\n    i += 1\n\n20 25 30 35 40 45 50 55 60 65 \n\n\nملاحظة: استعمال print(value, end=' ') يجعل الناتج يظهر في سطر واحد. وذلك لأن end='\\n' في الأصل وتعني سطرًا جديدًا.",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار-1",
    "href": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار-1",
    "title": "حل المسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة التالية بحلقة تكرار:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194\n\n\nالجواب:\n\nimport math\n\nday = 100\ngrowth_rate = 0.117\n\ni = 0\nwhile i &lt; 6:\n    day *= (1 + growth_rate)\n    print(math.floor(day))\n    i += 1\n\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "href": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "title": "حل المسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)\nقد مرت علينا هذه المسألة، لكن الآن المطلوب حلها بالتكرار.\n\nweight = 20\nfor week in range(12):\n    weight += weight * 0.1\nprint(weight)\n\n62.768567534419994",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "href": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "title": "حل المسائل",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”\n\nprint(\"\"\"مرحبا بك في خدمة التبرع\nفضلا أريد منك تزويدي ببعض المعلومات ..\n\"\"\")\n\nprint('أتشرف باسمك، مثلا: محمد أحمد')\nname = input()\n\nprint('زودنا برقم جوالك، يبدأ بـ966')\nphone = input()\n\nprint('ممكن تحدد مدينتك؟')\ncity = input()\n\nprint('الرجاء قم بكتابة اسم الحي')\nneighborhood = input()\n\nprint('name:', name)\nprint('phone:', phone)\nprint('city:', city)\nprint('neighborhood:', neighborhood)\n\nwhile True:\n    print('هل تود تأكيد طلب التبرع؟')\n    print('1. تأكيد الطلب')\n    print('2. تعديل الطلب')\n    print('3. إلغاء الطلب')\n    user_confirmation = input()\n\n    if user_confirmation == '1':\n        print('تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً')\n        break\n    elif user_confirmation == '2':\n        print('ما الشيء الذي تريد تعديله؟')\n        print('1. الاسم')\n        print('2. رقم الهاتف')\n        print('3. المدينة')\n        print('4. اسم الحي')\n        user_modification = input()\n        match user_modification:\n            case '1':\n                print('اسم الزبون')\n                name = input()\n            case '2':\n                print('رقم الهاتف')\n                phone = input()\n            case '3':\n                print('المدينة')\n                city = input()\n            case '4':\n                print('اسم الحي')\n                neighborhood = input()\n            case _:\n                print('إختيار غير موجود')\n\n    elif user_confirmation == '3':\n        print('تم إلغاء طلب التبرع')\n        break",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html",
    "href": "chapters/05_sequences/problems.html",
    "title": "في الجمع المرتب",
    "section": "",
    "text": "إنشاء قائمة\nلديك مجموعة طلاب في الفصل وتريد تجميع أسمائهم في مجموعة. وهم:",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#إنشاء-قائمة",
    "href": "chapters/05_sequences/problems.html#إنشاء-قائمة",
    "title": "في الجمع المرتب",
    "section": "",
    "text": "\"عمرو\"\n\"لؤي\"\n\"محمد\"\n\"علي\"\n\"فصيل\"",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#قائمة-الطلاب",
    "href": "chapters/05_sequences/problems.html#قائمة-الطلاب",
    "title": "في الجمع المرتب",
    "section": "قائمة الطلاب",
    "text": "قائمة الطلاب\nمن القائمة السابقة تريد تحصيل التالي:\n\nهل الطالب “لؤي” في القائمة؟\nكم عدد الطلاب؟\nاسرد الفائمة",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#أضف-طالبا-جديدا",
    "href": "chapters/05_sequences/problems.html#أضف-طالبا-جديدا",
    "title": "في الجمع المرتب",
    "section": "أضف طالبًا جديدًا",
    "text": "أضف طالبًا جديدًا\nأضف طالبًا جديدًا إلى القائمة، وهو: \"زياد\".",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#بالإشارة",
    "href": "chapters/05_sequences/problems.html#بالإشارة",
    "title": "في الجمع المرتب",
    "section": "بالإشارة",
    "text": "بالإشارة\n\nمن هو أول طالب؟\nمن هو آخر طالب؟\nمن هو الطالب الذي في المنتصف؟",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#بالقطعة",
    "href": "chapters/05_sequences/problems.html#بالقطعة",
    "title": "في الجمع المرتب",
    "section": "بالقطعة",
    "text": "بالقطعة\n\nمن هم الطلاب باستثناء الأول والأخير؟\nمن هم الطلاب الثلاثة الأُخَر\nمن هم الطلاب الذين في موضع فردي؟\nمن هم الطلاب الذين في موضع زوجي؟",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "title": "في الجمع المرتب",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\n\nلديك قائمة بالمبيعات اليومية.\n\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\nوتريد أن تحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الإجراء len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الإجراء sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الإجراء statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "href": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "title": "في الجمع المرتب",
    "section": "سلة مشتريات",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها:\nfruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\nاحسب حاصل مشتريات كل سلة وفق قائمة الأسعار:\nbasket1 = [\"apple\", \"apple\", \"apple\"]\nbasket2 = [\"banana\", \"apple\"]",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "href": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "title": "في الجمع المرتب",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\nيوصف ضرب المتجهين بالصيغة:\n\\[\n\\vec{u} \\cdot \\vec{v} = \\sum_{i=1}^{n} u_i v_i\n\\]\nأي أن كل عنصر من المتجه الأول يضرب في العنصر المناظر له في المتجه الثاني، ويُجْمَعُ ناتج ذلك كله.\nu = (1, 2, 3)\nv = (4, 5, 6)\nفهذا التوكيد الأول بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{v} &= [4, 5, 6] \\\\\n\\vec{u} \\cdot \\vec{v} &= (1)(4) + (2)(5) + (3)(6) \\\\\n                     &= 4 + 10 + 18 \\\\\n                     &= 32\n\\end{align*}\n\\]\nوهذا التوكيد الثاني بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{u} \\cdot \\vec{u} &= (1)(1) + (2)(2) + (3)(3) \\\\\n                     &= 1 + 4 + 9 \\\\\n                     &= 14\n\\end{align*}\n\\]",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرتب"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html",
    "href": "chapters/05_sequences/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "إنشاء قائمة\nلديك مجموعة طلاب في الفصل وتريد تجميع أسمائهم في مجموعة. وهم:\nstudents = [\"عمرو\", \"لؤي\", \"محمد\", \"علي\", \"فصيل\"]",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#إنشاء-قائمة",
    "href": "chapters/05_sequences/solutions.html#إنشاء-قائمة",
    "title": "حل المسائل",
    "section": "",
    "text": "\"عمرو\"\n\"لؤي\"\n\"محمد\"\n\"علي\"\n\"فصيل\"",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#قائمة-الطلاب",
    "href": "chapters/05_sequences/solutions.html#قائمة-الطلاب",
    "title": "حل المسائل",
    "section": "قائمة الطلاب",
    "text": "قائمة الطلاب\nمن القائمة السابقة تريد تحصيل التالي:\n\nهل الطالب “لؤي” في القائمة؟\nكم عدد الطلاب؟\nاسرد الفائمة\n\n\nprint(\"لؤي\" in students)\nprint(len(students))\nfor s in students:\n    print(\"Student:\", s)\n\nTrue\n5\nStudent: عمرو\nStudent: لؤي\nStudent: محمد\nStudent: علي\nStudent: فصيل",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#أضف-طالبا-جديدا",
    "href": "chapters/05_sequences/solutions.html#أضف-طالبا-جديدا",
    "title": "حل المسائل",
    "section": "أضف طالبًا جديدًا",
    "text": "أضف طالبًا جديدًا\nأضف طالبًا جديدًا إلى القائمة، وهو: \"زياد\".\n\nstudents.append(\"زياد\")\n\nأو\nstudents = students + [\"زياد\"]",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#بالإشارة",
    "href": "chapters/05_sequences/solutions.html#بالإشارة",
    "title": "حل المسائل",
    "section": "بالإشارة",
    "text": "بالإشارة\n\nمن هو أول طالب؟\nمن هو آخر طالب؟\nمن هو الطالب الذي في المنتصف؟\n\n\nprint(students[0])\nprint(students[-1])\nprint(students[len(students) // 2])\n\nعمرو\nزياد\nعلي",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#بالقطعة",
    "href": "chapters/05_sequences/solutions.html#بالقطعة",
    "title": "حل المسائل",
    "section": "بالقطعة",
    "text": "بالقطعة\n\nمن هم الطلاب باستثناء الأول والأخير؟\nمن هم الطلاب الثلاثة من النهاية\nمن هم الطلاب الذين في موضع فردي؟\nمن هم الطلاب الذين في موضع زوجي؟\n\n\nprint(students[1:-1])\nprint(students[:-3])\nprint(students[::2])\nprint(students[1::2])\n\n['لؤي', 'محمد', 'علي', 'فصيل']\n['عمرو', 'لؤي', 'محمد']\n['عمرو', 'محمد', 'فصيل']\n['لؤي', 'علي', 'زياد']",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/solutions.html#متوسط-المبيعات-اليومية",
    "title": "حل المسائل",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\n\nلديك قائمة بالمبيعات اليومية.\n\n\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\n\nوتريد أن تحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الإجراء len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الإجراء sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الإجراء statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري\n\n\nimport statistics\n\nprint(len(daily_sales))\nfor i in range(0, len(daily_sales), 7):\n    print(\"Week\", i//7+1)\n    print(\"Sales:\", sum(daily_sales[i:i+7]))\n    print(\"Mean:\", round(statistics.mean(daily_sales[i:i+7]), 2))\n    print(\"Std:\",  round(statistics.stdev(daily_sales[i:i+7]), 2))\n    print()\n\n28\nWeek 1\nSales: 84\nMean: 12\nStd: 2.08\n\nWeek 2\nSales: 86\nMean: 12.29\nStd: 3.5\n\nWeek 3\nSales: 85\nMean: 12.14\nStd: 3.53\n\nWeek 4\nSales: 101\nMean: 14.43\nStd: 4.12",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#سلة-مشتريات",
    "href": "chapters/05_sequences/solutions.html#سلة-مشتريات",
    "title": "حل المسائل",
    "section": "سلة مشتريات",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها:\n\nfruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\n\nاحسب حاصل مشتريات كل سلة وفق قائمة الأسعار:\n\nbasket1 = [\"apple\", \"apple\", \"apple\"]\nbasket2 = [\"banana\", \"apple\"]\n\nللسلة الواحدة نكتب هكذا\n\ntotal = 0\nfor item in basket1:\n    total += prices[fruits.index(item)]\nprint(total)\n\n4.5\n\n\nلجميع السلال يمكن أن نضيف حلقة أخرى:\n\ntotals = []\nfor basket in [basket1, basket2]:\n    total = 0\n    for item in basket:\n        total += prices[fruits.index(item)]\n    totals.append(total)\nprint(totals)\n\n[4.5, 3.5]\n\n\nونستطيع أن نجمع المجموعات كلها:\n\nprint(sum(totals))\n\n8.0\n\n\nأو نكتبها التعبير المختصر:\n\nprint(sum([sum(prices[fruits.index(item)] for item in basket) for basket in [basket1, basket2]]))\n\n8.0",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#ضرب-متجهين",
    "href": "chapters/05_sequences/solutions.html#ضرب-متجهين",
    "title": "حل المسائل",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\nيوصف ضرب المتجهين بالصيغة:\n\\[\n\\vec{u} \\cdot \\vec{v} = \\sum_{i=1}^{n} u_i v_i\n\\]\nأي أن كل عنصر من المتجه الأول يضرب في العنصر المناظر له في المتجه الثاني، ويُجْمَعُ ناتج ذلك كله.\n\nu = (1, 2, 3)\nv = (4, 5, 6)\n\nفهذا التوكيد الأول بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{v} &= [4, 5, 6] \\\\\n\\vec{u} \\cdot \\vec{v} &= (1)(4) + (2)(5) + (3)(6) \\\\\n                     &= 4 + 10 + 18 \\\\\n                     &= 32\n\\end{align*}\n\\]\nوهذا التوكيد الثاني بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{u} \\cdot \\vec{u} &= (1)(1) + (2)(2) + (3)(3) \\\\\n                     &= 1 + 4 + 9 \\\\\n                     &= 14\n\\end{align*}\n\\]\nنضم العناصر المتقابلة من المتجهين ونجمع حاصل ضربهما:\n\nresult = 0\nfor a, b in zip(u, v):\n    result += a * b\nprint(result)\n\n32\n\n\n\nresult = 0\nfor a, b in zip(u, u):\n    result += a * b\nprint(result)\n\n14",
    "crumbs": [
      "مسائل موضوعية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html",
    "href": "chapters/06_mapping/c_problems.html",
    "title": "في الجمع المرقَّم",
    "section": "",
    "text": "قاموس داخل قاموس\nإذا كان لديك قاموس متداخل كالتالي:\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\nالمطلوب أن تسحب من تفضيلات المستخدم المتغيرات التالية:",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرقَّم"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#قاموس-داخل-قاموس",
    "href": "chapters/06_mapping/c_problems.html#قاموس-داخل-قاموس",
    "title": "في الجمع المرقَّم",
    "section": "",
    "text": "theme\nsms\nآخر عنصر في: emails",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرقَّم"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#قائمة-قواميس",
    "href": "chapters/06_mapping/c_problems.html#قائمة-قواميس",
    "title": "في الجمع المرقَّم",
    "section": "قائمة قواميس",
    "text": "قائمة قواميس\nإليك هذه القائمة من القواميس:\n\ndata = [\n    {\n        'name': 'Ahmad Hamada',\n        'experiences': [\n            {\n                'company': 'Geo Space',\n                'start': '2038-01-01',\n                'end': '2039-01-01',\n                'role': 'Junior Software Engineer',\n            },\n            {\n                'company': 'Space Roots',\n                'start': '2039-01-01',\n                'end': '2041-01-01',\n                'role': 'Senior Software Engineer',\n            },\n        ],\n    },\n    {\n        'name': 'Belal Banana',\n        'experiences': [\n            {\n                'company': 'Banana Tech',\n                'start': '2041-01-01',\n                'end': '2042-01-01',\n                'role': 'Smoothie Operator',\n            },\n            {\n                'company': 'BugSquash Labs',\n                'start': '2042-02-01',\n                'end': '2043-08-01',\n                'role': 'Code Pest Control Specialist',\n            },\n            {\n                'company': 'Caffeinated Circuits Inc.',\n                'start': '2043-09-01',\n                'end': '2045-05-01',\n                'role': 'Espresso-Driven Engineer',\n            }\n        ]\n    },\n]\n\nوالمطلوب هو التالي:\n\nاستخرج اسم المرشح الثاني\nاستخرج اسم الشركة الثانية التي عمل فيها المشرح الأول\nللمرشح الأول، استخرج وقت البداية لأول شركة، ووقت النهاية لآخر شركة\nاستخرج قاموس الخبرة التي فيها القيمة: role: \"Espresso-Driven Engineer\"",
    "crumbs": [
      "مسائل موضوعية",
      "في الجمع المرقَّم"
    ]
  },
  {
    "objectID": "chapters/apps/random_problem.html",
    "href": "chapters/apps/random_problem.html",
    "title": "شبه العشوائية",
    "section": "",
    "text": "المسألة الأولى: توليد كلمة مرور\nأهداف التمرين:\nمكتبة العشوائية random هي من ضمن المكتبات المبنية في لغة بايثون.\nبينما تحل المسائل التالية، ستحتاج إلى البحث في صفحة المكتبة. جرب أن تضع في محرك البحث العبارة:\npython 3 docs random\nوستظهر في النتائج الأولى صفحة المكتبة في مراجع بايثون:\nولا أريد منك قراءة الصفحة كاملةً، ولذلك سأشير إلى بعض الأجزاء المهمة بالنسبة لنا الآن:\nاكتب إجراءً يقبل المعاملات التالية ليُنتِج كلمة مرور (Password):",
    "crumbs": [
      "مسائل مفتوحة",
      "شبه العشوائية"
    ]
  },
  {
    "objectID": "chapters/apps/random_problem.html#المسألة-الأولى-توليد-كلمة-مرور",
    "href": "chapters/apps/random_problem.html#المسألة-الأولى-توليد-كلمة-مرور",
    "title": "شبه العشوائية",
    "section": "",
    "text": "الطول\nالأحرف الصغيرة\nالأحرف الكبيرة\nالأرقام\nالحد الأدنى من الأرقام\nالرموز: !@#$%^&*\nالحد الأدنى من الرموز\n\ndef generate_password(length: int, ...) -&gt; str:\n    ...",
    "crumbs": [
      "مسائل مفتوحة",
      "شبه العشوائية"
    ]
  },
  {
    "objectID": "chapters/apps/random_problem.html#المسألة-الثانية-توليد-عبارة-مرور",
    "href": "chapters/apps/random_problem.html#المسألة-الثانية-توليد-عبارة-مرور",
    "title": "شبه العشوائية",
    "section": "المسألة الثانية: توليد عبارة مرور",
    "text": "المسألة الثانية: توليد عبارة مرور\nاكتب إجراءً آخر يقبل المعاملات التالية ليُنتِج عبارة مرور (Passphrase)، بحيث تكون سهلة الحفظ على البشر:\n\nعدد الكلمات\nفاصل الكلمات\nتكبير الحرف الأول من كل كلمة\nتضمين رقم\n\ndef ...",
    "crumbs": [
      "مسائل مفتوحة",
      "شبه العشوائية"
    ]
  },
  {
    "objectID": "chapters/apps/sentiment_analysis_problem.html",
    "href": "chapters/apps/sentiment_analysis_problem.html",
    "title": "تحليل المشاعر",
    "section": "",
    "text": "تحليل المشاعر (Sentiment Analysis) هو فرع من فروع معالجة اللغة الطبيعية (NLP) المندرجة تحت الذكاء الاصطناعي (AI) يهدف إلى تصنيف النصوص المكتوبة من جهة المشاعر المعبر عنها: إيجابية 😀 أو سلبية 😡 أو محايدة 😐️.\nوغالباً ما يطبَّق لأتمتة معرفة الرأي العام على المنتجات بشكل مباشر في استطلاعات الرأي، أو بشكل غير مباشر من التعليقات على وسائل التواصل.\nمهمتنا: بناء نموذج إحصائي مبني على قوائم كلمات مصنَّفة مُسبقًا.\nلدينا ثلاثة ملفات:\n\nالأول يحوي تغريدات: tweets.txt\nالثاني يحوي كلمات إيجابية: words_positive.txt\nالثالث يحوي كلمات سلبية: words_negative.txt",
    "crumbs": [
      "مسائل مفتوحة",
      "تحليل المشاعر"
    ]
  },
  {
    "objectID": "chapters/apps/sentiment_analysis_solution.html",
    "href": "chapters/apps/sentiment_analysis_solution.html",
    "title": "الحل",
    "section": "",
    "text": "تحليل المشاعر (Sentiment Analysis) هو فرع من فروع معالجة اللغة الطبيعية (NLP) المندرجة تحت الذكاء الاصطناعي (AI) يهدف إلى تصنيف النصوص المكتوبة من جهة المشاعر المعبر عنها: إيجابية 😀 أو سلبية 😡 أو محايدة 😐️.\nوغالباً ما يطبَّق لأتمتة معرفة الرأي العام على المنتجات بشكل مباشر في استطلاعات الرأي، أو بشكل غير مباشر من التعليقات على وسائل التواصل.\nمهمتنا: بناء نموذج إحصائي مبني على قوائم كلمات مصنَّفة مُسبقًا.\nلدينا ثلاثة ملفات:\n\nالأول يحوي تغريدات: tweets.txt\nالثاني يحوي كلمات إيجابية: words_positive.txt\nالثالث يحوي كلمات سلبية: words_negative.txt\n\nنريد تصنيف التغريدات بناءً على عدد الكلمات الإيجابية والسلبية فيها.\n\nfrom pathlib import Path\n\ndata_dir = Path('../../datasets/tweets')\n\nبعد النظر في شكل الملفات. يتبين لنا أن السطر الواحد يحتوي على “شيء” واحد. وبالتالي سنقسم البيانات على كل سطر.\nونلاحظ أيضًا وجود أسطر خاوية، يجب التخلص منها.\n\ndef read_lines(file_path: Path) -&gt; list[str]:\n    \"\"\"skips empty lines and converts to lowercase\"\"\"\n    result = []\n    with open(file_path, 'r') as file:\n        for line in file:\n            x = line.strip()\n            if len(x) &gt; 0:\n                x = x.lower()\n                result.append(x)\n    return result\n\nنستدعي الإجراء لقراءة الملفات الثلاث:\n\ntweets = read_lines(data_dir / 'tweets.txt')\npositive_words = read_lines(data_dir / 'words_positive.txt')\nnegative_words = read_lines(data_dir / 'words_negative.txt') \n\n\nfor i, tweet in enumerate(tweets):\n    print(i, tweet)\n\n0 أشعر بامتنان عميق للأشخاص الرائعين في حياتي! كل يوم معهم هو هدية جميلة\n1 الزهور المتفتحة تملأ المكان بألوانها الزاهية وعطرها الفواح! والعصافير تغرد بأجمل الألحان تحت أشعة الشمس الدافئة! يوم مثالي بكل تفاصيله\n2 الرجل العجوز قدوة في العطاء والكرم! يسعد دائماً بمساعدة الآخرين ويترك أثراً طيباً في كل من حوله! محبوب من الجميع لطيبة قلبه\n3 أتمنى لكم جميعاً يوماً مشرقاً مليئاً بالإنجازات والنجاحات! متحمس جداً لرؤية ابتساماتكم السعيدة!\n4 متحمس جداً للتحديات الجديدة! كل يوم فرصة للتعلم والنمو والتطور!\n5 تعذبت اليوم برحلة مزعجة في طريقي، رأيت مناظر مقرفة من حولي وأنا أتحمل ضجيج الطبيعة المزعجة\n6 صباح سيئ! استيقظت متأخراً وشربت فنجان قهوة مر. متوتر وقلق من لقاء زملائي المزعجين في العمل!\n7 أصوات الحياة من حولي تملأني إرهاقاً! أتعذب بالعمل من المنزل وأشعر بالملل والإحباط!\n8 قضيت أمسية متعبة مع أصدقائي المزعجين! تشاجرنا كثيراً وتذكرنا أسوأ الذكريات! أشعر بالحزن والضيق من وجودهم في حياتي!\n\n\n\nfor p in positive_words:\n    print(p)\n\nممتن\nامتنان\nرائع\nجميل\nهدية\nزاهية\nفواح\nأجمل\nدافئة\nمثالي\nقدوة\nعطاء\nكرم\nيسعد\nمساعدة\nطيب\nمحبوب\nمشرق\nإنجازات\nنجاحات\nمتحمس\nابتسامات\nسعيدة\nتعلم\nنمو\nتطور\nفرصة\nسعيد\n\n\n\nfor n in negative_words:\n    print(n)\n\nتعذب\nمزعج\nمقرف\nضجيج\nسيئ\nمتأخر\nمر\nمتوتر\nقلق\nإرهاق\nأتعذب\nملل\nإحباط\nمتعب\nتشاجر\nأسوأ\nحزن\nضيق\nمزعجين\nمتضايق\nمرهق\nفائت\nغير مرتاح\nوحيد\nحزين\n\n\nالآن نقوم بتصنيف التغريدات:\n\ndef classify(text: str) -&gt; (int, int):\n    \"\"\"Returns the number of positive and negative words in the text\"\"\"\n    \n    positive_count = 0\n    for word in positive_words:\n        if word in text:\n            positive_count += 1\n    \n    negative_count = 0\n    for word in negative_words:\n        if word in text:\n            negative_count += 1\n    \n    return positive_count, negative_count\n\nassert classify('أنا سعيد') == (1, 0)\nassert classify('أنا حزين') == (0, 1)\nassert classify('سعيد حزين اليوم') == (1, 1)\nassert classify('اذهب إلى الدكان') == (0, 0)\n\nنستدعي الإجراء على التغريدات، ونفرز النتائج في ثلاثة قوائم:\n\npositive_tweets = []\nnegative_tweets = []\nneutral_tweets = []\nfor tweet in tweets:\n    pos, neg = classify(tweet)\n    score = pos - neg\n    print(f'-{neg} +{pos} = {score:+}')\n    if score &gt; 0:\n        positive_tweets.append((tweet, score))\n    elif score &lt; 0:\n        negative_tweets.append((tweet, score))\n    else:\n        neutral_tweets.append((tweet, score))\n\n-0 +4 = +4\n-0 +5 = +5\n-0 +7 = +7\n-0 +7 = +7\n-0 +5 = +5\n-4 +0 = -4\n-7 +0 = -7\n-5 +0 = -5\n-7 +0 = -7\n\n\nنعرض التغريدات بحسب التصنيف مرتبة بقوة التصنيف من الأعلى إلى الأسفل:\n\nprint('positive_tweets:')\nfor tweet, score in sorted(positive_tweets, key=lambda x: x[1], reverse=True):\n    print(f'{score:+} {tweet}')\n\npositive_tweets:\n+7 الرجل العجوز قدوة في العطاء والكرم! يسعد دائماً بمساعدة الآخرين ويترك أثراً طيباً في كل من حوله! محبوب من الجميع لطيبة قلبه\n+7 أتمنى لكم جميعاً يوماً مشرقاً مليئاً بالإنجازات والنجاحات! متحمس جداً لرؤية ابتساماتكم السعيدة!\n+5 الزهور المتفتحة تملأ المكان بألوانها الزاهية وعطرها الفواح! والعصافير تغرد بأجمل الألحان تحت أشعة الشمس الدافئة! يوم مثالي بكل تفاصيله\n+5 متحمس جداً للتحديات الجديدة! كل يوم فرصة للتعلم والنمو والتطور!\n+4 أشعر بامتنان عميق للأشخاص الرائعين في حياتي! كل يوم معهم هو هدية جميلة\n\n\n\nprint('negative_tweets:')\nfor tweet, score in sorted(negative_tweets, key=lambda x: x[1]):\n    print(f'{score:+} {tweet}')\n\nnegative_tweets:\n-7 صباح سيئ! استيقظت متأخراً وشربت فنجان قهوة مر. متوتر وقلق من لقاء زملائي المزعجين في العمل!\n-7 قضيت أمسية متعبة مع أصدقائي المزعجين! تشاجرنا كثيراً وتذكرنا أسوأ الذكريات! أشعر بالحزن والضيق من وجودهم في حياتي!\n-5 أصوات الحياة من حولي تملأني إرهاقاً! أتعذب بالعمل من المنزل وأشعر بالملل والإحباط!\n-4 تعذبت اليوم برحلة مزعجة في طريقي، رأيت مناظر مقرفة من حولي وأنا أتحمل ضجيج الطبيعة المزعجة\n\n\n\nprint('neutral_tweets:')\nfor tweet, score in neutral_tweets:\n    print(f'{score} {tweet}')\n\nneutral_tweets:",
    "crumbs": [
      "مسائل مفتوحة",
      "الحل"
    ]
  },
  {
    "objectID": "chapters/apps/ceasar_cipher_problem.html",
    "href": "chapters/apps/ceasar_cipher_problem.html",
    "title": "التشفير",
    "section": "",
    "text": "رسالة في استخراج المعمى\nالتعمية أو التشفير المُلغَّز أو الإلغاز (بالإنجليزية: Cryptography) هو فرع من علم التعمية يهتم بممارسة بعض التقنيات لتأمين عملية التواصل بوجود أشخاص أخرين والذين يسمون أعداء (adversaries). بصوره عامة، تهتم التعمية بإنشاء الأنظمة التي تمنع الأعداء أو العامة من قراءة الرسائل الخاصة. أي بوسائل تحويل البيانات (مثل الكتابة) من شكلها الطبيعي المفهوم لأي شخص إلى شكل غير مفهوم بحيث يتعذّر على من لا يملك معرفة سرية محددة معرفة فحواها.\nكان غايوس يوليوس قيصر (44 ق.م) يواجه خطر تسرب المعلومات في رسائله العسكرية في حال وقعت رسائله في أيدي العدو، فابتكر وسيلة بسيطة لإخفاء مضمونها: كان يُبدل كل حرف في النص بحرف آخر يليه بعدد معين من الخانات هذه الطريقة أصبحت تُعرف اليوم بـ شيفرة قيصر (Caesar Cipher).\nفإذا كان مقدار الإزاحة 3 مثلاً يصير:\nوأما الحروف الأخيرة فتدور، فيكون:\nومهمتنا تطبيقها بخوارزمية تأخذ نصًّا وتعميه.\nأولاً نعرف الحروف الكبيرة والصغيرة:\nتذكر أن لدينا في بايثون الفعل: str.index(sub: str) -&gt; int حيث يأخذ هذا الفعل جُزءًا نصيًّا ويأتي على النص من أوله إلى آخر باحثًا عن موضعه. ونحن سنستعمل ذلك في البحث عن موضع الحرف فسيكون على النحو التالي:\nوالأمر الآخر الذي سيفيدنا في تدوير الأرقام هو:\nالحسابيات المقاسية (Modular Arithmetic) تتحرك فيه الأرقام بالجمع والضرب ونحوه بحيث تلتف الأرقام حول بعضها البعض عند الوصول إلى قيمة معينة، تسمى القياس (Modulus).\nوهذه العملية في بايثون هي % وتعبر عن باقي القسمة:\nوالآن نعرف الدالة التي ستأخذ حرفًا (char) ومقدار الإزاحة (shift) لتعيد الحرف البديل عنه بعد الإزاحة.\nنختبر الدالة ببعض التوكيادت:\nأما دالة عكس التعمية، فهي ببساطة تعكس الإزاحة بطرح الرقم بعد جمعه.\nفأما دالة استخراج المعمى، فنريدها أن تكون فعلاً تعكِس، ولذلك سنستعمل التوكيد بتمرير المعمة لعكسه مباشرة بهذه الطريقة:\nوالآن بعد أن تأكدنا من عمل ذلك على مستوى الحرف الواحد، نريد أن نأخذ النص كاملاً فنعميه:\nأما عكس التعمية فباستعمال decode بدلاً من encode بمثل ما تقدَّم:\nوالآن نريد أن نختبر، ولذلك سنستعين بموقع تفاعلي قد تم فيه عمل ذلك قبلنا، وهو موقع: cryptii.com فنأخذ النص ونستعمله ونتأكد أن ما نخرج به نفس ما خرجوا به:\nأخيرًا نستعمل ذلك بعد أن تأكدنا من صحته كاملاً:\nعهد الخليفة المأمون إلى الكندي، وهو أبو يُوسُفَ يَعْقُوبُ بنُ إِسْحاقَ الكِنْدِيُّ (185- 256 هـ / 801- 873 م) بإدارة بيت الحكمة، وكان ذلك بعد إتمام دراسته، حيث بدأ العمل في ترجمة المخطوطات اليونانية لأرسطو وغيره من الفلاسفة إلى اللغة العربية. واجه الكندي أول مرة خلال عمله الحاجة إلى استخراج النصوص المعماة، حيث كانت بعض المخطوطات التي كان عليه ترجمتها معماة.\nقدم الكندي جدولاً بالتكرارات المطلقة لحروف الأبجدية العربية، والتي حسبها في عينة من سبع أوراق من النص.\nملاحظة: لم يشر المؤلف إلى تكرارات حروف الشين والضاد والخاء، مع الإشارة إلى مكانها في الجدول، مرتبة حسب الترتيب التنازلي للتكرارات.\nيصف المؤلف طريقة استخراج المعمى التكراري على النحو التالي:",
    "crumbs": [
      "مسائل مفتوحة",
      "التشفير"
    ]
  },
  {
    "objectID": "chapters/apps/ceasar_cipher_problem.html#المسألة",
    "href": "chapters/apps/ceasar_cipher_problem.html#المسألة",
    "title": "التشفير",
    "section": "المسألة",
    "text": "المسألة\nاكتب خوارزمية استخراج المعمى، كما بينها الكندي. وذلك يعني أننا لو جئنا بنصٍّ معمَّى بشفرة قيصر ولا تعلم مقدار الإزاحة، فإنك تستطيع أعادة النص الأصلي.",
    "crumbs": [
      "مسائل مفتوحة",
      "التشفير"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html",
    "href": "chapters/02_numbers/a_numbers.html",
    "title": "ملحق A — الأرقام",
    "section": "",
    "text": "الحساب والمقارنة\nشجرة أنواع الأرقام في بايثون:\nالإجراءات العامة المتعلقة بنوع العدد:\nللمزيد راجع صفحة المكتبة الأساسية لوحدات الأرقام والرياضيات.\nالأعداد هي الحجر الأساس في أي برنامج. بل يُبنى عليها فهم البرنامج للنصوص المكتوبة والأصوات والصور وجميع أنواع البيانات. ولذلك وجب معرفة أساسياتها.\nملاحظة: كل ما بعد علامة # يعتبر تعليقًا يتجاهله الحاسب ولا يفسره. فنستخدمه للملاحظات والشرح في ثنايا القطعة البرمجية.\nx = 5\ny = 10\n\nprint(x + y) # الجمع\nprint(x - y) # الطرح\nprint(x * y) # الضرب\nprint(x / y) # القسمة\nprint(x % y) # باقي القسمة\nprint(x ** y) # الأس\n\n15\n-5\n50\n0.5\n5\n9765625\nالمقارنة بين الأعداد:\nx = 5\ny = 10\n\nprint(x == y) # التطابق\nprint(x != y) # الاختلاف\nprint(x &gt; y) # أكبر\nprint(x &lt; y) # أصغر\nprint(x &lt;= y) # أصغر أو يساوي\nprint(x &gt;= y) # أكبر أو يساوي\n\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "href": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "title": "ملحق A — الأرقام",
    "section": "ترتيب العمليات",
    "text": "ترتيب العمليات\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\nإليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه. ولاحظ أننا نستعمل جملة التوكيد (assert) التي تسكُت إن كان الشيء الذي أمامها جملة منطقية صحيحة؛ وإلا فهي تظهر رسالة خطأ. وسترى أننا نستعملها بكثرة لتقرير لوازم ما نبينه في الدرس:\n\nassert 3 + 2 * 5 == 13\nassert (3 + 2) * 5 == 25\n\n\nassert 8 - 4 / 2 == 6\nassert (8 - 4) / 2 == 2\n\n\nassert 2 ** 3 * 4 == 32\nassert (2 ** 3) * 4 == 32",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "href": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "title": "ملحق A — الأرقام",
    "section": "التعيين النسبي",
    "text": "التعيين النسبي\nكثيرًا ما نريد زيادة العدد أو إنقاصه؛ لذلك وضعت بايثون ما يسمى التعيين النسبي (Augmented Assignment). فجمل التعيين التالية متكافئة:\n\nx = x + 1 تعادل x += 1\nx = x - 1 تعادل x -= 1\nx = x * 2 تعادل x *= 2\nx = x / 2 تعادل x /= 2\n\nجرب النص البرمجي أدناه لترى النتيجة:\n\ni = 0\ni = i + 1\ni += 1\nprint(i)\n\n2\n\n\nالتعيين المتعدد (Multiple Assignment):\n\nstart, end = -5, 10\nleft, middle, right = 3, 5, 7",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات-math",
    "href": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات-math",
    "title": "ملحق A — الأرقام",
    "section": "وحدة الرياضيات (math)",
    "text": "وحدة الرياضيات (math)\n\nimport math\n\nx = 5.4\n\nكل هذه الطرق الثلاث يتم فيها حساب الأس:\n\nالأولى pow فعل مبني\nالثانية math.pow فعل من وحدة الرياضيات\nالثالثة x ** 2 عن طريق العامل **\n\n\\[\nx^2 = x \\times x\n\\]\n\nassert(\n    pow(x, 2) ==\n    math.pow(x, 2) ==\n    x ** 2 ==\n    x * x\n)\n\nوكذلك الجذر التربيعي:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\n\nالأولى math.sqrt فعل من وحدة الرياضيات\nالثانية x ** 0.5 عن طريق العامل **\n\n\nassert (\n    math.sqrt(x) ==\n    x ** 0.5\n)\n\nتقريب لأقرب عدد صحيح أصغر:\n\\[\n\\text{floor}(x) = \\lfloor x \\rfloor\n\\]\n\nmath.floor(5.4)\n\n5\n\n\nتقريب لأقرب عدد صحيح أكبر:\n\\[\n\\text{ceil}(x) = \\lceil x \\rceil\n\\]\n\nmath.ceil(5.4)\n\n6\n\n\nحذف ما بعد الفاصلة:\n\nmath.trunc(5.4)\n\n5\n\n\nتقريب إلى رقمين بعد الفاصلة:\n\nround(5.436, 2)\n\n5.44\n\n\nملاحظة: الإجراء الأخير round ليس مستوردًا من math وإنما هو مُضمَّن في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "href": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "title": "ملحق A — الأرقام",
    "section": "مجموعة الأعداد",
    "text": "مجموعة الأعداد\nأما التعامل مع المجموعات (كمجموعة الأعداد) فسيأتي في باب المجموعات المرتبة. لكننا نعرض لمثال بسيط للتعامل مع المجموعات العددية:\n\nxs = [10, 20, 30, 40, 50]\n\nتوفر بايثون الدوال التالية للمجموعة العددية:\n\nالطول (عدد العناصر): len (من كلمة length)\nمجموع العناصر: sum\nالعنصر الأكبر: max\nالعنصر الأصغر: min\n\n\nprint('length:', len(xs))\nprint('total:', sum(xs))\nprint('average:', sum(xs) / len(xs))\nprint('maximum:', max(xs))\nprint('minimum:', min(xs))\n\nlength: 5\ntotal: 150\naverage: 30.0\nmaximum: 50\nminimum: 10\n\n\n\nالإحصاء\nونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:\n\nالمتوسط الحسابي: statistics.mean\nالوسيط: statistics.median\nالمنوال: statistics.mode\nالانحراف المعياري: statistics.stdev\n\n\nimport statistics\n\nxs = [\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20,\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20\n]\n\nprint('mean:', statistics.mean(xs))\nprint('median:', statistics.median(xs))\nprint('mode:', statistics.mode(xs))\nprint('standard deviation:', statistics.stdev(xs))\n\nmean: 20.785714285714285\nmedian: 20.5\nmode: 20\nstandard deviation: 1.8126539343499315",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "href": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "title": "ملحق A — الأرقام",
    "section": "أنواع العدد في بايثون",
    "text": "أنواع العدد في بايثون\n\nالعدد الصحيح (int)\nالقيمة المنطقية (bool)\nالعدد العشري (float)\nالعدد المركب (complex)\n\nصفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالإجراء فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.\nفالتمثيل الداخلي للأعداد له أثر:\n\nفي مساحة التخزين\nدقة العدد؛ وبالتالي صحة الحساب\nسرعة الحساب\n\nلكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.\n\nالعدد الصحيح (int)\nالوظيفة: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك\n\nage = 20\nlevel = 3\nindex = -2\nstart, end = -5, 10\nleft, middle, right = 3, 5, 7\n\nيؤتى بالإجراء type لمعرفة نوع المتغير:\n\nassert int == type(age) \nassert int == type(level) \nassert int == type(index) \nassert int == type(start) == type(end)\nassert int == type(left) == type(middle) == type(right)\n\nالمجال: نقصد بالمجال هو أعلى قيمة ممكنة وأقل قيمة ممكنة للنوع. فنوع العدد الصحيح (int ويرمز له بالرياضي \\(\\mathbb{Z}\\)) هو في واقع الحواسيب محكوم بعدد الخانات (Bits) التي يتم استعمالها في تمثيله. ورغم أن بايثون تخفي عنا عدد الخانات؛ إلا أنها تتعامل مع هذا الواقع، ولذلك وجب معرفته:\n\n8-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^7 \\leq x &lt; 2^7\\} = \\{-128, \\ldots, 127\\}\\) أي أن أقل عدد ممكن في 8 خانات: \\(-128\\) وأعلى عدد ممكن: \\(127\\). وهلم جرا.\n16-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{15} \\leq x &lt; 2^{15}\\}\\)\n32-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{31} \\leq x &lt; 2^{31}\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{63} \\leq x &lt; 2^{63}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{127} \\leq x &lt; 2^{127}\\}\\)\n\n\n\n\n\n\n\nملاحظة\n\n\n\n\n\nلاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)\n\n\n\n\n\nالقيمة المنطقية (bool)\nوهي مجموعة العددين: \\(\\{0, 1\\}\\) الذين يمثل لهما بالكلمتين: True و False وذلك لتبيين وظيفتهما المنطقية.\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nالوظيفة: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.\nنلجئ الكلام عنها إلى باب الشرط والتكرار.\n\n\nالعدد العشري (float)\nالوظيفة: تمثيل الكميات مثل المال، المسافة، والوقت\n\ndistance = 100.0\nprice = 10.5\ntime = 1.5\ntemperature = 36.6\ndifference = 0.001\n\nنفحص أنواعها:\n\nassert float == type(distance)\nassert float == type(price)\nassert float == type(time)\nassert float == type(temperature)\nassert float == type(difference)\n\nالمجال: يعبر الرمز \\(\\mathbb{R}\\) عن مجموعة الأعداد العشرية (float). وهي تتبع نظام التمثيل IEEE 754.\n\n32-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{31} \\leq x &lt; 2^{31}\\} = \\{-3.4 \\times 10^9, \\ldots, 3.4 \\times 10^9\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{63} \\leq x &lt; 2^{63}\\} = \\{-1.8 \\times 10^{19}, \\ldots, 1.8 \\times 10^{19}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{127} \\leq x &lt; 2^{127}\\} = \\{-1.2 \\times 10^{38}, \\ldots, 1.2 \\times 10^{38}\\}\\)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "href": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "title": "ملحق A — الأرقام",
    "section": "اختلاف نوع العدد",
    "text": "اختلاف نوع العدد\nإذا اختلف النوع تُقدَّرُ الترقيةُ للأشمل، وذلك بحسب ناتج العملية:\n\nجمع صحيح وعشري = عشري: int + float = float\nقسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): int / int = float\nالقسمة الصحيحة بين صحيح وصحيح = صحيح: int // int = int\n\nالمثال الأول: جمع عدد صحيح وعدد عشري:\n\na = 1 + 1.0\nprint(a)\nassert type(a) == float\n\n2.0\n\n\nالمثال الثاني: قسمة عدد صحيح على عدد عشري:\n\nc = 1 / 2\nprint(c)\nassert type(c) == float\n\n0.5\n\n\nالمثال الثالث: استعمال القسمة الصحيحة //:\n\nb = 9 // 2\nprint(b)\nassert type(b) == int\n\n4\n\n\nس: لماذا النتيجة 4؟\nج: لأن قسمة 9 على 2 تُنتِج 4.5 ولكن بايثون تقربها لأقرب عدد صحيح أصغر وهو 4؛ وذلك لأننا اخترنا القسمة الصحيحة بالعلامة // وليس القسمة العشرية بالعلامة /.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "ملحق A — الأرقام",
    "section": "الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "الفرق بين النوع العددي والنوع النصي للعدد\nتأمل المتغيرين\n\na = 50\nb = '50'\n\n\nالأول: عدد صحيح (int)\nالثاني: حرفان (str)\n\nنستعمل جمل التوكيد لبيان ذلك:\n\nassert type(a) == int\nassert type(b) == str\nassert type(a) != type(b)\n\nومقتضى ذلك: امتناع عملية الجمع: a + b\n\n'5' + 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 '5' + 5\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nبل يجب التحويل أولاً باستعمال الإجراء int الذي يفسر الأحرف كعدد صحيح:\n\na = 5\nb = '5'\n\nb = int(b)\n\nassert a + b == 10",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "href": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "title": "ملحق A — الأرقام",
    "section": "كتابة القيَم العددية",
    "text": "كتابة القيَم العددية\nالحروفيَّة (Literals) هي رموز للقيم لبعض الأنواع المدمجة. مثال: 42 هو حرفيُّ عدد صحيح و 3.14 هو حرفيُّ عدد عشري.\nوتخصيص الحرفيّ True للعدد 1 و False للعدد 0 ليس من قبيل الضرورة في اللغة وإنما من قبيل التسهيل (وفوق ذلك فإن بايثون تجعل له نوعًا خاصًّا وعمليات مصاحبة).\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nكذلك خصصت بايثون e أو E للترميز العلمي (وجاء الحرف e من كلمة: Exponent) المخصص للأعداد العشرية الكبيرة والصغيرة.\n\nassert 1e2 == 100\nassert 1e9 == 1E9\nassert 1e-4 == 0.0001\n\nويجوز استعمال الشرطة السفلية _ لفاصلة الألوف:\n\nassert 1_000_000 == 1000000\n\nوأما إن كنت تهتم بالتمثيل الثنائي أو الثماني أو الست عشري فذلك أيضًا له تعبيرات مخصصة:\n\n0b أو 0B للأرقام الثنائية\n0o أو 0O للأرقام الثمانية\n0x أو 0X للأرقام الست عشرية\n\nوإليك تطبيق ذلك:\n\nassert 0b1010 == 10\nassert 0o10 == 8\nassert 0x10 == 16\n\nوأخيرًا يمكن استعمال j أو J للأعداد المركبة:\n\nassert 1 + 2j == 2j + 1",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#خلاصة",
    "href": "chapters/02_numbers/a_numbers.html#خلاصة",
    "title": "ملحق A — الأرقام",
    "section": "خلاصة",
    "text": "خلاصة\nعرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.\nننتقل الآن لباب الشرط والتكرار حيث الجمل الشرطية والتعيين المشروط.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html",
    "href": "chapters/02_numbers/apps.html",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "",
    "text": "احسب مبلغ الزكاة\nلا يلزمنا اشتقاق هذه المعادلات؛ لكن نستعمل النتائج التي خرج بها أهل الرياضيات فنعوض هذه المتغيرات بالقيم التي نريد لنتحصل على الناتج.\nmoney = 100_000\n\nzakah1 = money * (1/4) * (1/10)\nzakah2 = money * 0.25 * 0.10\nzakah3 = money * 0.025\nzakah4 = money / 40\n\nprint(zakah1 == zakah2 == zakah3 == zakah4)\nprint(zakah4)\n\nTrue\n2500.0\nوكم يكون الباقي بعد صرف الزكاة؟\nprint(money - zakah4)\n\n97500.0",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#احسب-مبلغ-الزكاة",
    "href": "chapters/02_numbers/apps.html#احسب-مبلغ-الزكاة",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "",
    "text": "أن تضرب المبلغ في حاصل ضرب الرُّبْع بالعُشر\nأو أن تقسم المبلغ على أربعين",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-مساحة-المكعب",
    "href": "chapters/02_numbers/apps.html#معادلة-مساحة-المكعب",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "معادلة مساحة المكعب",
    "text": "معادلة مساحة المكعب\nاكتب برنامجًا يحسب مساحة المكعب وفق المعادلة:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\n\nwidth = 3\nlength = 4\nheight = 5\n\narea = width * length * height\nprint(area)\n\n60",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "href": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "معادلة تحويل وحدة إلى وحدة أخرى",
    "text": "معادلة تحويل وحدة إلى وحدة أخرى\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n\nc = 32\nf = (9 / 5) * c + 32\n\nprint('Celsius:', c)\nprint('Fahrenheit:', f)\n\nCelsius: 32\nFahrenheit: 89.6",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "href": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "معادلة مساحة الدائرة",
    "text": "معادلة مساحة الدائرة\nاكتب برنامجًا لحساب مساحة الدائرة وفق المعادلة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nimport math\n\nradius = 5\narea = math.pi * radius**2\nprint(area)\n\n78.53981633974483\n\n\nملاحظة:\n\nتم استعمال radius ** 2 بدلاً من الإجراء math.pow(radius, 2) لتربيع العدد.\nكذلك يجوز استعمال x ** 0.5 بدلاً من الإجراء math.sqrt(x) لحساب الجذر التربيعي.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "href": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "معادلة طول الخط المستقيم بين نقطتين",
    "text": "معادلة طول الخط المستقيم بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#الزيادة",
    "href": "chapters/02_numbers/apps.html#الزيادة",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "الزيادة",
    "text": "الزيادة\nإذا كنت تقضي في القراءة 15 دقيقة في اليوم. ثم أحببت أن تزيد في كل أسبوع 5 دقائق. فكم ستكون الزيادة في 10 أسابيع؟\n\ntoday = 15\nincrease = 5\nweeks = 9\n\ntotal = today + (increase * weeks)\nprint(total)\n\n60\n\n\nأو لحساب كل أسبوع:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#النمو",
    "href": "chapters/02_numbers/apps.html#النمو",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "النمو",
    "text": "النمو\nإذا كان عدد الأرانب في السنة الأولى 100. وكان عدد الأرانب يزيد بنسبة 11.7% في اليوم. فكم سيكون عدد الأرانب في اليوم السابع؟\n\nrabbits = 100\ngrowth_rate = 0.117\ndays = 7\n\ntotal = rabbits * (1 + growth_rate) ** days\nprint(total)\n\n216.9562730596121\n\n\nأو لحساب كل يوم:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#نسبة-التغير",
    "href": "chapters/02_numbers/apps.html#نسبة-التغير",
    "title": "ملحق B — تطبيقات في الأرقام",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كان معدل قراءتك في الأسبوع الثاني 15 دقيقة، وكان معدل قراءتك في الأسبوع الأول 10 دقائق، فكم نسبة الزيادة في معدل قراءتك؟\n\nweek1 = 10\nweek2 = 15\n\nincrease_ratio = (week2 - week1) / week1\nprint(increase_ratio * 100, '%')\n\n50.0 %",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>تطبيقات في الأرقام</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/control_flow.html",
    "href": "chapters/03_control_flow/control_flow.html",
    "title": "ملحق C — توالي الأوامر",
    "section": "",
    "text": "جملة التعيين المشروط\nتستطيع في بايثون أن تجعل جملة التعيين تأخذ قيمتها بحسب شرطٍ معين. مثلاً:\nage = 18\nstatus = 'adult' if age &gt; 14 else 'child'\n\nprint(status)\n\nadult\nوهذه شجرة التعيين المشروط:\nوهذا مكافئ للنص البرمجي التالي:\nage = 18\n\nif age &gt; 14:\n  status = 'adult'\nelse:\n  status = 'child'\n\nprint(status)\n\nadult\nويحصل تسلسل التعيين المشروط بالصيغة التالية:\nscore = 75\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\"\nprint(grade)\n\nC",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/control_flow.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/control_flow.html#جملة-التعيين-المشروط",
    "title": "ملحق C — توالي الأوامر",
    "section": "",
    "text": "flowchart TD\n    IF{{if age &gt; 14}}\n    IF -- False --&gt; S2[\"status = 'child'\"]\n    IF -- True --&gt; S1[\"status = 'adult'\"]\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0 color:red;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n  S1[\"score = 75\"] --&gt; IF1\n  IF1{{if score &gt;= 90}} -- True --&gt; A[\"grade = 'A'\"]\n  IF1 -- False --&gt; IF2{{if score &gt;= 80}} -- True --&gt; B[\"grade = 'B'\"]\n  IF2 -- False --&gt; C[\"grade = 'C'\"]\n  \n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 2,4 color:red;",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/control_flow.html#تضمين-الجمل-الشرطية",
    "href": "chapters/03_control_flow/control_flow.html#تضمين-الجمل-الشرطية",
    "title": "ملحق C — توالي الأوامر",
    "section": "تضمين الجمل الشرطية",
    "text": "تضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\nوهذا تصويرها:\n\n\n\n\n\n\nflowchart TD\n  IF1{{if condition_1}}\n  IF1 -- False --&gt; ELSE1\n  IF1 -- True --&gt; IF2{{if condition_2}}\n  IF2 -- False --&gt; code_2\n  IF2 -- True --&gt; code_1\n  ELSE1[code_3]\n\n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nننبه مرة أخرى أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\nمثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+\n\n\nوهذا تصوير له:",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/control_flow.html#التكرار",
    "href": "chapters/03_control_flow/control_flow.html#التكرار",
    "title": "ملحق C — توالي الأوامر",
    "section": "التكرار",
    "text": "التكرار\nحلقة التكرار: هي الرجوع بالتنفيذ لجملة سابقة (غالبًا تكون سطرًا سابقًا) وذلك يحصل عددًا من المرات أو معلَّقًا بشرط.\nفللتكرار طريقتان:\n\nسرد مكرر (for): حيث يعيَّن متغير التكرار لكل عنصر في المكرر، واحدًا تلوَ الآخر. (وسيأتي ذكره في باب الجمع المرتب)\nالتكرار بشرط (while): حيث يستمر التكرار مادام الشرط متحققًا. (وهو موضوع هذا القسم)\n\n\nالتكرار بشرط\nنبدأ بالتكرار بالطريقة غير المحددة، وهي جُملة تبدأ بالكلمة while على النحو التالي. كأنها if متكررة إلى حين تخلُّف الشرط (أن يصبح False). وإن لم يتحقق الشرط أصلاً فلا ينفذ القطعة المضمَّنة أصلا:\nwhile &lt;boolean expression&gt;:\n    &lt;code&gt;\n\n\n\n\n\n\nflowchart TD\n  WHILE{{while condition}}\n  WHILE -- False --&gt; END\n  WHILE -- True --&gt; S1[code] --&gt; WHILE\n  \n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\nمثال:\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n3\n4\nDone\n\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; S3[\"Done\"]\n  WHILE -- True --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\nلنقم بتتبع الخطوات عندما تكون i = 0:\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\nوهذا تصوير لسير الإجراءات لنفس النص البرمجي. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الإجراءية:\n\n\nلاحظ أن نسيان جملة الزيادة (i += 1) يجعل الشرط دائمًا صحيحًا، فيدور البرنامج في حلقة لا نهيائة ولا يخرج أبدًا. ويعتبر هذا خطأ برمجيًّا يتعذر على البرنامج التعامل معه بنفسه؛ بل يجب على المبرمج أن يكتشفه. وسيأتي الكلام عن أنواع الأخطاء في البرمجة في باب الخطأ.\n\n\nالخروج من الحلقة\n\nتستخدم كلمة break لإيقاف عملية التكرار كلها.\nتستخدم كلمة continue للانتقال إلى الكرة التالية متخطيةً بقية الخطوات في الكرة الحالية.\n\nأولاً نمثل لاستعمال جملة break على النحو التالي:\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- break --&gt; Done\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,4 color:red;\n\n\n\n\n\n\n\n\n\nوهذا مثال لاستخدام عبارة continue للتخطي:\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- True --&gt; S3[\"i += 1\"]\n  S3 -- continue --&gt;  WHILE\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,5 color:red;\n  linkStyle 4 color:blue;\n\n\n\n\n\n\n\n\nأما جملة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط، ولا يتوقف الخارجي. وهذا مثال:\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone\n\n\nوهذا تصويرها:\n\n\n\n\n\n\nflowchart TD\n  INIT1[\"i = 0\"] --&gt; WHILE1\n  WHILE1{{\"while i &lt; 3\"}}\n    S3[\"i += 1\"] --&gt; WHILE1\n    WHILE1 -- True --&gt; INIT2[\"j = 0\"] --&gt; WHILE2\n    WHILE2{{\"while j &lt; 3\"}}\n      WHILE2 -- True --&gt; IF1{{\"if i == 1\"}} -- break --&gt; WHILE1\n      IF1 -- False --&gt; S1[\"print(i, j)\"] --&gt; S2[\"j += 1\"] --&gt; WHILE2\n    WHILE2 -- False --&gt; S3\n\n  style WHILE1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style WHILE2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 5,8 color:red;\n\n\n\n\n\n\n\n\n\n\n\nالملحق بنعم ولا\nتعتبر بايثون بعض القيَم تابعة للا (False) وهي:\n\nFalse\nNone\n0\n0.0\n''\n[]\n()\n{}\nset()\n\nوما عدا ذلك فيُلحق بنعم (True).\n\nif False or None or 0 or 0.0 or '' or [] or () or {} or set():\n    print('True')\nelse:\n    print('False')\n\nFalse",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html",
    "href": "chapters/03_control_flow/apps.html",
    "title": "ملحق D — تطبيقات في توالي الأوامر",
    "section": "",
    "text": "تسجيل الدخول\nلاحظ:",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>تطبيقات في توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "href": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "title": "ملحق D — تطبيقات في توالي الأوامر",
    "section": "",
    "text": "استخدم الإجراء input() لطلب اسم المستخدم (username) و كلمة المرور (password) من المستخدم وخزن كل منهما في متغير مناسب\nإذا كان اسم المستخدم هو \"admin\" وكلمة المرور هي \"abc123\"، اطبع: \"Welcome admin\"\nأو إذا كان اسم المستخدم هو \"backdoor\" وكلمة المرور هي \"let me in\"، اطبع: \"Nobody knows!\"\nخلاف ذلك، اطبع: \"Access denied!\"\n\nimport getpass\n\nusername = input(\"Enter your username: \")\npassword = getpass.getpass(\"Enter your password: \")\n\nmax_tries = 3\ntries = 0\n\nwhile tries &lt; max_tries:\n  if username == \"admin\" and password == \"abc123\":\n    print(\"Welcome admin\")\n    break\n  elif username == \"backdoor\" and password == \"let me in\":\n    print(\"Nobody knows!\")\n    break\n  else:\n    print(\"Access denied!\")\n    tries += 1\n\n\nوجود حلقة while لإعادة المحاولة ثلاث مرات فقط\nوجود جملة break لإنهاء الحلقة إذا تم التسجيل بنجاح\n\nلا توجد break في جزئية else الأخيرة وذلك لأن عدد المحاولات يزيد في كل مرة ليؤول الإجراء إلى انتفاء شرط الدوران",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>تطبيقات في توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "href": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "title": "ملحق D — تطبيقات في توالي الأوامر",
    "section": "حساب مجموع الأعداد المدخلة",
    "text": "حساب مجموع الأعداد المدخلة\nهذا البرنامج الصغير يأخذ مجموعة أعداد، واحدًا تلوَ الآخر، ويجمعها جميعًا.\ntotal = 0\n\nwhile True:\n  user_input = input(\"Enter a number: \")\n  if user_input == \"quit\":\n    break\n  x = int(user_input)\n  total += x\nprint(total)\nإليك شرحه بالتفصيل:\nتذكر: أن لكل متغير قيمة. وأن لكل قيمة نوعًا. وأن النوع يحدد ما يقبله المتغير من عمليات.\n\nنعين المتغير total = 0 لتجميع النتائج\nنستعمل حلقة لا نهائية: while True لأننا نريد أن يستمر البرنامج إلى أن يكتب المستخدم quit\nنطلب من المستخدم أن يدخل عددًا، ونضع ما أدخَل في متغير: user_input\nهذا المتغير نوعه: str (نصي) لأن الإجراء input() يعطينا قيمة نصية\nإن كان المدخل كلمة quit، نكسر الحلقة بـ: break\nوإلا:\n\nننشئ قيمة عددية من المتغير user_input باستخدام int(user_input) أو float(user_input) ونعيِّنُ النتيجة في متغير جديد: x\nنجمع العدد إلى الحاصل: total\nعندها نكسر الحلقة بكلمة: break",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>تطبيقات في توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#المكيف",
    "href": "chapters/03_control_flow/apps.html#المكيف",
    "title": "ملحق D — تطبيقات في توالي الأوامر",
    "section": "المكيف",
    "text": "المكيف\nتشغييل المكيف إن كانت درجة الحرارة أعلى من المرغوب، بشرط أن يكون المكيف يعمل:\n\nroom_temp = 30\ndesired_temp = 24\nac_functional = False\n\nif room_temp &gt; desired_temp:\n    if ac_functional:\n        print(\"Turning on AC.\")\n    else:\n        print(\"AC malfunction! Please repair.\")\n\nAC malfunction! Please repair.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>تطبيقات في توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "href": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "title": "ملحق D — تطبيقات في توالي الأوامر",
    "section": "برنامج تفاعلي",
    "text": "برنامج تفاعلي\nجرب انسخ هذا البرنامج واختبره بنفسك حتى تفهمه.\ninventory = 100\n\nwhile True:\n    print(\"Store Menu:\")\n    print(\"1. Buy Apples\")\n    print(\"2. Restock Apples\")\n    print(\"3. Exit\")\n\n    choice = input(\"Enter your choice: \")\n\n    if choice == \"1\":\n        quantity = int(input(\"Enter the quantity of fish to buy: \"))\n\n        if quantity &lt;= inventory:\n            inventory -= quantity\n            print(\"You bought\", quantity, \"fish. Remaining inventory:\", inventory)\n        else:\n            print(\"Insufficient stock. Please try again later.\")\n\n    elif choice == \"2\":\n        quantity = int(input(\"Enter the quantity of fish to restock: \"))\n        inventory += quantity\n        print(\"Restocked\", quantity, \"fish. New inventory:\", inventory)\n\n    elif choice == \"3\":\n        print(\"Exiting the store...\")\n        break\n\n    else:\n        print(\"Invalid choice. Please try again.\")",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>تطبيقات في توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "href": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "title": "ملحق D — تطبيقات في توالي الأوامر",
    "section": "حساب مضروب العدد",
    "text": "حساب مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots 1\n\\]\n\ni = 5\nj = i\nwhile j &gt; 1:\n  j -= 1\n  i *= j\nprint(i)\n\n120\n\n\nشرح للخطوات التنفيذية التفصيلية:\n\nأولاً، قم بتعيين المتغير i إلى العدد 5\nثانياً، قم بتعيين المتغير j إلى العدد 5\nثالثاً، استمر في الدوران إلى أن يصل j إلى القيمة 1\n\nفي كل دوران، قم بطرح 1 من j\nثم قم بضرب i بالقيمة الجديدة لـ j: المتحصل هو أن `i = i * (i - 1)\n\nأخيراً، قم بطباعة القيمة النهائية لـ i",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>تطبيقات في توالي الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html",
    "href": "chapters/08_procedural/a1_functions.html",
    "title": "ملحق E — الدالة",
    "section": "",
    "text": "تعدد المعطيات في استدعاء الإجراء\nالدالة (Function) قطعة نص برمجيّ لها اسم، يتم استدعاؤها بمعطيات مختلفة بحسب معاملاته. ويسمى الإجراء (Procedure) أو الروتين (Routine) أو البرنامج الفرعي (Sub-Program).\nونقول استدعي الدالة (Call) أو نفذه (Execute). ويسمى مكان القطعة التي قامت بالاستدعاء: موقع الاستدعاء (Call-site).\nفقد يأخذ الإجراء أكثر من معطى:\nوقد يأخذ معطىاً واحدًا لكنَّهُ يمثل مجموعة معطيات، لكونِه جَمعًا في نفسه (كالقائمة: list):\nوقد يكون عدد معطياته لا محدودًا:\nname = \"Adam\"\nage = 25\nprint(\"My name is\", name, \"and I'm\", age, \"years old\")\n\nMy name is Adam and I'm 25 years old\nفإن print قبلت خمسة عوامل:",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#تعدد-المعطيات-في-استدعاء-الإجراء",
    "href": "chapters/08_procedural/a1_functions.html#تعدد-المعطيات-في-استدعاء-الإجراء",
    "title": "ملحق E — الدالة",
    "section": "",
    "text": "نحو: round(x, n) مثل: round(10.259, 2) ينتج: 10.26.\nأو نحو: pow(x, y) لرفع العدد x إلى القوة y. مثل: pow(2, 3) ينتج: 8.\n\n\n\nنحو: sum(numbers) مثل: sum([1, 2, 3, 4, 5]) ينتج: 15.\nأو نحو: max(numbers) لأكبر عدد في القائمة. مثل: max([1, 2, 30, 4, 5]) ينتج: 30.\n\n\n\nنحو: print(*values). فعلامة النجمة (*) تشير لقبول عدد مطلق من العوامل. مثل:\n\n\n\n\nالنص: \"My name is\"\nقيمة المتغير: name\nالنص: \"and I'm\"\nقيمة المتغير: age\nالنص: \"years old\"",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#طلب-المساعدة",
    "href": "chapters/08_procedural/a1_functions.html#طلب-المساعدة",
    "title": "ملحق E — الدالة",
    "section": "طلب المساعدة",
    "text": "طلب المساعدة\nوقد عرفت أن طلب التنفيذ يكون بالقوسين بعد اسمه ()، وتوضَع المعطيات فيهما. ولدينا الإجراء help(func) يطلب مساعدة الإجراء المعيَّن، بلا أقواس، هكذا:\n\nhelp(sum)\n\nHelp on built-in function sum in module builtins:\n\nsum(iterable, /, start=0)\n    Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\n    When the iterable is empty, return the start value.\n    This function is intended specifically for use with numeric values and may\n    reject non-numeric types.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#شكلان-لاستدعاء-الإجراء",
    "href": "chapters/08_procedural/a1_functions.html#شكلان-لاستدعاء-الإجراء",
    "title": "ملحق E — الدالة",
    "section": "شكلان لاستدعاء الإجراء",
    "text": "شكلان لاستدعاء الإجراء\nوقد وضعت اللغات الكائنية (Object-oriented) مثل بايثون صياغة خاصَّةً: للإجراء المسند إلى الكائن. وبذلك يتحصل لدينا طريقتان كلتاهما تؤديان نفس المعنى:\n\nإسناد الإجراء للنوع: list.append(xs, 25)\nإسناد الإجراء للكائن: xs.append(25)\n\nومثاله أيضًا في الإجراء list.sort للترتيب وكذلك في list.append للإضافة:\n\nxs = [20, 10, 30, 40]\nys = [20, 10, 30, 40]\n\n\nlist.sort(xs)\nys.sort()\nprint(xs == ys)\n\nTrue\n\n\n\nlist.append(xs, 50)\nys.append(50)\nprint(xs == ys)\n\nTrue",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#نتيجة-الإجراء",
    "href": "chapters/08_procedural/a1_functions.html#نتيجة-الإجراء",
    "title": "ملحق E — الدالة",
    "section": "نتيجة الإجراء",
    "text": "نتيجة الإجراء\nلابد للإجراء -حتى يكون نافعًا- أن يكون له أثر. وإنما يحقق الإجراء تأثيرًا بإحدى طريقتين:\nأحدها: الرجوع بنتيجة لموضِع الاستدعاء؛ وذلك بجملة الرجوع (return). مثال ذلك:\n\ndef pow(x, y):\n    return x ** y\n\n\ny = pow(2, 3)\n\nوالأخرى: التغيير في مُعطىً قابل للتغيير (كالقائمة أو الملف). مثال ذلك:\n\ndef print_decorated(message: str, n: int):\n    print(\"=\" * n)\n    print(message)\n    print(\"=\" * n)\n\n\nprint_decorated(\"Salam alykom\", 15)\n\n===============\nSalam alykom\n===============\n\n\nوالكائنات قد يحصل فيها إحدى الأمرين لغرض ما.\nفالقائمة (list) هي مظنَّة التغيير.\nففي نحو: sorted(xs) فإن الإجراء يُنتِجُ نُسخةً معدَّلة، ولا يغير القائمة الأصلية؛ وذلك يتطلَّبُ مساحة إضافية في الذاكرة أثناء العمليَّة. وقد يكون هذا مرغوبًا في البرامج التي تحتاج لمتابعة التغييرات الحاصلة، حيث يتم الاحتفاظ بالنُّسَخ البينية.\n\nxs = [40, 20, 10, 30]\nys = sorted(xs)\nprint(xs, \"لم يعمل الإجراء في القائمة نفسها\")\nprint(ys, \"هي قائمة جديدة\")\n\n[40, 20, 10, 30] لم يعمل الإجراء في القائمة نفسها\n[10, 20, 30, 40] هي قائمة جديدة\n\n\nوأما في نحو: xs.sort() فإن الطريقة (.sort()) تغيِّرُ القائمة المُسندَة؛ فلا تحتاجُ لنسخ القائمة في الذاكرة للتعديل عليها.\n\nxs = [20, 10, 30, 40]\nxs.sort()\nprint(xs)\n\n[10, 20, 30, 40]",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#تمرير-المعطيات-بالاسم",
    "href": "chapters/08_procedural/a1_functions.html#تمرير-المعطيات-بالاسم",
    "title": "ملحق E — الدالة",
    "section": "تمرير المعطيات بالاسم",
    "text": "تمرير المعطيات بالاسم\nوقد تُعَيَّنُ المعطيات بأحد طريقتين:\n\nتعيين بالموضع: نحو: round(3.14159, 2)\nتعيين بالاسم: نحو: round(number=3.14159, ndigits=2) فلا يشترط فيه ترتيب المعطيات.\n\nويجوز استعمال الطريقتين معًا في نحو: list.sort(numbers, reverse=True) ويشترط فيه تقدم التعيين بالموضع ليكون في مكانه، ثم يتبعه التعيين بالاسم حيث لا يشترط الترتيب فيه.\nوفي التعريف تكون المعطيات كثيرة في الإجراء على النحو التالي:\n\ndef weather_condition(temperature, humidity, wind_speed):\n    if temperature &gt;= 30 and humidity &gt;= 60 and wind_speed &gt;= 10:\n        return \"Rainy\"\n    elif temperature &gt;= 20 and humidity &gt;= 50 and wind_speed &gt;= 5:\n        return \"Cloudy\"\n    elif temperature &gt;= 10 and humidity &gt;= 30 and wind_speed &gt;= 0:\n        return \"Sunny\"\n    return \"Normal\"\n\nويكون طلبها بالطريقتين كما تقدَّم، بالموضع أو بالاسم. ولاحظ أن التمرير بالاسم يجوز فيه تبديل الترتيب، وأما القيمة التي تمرر بالموضع فلا بد أن تكون في الموضع.\n\ncond = weather_condition(30, wind_speed=10, humidity=60)\n\nif cond == \"Rainy\":\n    print(\"Don't forget your umbrella!\")\n\nDon't forget your umbrella!",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#المعطيات-الجائزة",
    "href": "chapters/08_procedural/a1_functions.html#المعطيات-الجائزة",
    "title": "ملحق E — الدالة",
    "section": "المعطيات الجائزة",
    "text": "المعطيات الجائزة\nالأصل في المعطيات المعرَّفة الوجوب؛. فلو أهملت أحدها فإنك ستواجه بالخطأ:\n\ndef weather_condition(temperature, humidity, wind_speed):\n    pass\n\nweather_condition(30)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[14], line 4\n      1 def weather_condition(temperature, humidity, wind_speed):\n      2     pass\n----&gt; 4 weather_condition(30)\n\nTypeError: weather_condition() missing 2 required positional arguments: 'humidity' and 'wind_speed'\n\n\n\nتقول رسالة الخطأ (السطر الأخير) أن الإجراء يفتقد معطىيْن موضعيين إلزاميين، وهما: humidity و wind_speed.\nفلو أردنا أن يكون عمل الإجراء بحسب أحد المعطيات بالتعيين، على نحو:\n\nلو عينت السلزيوس فالتحويل لفهرنهايت: convert_temperature(celsius=32)\nلو عينت الفهرنهايت فالتحويل لسلزيوس: convert_temperature(fahrenheit=89.6)\n\nوإليك معادلة التحويل بين نوعيْ درجة الحرارة:\n\\[\nF = \\frac{9}{5} C + 32\n\\]\nفأي معطى نعرفه بقيمة افتراضية فإن بايثون تعتبره اختياريًّا، ولو بالقيمة العدميَّة None. فنعرِّفُ المعطيات بقيَم عدميَّة، ونفحص وجودها بالشرط is not None لنُعمِلَها أو نهملها:\n\ndef convert_temperature(celsius = None, fahrenheit = None):\n    if celsius is not None:\n        fahrenheit = (9 / 5) * celsius + 32\n        return fahrenheit\n    elif fahrenheit is not None:\n        celsius = (fahrenheit - 32) * (5 / 9)\n        return celsius\n\nنتأكد:\n\nassert convert_temperature(celsius=32) == 89.6\nassert convert_temperature(fahrenheit=89.6) == 32",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#نطاق-التسمية",
    "href": "chapters/08_procedural/a1_functions.html#نطاق-التسمية",
    "title": "ملحق E — الدالة",
    "section": "نطاق التسمية",
    "text": "نطاق التسمية\nومن خصائصها أن المتغيرات في الداخل لا تظهر للخارج.\n\ndef calculate_bmi(weight, height):\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\n\nفنتوقع وقوع خطأ هنا لأن bmi غير معرفة إلا في نطاق الإجراء:\n\nprint(bmi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 1\n----&gt; 1 print(bmi)\n\nNameError: name 'bmi' is not defined\n\n\n\nتقول رسالة الخطأ (السطر الأخير) أن المتغير bmi غير معرَّف. وهذا منطقي لأن النطاق الخارجي لا يعلم ما تكنه النطاقات الداخلية الخاصة بالإجراءات. وهو أمر مطلوب جدًّا ومرغوب في البرمجة. وذلك يعني أننا لن نتعب كثيرًا في اختيار الأسماء داخل كل إجراء، مخافة التعارض.\n\nمعطيات غير مصرح بها\nوعلى العكس فإن المعرَّفات الخارجة معروفة في الداخل؛ وذلك يعني أنها يمكن أن تعمل في الإجراء بشكل غير مباشر. أي أنها معطيات غير مصرَّح بها (هو: max_length في هذا المثال):\n\nmax_length = 8\n\ndef check_password_strength(password):\n    if len(password) &gt; max_length:\n        return \"strong\"\n    elif len(password) &gt; max_length // 2:\n        return \"medium\"\n    return \"weak\"\n\n\n\nمستويات نطاق التسمية\n\n\n\nمستويات نطاق التسمية\n\n\nمستويات النطاقات (Scopes) من الداخل إلى الخارج:\n\nالنطاق المحلي (Local Scope): المتغيرات المعرفة داخل إجراء.\nالنطاق المحيط (Enclosing Scope): المتغيرات المعرفة في إجراء يتحوي ذلك الإجراء.\nالنطاق العام (Global Scope): المتغيرات المعرفة خارج جميع الإجراءات.\nالنطاق المدمج (Built-in Scope): الإجراءات المدمجة في بايثون مثل print().\n\nنصيحة: اجعل الاستعمال تاليًا لأخص نطاق؛ تَسْلَم. فهو كاستعمال الضمائر في اللغة: لا نحب أن تبعُد عما أُبدلت عنه إذ ذلك مظنَّة الإبهام. لكن قد يكون من المعرَّفات ما هو ثابت ومعطىٌ به في كل مكان. فهو أشبه بالإعدادات أو الضبط للبرنامج كله. ومثل ذلك الأليق فيه أن يكون في نطاقٍ أعم.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#التصريح-بالأنواع",
    "href": "chapters/08_procedural/a1_functions.html#التصريح-بالأنواع",
    "title": "ملحق E — الدالة",
    "section": "التصريح بالأنواع",
    "text": "التصريح بالأنواع\nتسمح بايثون بعدم التصريح بأنواع المعاملات إلا أنه يجوز، وذلك على النحو التالي:\n\ndef add(x: int, y: int) -&gt; int:\n    result = x + y\n    return result\n\n\nوبهذا نعرف أن التصريح بنوع المتغيِّر يكون بعد النقطتين رأسيتين (:)\nوبعد السهم لنوع الناتج من الإجراء (-&gt;)\n\nومن الأنواع المبنيَّة في بايثون:\n\nint الأعداد الصحيحة، نحو: 10\nfloat الأعداد العشرية، نحو: 10.5\nstr وهي نوع النص، نحو: \"Salam\"\nlist قائمة وإن شئت تحديد نوع العنصر الواحد فيها؛ فإنك تضعه بين القوسين المربعين، نحو:\n\nlist[int]\nlist[float]\nlist[str]\n\n\nللاستزادة راجع: MyPy Type hints cheat sheet.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_functions.html#إطلاق-عدد-المعطيات",
    "href": "chapters/08_procedural/a1_functions.html#إطلاق-عدد-المعطيات",
    "title": "ملحق E — الدالة",
    "section": "إطلاق عدد المعطيات",
    "text": "إطلاق عدد المعطيات\nقد تتساءل كيف تعمل print وهي تأخذ عددًا لا محدودًا من المعطيات؟ حتى نجيب عن ذلك ننظر في عملية فك الأقواس وهي علامة النجمة * قبل المتغيِّر المشير لمجموعة، على النحو التالي:\n\nxs = [10, 20, 30]\nprint(xs)\nprint(*xs)\n\n[10, 20, 30]\n10 20 30\n\n\nلاحظ الفرق بين الطلب الأول والثاني:\n\nالأوَّل يطبع المتغير xs ككل، أي: كقائمة من ثلاثة أعناصر\nيُمرر واحدًا تلوَ الآخر للإجراء print بعد فك الأقواس كأنك كتبت: print(10, 20, 30)\n\nوحين تستعمل علامة النجمة في تعريف معاملات الإجراء، فإن أي معطى موضعي زائد عن العدد، يكونُ فيه كصفّ (وسيأتي الكلام عن الصف في باب الجمع المرتبة). وبالمثال يتضح المقال. وقد اصطُلح على تسميته args وهي اختصار كلمة Arguments:\n\ndef show(a, *args):\n    print(a)\n    print(type(args), args)\n    print('print:', *args)\n\nshow(1, 2, 3, 4, 5)\n\n1\n&lt;class 'tuple'&gt; (2, 3, 4, 5)\nprint: 2 3 4 5\n\n\nوكذلك العوامل المعيَّنة بالاسم، لكن بالنجمتين ** وتكون قاموسًا (وسيأتي الكلام عنه في باب المجموعة المرقمة) ومعنى الكلمة kwargs هو: Keyword Arguments:\n\ndef show(a, **kwargs):\n    print(a)\n    print(type(kwargs), kwargs)\n    print('print:', *kwargs)\n\nshow(a=1, b=2, c=3, d=4, e=5)\n\n1\n&lt;class 'dict'&gt; {'b': 2, 'c': 3, 'd': 4, 'e': 5}\nprint: b c d e\n\n\nوقد يجتمعان في نفس الإجراء *args و **kwargs نحو:\n\ndef show(x, y, *args, **kwargs):\n    print(x, y)\n    print(type(args), args)\n    print(type(kwargs), kwargs)\n\nshow(1, 2, 3, 4, 5, a=1, b=2, c=3)\n\n1 2\n&lt;class 'tuple'&gt; (3, 4, 5)\n&lt;class 'dict'&gt; {'a': 1, 'b': 2, 'c': 3}\n\n\nولا بد من تقديم الموضعية قبل الاسمية.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>الدالة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html",
    "href": "chapters/05_sequences/a_sequences.html",
    "title": "ملحق F — التسلسل",
    "section": "",
    "text": "الجمع (Collection)\nشجرة أنواع الجمع في بايثون بالتركيز على نوع التسلسل (بغض النظر عن أشقائه):\nflowchart BT\n    Container[&lt;b&gt;الحاوي&lt;/b&gt;&lt;br&gt;Container]\n    Sized[&lt;b&gt;المحجَّم&lt;/b&gt;&lt;br&gt;Sized]\n    Iterable[&lt;b&gt;القابل للكر&lt;/b&gt;&lt;br&gt;Iterable]\n    Sequence[&lt;b&gt;التسلسل&lt;/b&gt;&lt;br&gt;Sequence]\n    MutableSequence[&lt;b&gt;التسلسل المتغير&lt;/b&gt;&lt;br&gt;MutableSequence]\n    Collection[&lt;b&gt;الجمع&lt;/b&gt;&lt;br&gt;Collection]\n    Collection --&gt; Container\n    Collection --&gt; Sized\n    Collection --&gt; Iterable\n    Sequence --&gt; Collection\n    MutableSequence --&gt; Sequence\n    \n    list[&lt;b&gt;القائمة&lt;/b&gt;&lt;br&gt;&lt;code&gt;list&lt;/code&gt;]\n    list --&gt; MutableSequence\n\n    tuple[&lt;b&gt;الصف&lt;/b&gt;&lt;br&gt;&lt;code&gt;tuple&lt;/code&gt;]\n    tuple --&gt; Sequence\n    str[&lt;b&gt;النص&lt;/b&gt;&lt;br&gt;&lt;code&gt;str&lt;/code&gt;]\n    str --&gt; Sequence\n    bytes[&lt;b&gt;البايتات&lt;/b&gt;&lt;br&gt;&lt;code&gt;bytes&lt;/code&gt;]\n    bytes --&gt; Sequence\n    range[&lt;b&gt;المجال&lt;/b&gt;&lt;br&gt;&lt;code&gt;range&lt;/code&gt;]\n    range --&gt; Sequence\nلمزيد من التفاصيل راجع صفحة المكتبة الأساسية للأنواع المجردة للجموع.\nما يجري على القابل للكر (Iterable):\nإجراءات مبنيَّة تعمل على المكرَّرَات عمومًا؛ ومنها القائمة:\nراجع فصل أنواع المكررات (Iterator Types) في صفحة الأنواع المبنية.\nكثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، …إلخ من العمليات التي تعمل على جميع عناصر المجموعة.\nالجمع (Collection) كل حاوٍ ذي حجمٍ قابل للكر.\nوسنرمز للمفرد هنا بالمتغير x ولما يدل على الجمع بالمتغير c فيما يلي..\nويتفرع من الجمع ثلاثة أنواع رئيسية. والشكل في الأعلى يُظهر فقط نوع التسلسل، لأنه موضوع هذا الفصل. وهي:",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الجمع-collection",
    "href": "chapters/05_sequences/a_sequences.html#الجمع-collection",
    "title": "ملحق F — التسلسل",
    "section": "",
    "text": "الإجراء\nعمله\n\n\n\n\nlen(collection)\nعدّ العناصر\n\n\nmax(iterable)\nأكبر عنصر\n\n\nmin(iterable)\nأصغر عنصر\n\n\nsum(iterable)\nجمع العناصر\n\n\nsorted(iterable)\nنسخة مرتبة\n\n\nreversed(seq)\nنسخة معكوسة\n\n\n\n\n\n\n\n\nفكونه يقبل العضوية (طريقتها: __contains__): وسياقها x not in c يجعله من نوع الحاوي (Container)\nوكونه يقبل العد (طريقتها: __len__): وسياقها len(c) يجعله من نوع المحجَّم (Sized)\nوكونه يقبل الكر (طريقتها: __iter__): وسياقها for x in c يجعله من نوع القابل للكر (Iterable)\n\n\n\nالتسلسل: Sequence\nالمجموعة: Set\nالدالة: Mapping",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#التسلسل-sequence",
    "href": "chapters/05_sequences/a_sequences.html#التسلسل-sequence",
    "title": "ملحق F — التسلسل",
    "section": "التسلسل (Sequence)",
    "text": "التسلسل (Sequence)\n\n\n\nتسلسل أحرف\n\n\nالتسلسل (Sequence) جمع مرتب.\n\nجمع: يعني قبوله الإجراءات الثلاثة السابق ذكرها (العضوية والعد والكر).\nمرتب: يعني أن لكل عنصرٍ موضعًا بالنسبة لبدايته.\n\nويبدأ ترقيم المواضع بالنسبة لبداية التسلسل لذلك نجعل للعنصر الأوَّل الموضِع 0، إذ نسبةُ ذلك لبداية التسلسل. ويكون موضع الثاني 1 بالنسبة لبداية التسلسل، وللثالث 2، وهكذا إلخ.\nومن أمثلة المجموعات المرتبة:\n\nقائمة الرسائل، إذ هي مرتبة بالوقت واحدة تتلو الأخرى\nمجموعة الحروف في اللغة العربية، إذ تبدأ بالألف وتنتهي بالياء وما بينهما كلٌّ له ما قبله وما بعده\nقائمة الانتظار التي تعطي الأولويَّة لمن يأتي أوَّلاً للدخول على الطبيب\n\nوالمشترك في هذه الأمثلة الثلاثة: أن العناصر لها موضِعٌ بالنسبة لبعضها (مرتَّبة).\nوالأنواع الأربعة التي من جنس التسلسل هي:\n\nالقائمة (list) ويُعبَّرُ عنه بالقوسين المربعين [].\nالصف (tuple) ويُعبَّرُ عنه بالقوسين الهلاليين ().\nالمجال (range) ويُعبَّرُ عنه بالإجراء المنشئ range().\nالنص (str) ويُعبَّرُ عنه بالتنصيص المفرد '' أو المزدوج \"\"\n\nفهذه الأربعة تقبل الإجراءات التالية (المتغير s هو التسلسل هنا):\n\nالإشارة:\n\nبالموضع: s[i]\nبالقطعة: s[i:j]\nبالقطعة مع خطوة: s[i:j:k]\n\nمعرفة موضع شيء (إن وجد): s.index(x)\nعد تكرارات شيء: s.count(x)\nالبحث عن الأصغر والأكبر: min(s) و max(s)\n\nوتقبل من إجراءات الإنشاء:\n\nالدمج: s1 + s2\nالتكرار: s * n\n\nأما تخصيص حرف + للدمج (لا للجمع) ، وحرف * للتكرار (لا للضرب)؛ فسيأتي معنا -إن شاء الله- في فصل تعريف الإجراءات المخصوصة في باب الكائنات.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الصف-tuple",
    "href": "chapters/05_sequences/a_sequences.html#الصف-tuple",
    "title": "ملحق F — التسلسل",
    "section": "الصف (tuple)",
    "text": "الصف (tuple)\nالصف تسلسل جامد.\nفالجامد هو ما لا يقبل التغيير بعد إنشائه.\nيراجع في هذا صفحة هياكل البيانات.\n\nالإنشاء\nيكون إنشاء الصف بالقوسين الهلاليين () على النحو التالي:\n\nالفرد: (x,) وهو صف بعنصر واحد\nالزوج: (x, y) وهو صف بعنصرين\nالثلاثي: (x, y, z) وهو صف بثلاثة عناصر\n…إلخ.\n\nولا يشترط تجانس العناصر؛ بل يجوز أن تكون أنواعها مختلفة:\n\ns = (10, 20, 'hello', True, (300, 400))\nprint(s)\n\n(10, 20, 'hello', True, (300, 400))\n\n\nوقد يتألف الإنشاء بالتكرار بعلامة *:\n\ns = (10, 20) * 3\nprint(s)\n\n(10, 20, 10, 20, 10, 20)\n\n\nأو الدمج، بعلامة +:\n\ns = (10, 20) + (30, 40)\nprint(s)\n\n(10, 20, 30, 40)\n\n\nنستعرض هنا العضوية والعد والكر:\n\ns = (100, 200, 300)\n\nassert 100 in s\nassert 400 not in s\nassert len(s) == 3\n\nfor x in s:\n    print(x)\n\n100\n200\n300\n\n\n\n\nالإشارة\nتستعمل الإشارة الموضعية لقراءة عنصر من التسلسل.\n\ns = (10, 20, 30, 40, 50)\nassert s[0] == 10\nassert s[-1] == 50\nassert s[len(s) // 2] == 30\n\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\nويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل.\nفهذا يفشل لأن المؤشر ليس رقمًا صحيحًا:\n\ns = (10, 20, 30, 40, 50)\ns['3']\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[6], line 2\n      1 s = (10, 20, 30, 40, 50)\n----&gt; 2 s['3']\n\nTypeError: tuple indices must be integers or slices, not str\n\n\n\nوكذلك هذا لأنه يتجاوز نطاق التسلسل (0 - 4):\n\ns = (10, 20, 30, 40, 50)\ns[5]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[7], line 2\n      1 s = (10, 20, 30, 40, 50)\n----&gt; 2 s[5]\n\nIndexError: tuple index out of range\n\n\n\nشكل الإشارة بالقطعة (slice) على نحو: s[start : end : step]. والقيم الابتدائية عند الإغفال هي: s[0:len(s):1].\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\n\ns = (10, 20, 30, 40, 50)\nassert s[1:3] == (20, 30)\nassert s[::2] == (10, 30, 50)\nassert s[::-1] == (50, 40, 30, 20, 10)\nassert s[1:4:2] == (20, 40) == s[-4:-1:2]\nassert s[1:4:2] == s[slice(1,4,2)] == (20, 40)\n\nلاحظ استعمال الإجراء المنشئ slice() في الإشارة بالقطعة، وقد جعلت بايثون علامة : بديلاً عنه.\nوإذا جعلته صفًّا من صفوف؛ صار مصفوفة:\n\nmatrix = (\n    (10, 20, 30),\n    (40, 50, 60),\n    (70, 80, 90)\n)\n\nassert matrix[0] == (10, 20, 30)\nassert matrix[-1] == (70, 80, 90)\n\nوتتبع الإشارة بالإشارة حتى تصل للعنصر هكذا:\n\nassert matrix[1][2] == 60\n\nفإن بايثون تقيم مثل هذا التعبير من اليسار إلى اليمين:\n\nأريد المصفوفة\nومنها أريد العنصر الثاني (1)\nومنه أريد العنصر الثالث (2)\n\nوإن أردت قراءتها من اليمين إلى اليسار فتقول:\n\nأريد العنصر الثالث من\nالعنصر الثاني من\nالمصفوفة\n\nويجوز لك تفريقها هكذا:\n\nsecond = matrix[1]\nassert second[2] == 60\n\nحيث إن نوع المتغير second هو صف (tuple).\n\ntype(second)\n\ntuple\n\n\nونتصورها بهذا الشكل\n 0              1              2              3\n +--------------+--------------+--------------+\n | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |\n +--------------+--------------+--------------+\n-3             -2             -1\nوفي كل مرة تشير إلى أحدها يخرج الصف كاملاً:\n 0    1    2    3\n +----+----+----+\n | 10 | 20 | 30 |\n +----+----+----+\n-3   -2   -1\n 0    1    2    3 \n +----+----+----+\n | 40 | 50 | 60 |\n +----+----+----+\n-3   -2   -1\n 0    1    2    3\n +----+----+----+\n | 70 | 80 | 90 |\n +----+----+----+\n-3   -2   -1\nعناصر نصوص:\n\nss = (\"Apple\", \"Banana\", \"Orange\", \"Lemon\")\nassert ss[1] == \"Banana\"\nassert ss[-1][0] == \"L\"\n\n 0       1        2        3       4\n +-------+--------+--------+-------+\n | Apple | Banana | Orange | Lemon |\n +-------+--------+--------+-------+\n-4      -3       -2       -1\nالإشارة لصف الأحرف في النص الواحد:\n 0   1   2   3   4   5\n +---+---+---+---+---+\n | L | e | m | o | n |\n +---+---+---+---+---+\n-5  -4  -3  -2  -1\nوسيأتي التفصيل في باب النص.\n\n\nالبحث\nالبحث عن موضع العنصر (s.index(x)) وعد تكراره (s.count(x)):\n\ns = ('Python', 'Python', 'Go')\nassert s.index('Go') == 2\nassert s.count('Python') == 2\n\nالبحث عن الأصغر والأكبر:\n\ns = (30, 20, 40, 10, 50)\nassert s.index(min(s)) == 3\nassert s.index(max(s)) == 4",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#القائمة-list",
    "href": "chapters/05_sequences/a_sequences.html#القائمة-list",
    "title": "ملحق F — التسلسل",
    "section": "القائمة (list)",
    "text": "القائمة (list)\nالقائمة (list) تسلسل متغير.\nجدول طرائق القائمة:\n\n\n\n\n\n\n\nالطريقة\nعملها\n\n\n\n\nlist.append(x)\nإضافة عنصر إلى نهاية القائمة.• x: العنصر المراد إضافته.\n\n\nlist.extend(iterable)\nتوسيع القائمة بإضافة كافة العناصر من iterable.• iterable: المجموعة المراد إضافة عناصرها.\n\n\nlist.insert(i, x)\nإدراج عنصر في موضع محدد.• i: موضع الإدراج.• x: العنصر المراد إدراجه.\n\n\nlist.remove(x)\nإزالة أول تكرار لعنصر من القائمة.• x: العنصر المراد إزالته.\n\n\nlist.pop([i])\nإزالة وإرجاع عنصر من موضع محدد.• i: موضع العنصر (اختياري، افتراضيًا آخر عنصر).\n\n\nlist.clear()\nإزالة كافة العناصر من القائمة.\n\n\nlist.index(x[, start[, end]])\nإرجاع موضع أول تكرار لعنصر.• x: العنصر المراد البحث عنه.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nlist.count(x)\nعد عدد تكرارات عنصر في القائمة.• x: العنصر المراد عده.\n\n\nlist.sort(*, key=None, reverse=False)\nترتيب عناصر القائمة في مكانها.• key: دالة لتحديد معيار الترتيب (اختياري).• reverse: ترتيب تنازلي إذا كانت True.\n\n\nlist.reverse()\nعكس ترتيب عناصر القائمة في مكانها.\n\n\nlist.copy()\nإنشاء نسخة سطحية من القائمة.\n\n\n\nيراجع في هذا الجدول صفحة هياكل البيانات.\n\nالتغير\nفالأنواع على قسمين من حيث قبول التغير بعد الإنشاء:\n\nمتغير (Mutable: قابل للتغيير): يعني قبوله الإضافة والحذف والتعديل على عناصرها بعد الإنشاء.\nجامد (Immutable: غير قابل للتغيير): لا يقبل التغير. ومن جهة كونها عوامل للإجراء؛ فإن الجامد لا يقبل أن يكون محل عمل الإجراء.\n\n\n\n\n\n\n\nملاحظة\n\n\n\nالتغير والجمود مفهومان يتكرران كثيرًا في البرمجة. للمزيد راجع: بناء البرمجيات: الفصل التاسع، الجمود (MIT-6.005)\n\n\nالتغير هي الخاصية التي تختلف فيها القائمة عن قسيماتها التسلسلية (الصف والمجال والنص). ومعناه قبولها الإجراءات التالية (نستعمل في المثال حرف l للقائمة):\n\nالاستبدال:\n\nلموضع: l[i] = x\nلقطعة: l[i:j] = t\nلقطعة بخطوة: l[i:j:k] = t\n\nالحذف:\n\nلموضع: del l[i]\nلقطعة: del l[i:j]\nلقطعة بخطوة: del l[i:j:k]\n\nالإزالة: l.remove(x) لحذف أول ورود للعنصر\nالنزع: l.pop([i]) أخذ العنصر من الموضع (مع حذفه من ذلك الموضع)\n\nإن لم يحدد الموضع: نزع الأخير. إذ القوسان [i] هنا في التعريف يعبران عن عامل اختياري وهو الموضع i\n\nالإدراج: l.insert(i, x) لإضافة عنصر في موضع محدد\nالإلحاق: l.append(x) لإضافة عنصر في النهاية\nالترتيب: l.sort() أو بالإجراء المبني sorted(l)\nالعكس: l.reverse() أو بالإجراء المبني reversed(l)\n\nلاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين الهلاليين ()، إذْ هو جامد لا يقبل التغير:\n\nt = (10, 20, 30, 40, 50)\nt[0] = 100\nprint(t)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[16], line 2\n      1 t = (10, 20, 30, 40, 50)\n----&gt; 2 t[0] = 100\n      3 print(t)\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nلكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين []، لأنها متغيرة:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nprint(l)\n\n[100, 20, 30, 40, 50]\n\n\nالاستبدال بالموضع والحذف منه:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nassert l == [100, 20, 30, 40, 50]\n\ndel l[0]\nassert 100 not in l\n\nالاستبدال بالقطعة والحذف منها\n\nl = [10, 20, 30, 40, 50]\nl[1:3] = [200, 300]\nassert l == [10, 200, 300, 40, 50]\n\ndel l[1:3]\nassert l == [10, 40, 50]\n\nالإدراج:\n\nl = [10, 20, 30, 40, 50]\nl.insert(1, 100)\nassert l == [10, 100, 20, 30, 40, 50]\n\nالإزالة:\n\nl = [10, 20, 30, 40, 50]\nl.remove(20)\nassert l == [10, 30, 40, 50]\n\nالإلحاق:\n\nl = [10, 20, 30, 40, 50]\nl.append(60)\nassert l == [10, 20, 30, 40, 50, 60]\n\nالترتيب والعكس:\n\nl = [30, 40, 10, 20, 50]\nl.sort()\nassert l == [10, 20, 30, 40, 50]\n\nl.reverse()\nassert l == [50, 40, 30, 20, 10]\n\nنزع العنصر الأخير:\n\nl = [10, 20, 30, 40, 50]\nx = l.pop()\nassert x == 50\nassert 50 not in l",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#النطاق-range",
    "href": "chapters/05_sequences/a_sequences.html#النطاق-range",
    "title": "ملحق F — التسلسل",
    "section": "النطاق (range)",
    "text": "النطاق (range)\nيمثل النطاق (range) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فثلاثة عوامل تحدده:\n\nالبداية (start=0):\n\nمشمولة\nقيمتها الابتدائية 0 (إذا أهملت)\n\nالنهاية (stop):\n\nغير مشمولة\nوهي واجبة (إهمالها ممتنع)\n\nالخطوة (step=1):\n\nمقدار الزيادة أو النقص للعدد في كل كرة\nقيمتها الابتدائية 1 (إذا أهملت)\n\n\nدعونا الآن نلقي نظرة على التعريف كما هو موجود في مراجع بايثون، وذلك لنتعلم كيف نقرؤ التعريف. ادخل الرابط وتأمل معي ..\n\nclass range(stop)\nclass range(start, stop[, step])\n\nأولا: تدل كلمة class على أنها معرَّفة كنوع، فيكون طلب الإجراء بنفس الاسم range للإنشاء.\nثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما يكون؟\nنجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو stop وتأخذ البداية والخطوة قيمتهما الابتدائية: start=0 و step=1 حسب ما كُتب:\n\nIf the step argument is omitted, it defaults to 1.\nIf the start argument is omitted, it defaults to 0\n\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nأما التعريف الثاني فيجب تفكيكه لنفهمه: class range(start, stop[, step]).\nوجود الأقواس المربعة [ ] يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو start, stop؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الابتدائية step=1.\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\nالكر والإشارة\n\nxs = [10, 20, 30, 40, 50, 60]\n\nيتم كرّ التسلسل بكلمة for، على النحو التالي:\n\nfor x in xs:\n    print(x)\n\n10\n20\n30\n40\n50\n60\n\n\nأو بسرد النطاق (حيث النهاية تكون: len(xs) أي: طول التسلسل) واستعمال الإشارة بالموضع (xs[i])، نحو:\n\nfor i in range(len(xs)):\n    print(xs[i])\n\n10\n20\n30\n40\n50\n60\n\n\nفهذا يفيد في التحكم في السرد، فلو أردنا كل عنصرٍ ثانٍ، نجعل الخطوة 2 ابتداء من العنصر الثاني 1، فنكتبها هكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i])\n\n20\n40\n60\n\n\nأو أردنا قراءة الموضع والذي قبله، فهكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i-1], xs[i])\n\n10 20\n30 40\n50 60\n\n\nفإن جوَّزنا التداخل، جعلنا الخطوة 1، هكذا:\n\nfor i in range(1, len(xs), 1):\n    print(xs[i-1], xs[i])\n\n10 20\n20 30\n30 40\n40 50\n50 60\n\n\nوهلم جرا..\n\n\nتأجيل النتيجة\nويجدر بالذكر أن النطاق لا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وهو كالصف لا يقبل التعديل.\nنستعمل فعل الإنشاء range() لإنشاء نطاق:\n\nr = range(0, 20, 2)\nr\n\nrange(0, 20, 2)\n\n\nفحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:\n\nprint(11 in r)\nprint(10 in r)\n\nFalse\nTrue\n\n\nكذلك الإجراء عند البحث عن موضع رقمٍ ما:\n\nprint(r.index(10))\n\n5\n\n\nوالإشارة لموضع ما أو قطعة كذلك:\n\nprint(r[5])\nprint(r[:5])\nprint(r[-1])\n\n10\nrange(0, 10, 2)\n18\n\n\n\n\nتحقيق النطاق\nالمولِّد لا تتحقق عناصره إلا عند الحاجة إليها؛ أي: عند قراءتها. فإذا جعلناه عاملاً في جملة الإنشاء list؛ تولَّدَت جميع عناصره ووُضِعَت في قائمة:\n\nevens = list(range(0, 10, 2))\nodds = list(range(1, 10, 2))\nprint(evens)\nprint(odds)\n\n[0, 2, 4, 6, 8]\n[1, 3, 5, 7, 9]",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#ضم-التسلسلات-المرتبطة-zip",
    "href": "chapters/05_sequences/a_sequences.html#ضم-التسلسلات-المرتبطة-zip",
    "title": "ملحق F — التسلسل",
    "section": "ضم التسلسلات المرتبطة (zip)",
    "text": "ضم التسلسلات المرتبطة (zip)\nهذان تسلسلان مرتبطان:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = [90, 80, 75, 85, 95]\n\nassert len(students) == len(marks)\n\nويُمكن ضمُّ السلسلتين بحيث ينتج في التكرار عُنصران في كل مرة؛ وذلك بفعل الضم zip() الذي يُنتج مُكَرَّرًا -بفتح الراء- (Iterable). فإذا ضممنا سلسلتين، خرج لنا في كل كرَّة زوج (x, y):\n\nfor x, y in zip(students, marks):\n    print(x, y)\n\nAhmad 90\nBelal 80\nCamal 75\nDawud 85\nEmad 95\n\n\n\n\n\n\n\nflowchart LR\n    students --&gt; zip\n    marks --&gt; zip\n    zip --&gt; for\n    for --&gt; x\n    for --&gt; y\n\n\n\n\n\n\n\nضم المكررات\nولاحظ فيما يلي أن:\n\nنوع students قائمة (list)\nونوع marks نطاق (range)\nونوع classes صف (tuple)\n\nومع ذلك فإنه يجوز ضمُّها لأن الإجراء يقبلُ كُل ما هو مُكَرَّر:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = range(75, 95+1, 5)\nclasses = ('A-1', 'A-1', 'A-2', 'A-1', 'A-2')\n\nassert list == type(students)\nassert tuple == type(classes)\nassert range == type(marks)\n\nfor x, y, z in zip(students, marks, classes):\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2\n\n\n\n\nالقراءة بالموضع المشترك\nويكون قراءة التسلسلات المرتبطة أيضًا بسرد مُكَرَّر النطاق، والإشارة إلى كل عنصر بالموضع:\n\nfor i in range(len(students)):\n    x, y, z = students[i], marks[i], classes[i]\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "href": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "title": "ملحق F — التسلسل",
    "section": "الإنشاء المختصر: الجملة الثلاثية",
    "text": "الإنشاء المختصر: الجملة الثلاثية\nمما تميزت به لغة بايثون عن غيرها: مختصرة الإنشاء (Comprehension)؛ وهي جملة تُنشئ مجموعة مستمَدَّة من مكرر في ثلاث جُمَل في سطرٍ واحدٍ -غالبًا- ووظيفتها: إنشاء مجموعة مستمَدَّة من مكرر.\nوليسَت زيادتها في اللغة من باب الضرورة وإنما من باب التحسين. إذْ فيها قوة في التعبير عن جمل كثيرة في مساحة صغيرة. فهذا المثال يعبر عن إنشاء قائمة كل عنصرٍ فيها مربَّعٌ من المكرر range(10) في سطرٍ واحد:\n\nsquares = [x ** 2 for x in range(10)]\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nفهي جملة إنشاء مركَّبة من ثلاث جمل:\n\nتعبير (x ** 2) ، الذي يشتمل غالبًا على متغير التكرار (x)\nتكرار: (for x in range(10))\nوشرط: والشرطُ ليسَ بشرط؛ لذا جاز إهماله في هذا المثال\n\nفهي مكافئة للقطعة التالية:\n\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nولو أردنا ترشيح الأعداد الزوجية من قائمة، نستطيع استعمال جملة الشرط في الاختصار على النحو التالي:\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nevens = [x for x in numbers if x % 2 == 0]\nevens\n\n[0, 2, 4, 6, 8]\n\n\n\nالتعبير: (x) فقط\nالتكرار: (for x in numbers)، وتذكر أن القائمة مُكرَّر\nالشرط: (if x % 2 == 0)\n\nوهي مكافئة للقطعة التالية:\n\nevens = []\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\nevens\n\n[0, 2, 4, 6, 8]\n\n\nوأما القوسان المربعان [ ] -في كلا المثالين- فلإنشاء قائمة. وبحسب ما يُراد إنشاؤه تختلف الأقواس:\n\n[expression for item in iterable if condition] للقائمة (list)\n(expression for item in iterable if condition) للمولِّد (Generator)\n{expression for item in iterable if condition} لمجموعة الفرائد (set) وسيأتي الكلام عنها في الباب القادم\n{expression: expression for item in iterable if condition} للقاموس (dict) وسيأتي الكلام عنه في الباب القادم",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html",
    "href": "chapters/05_sequences/apps.html",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "",
    "text": "ترتيب قائمة الأسماء\nإن تطبيقات البيانات المتسلسلة كثيرة جدًا وواقعية إلى حد كبير. ولن نتطرق الآن إلى كيفية وصول هذه البيانات إلى بايثون (فذلك موضوع له تفاصيله)، لكننا سنتعامل مع البيانات باعتبار أنها وصلت إلينا.\nلو كان لدينا قائمة من الأسماء ونريد ترتيبها أبجديًّا؛ فإننا نستعمل الإجراء sort() الذي يأخذ القائمة كمفعول به ويرتبها في مكانها:\nnames = [\n    \"Yousef\",\n    \"Ali\",\n    \"Belal\",\n]\nlist.sort(names)\nnames\n\n['Ali', 'Belal', 'Yousef']",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#ضم-القوائم",
    "href": "chapters/05_sequences/apps.html#ضم-القوائم",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "ضم القوائم",
    "text": "ضم القوائم\nتأتي البيانات عادة من مصادر متعددة. فلو كان لدينا قائمتان لدرجات الطلاب، بحيث تحتوي القائمة أزواجًا تحوي اسم الطالب ودرجته، فإننا نريد ضمها جميعًا في قائمة واحدة. وهذا يتحقق بعملية الجمع + بين القوائم:\n\nclass1_marks = [\n    (\"Yousef\", 80),\n    (\"Ali\", 70),\n    (\"Belal\", 90),\n]\nclass2_marks = [\n    (\"Dawood\", 85),\n    (\"Muhammad\", 75),\n    (\"Yaser\", 95),\n]\nstudent_marks = class1_marks + class2_marks\nstudent_marks\n\n[('Yousef', 80),\n ('Ali', 70),\n ('Belal', 90),\n ('Dawood', 85),\n ('Muhammad', 75),\n ('Yaser', 95)]\n\n\nنتأكد من عدد الطلاب:\n\nassert len(student_marks) == len(class1_marks) + len(class2_marks)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#ترتيب-قائمة-صفوف",
    "href": "chapters/05_sequences/apps.html#ترتيب-قائمة-صفوف",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "ترتيب قائمة صفوف",
    "text": "ترتيب قائمة صفوف\nوالآن نريد أن نرتب هذه القائمة تصاعديًّا بحسب الدرجات.\n\n# أولاً سنفصل قائمة الدرجات لوحدها\nmarks = [mark for name, mark in student_marks]\n\nresult = []\n# نأتي على قائمة الدرجات بشكل تصاعدي\nfor mark in sorted(marks, reverse=True):\n    # نبحث عن الطلاب الذين حصلوا على هذه الدرجة\n    for row in student_marks:\n        # إذا كانت الدرجة متطابقة\n        if row[1] == mark:\n            # نضيفهم إلى النتيجة\n            result.append(row)\nresult\n\n[('Yaser', 95),\n ('Belal', 90),\n ('Dawood', 85),\n ('Yousef', 80),\n ('Muhammad', 75),\n ('Ali', 70)]\n\n\nولو أردنا أسماء الثلاثة الأوَل:\n\nhigh = [x[0] for x in result[:3]]\nhigh\n\n['Yaser', 'Belal', 'Dawood']\n\n\nونستطيع أن نأخذ أسماء الطلبة الأضعف في الدرجات حتى نفهم الأسباب ونحاول أن نرفع من مستواهم الدراسي. ولاحظ هنا نستعمل فك الأقواس بدل تحديد الموضع بالرقم:\n\nlow = [name for name, mark in result[-3:]]\nlow\n\n['Yousef', 'Muhammad', 'Ali']",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#توزيع-نماذج-الاختبار",
    "href": "chapters/05_sequences/apps.html#توزيع-نماذج-الاختبار",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "توزيع نماذج الاختبار",
    "text": "توزيع نماذج الاختبار\nتصور أن لدينا نموذجين من الاختبار، ونريد أن نوزعها بحيث يأخذ نصفهم النموذج الأول والنصف الثاني يأخي النموذج الثاني، لكن نريد أن يكون التوزيع بحسب الصف الذي يجلس فيه الطلاب.\nنفترض أن كل صف يجلس فيه ثلاثة طلاب، ونريد أن نجعل لكل صف نموذجًا.\n\nstudents = [\n    'Ahmad',\n    'Belal',\n    'Camal',\n    'Dawood',\n    'Emad',\n    'Faris',\n    'Ghaith',\n    'Hussain',\n]\n\nنمر على قائمة الأسماء بخطوة مقدارها 3 (عدد الطلاب في كل صف):\n\nfor i in range(0, len(students), 3):\n    print(students[i:i+3])\n\n['Ahmad', 'Belal', 'Camal']\n['Dawood', 'Emad', 'Faris']\n['Ghaith', 'Hussain']\n\n\nوالآن نريد أن نحدد لكل صف نموذجًا. نحقق ذلك بعملية باقي القسمة لمعرفة ما إذا كان العدد يقبل القسمة على 2؛ إذ به يعرف الزوجي، والآخر هو الفردي:\n\nfor i in range(0, len(students), 3):\n    if i % 2 == 0:\n        print(students[i:i+3], 'test1')\n    else:\n        print(students[i:i+3], 'test2')\n\n['Ahmad', 'Belal', 'Camal'] test1\n['Dawood', 'Emad', 'Faris'] test2\n['Ghaith', 'Hussain'] test1",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#فرز-البيانات",
    "href": "chapters/05_sequences/apps.html#فرز-البيانات",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "فرز البيانات",
    "text": "فرز البيانات\nتصور أن لدينا قائمة من الأرقام الموجبة والسالبة في مجموعة واحدة، ونريد فصلها لمجموعتين:\n\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = []\nnegatives = []\n\nfor x in numbers:\n    if x &gt; 0:\n        positives.append(x)\n    else:\n        negatives.append(x)\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]\n\n\nأو باستعمال الإنشاء المختصر:\n\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = [x for x in numbers if x &gt; 0]\nnegatives = [x for x in numbers if x &lt; 0]\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#المحاسبة-المالية",
    "href": "chapters/05_sequences/apps.html#المحاسبة-المالية",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "المحاسبة المالية",
    "text": "المحاسبة المالية\nافترض أن لديك قائمة بالمصروفات والإيرادات لكل رُبع من السنة، وتريد حساب صافي الربح لكل ربع على حدة، ثم جمعها لتحصل على الربح الإجمالي للسنة.\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet     = [    0,     0,     0,     0]\nfor i in range(len(income)):\n    net[i] = income[i] - expense[i]\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100\n\n\nأو باستعمال zip للتكرار على مضموم القائمتين:\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet = []\nfor inc, exp in zip(income, expense):\n    net.append(inc - exp)\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100\n\n\nأو باستعمال الإنشاء المختصر:\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet = [inc - exp for inc, exp in zip(income, expense)]\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#أسعار-السلة",
    "href": "chapters/05_sequences/apps.html#أسعار-السلة",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "أسعار السلة",
    "text": "أسعار السلة\nلديك قائمة بالأسعار:\n\nprices = [\n    ('apple', 10),\n    ('banana', 20),\n    ('orange', 30),\n    ('mango', 40),\n    ('pineapple', 50),\n]\n\nوتريد حساب مجمل سلة مشتريات لأحد الزبائن:\n\nbasket1 = [\n    ('apple', 2),\n    ('mango', 1)\n]\nbasket2 = [\n    ('banana', 1),\n    ('orange', 2),\n    ('pineapple', 1),\n]\n\nنكرر على العناصر\n\ntotal_basket1 = 0\nfor fruit, count in basket1:\n    for label, price in prices:\n        if fruit == label:\n            total_basket1 += price * count\nprint(total_basket1)\n\n60\n\n\nوكذلك للسلة الثانية:\n\ntotal_basket2 = 0\nfor fruit, count in basket2:\n    for label, price in prices:\n        if fruit == label:\n            total_basket2 += price * count\nprint(total_basket2)\n\n130",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#إدارة-الطلبات",
    "href": "chapters/05_sequences/apps.html#إدارة-الطلبات",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "إدارة الطلبات",
    "text": "إدارة الطلبات\n\norders = []\n\nوتدخل الطلبات بإجراء الإلحاق append للقائمة:\n\nx = (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\norders.append(x)\n\nوهكذا الطلبات اللاحقة:\n\norders.append((('falafel', 'hummus', 'tea'), '8:48 PM'))\norders.append((('kabab', 'tabbouleh', 'water'), '8:52 PM'))\n\nوإننا حين ننجز الطلبات أو نعرضها، يكون بالترتيب التي دخلت به من الأول:\n\nfor order in orders:\n    print(order)\n\n(('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n(('kabab', 'tabbouleh', 'water'), '8:52 PM')\n\n\nوإذا أنجزنا الطلب (بالترتيب)، نزيله من القائمة:\n\nfinished = orders.pop(0)\nprint('done:', finished)\n\nprint('remaining:')\nfor order in orders:\n    print(order)\n\ndone: (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\nremaining:\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n(('kabab', 'tabbouleh', 'water'), '8:52 PM')\n\n\nأو هب أن الزبون الأخير ألغى الطلب، فإننا نزيله هكذا:\n\ncancelled = orders.pop(-1)\nprint('cancelled:', cancelled)\n\nprint('remaining:')\nfor order in orders:\n    print(order)\n\ncancelled: (('kabab', 'tabbouleh', 'water'), '8:52 PM')\nremaining:\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n\n\nملاحظة: pop(-1) تساوي pop() إذ القيمة الابتدائية هي -1.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#إزالة-العناصر-المتكررة",
    "href": "chapters/05_sequences/apps.html#إزالة-العناصر-المتكررة",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "إزالة العناصر المتكررة",
    "text": "إزالة العناصر المتكررة\nهب أننا وجدنا الطلب أدخل بالخطأ مرتين، ونريد إزالة التكرارات الموجودة في قائمة الطلبات كلها:\n\norders = [\n    (('falafel', 'hummus', 'tea'), '8:42 PM'),\n    (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n    (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n    (('falafel', 'hummus', 'tea'), '8:50 PM'),\n]\n\nلاحظ أن الطلب الأول والأخير ليسا مكررين، وذلك لأنهما في وقتين مختلفين، أم الطلبان في الوسط فهما في نفس الوقت بالضبط، ونريد إزالة مثل هذا التكرار:\n\nresult = []\nfor order in orders:\n    if order not in result:\n        result.append(order)\nresult\n\n[(('falafel', 'hummus', 'tea'), '8:42 PM'),\n (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n (('falafel', 'hummus', 'tea'), '8:50 PM')]",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#تعديل-الطلب",
    "href": "chapters/05_sequences/apps.html#تعديل-الطلب",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "تعديل الطلب",
    "text": "تعديل الطلب\nنريد أن نتابع حالة الطلب، ونعدلها إذا أنهينا الطلب. لن نستطيع ذلك إذا حاولنا تعديل الصف ()، بل يجب أولًا أن نجعل قائمة الطلبات مكونة من قوائم [] وليس من صفوف:\n\norders = [\n    [('falafel', 'hummus', 'tea'), '8:42 PM', 'PENDING'],\n    [('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM', 'PENDING'],\n    [('falafel', 'hummus', 'tea'), '8:50 PM', 'PENDING'],\n]\n\n\norders[0][2] = 'DONE'\n\nوالآن نستطيع فرز الطلبات بحسب حالة الطلب:\n\norders_done = [order for order in orders if order[2] == 'DONE']\norders_pending = [order for order in orders if order[2] == 'PENDING']\n\nprint('done:')\nfor order in orders_done:\n    print(order)\n\nprint('pending:')\nfor order in orders_pending:\n    print(order)\n\ndone:\n[('falafel', 'hummus', 'tea'), '8:42 PM', 'DONE']\npending:\n[('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM', 'PENDING']\n[('falafel', 'hummus', 'tea'), '8:50 PM', 'PENDING']",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "href": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "معرفة النقاط المجاورة",
    "text": "معرفة النقاط المجاورة\nتقول الرياضيات أن المسافة الإقليدية (على سطح مستوي لا متعرج) بين نقطتين تحكمها المعادلة:\n\\[\nd = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nنريد استعماله لقائمة من النقاط لمعرفة النقاط المجاورة.\n\npoints = [(1, 2), (5, 6), (7, 8), (3, 4)]\nx1, y1 = (2, 4)\n\ndistances = []\n\nfor x2, y2 in points:\n  d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n  distances.append(d)\n  print(f'distance from {x1, y1} to {x2, y2} is {d}')\n\nmin_distance = min(distances)\nmin_distance_index = distances.index(min_distance)\n\nprint('min distance index:', min_distance_index, 'with distance:', min_distance)\n\nnearest_point = points[min_distance_index]\n\nprint(f'nearest point to {x1, y1} is {nearest_point}')\n\ndistance from (2, 4) to (1, 2) is 2.23606797749979\ndistance from (2, 4) to (5, 6) is 3.605551275463989\ndistance from (2, 4) to (7, 8) is 6.4031242374328485\ndistance from (2, 4) to (3, 4) is 1.0\nmin distance index: 3 with distance: 1.0\nnearest point to (2, 4) is (3, 4)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "href": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "title": "ملحق G — تطبيقات في التسلسل",
    "section": "أمثلة إضافية على الإنشاء المختصر",
    "text": "أمثلة إضافية على الإنشاء المختصر\nيمكن استعمال اختصار من اختصار على النحو التالي. في هذا المثال نفرد قائمة مكونة من قوائم عددية، فنحوِّلها لتكون قائمة واحدة مكوَّنة من جميع هذه الأرقام:\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nإذا كتبناها من غير اختصار فشكلها كالتالي (لاحظ استعملنا متغير flat لتجميع القيَم المفردة):\n\nflat = []\nfor elem in vec:\n    for num in elem:\n        flat.append(num)\nflat\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nوهذا مثال لحاصل الضرب الديكارتي بين مجموعتين رياضيتين:\n\ncolors = ['red', 'green']\nshapes = ['circle', 'square']\ncartesian_product = [(color, shape) for color in colors for shape in shapes]\ncartesian_product\n\n[('red', 'circle'),\n ('red', 'square'),\n ('green', 'circle'),\n ('green', 'square')]\n\n\nانظر المرجع لمزيد من الأمثلة.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>تطبيقات في التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html",
    "href": "chapters/06_mapping/a1_set.html",
    "title": "ملحق H — المجموعة",
    "section": "",
    "text": "التحقق السريع\nشجرة أنواع المجموعة في بايثون.\nللتفصيل راجع خريطة الجموع: شكل P.1\nالمجموعة (set) هي جمع متغير من عناصر مرقَّمة فريدة بلا ترتيب.\nأو بالقوسين المتعرجين {} أو بالإجراء المُنشئ set() على النحو التالي:\nتقبل المجموعة -لكونها من نوع الجمع (Collection)- العمليات التالية:\nوباعتبارها مجموعة متغيرة (MutableSet)، فإنها تقبل الإجراءات التالية:\nوإليك جدول طرق المجموعة:\nولا يشترط تجانس العناصر؛ بل يجوز أن تكون أنواعها مختلفة:\nونرى عمليات المجموعة عليها: العد، والعضوية والتكرار:\nوكون المجموعة غير مرتبة، فإنها لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تقبل الإشارة (xs[i]) أو التقطيع (xs[i:j]) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:\nعرفنا أن المجموعة تقبل إجراء العضوية x in s، ولكن ثمة خصوصية لهذا الإجراء في المجموعة. وهذه الخصوصية تكمن في سرعة هذا الإجراء في المجموعة مقارنة بسرعة عمله في المجموعة المرتبة.\nفهذه المقارنة تكون بالمجموعة {}:\nblack_set = {\"192.168.1.1\", \"10.0.0.5\", \"172.16.0.2\"}\nip = \"10.0.0.5\"\nif ip in black_set:\n    print(\"Access Denied\")\n\nAccess Denied\nوتكون كذلك في القائمة []:\nblack_list = [\"192.168.1.1\", \"10.0.0.5\", \"172.16.0.2\"]\nip = \"10.0.0.5\"\nif ip in black_list:\n    print(\"Access Denied\")\n\nAccess Denied\nلكن الفرق هو تفاصيل هذه العملية، إذ تختلف الكيفية خلف الكواليس. ولن يكون الفرق في السرعة واضحًا إلا حين تكون المجموعة كبيرة جدًّا.\nوهذا يدخل في دراسة الخوارزميات وهيكلة البيانات. فإن أردت مزيد تفصيل فراجع هذه المادة: W3Schools DSA Hash Sets.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#التحقق-السريع",
    "href": "chapters/06_mapping/a1_set.html#التحقق-السريع",
    "title": "ملحق H — المجموعة",
    "section": "",
    "text": "وذلك أننا في القائمة نحتاج أن نمر على العناصر واحدًا تلو الآخر، حتى نجد العنصر أو لا نجده\nأما في المجموعة، فإن القيمة يتم تجزئتها (hash) حتى يُعرف رقم العنصر في المجموعة مباشرة من غير المرور على عناصرها. فعملية التجزئة هذه تعطينا العنوان بشكل رياضي.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#منطق-المجموعة-الرياضية",
    "href": "chapters/06_mapping/a1_set.html#منطق-المجموعة-الرياضية",
    "title": "ملحق H — المجموعة",
    "section": "منطق المجموعة الرياضية",
    "text": "منطق المجموعة الرياضية\nمما تتميز به المجموعة عن بقية أنواع الجمع: قبولها المنطق الرياضي على النحو التالي:\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل).\n\nوهذه القطعة مثال لجميع هذه العمليات الرياضية:\n\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#العمليات-على-المجموعات",
    "href": "chapters/06_mapping/a1_set.html#العمليات-على-المجموعات",
    "title": "ملحق H — المجموعة",
    "section": "العمليات على المجموعات",
    "text": "العمليات على المجموعات\n\nالاتحاد\n\n\n\nاتحاد مجموعتين\n\n\n\nset.union(set1, set2)\n\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n\n\n\nالتقاطع\n\n\n\nتقاطع مجموعتين\n\n\n\nset.intersection(set1, set2)\n\n{4, 5}\n\n\n\n\nالفرق\n\n\n\nالفرق\n\n\n\nset.difference(set1, set2)\n\n{1, 2, 3}\n\n\n\nset.difference(set2, set1)\n\n{6, 7, 8}\n\n\n\n\nالفرق التماثلي\n\n\n\nالفرق التماثلي\n\n\n\nset.symmetric_difference(set1, set2)\n\n{1, 2, 3, 6, 7, 8}\n\n\nملاحظة: لكل من الإجراءات السابقة علامة تمثله كما هو موضَّح في الجدول. إلا أن استعمال اسم الإجراء يقبل أي نوع من المتكررات (Iterables) ولا تقتصر على نوع المجموعة فقط (set):\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nالاتحاد\nset1 | set2\nset1.union(set2)\n\n\nالتقاطع\nset1 & set2\nset1.intersection(set2)\n\n\nالفرق\nset1 - set2\nset1.difference(set2)\n\n\nالفرق التماثلي\nset1 ^ set2\nset1.symmetric_difference(set2)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#العلاقات-بين-المجموعات",
    "href": "chapters/06_mapping/a1_set.html#العلاقات-بين-المجموعات",
    "title": "ملحق H — المجموعة",
    "section": "العلاقات بين المجموعات",
    "text": "العلاقات بين المجموعات\n\nالجزئية والشمول\nوكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nتحقق الجزئية (جزء من)\nset1 &lt;= set2\nset1.issubset(set2)\n\n\nتحقق الشمول (يشمل)\nset1 &gt;= set2\nset1.issuperset(set2)\n\n\nتحقق الانفصال (عدم التقاطع)\nlen(set1 & set2) == 0\nset1.isdisjoint(set2)\n\n\n\n\n\n\nالجزئية والشمول\n\n\n\nA = {1, 2, 3}\nB = {1, 2, 3, 4, 5, 6}\n\nوهذا مثال لاستعمالها كما في الجدول:\n\nassert A.issubset(B)\nassert B.issuperset(A)\n\n\n\nالانفصال\nوأما الانفصال، فهو عدم وجود أدنى تقاطع بين المجموعتين:\n\nC = {'Apple', 'Banana'}\nassert C.isdisjoint(A)\nassert C.isdisjoint(B)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html",
    "href": "chapters/06_mapping/a2_dict.html",
    "title": "ملحق I — القاموس",
    "section": "",
    "text": "استعمالات القاموس\nوراجع خريطة المجموعات: شكل P.1\nالقاموس (dict) جمع متغير مرتب من المفاتيح المرقَّمة الفريدة، تقابل كل منها قيمةً.\nينشأ القاموس بالإجراء المنشئ dict() أو بالقوسين المتعرجين {} وذلك على النحو التالي:\nولاحظ أن القاموس عبارة عن مجموعة اقترانات أو مقابلات:\nيستعمل القاموس في كثير من السياقات في البرمجة، وهو من أهم هياكل البيانات.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#استعمالات-القاموس",
    "href": "chapters/06_mapping/a2_dict.html#استعمالات-القاموس",
    "title": "ملحق I — القاموس",
    "section": "",
    "text": "الكلمة ومعناها\nالقاموس بالمعنى الذي يشير إليه اللفظ. نفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:\n\nenglish_to_arabic = {\n    'apple': 'تفاحة',\n    'banana': 'موزة',\n    'orange': 'برتقالة',\n}\n\n\n\nربط الأسماء بالأرقام\nمثلاً: دليل أرقام الهواتف هو قاموس:\n\nname_to_phone = {\n    'Adam': '966xxxxxxxxx',\n    'Mohammed': '966xxxxxxxxx',\n}\n\n\n\nدليل أسماء النطاقات\nوكذلك دليل أسماء النطاقات (DNS: Domain Name System) على شبكة الانرتنت هو قاموس:\n\ndomain_to_ip = {\n    'google.com': '172.217.14.206',\n    'wikipedia.org': '103.86.96.10',\n}\n\n\n\nاختصار الروابط الطويلة\nمن استعمالات القاموس: اختصار الروابط الطويلة في روابط قصيرة.\n\nshort_to_full = {\n    'google': 'https://www.google.com',\n    'python': 'https://www.python.org',\n    'wiki': 'https://www.wikipedia.org',\n}\n\n\n\nالكلمات المختصرة\nأو الاختصارات إلى الكلمة التامة:\n\nabb_to_full = {\n    'ASAP': 'As Soon As Possible',\n    'BRB': 'Be Right Back',\n    'DIY': 'Do It Yourself',\n    'EDA': 'Exploratory Data Analysis',\n    'FYI': 'For Your Information',\n    'SAR': 'Saudi Riyal',\n}",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#القاموس-dict",
    "href": "chapters/06_mapping/a2_dict.html#القاموس-dict",
    "title": "ملحق I — القاموس",
    "section": "القاموس (dict)",
    "text": "القاموس (dict)\nومن حيث كون القاموس من نوع الجمع (Collection)، فإنه يقبل الإجراءات ثلاثة:\n\nالعضوية: x not in d\nالعد: len(d)\nالتكرار: for x in d\n\nويقبل القاموس لكونه مقابلة (Mapping) الإجراءات التالية:\n\nالإشارة مفتاح: dict[key]\nالإشارة بمفتاح مع الرجوع بقيمة ابتدائية إن لم يُعثَر عليه: dict.get(key[, default])\n\nولكونه مقابلة متغيرة (MutableMapping)، فإنه يقبل الإجراءات التالية:\n\nالتعديل بمفتاح: dict[key] = value\nالحذف بمفتاح: del dict[key]\nنزع بمفتاح وإرجاع القيمة: x = dict.pop(key)\nالتحديث: dict.update(mapping)\n\nراجع خريطة الجموع: شكل P.1.\nوإليك جدول طرق القاموس:\n\n\n\n\n\n\n\nالفعل\nعمله\n\n\n\n\ndict.clear()\nتزيل جميع العناصر من القاموس.\n\n\ndict.get(key[, default])\nترجع قيمة المفتاح key. إذا لم يكن المفتاح موجودًا، فإنها ترجع default (أو القيمة العدمية None إذا لم يتم توفير قيمة افتراضية default).\n\n\ndict.items()\nترجع عرضًا لعناصر القاموس (أزواج المفتاح والقيمة).\n\n\ndict.keys()\nترجع عرضًا لمفاتيح القاموس.\n\n\ndict.values()\nترجع عرضًا لقيم القاموس.\n\n\ndict.pop(key[, default])\nتزيل المفتاح key وتعيد قيمته. إذا لم يكن المفتاح موجودًا، يتم إرجاع default إذا تم توفيره، وإلا يتم رفع خطأ KeyError.\n\n\ndict.popitem()\nتزيل وتعيد زوجًا عشوائيًا (مفتاح، قيمة) من القاموس. يتم ترتيب الأزواج بترتيب LIFO (الأخير يدخل أولاً) في الإصدارات قبل Python 3.7.\n\n\ndict.setdefault(key[, default])\nإذا كان المفتاح key موجودًا في القاموس، فإنه يعيد قيمته. إذا لم يكن كذلك، فإنه يُدخل المفتاح مع القيمة default ويعيد default.\n\n\ndict.update([other])\nتقوم بتحديث القاموس بالمفاتيح/القيم من other، مع الكتابة فوق المفاتيح الموجودة.\n\n\ndict.fromkeys(iterable[, value])\nينشئ قاموسًا جديدًا بمفاتيح من iterable وقيم تم تعيينها على value (افتراضيًا None).\n\n\ndict.copy()\nترجع نسخة سطحية من القاموس.\n\n\n\nوهذه كذلك، كلها قابلة للتجزئة، ولا يشترط أن تكون متجانسة (من نفس النوع)، كما يلي:\n\ndata = {\n    # مقابلة نص بعدد\n    'key1': 100,\n\n    # مقابلة عدد بنص\n    20: 'value2',\n\n    # مقابلة نص بقائمة\n    'c': [10, 20, 30, True],\n\n    # مقابلة صف من أعداد بنص\n    (1, 2): 'value3',\n\n    # مقابلة صف من نصوص بنص\n    ('a', 'b', 'c'): 'value4',\n}\n\nassert len(data) == 5\ndel data['key1']\nassert 'key1' not in data\n\nونحصل عليها بالإشارة بأحد المفاتيح:\n\nprint(data[20])\nprint(data['c'])\nprint(data[(1, 2)])\nprint(data[('a', 'b', 'c')])\n\nvalue2\n[10, 20, 30, True]\nvalue3\nvalue4",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#التضمين",
    "href": "chapters/06_mapping/a2_dict.html#التضمين",
    "title": "ملحق I — القاموس",
    "section": "التضمين",
    "text": "التضمين\nوقد تكون البيانات متضمنة بعضها في بعض، كتفضيلات المستخدم (user):\n\nuser = {\n    \"name\": \"Adam\",\n    \"language\": \"Arabic\",\n    \"phone\": \"966xxxxxxxxx\",\n    \"last_updated\": \"2021-09-01\",\n    \"age\": 25,\n    \"notifications\": {\n        \"email\": \"monthly\",\n        \"sms\": \"weekly\",\n        \"push\": \"daily\"\n    },\n    \"emails\": [\"example1@domain.com\", \"example2@domain.com\"]\n}\n\nفالمفتاح (Key) عادةً ما يكون نصًّا كما ترى. وأما القيمة (Value) فقد تكون نصًّا أو عددًا أو قائمة أو حتى قاموسًا!\nوللوصول إلى قيمة مضمَّنة، قد تكتب:\n\na = user['notifications']\nprint(a)\n\n{'email': 'monthly', 'sms': 'weekly', 'push': 'daily'}\n\n\n\nb = a['sms']\nprint(b)\n\nweekly\n\n\nوذلك أن نوع قيمة المتغير a هو قاموس:\n\ntype(a)\n\ndict\n\n\nأو تأتي بها مرة واحدة:\n\nc = user['notifications']['sms']\nprint(c)\n\nweekly\n\n\nوكذا الأمر في الوصول للقائمة المضمَّنة (emails) كما يلي:\n\ne = user['emails']\nprint(e)\n\n['example1@domain.com', 'example2@domain.com']\n\n\nثم الوصول إلى عنصرٍ من هذه القائمة:\n\nprint(e[0])\n\nexample1@domain.com\n\n\nوذلك أن نوع قيمة المتغير c هو قائمة:\n\ntype(e)\n\nlist\n\n\nأو الوصول إليها مرة واحدة:\n\nf = user['emails'][0]\nprint(f)\n\nexample1@domain.com\n\n\nومن الأنماط المستعملة بكثرة: استعمال القواميس كعناصر لقائمة. ولذلك وجب علينا التدرب على قراءتها.\nفمثلاً هذه قائمة يحتوي كل عنصرٍ منها على قاموس لبيانات مُرَشَّح للتوظيف، ونريد أن نستخلص خبراتهم المهنية منها:\n\ndata = [\n    {\n        'name': 'Ahmad Hamada',\n        'experiences': [\n            {\n                'company': 'Geo Space',\n                'start': '2038-01-01',\n                'end': '2039-01-01',\n                'role': 'Junior Software Engineer',\n            },\n            {\n                'company': 'Space Roots',\n                'start': '2039-01-01',\n                'end': '2041-01-01',\n                'role': 'Senior Software Engineer',\n            },\n        ],\n    },\n    {\n        'name': 'Belal Banana',\n        'experiences': [\n            {\n                'company': 'Banana Tech',\n                'start': '2041-01-01',\n                'end': '2042-01-01',\n                'role': 'Smoothie Operator',\n            },\n            {\n                'company': 'BugSquash Labs',\n                'start': '2042-02-01',\n                'end': '2043-08-01',\n                'role': 'Code Pest Control Specialist',\n            },\n            {\n                'company': 'Caffeinated Circuits Inc.',\n                'start': '2043-09-01',\n                'end': '2045-05-01',\n                'role': 'Espresso-Driven Engineer',\n            }\n        ]\n    },\n]\n\nولنفترض أننا نريد آخر وظيفة شغلها المرشح الثاني، فإننا نكتبها في بايثون بهذا الشكل:\n\ndata[1]['experiences'][-1]['role']\n\n'Espresso-Driven Engineer'\n\n\nوبايثون تقيِّمها (أي: تحسبها أو تفسِّرها) من اليسار إلى اليمين، على النحو التالي:\nمن المتغير data أريد العنصر الثاني، ومنه أريد مقابل المفتاح experiences، ومنه أريد العنصر الأخير، ومنه أريد مقابل المفتاح role.\nوقد يكون فصلها أوضَح هكذا:\n\nمن المتغير data (هو قائمة)\nمنه: العنصر الثاني (1) (هو قاموس)\nمنه: مقابل المفتاح experiences (هو قائمة)\nمنه: العنصر الأخير (هو قاموس)\nمنه: مقابل المفتاح role (هو نص)\n\nفإذا أردت أن تقرأها بالعكس من اليمين إلى اليسار، فتقول:\n\nمقابل المفتاح role\nفي العنصر الأخير من\nمقابل المفتاح experiences\nفي العنصر الثاني (1) من\nالمتغير data\n\nوتقول أيضًا: أريد وظيفةَ آخر خبرات الثاني من المرشحين.\n\n\n\n\n\n\nنصيحة\n\n\n\nقراءة صيَغ الوصول هي من مهارات المبرمج الذي يحتاجها كثيرًا.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#الكر",
    "href": "chapters/06_mapping/a2_dict.html#الكر",
    "title": "ملحق I — القاموس",
    "section": "الكر",
    "text": "الكر\nويحصل الكر بثلاثة طرق:\n\nكر المفاتيح: for key in d.keys()\nكر القيم: for value in d.values()\nكر العناصر: for key, value in d.items() (ينتج عنها أزواج (2-tuple) من الفاتيح والقيم)\n\nمثال:\n\nd = {\n    'A': 'Salam',\n    'B': 'Hello',\n    'C': 'Hi',\n}\nfor value in d.values():\n    print(value)\n\nSalam\nHello\nHi",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#عكس-القاموس",
    "href": "chapters/06_mapping/a2_dict.html#عكس-القاموس",
    "title": "ملحق I — القاموس",
    "section": "عكس القاموس",
    "text": "عكس القاموس\nإذا أردت عكس القاموس بحيث يصير المفتاح مكان القيمة والقيمة مكان المفتاح، فبهذه الطريقة:\n\nd = {\n    'ASAP': 'As soon as possible',\n    'TBD': 'To be determined',\n    'IDK': 'I don\\'t know',\n}\ninverse = dict()\nfor k, v in d.items():\n    inverse[v] = k\ninverse\n\n{'As soon as possible': 'ASAP',\n 'To be determined': 'TBD',\n \"I don't know\": 'IDK'}\n\n\nأو بالجملة المختصرة:\n\ninverse = {v: k for k, v in d.items()}\ninverse\n\n{'As soon as possible': 'ASAP',\n 'To be determined': 'TBD',\n \"I don't know\": 'IDK'}",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#إنشاء-قاموس-من-سلسلتين",
    "href": "chapters/06_mapping/a2_dict.html#إنشاء-قاموس-من-سلسلتين",
    "title": "ملحق I — القاموس",
    "section": "إنشاء قاموس من سلسلتين",
    "text": "إنشاء قاموس من سلسلتين\nويتحصل القاموس من سلسلتين باستعمال الإجراء zip()، كما يلي:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawood']\nmarks    = [     90,      80,      75,       85]\ndata = dict(zip(students, marks))\ndata\n\n{'Ahmad': 90, 'Belal': 80, 'Camal': 75, 'Dawood': 85}",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_apps.html",
    "href": "chapters/06_mapping/b_apps.html",
    "title": "ملحق J — تطبيقات في القاموس",
    "section": "",
    "text": "الأجزاء المنتمية إلى الكل\nأو الاختصارات إلى الكلمة التامة:\nanimal_class = {\n    \"Dog\": \"Mammalia\",\n    \"Cat\": \"Mammalia\",\n    \"Elephant\": \"Mammalia\",\n    \"Snake\": \"Reptilia\",\n    \"Lizard\": \"Reptilia\",\n    \"Frog\": \"Amphibia\",\n}\nنريد عكس هذه القائمة أيضًا بحيث نستطيع أن نعرف من الصنف كل الحيوانات المتنمية إليه.\nنأتي على جميع المفاتيح في القاموس الأول ونضيفها بحسب القيمة التي تقابلها:\nclass_animal = {}\nfor animal, clazz in animal_class.items():\n    if clazz not in class_animal:\n        class_animal[clazz] = []\n    class_animal[clazz].append(animal)\nclass_animal\n\n{'Mammalia': ['Dog', 'Cat', 'Elephant'],\n 'Reptilia': ['Snake', 'Lizard'],\n 'Amphibia': ['Frog']}\nلاحظ استعمال اسم clazz بدل class لأن كلمة class أصلية في لغة بايثون فلا يجوز استعمالها كمتغير.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>تطبيقات في القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_apps.html#سلة-المشتريات",
    "href": "chapters/06_mapping/b_apps.html#سلة-المشتريات",
    "title": "ملحق J — تطبيقات في القاموس",
    "section": "سلة المشتريات",
    "text": "سلة المشتريات\nنفترض أن لدينا سلة تحتوي على مشتريات العميل (basket)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس prices بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).\n\nprices = {\n    'apple': 15.25,\n    'banana': 10.50,\n    'orange': 5.75,\n    'cantaloupe': 40.00\n}\n\nيجوز تحديث الأسعار هكذا:\n\nprices['banana'] = 12\nprices['orange'] = 15\n\nأو تحديثها بالإجراء update():\n\nprices.update({'banana': 12, 'orange': 15})\nprices\n\n{'apple': 15.25, 'banana': 12, 'orange': 15, 'cantaloupe': 40.0}\n\n\nوالآن نفترض أن لدينا قائمة بالفواكه التي يريدها العميل:\n\nbasket = ['apple', 'apple', 'banana', 'orange', 'banana']\n\nنحسب سعر كل فاكهة في السلة بناءً على الأسعار الموجودة في القاموس:\n\ntotal = 0\n\nfor fruit in basket:\n    total += prices[fruit]\n\nprint(total)\n\n69.5\n\n\nأو تستطيع أن تعدها أولاً ثم تضربها بالسعر:\n\ncounts = dict()\nfor fruit in set(basket):\n    counts[fruit] = basket.count(fruit)\ncounts\n\n{'apple': 2, 'orange': 1, 'banana': 2}\n\n\nثم تضربها بالسعر:\n\ntotal = sum(counts[fruit] * prices[fruit] for fruit in counts)\ntotal\n\n69.5",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>تطبيقات في القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_apps.html#استعمال-الإنشاء-المختصر",
    "href": "chapters/06_mapping/b_apps.html#استعمال-الإنشاء-المختصر",
    "title": "ملحق J — تطبيقات في القاموس",
    "section": "استعمال الإنشاء المختصر",
    "text": "استعمال الإنشاء المختصر\nتقدم معنا الكلام عن الإنشاء المختصر. وسنستعرضه الآن مع القاموس.\nهنا مثال لقاموس من الفواكه، نريد ترشيح ما قيمته أقل من 20:\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nfiltered_menu = {k: v for k, v in menu.items() if v &lt; 20}\nfiltered_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5}\n\n\nوهذا مثال أكثر تعقيدًا. نطبق خصم 20% فقط على العناصر التي يكون سعرها أعلى من المتوسط، مع الحفاظ على بقية الأسعار كما هي. لاحظ أن التعبير هنا هو تعيين شرطي: value * (1 - discount) if value &gt; avg_price else value وليس هو قطعة الترشيح (if)؛ إذ تلك تأتي في نهاية الجملة، بعد قطعة التكرار (for).\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\navg_price = sum(menu.values()) / len(menu)\ndiscount = 0.20\n\ndiscounted_menu = {\n    k: v * (1 - discount) if v &gt; avg_price else v\n    for k, v in menu.items()\n}\ndiscounted_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5, 'cantaloupe': 32.0}",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>تطبيقات في القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html",
    "href": "chapters/07_strings/a1_strings.html",
    "title": "ملحق K — النص",
    "section": "",
    "text": "إجراءات مبنيَّة\nالنص (str) صف من الأحرف. وهو تسلسل ثابت من أرقام الترميز العالمي (Unicode) التي هي رموز تتبع ترميزًا عالميًا يحوي جميع أحرف اللغات بالإضافة إلى علامات الترقيم والرسوم (مثل: 💡🔍📐) ونحوها.\nإليك شجرة النص:\nوإليك طرائق وإجراءات النص:",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إجراءات-مبنية",
    "href": "chapters/07_strings/a1_strings.html#إجراءات-مبنية",
    "title": "ملحق K — النص",
    "section": "",
    "text": "الإجراء\nعمله\n\n\n\n\nlen(obj) -&gt; int\nلمعرفة عدد العناصر.• obj: كائن قابل للعد مثل السلسلة النصية أو القائمة.\n\n\nprint(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False)\nطباعة.• objects: الكائنات المراد طباعتها.• sep: الفاصل بين الكائنات (افتراضيًا مسافة).• end: النهاية (افتراضيًا سطر جديد).• file: وجهة الطباعة (افتراضيًا الشاشة).• flush: تنظيف المخزن المؤقت فورًا.\n\n\nord(c) -&gt; int\nلمعرفة رمز Unicode لحرف.• c: حرف واحد كسلسلة نصية.\n\n\nint(x=0, base=10) -&gt; int\nتحويل سلسلة نصية إلى عدد صحيح.• x: القيمة المراد تحويلها.• base: النظام العددي (افتراضيًا عشري).\n\n\nfloat(x) -&gt; float\nتحويل سلسلة نصية إلى عدد عشري.• x: القيمة المراد تحويلها.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#طرائق-شائعة",
    "href": "chapters/07_strings/a1_strings.html#طرائق-شائعة",
    "title": "ملحق K — النص",
    "section": "طرائق شائعة",
    "text": "طرائق شائعة\n\n\n\n\n\n\n\nالطريقة\nعمله\n\n\n\n\nstr.upper() -&gt; str\nتحويل السلسلة النصية إلى أحرف كبيرة.\n\n\nstr.lower() -&gt; str\nتحويل السلسلة النصية إلى أحرف صغيرة.\n\n\nstr.find(sub[, start[, end]]) -&gt; int\nالبحث عن موضع سلسلة نصية فرعية داخل سلسلة نصية.• sub: السلسلة النصية المراد البحث عنها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.replace(old, new[, count]) -&gt; str\nاستبدال تكرارات سلسلة نصية فرعية داخل سلسلة نصية.• old: السلسلة النصية المراد استبدالها.• new: السلسلة النصية البديلة.• count: عدد مرات الاستبدال (اختياري).\n\n\nstr.split(sep=None, maxsplit=-1) -&gt; list\nتقسيم السلسلة النصية إلى قائمة من السلاسل النصية الفرعية.• sep: المحدد (افتراضيًا المسافات البيضاء).• maxsplit: أقصى عدد للتقسيمات.\n\n\nstr.join(iterable) -&gt; str\nدمج عناصر من iterable إلى سلسلة نصية باستخدام فاصل.• iterable: مجموعة من السلاسل النصية.\n\n\nstr.strip([chars]) -&gt; str\nإزالة المسافات البيضاء من بداية ونهاية السلسلة النصية.• chars: الأحرف المراد إزالتها (اختياري).\n\n\nstr.startswith(prefix[, start[, end]]) -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تبدأ بمقدمة محددة.• prefix: المقدمة المراد التحقق منها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.endswith(suffix[, start[, end]]) -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تنتهي بنهاية محددة.• suffix: النهاية المراد التحقق منها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.count(sub[, start[, end]]) -&gt; int\nعد عدد تكرارات سلسلة نصية فرعية داخل سلسلة نصية.• sub: السلسلة النصية المراد عدها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.format(*args, **kwargs) -&gt; str\nإنشاء سلسلة نصية منسقة باستخدام عناصر نائبة.• args: المتغيرات المراد تنسيقها بالترتيب.• kwargs: المتغيرات المراد تنسيقها بالاسم.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#طرائق-معروفة",
    "href": "chapters/07_strings/a1_strings.html#طرائق-معروفة",
    "title": "ملحق K — النص",
    "section": "طرائق معروفة",
    "text": "طرائق معروفة\n\n\n\n\n\n\n\nالطريقة\nعمله\n\n\n\n\nstr.encode(encoding='utf-8', errors='strict') -&gt; bytes\nترميز السلسلة النصية باستخدام ترميز محدد.• encoding: نوع الترميز.• errors: كيفية معالجة الأخطاء.\n\n\nstr.casefold() -&gt; str\nتحويل السلسلة النصية إلى نسخة casefold للمقارنات غير الحساسة لحالة الأحرف.\n\n\nstr.capitalize() -&gt; str\nتحويل الحرف الأول من السلسلة النصية إلى حرف كبير.\n\n\nstr.center(width[, fillchar]) -&gt; str\nتوسيط السلسلة النصية داخل عرض حقل محدد.• width: العرض المطلوب.• fillchar: حرف التعبئة (اختياري).\n\n\nstr.translate(table) -&gt; str\nاستبدال الأحرف في السلسلة النصية باستخدام جدول ترجمة.• table: جدول الترجمة.\n\n\nstr.expandtabs(tabsize=8) -&gt; str\nتوسيع أحرف الجدولة في السلسلة النصية.• tabsize: حجم التبويب (افتراضيًا 8).\n\n\nstr.index(sub[, start[, end]]) -&gt; int\nالبحث عن موضع سلسلة نصية فرعية، وإثارة استثناء إذا لم يتم العثور عليها.• sub: السلسلة النصية المراد البحث عنها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.rjust(width[, fillchar]) -&gt; str\nمحاذاة السلسلة النصية إلى اليمين.• width: العرض المطلوب.• fillchar: حرف التعبئة (اختياري).\n\n\nstr.ljust(width[, fillchar]) -&gt; str\nمحاذاة السلسلة النصية إلى اليسار.• width: العرض المطلوب.• fillchar: حرف التعبئة (اختياري).\n\n\nstr.swapcase() -&gt; str\nتبديل حالة الأحرف في السلسلة النصية.\n\n\nstr.title() -&gt; str\nتحويل السلسلة النصية إلى حالة عنوان.\n\n\nstr.zfill(width) -&gt; str\nملء السلسلة النصية بالأصفار على اليسار.• width: العرض المطلوب.\n\n\nstr.splitlines([keepends]) -&gt; list\nتقسيم السلسلة النصية إلى قائمة من الأسطر.• keepends: الاحتفاظ بنهايات الأسطر (اختياري).\n\n\nstr.partition(sep) -&gt; tuple\nتقسيم السلسلة النصية إلى ثلاثة أجزاء.• sep: الفاصل.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#طرائق-نادرة-الاستعمال",
    "href": "chapters/07_strings/a1_strings.html#طرائق-نادرة-الاستعمال",
    "title": "ملحق K — النص",
    "section": "طرائق نادرة الاستعمال",
    "text": "طرائق نادرة الاستعمال\n\n\n\n\n\n\n\nالطريقة\nعمله\n\n\n\n\nstr.isalnum() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف أبجدية رقمية.\n\n\nstr.isalpha() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف أبجدية.\n\n\nstr.isdecimal() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف عشرية.\n\n\nstr.isdigit() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أرقام.\n\n\nstr.isidentifier() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية معرف بايثون صالح.\n\n\nstr.islower() -&gt; bool\nالتحقق مما إذا كانت جميع الأحرف المكونة في السلسلة النصية صغيرة.\n\n\nstr.isnumeric() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف رقمية.\n\n\nstr.isprintable() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف قابلة للطباعة.\n\n\nstr.isspace() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من مسافات بيضاء.\n\n\nstr.istitle() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية في حالة عنوان.\n\n\nstr.isupper() -&gt; bool\nالتحقق مما إذا كانت جميع الأحرف المكونة في السلسلة النصية كبيرة.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "href": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "title": "ملحق K — النص",
    "section": "النص الطبيعي",
    "text": "النص الطبيعي\nالنص الطبيعي (الحر أو البشري) هو ما لا يتبع هيكلاً أو قالبًا يحكم طريقة كتابته؛ وهو يطول ويقصر من الحرف الواحد إلى مجموعة الأحرف إلى الكلمة إلى الجملة وإلى أكبر من ذلك نحو:\n\nمحادثات وسائل التواصل الاجتماعي\nرسائل البريد الإلكتروني\nمقالات\nكتب\nموسوعات\nصفحات الشبكة\nمواقع الشبكة\n\nوأوجه معالجة النصوص الحرة كثيرة منها: الفهرسة والبحث والاستبدال والعد والتصنيف والترتيب والقولبة …إلخ.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "href": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "title": "ملحق K — النص",
    "section": "النص المُقَوْلَب",
    "text": "النص المُقَوْلَب\nالنص المقولَب الذي يأخذ شكلاً محددًا؛ وله صيغ متعددة يُنشئ الناس منها قوالب للنص لتمثل مجموعات أو ارتباطات من البيانات، كالجداول ونحوها.\nوصيغ القولبة كثيرة من أشهرها: XML, YAML, JSON, CSV.\nمثال لقالب بصيغة YAML:\n---\nName: Adam\nAge: 25\nCity: Riyadh\nمثال لقالب بصيغة JSON:\n{\n  \"Name\": \"Adam\",\n  \"Age\": 25,\n  \"City\": \"Riyadh\"\n}\nوهذا مثال لقالب بصيغة XML:\n&lt;person&gt;\n  &lt;name&gt;Adam&lt;/name&gt;\n  &lt;age&gt;25&lt;/age&gt;\n  &lt;city&gt;Riyadh&lt;/city&gt;\n&lt;/person&gt;\nوالصيغة التي تستعمل كثيرًا لتمثيل الجداول (صفوف) هي صيغة CSV. فكل سطرٍ هو صفٌّ في الجدول، وأوَّلُ سطرٍ هو رأس الجدول عادةً. وذلك على النحو التالي:\nName,Age,City\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\nجرب أن تُنشئ ملفًّا نصيًّا وتكتب فيه ذلك وتحفظه بصيغة csv ثم سترى أنه يمكنك فتحه بمحرر جداول (:مثل إكسل - Excel).\nوستأتي في فصل الملفات النصية إن شاء الله.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "href": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "title": "ملحق K — النص",
    "section": "إنشاء النص",
    "text": "إنشاء النص\nجملة إنشاء النص في بايثون تكون كالتالي:\n\nبعلامة اقتباس مفردة: 'السلام عليكم!'\nأو بعلامة اقتباس مزدوجة: \"السلام عليكم!\" وليس بينهما فرق.\nأو بعلامة اقتاس مكررة ثلاثة مرات: \"\"\"السلام عليكم!\"\"\" للنص الجاري على أكثر من سطر.\n\nعلى سبيل المثال:\n\nname = 'Adam'\naddress = \"Makkah, Saudi Arabia\"\n\nتأمل إنشاء هذا النص الذي يبتدئ في السطر الأول ويمتد لأربعة أسطر:\n\nmessage = \"\"\"السلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\"\"\"\nprint(message)\n\nالسلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\n\n\n\nقراءة الملفات النصية\nوكثيرًا ما يكون وجود النص في البرنامج ناتجًا عن قراءة ملف نصي بالإجراء open() وذلك بإضافة الحرف r ميشرًا إلى أن غرض الفتح للقراءة (ويجب أن يكون الملف موجودًا إلى جانب البرنامج - أي: في نفس المجلد الذي يوجد فيه البرنامج):\nfile = open('my_file.txt', 'r')\nmessage = file.read()\nfile.close()\nprint(message)\nوسيأتي مزيد بيان في باب الملفات.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "href": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "title": "ملحق K — النص",
    "section": "الإشارة لجزء من النص",
    "text": "الإشارة لجزء من النص\nولكون النص تسلسلاً ثابتًا فإنه يقبل جميع عمليات التسلسل السابق ذكرها (انظر باب المجموعة المرتبة).\n\ns = 'Arabian'\n\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\n 0   1   2   3   4   5   6   7\n +---+---+---+---+---+---+---+\n | A | r | a | b | i | a | n |\n +---+---+---+---+---+---+---+\n-7  -6  -5  -4  -3  -2  -1\n\nجرب\n\ns[1:5]\ns[1:5:2]\ns[::2]\ns[::-1]\n\nلاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:\n\ns = ('A', 'r', 'a', 'b', 'i', 'a', 'n')\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\nلكن الفرق أن النص نوعٌ له إجراءات / عمليات خاصة تتعلق بالنصوص.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "href": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "title": "ملحق K — النص",
    "section": "النص ثابت لا يقبل التغير",
    "text": "النص ثابت لا يقبل التغير\nفالنص تسلسل يشبه الصف في كوْنه ثابتًا (أي لا يقبل تعديل عنصر أو إضافته أو حذفه). فلو حاولت تغيير موضعٍ s[i] في النص أو قطعة s[i:j] فإنك ستواجه خطأ:\n\ns = 'Arabian'\ns[0] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 s = 'Arabian'\n----&gt; 2 s[0] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nلكننا لتعديل النص في الواقع نعيِّنُ إلى نفس المتغير نصًّا جديدًا منه:\n\ns = 'Arabian'\ns = 'a' + s[1:]\nprint(s)\n\narabian\n\n\nلاحظ أننا أسندنا النص الجديد إلى المتغير s، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "href": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "title": "ملحق K — النص",
    "section": "العمليات الخاصة بالنصوص",
    "text": "العمليات الخاصة بالنصوص\n\nالاستبدال\nلاستبدال جزء من النص، نستخدم طريقة .replace():\n\ns = 'Arabian'\ns = s.replace('ian', 'y')\nprint(s)\n\nAraby\n\n\nوللإزالة من البداية والنهاية: .removeprefix() و .removesuffx()\n\nprint('Arabian'.removeprefix('Arab'))\nprint('Arabian'.removesuffix('ian'))\n\nian\nArab\n\n\n\n\nإزالة المسافات\nكما لدينا علميات .strip() لإزالة المسافات البيضاء من بداية ونهاية النص.\n\nassert '  Arabian  '.strip() == 'Arabian'\n\n\n\nالبحث والمطابقة\nوكذلك لدينا عمليات البحث:\n\nالتحقق من البدء والنهاية وما بينهما: .startswith(prefix) و .endswith(suffix) أو sub in string وهي أعم.\nلمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص .find()\n\n\ns = 'Arabian'\nassert s.startswith('A')\nassert not s.startswith('a')\nassert s.endswith('n')\nassert 'rabia' in s\nassert s.find('a') == 2\n\n\n\nالفصل والوصل\n\nفصل النص لقائمة بناءً على جزء فاصل: list.split(seperator)\nوصل عناصر القائمة في نص مفصول بجزء فاصل: seperator.join(list)\n\nأولاً: الفصل: مثاله قراءة سطر في ملف csv إذْ القيم مفصولة بعلامة الفاصلة ,:\n\ncsv = \"Adam,25,Riyadh\"\nassert csv.split(',') == ['Adam', '25', 'Riyadh']\n\nولقراءة الملف كاملاً نكرر:\n\nالقيم في السطر الواحد مفصولة بعلامة الفاصلة ,\nوالصفوف مفصولة بعلامة السطر الجديد \\n\n\nلذلك سنستعمل الاثنين هنا:\n\ncsv = \"\"\"name,age,city\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\"\"\"\n\ndata = []\nfor line in csv.split(sep='\\n'):\n  row = line.split(sep=',')\n  data.append(row)\nprint(data)\n\n[['name', 'age', 'city'], ['Adam', '25', 'Riyadh'], ['Belal', '30', 'Jeddah'], ['Camal', '35', 'Dammam']]\n\n\nثانيًا: الوَصل: مثاله أننا نحول القائمة إلى نص مفصول بعلامة الفاصلة , وذلك ليكون سطرًا في ملف csv:\n\ndata = ['Adam', '25', 'Riyadh']\nseperator = ','\ncsv = seperator.join(data)\nassert csv == 'Adam,25,Riyadh'\n\n\n\nعمليات إنجليزية\nوهنا عمليات خاصة بالنصوص الإنجليزية:\n\nupper() نسخة ذات حروف كبيرة.\nlower() نسخة ذات حروف صغيرة.\ncapitalize() نسخة ذات حرف أول كبير من كل كلمة.\ntitle() نسخة ذات حالة عنوان.\n\n\nname = 'Adam ibraheeM'\nprint(name.upper())\nprint(name.lower())\nprint(name.capitalize())\nprint(name.title())\n\nADAM IBRAHEEM\nadam ibraheem\nAdam ibraheem\nAdam Ibraheem\n\n\nوانظر مستندات النصوص لمعرفة كافة الإجراءات الممكنة على النصوص.\n\n\nتفسير الأرقام\nتفسير الأرقام المكتوبة نصًّا تكثر الحاجة إليه خصوصًا عند قراءة ملفات أو التعامل مع بيانات من المستخدم، إذ يكون الإدخال نصيًّا:\n\nint(x) لتحويل نص إلى عدد صحيح.\nfloat(x) لتحويل نص إلى عدد عشري.\n\nلاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:\n\nx = '20'\ny = '40'\nprint(x + y)\n\n2040\n\n\nالواجب تحويلهما إلى أعداد أولاًً:\n\nx2 = float(x)\ny2 = float(y)\nprint(x2 + y2)\n\n60.0",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "href": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "title": "ملحق K — النص",
    "section": "إخراج النص",
    "text": "إخراج النص\nنستعرض ثلاث طرق لدمج النصوص في بايثون:\n\nالأولى: تحويل الشيء إلى نص قبل دمجه مع النص، باستعمال str(x)\nالثانية: استعمال فراغات بالقوسين المعكوفين {} مع الإجراء .format() لاستبدالها.\nالثالثة: استعمال f-string بأن تضع الحرف f قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل الأقواس المعكوفة {}. وهي الطريقة التي نفضلها.\n\n\nname = \"John\"\nlvl = 300\n\ns1 = \"I am \" + name + \" and I want to reach level \" + str(lvl) # + operator\ns2 = \"I am {} and I want to reach level {}\".format(name, lvl)  # .format() method\ns3 = f\"I am {name} and I want to reach level {lvl}\"            # f-strings\nassert s1 == s2 == s3\nprint(s1)\n\nI am John and I want to reach level 300\n\n\nيقبل النص التكرار بعلامة *:\n\nprint('-' * 10)\nprint('*' * 10)\nprint('=' * 10)\n\n----------\n**********\n==========",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "href": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "title": "ملحق K — النص",
    "section": "المحاذاة والحشو",
    "text": "المحاذاة والحشو\n\nname = 'Adam'\nprint(name.ljust(15)) \nprint(name.center(15))\n\nAdam           \n      Adam     \n\n\nطريقة ممتعة لتزيين سلسلة نصية باستخدام الإجراء center:\n\nprint('*' * 20)\nprint('Adam'.center(20, \"*\"))\nprint('*' * 20)\n\n********************\n********Adam********\n********************",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "href": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "title": "ملحق K — النص",
    "section": "تنسيق الأرقام",
    "text": "تنسيق الأرقام\n\nمحاذاة الأرقام\n\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\n       100\n      1000\n     10000\n\n\nيمكننا أيضًا جعل كل من العدد n والتعبئة p متغيرات:\n\nn = 100\np = 5\nprint(f'{n:{p}}')\n\n  100\n\n\nبشكل افتراضي، يتم محاذاة الرقم إلى اليمين. يمكننا محاذاته إلى اليسار بإضافة &lt;. لاحظ الفرق بين التعبيرين أدناه:\n\nprint(f'{n:&gt;{p}}')\nprint(f'{n:&lt;{p}}')\n\n  100\n100  \n\n\n\n\nفاصل الآلاف\n\nbig_num = 10000\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n10000\n10,000\n\n\n\n\nالترميز العلمي\n\nsmall_num = 0.00001\nprint(f\"{small_num:.2e}\")\n\n1.00e-05\n\n\n\n\nالأعداد العشرية\n\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\nمثال: تنسيق الكم المالي\n\nprice_dollars = 2978.95\nprice_riyals = price_dollars * 3.75\nprint(f\"${price_dollars:,.2f} = {price_riyals:,.2f} SAR\")\n\n$2,978.95 = 11,171.06 SAR",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html",
    "href": "chapters/07_strings/a2_unicode.html",
    "title": "ملحق L — ترميز الحروف",
    "section": "",
    "text": "ترميز (Unicode)\nترميز الحروف هي عملية تعيين أرقام للأحرف الرسومية مما يسمح بتخزينها ونقلها وتحويلها باستخدام الحواسيب الرقمية.\nرموز ASCII تحتوي على 128 حرف للغة الإنجليزية وبعض علامات الترقيم. منها 95 فقط هي أحرف قابلة للطباعة أما البقية فتسمى أحرف تحكُّم (مثل حرف السطر الجديد \\n ، وحرف الرجوع لبداية السطر \\r).\nثم امتدت عن طريق رموز ANSII لتغطي أحرف إضافية (من 128 إلى 255) وهي الأحرف الاتينية للغات الأخرى.\nلنستكشف السلاسل عن طريق حزمة من المكتبة الأساسية string. الآتي الأحرف اللاتينية الكبيرة والصغيرة، وعلامات الترقيم:\nواليوم رموز Unicode تحتوي على أكثر من مليون حرف لتغطية لغات العالم كافة: اللاتينية، اليونانية، السيريلية، الأرمنية، العبرية، العربية، السريانية، الثانا، الديفاناغارية، البنغالية، الجورموخية، الأورية، التاميلية، التيلوغوية، الكانادية، المالايالامية، السنهالية، التايلاندية، اللاوية، التبتية، الميانمارية، الجورجية، الهانغول، الإثيوبية، الشيروكية، الرموز الكندية الأصلية، الخميرية، المنغولية، الهان (الأيدوغراف الياباني، الصيني، الكوري)، الهيراغانا، الكاتاكانا، واليي. المصدر. وما يزال أول 128 حرف منها متطابق مع رموز ASCII.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "href": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "title": "ملحق L — ترميز الحروف",
    "section": "",
    "text": "مثال\nماذا يحصل لو كتبنا حروف عربية ثم حاولنا حفظ الملف بترميز ASCII ولم نحفظه بترميز Unicode؟\n\n\n\nبرنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات\n\n\nالخطأ يقول: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "href": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "title": "ملحق L — ترميز الحروف",
    "section": "كيف يتم تمثيل النصوص في بايثون؟",
    "text": "كيف يتم تمثيل النصوص في بايثون؟\nتمثيل النصوص في بايثون يكون عن طريق النوع str؛ يُعرَّف بكتابة سلسلة من الأحرف لكن في الواقع تتحول إلى سلسلة من رموز Unicode (أي: أرقام). هذا يعني أنها قد تكون سلسلة رموز لاتينية أو عربية أو صينية أو غير ذلك مما تحويه رموز Unicode.\nالإجراء المبني ord() تقوم بتحويل الحرف إلى رقم الرمز. بينما chr() تعكس ذلك (من الرمز إلى الحرف).\nعلى النقيض من سي وجافا؛ لا يوجد نوع خاص بالحرف الواحد (char) في بايثون.\n\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nماذا عن الحروف العربية؟ أين تقع في أرقام ترميز Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nلمعرفة أرقام الحروف في نصٍّ ما؛ نستعمل التكرار هكذا:\n\ns = \"'Arabian'\"\ncodes = []\nfor c in s:\n    codes.append(ord(c))\nprint(codes)\n\n[39, 65, 114, 97, 98, 105, 97, 110, 39]\n\n\n\ns = 'السَّلَامُ عَلَيْكُمْ'\ncodes = []\nfor c in s:\n    codes.append(ord(c))\nprint(codes)\n\n[1575, 1604, 1587, 1614, 1617, 1604, 1614, 1575, 1605, 1615, 32, 1593, 1614, 1604, 1614, 1610, 1618, 1603, 1615, 1605, 1618]\n\n\nفهذه هي الحروف في الواقع، إلا أننا نتعامل مع شيء مجرَّد في لغات البرمجة العالية غالبًا ما يسمى str.\nراجع ويكيبيديا: النص العربي في Unicode لمزيد من التفاصيل.\nوماذا عن الرموز؟\n\nprint(hex(ord(\"😄\")))\nprint(hex(ord(\"🚀\")))\n\n0x1f604\n0x1f680\n\n\n\nالأحرف البيضاء\nالأحرف في الأجهزة الرقمية على نوعين:\n\nأحرف طباعة: مثلاً: الأحرف اللاتينية والأرقام وعلامات الترقيم\nأحرف تحكم: مخفيَّة؛ والغرض منها التحكم بمعالج هذا النص\n\nلعرض الأحرف القابلة للطباعة في محارف آسكي (ASCII)، لدينا المتغير printable من مكتبة string:\n\nimport string\nstring.printable\n\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n\n\nكانت أحرف التحكُّم تستخدم لرن جرس الآلة الطابعة ، والتحكم بها ، لكن اليوم الذي يُستخدم منها غالبًا هو الأحرف البيضاء (Whitespace Characters) ويشمل ذلك الأحرف التالية:\n\nspace: \\s ويمثل المسافة التي بين الكلمات\ntab: \\t ويمثل المسافة التي بين أعمدة الجداول\nlinefeed: \\n تعليمة سطر جديد\nreturn: \\r تعليمة العودة لبداية السطر الجديد\nformfeed: \\f تعليمة الصفحة الجديدة\nvertical tab: \\v تعليمة العمود الجديد\nbackspace: \\b تعليمة عودة المؤشر بمقدار حرف واحد للكتابة فوق الحرف السابق\n\nأما الثلاثة الأخيرة فقد كانت تستخدم فيما مضى، لكن اليوم المستخدم هو الأربعة الأولى فقط. ويجدر بالذكر أن ملفات نصوص نظام ويندوز تستعمل \\r\\n للانتقال لسطر جديد بينما تستعمل الأنظمة الأخرى \\n فقط.\nتذكر أن بايثون تعتمد على space و tab للمسافة البادئة للسطر (indentation)، لتحديد نطاقات القطع البرمجية بحسب المحاذاة العمودية.\n\nimport string\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\nيهمنا هنا الأحرف البيضاء لأنها تظهر في النصوص وقد تكون مزعجة عند معالجتها. لنلقي نظرة على ثلاثة من الأحرف البيضاء: المسافة (space)، التبويب (tab)، وتعليمة السطر الجديد (linefeed).\n\n# Tab character: \"\\t\"\nprint('A\\tB')\n\nA   B\n\n\n\n# Space character: \" \"\nprint('   A            B   ')\n\n   A            B   \n\n\n\n# Newline character: '\\n'\nprint('A\\nB')\n\nA\nB\n\n\nلاحظ أن طول السلسلة النصية هو عدد الأحرف في السلسلة، سواء كانت قابلة للطباعة (printable) أو أحرف بيضاء (whitespace).\n\nassert len('A B') == 3\nassert len('A\\tB') == 3\nassert len('A\\nB') == 3\n\n\n\nالأطراف الزائدة\nلاحظ أن هذا الإجراء سيزيل الأحرف البيضاء من بداية ونهاية السلسلة النصية، ولكن ليس الأحرف البيضاء في منتصف السلسلة\nقبل:\n\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\nبعد:\n\nprint(text.strip())\n\nhello    world\n\n\n\n\nتجزئة النص\nانظر: Splitlines\n\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\nإذا تركنا القطعة البرمجية كما هي في السطر من غير print فإن ذلك يعرض السلسلة النصية كما هي (بما في ذلك أحرف المسافات البيضاء)\n\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\nأما إذا وضعنا print فإنه يطبع الأحرف المرئية ، وينسِّقُ المظهر بناءً على أحرف التحكُّم المخفية:\n\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\nإذا لم نحدد محدد الفاصل فإن الفاصل الافتراضي هو المسافة.\n\nprint(\"Hello, world\".split())\n\n['Hello,', 'world']\n\n\nهنا نحدد الفاصل أنه الحرف \"l\":\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\nلإزالة الأحرف البيضاء جميعها؛ نستعمل التكرار هكذا:\n\ntext = '\\t hello    world \\n\\n\\n'\nsp = text.split()\nprint('split:', sp)\nclean = ' '.join(sp)\nprint('clean:', clean)\n\nsplit: ['hello', 'world']\nclean: hello world\n\n\nالفصل في الداخل ينتج قائمة من النصوص، بعضها فارغ لوجود الأحرف البيضاء المتتالية، فلا تتضمن في القائمة الناتجة.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#الطباعة",
    "href": "chapters/07_strings/a2_unicode.html#الطباعة",
    "title": "ملحق L — ترميز الحروف",
    "section": "الطباعة",
    "text": "الطباعة\n\nحروف التحكم بآلة الطباعة\nيسمّى الحرف \\r بالعودة للبداية لأنه يعني فعل يقوم بإرجاع المؤشر إلى بداية السطر.\nكانت آلة الطباعة قديمًا يتحرك رأس الطباعة فيها بعد طباعة كل حرف. ثم عندما ينتهي السطر، يجب على الشخص أن يقوم بعمليتين:\n\nالضغط على المفتاح الذي يرفع الورقة بمقدار سطر (ويرمز له بالحرف \\r)\nالضغط على المفتاح الذي يرجع رأس الطباعة لبداية السطر (ويرمز له بالحرف \\n)\n\nوهما مستخدمان اليوم فيما يُعرض على الشاشة.\nففعل print في الحقيقة يضع سطرًا جديدًا (حرف \\n) في الوضع الافتراضي. فإن أردنا ألا يضعه، فنحدد العامل end الذي فيه على النحو التالي:\n\nprint('Hello', end='')\nprint('World', end='')\n\nHelloWorld\n\n\nلاحظ أننا جعلنا (end='') أي: لا نريده أن يضع حرفًا بعد طباعة النص. ولذلك ظهرت الكلمتان في نفس السطر.\nولو أردت أن تعيد الكتابة على نفس السطر، يمكنك أن تضع الحرف (\\r) الذي يفعل رأس الطباعة بالرجوع لبداية السطر:\n\nprint('123', end='\\r')\nprint('45')\n\n12345\n\n\nلاحظ أن النتيجة هي طباعة الحرفين 45 فوق الحرفين 12 مع بقاء الحرف الأخير 3 في الأخير. وذلك لرجوع رأس الطباعة.\nتستعمل هذه اللطيفة في تحديث العداد حتى يظهر على الشاشة وكأنه يزيد شيئًا فشيئًا. وذلك على النحو التالي (لاحظ أننا نستعمل time.sleep(t) حتى نمثِّل وجود عمليَّة تأخذ وقتًا طويلاً فحسب):\nimport time\n\nfor x in range(10 + 1):\n    time.sleep(0.20)\n    print(f'[{x}/10] ' + '===' * x + '&gt;', end='\\r')",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/regex.html",
    "href": "chapters/07_strings/regex.html",
    "title": "ملحق M — التعبير النمطي",
    "section": "",
    "text": "التعبير النمطي (re)\nإليك جدول مختارات من إجراءات التعبير النمطي وكائناته:",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>M</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/regex.html#التعبير-النمطي-re",
    "href": "chapters/07_strings/regex.html#التعبير-النمطي-re",
    "title": "ملحق M — التعبير النمطي",
    "section": "",
    "text": "الإجراء\nعمله\n\n\n\n\nre.match(pattern, string, flags=0) -&gt; Match or None\nمطابقة النمط في بداية السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.\n\n\nre.search(pattern, string, flags=0) -&gt; Match or None\nالبحث عن أول تطابق للنمط في السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.\n\n\nre.findall(pattern, string, flags=0) -&gt; list\nإنشاء قائمة من جميع التطابقات للنمط في السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.\n\n\nre.finditer(pattern, string, flags=0) -&gt; Iterator[Match[str]]\nإنشاء مكرر لجميع التطابقات للنمط في السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>M</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/regex.html#المطابق-match",
    "href": "chapters/07_strings/regex.html#المطابق-match",
    "title": "ملحق M — التعبير النمطي",
    "section": "المطابق (Match)",
    "text": "المطابق (Match)\n\n\n\n\n\n\n\nالفعل\nعمله\n\n\n\n\nmatch.group([group]) -&gt; str\nإرجاع النص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاعها (افتراضيًا المجموعة الكاملة).\n\n\nmatch.groups(default=None) -&gt; tuple\nإرجاع جميع المجموعات الفرعية كنصوص.• default: القيمة الافتراضية للمجموعات غير المطابقة.\n\n\nmatch.groupdict(default=None) -&gt; dict\nإرجاع القاموس الذي يحتوي على المجموعات المسماة.• default: القيمة الافتراضية للمجموعات غير المطابقة.\n\n\nmatch.start([group]) -&gt; int\nإرجاع موضع بداية النص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاع موضع بدايتها (اختياري).\n\n\nmatch.end([group]) -&gt; int\nإرجاع موضع نهاية النص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاع موضع نهايتها (اختياري).\n\n\nmatch.span([group]) -&gt; tuple\nإرجاع موضع البداية والنهاية للنص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاع مواضعها (اختياري).\n\n\nmatch.pos -&gt; int\nموضع بداية البحث في السلسلة النصية.\n\n\nmatch.endpos -&gt; int\nموضع نهاية البحث في السلسلة النصية.\n\n\nmatch.lastindex -&gt; int or None\nرقم آخر مجموعة فرعية مطابقة أو None إذا لم توجد.\n\n\nmatch.lastgroup -&gt; str or None\nاسم آخر مجموعة فرعية مطابقة أو None إذا لم توجد.\n\n\nmatch.re -&gt; Pattern\nكائن النمط المستخدم في المطابقة.\n\n\nmatch.string -&gt; str\nالسلسلة النصية التي تم مطابقتها.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>M</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/regex.html#تحرير-التعبيرات-النمطية",
    "href": "chapters/07_strings/regex.html#تحرير-التعبيرات-النمطية",
    "title": "ملحق M — التعبير النمطي",
    "section": "تحرير التعبيرات النمطية",
    "text": "تحرير التعبيرات النمطية\nننصح باستعمال أدوات تحرير التعبير النمطي مثل: regex101 فهي أفضل بكثير من كتابته دون أداة.\n\nفي القائمة الجانبية اختر نكهة (Flavour) Python\nفي الحقل الأول تكتب التعبير النمطي\nفي الصندوق الكبير تضع النص الذي تريد مطابقته\n\nوكذلك يوجد محرر آخر مثل regexr وفي القائمة الجانبية تجد Community Patterns حيث تجد فهرس لأنماط نصية شاركها المبرمجون الآخرون. أو في: regexHQ.\nوهكذا فإنك تعدل على النمط وتزيد في النصوص، حتى تصل إلى أفضل نمط لتنسخه وتضعه عندك في البرنامج.\nوهذا المحرر يستعمل نفس محرك: pythex.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>M</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/regex.html#مصادر-أخرى-لتعلم-التعبيرات-النمطية",
    "href": "chapters/07_strings/regex.html#مصادر-أخرى-لتعلم-التعبيرات-النمطية",
    "title": "ملحق M — التعبير النمطي",
    "section": "مصادر أخرى لتعلم التعبيرات النمطية",
    "text": "مصادر أخرى لتعلم التعبيرات النمطية\n\nLearn Regex The Easy Way\n\nدروس تفاعلية لتعلم التعبيرات النمطية:\n\nRegexLearn\nRegexOne",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>M</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html",
    "href": "chapters/09_files_and_directories/a1_file_io.html",
    "title": "ملحق N — الملفات",
    "section": "",
    "text": "عمليات المسار\nوإليك تصنيف لعمليات مكتبة pathlib:",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#المسار",
    "href": "chapters/09_files_and_directories/a1_file_io.html#المسار",
    "title": "ملحق N — الملفات",
    "section": "المسار",
    "text": "المسار\nالمسار هو سلسلة تحدد موقع الملف في النظام. وهو على نوعين:\n\nمطلق (Absolute): يحدد المسار بشكل كامل بدءًا من الجذر.\nنسبي (Relative): يحدد المسار بالنسبة لموقع الملف الحالي.\n\nوفواصل المسار شرطة مائلة:\n\n/ تميل للأمام (اليمين) في عُرف أنظمة ويندوز\n\\ تميل للخلف (اليسار) في عُرف أنظمة يونكس\n\nوالنقطة والنقطتان تدل على نسبية المسار:\n\n. للدليل الحالي (هنا)\n.. للدليل الأب (صعود)\n\n\n\n\n\nPath\nExample\n\n\n\n\nAbsolute\n/home/adam/projects/xyz/scripts/analysis.py\n\n\nRelative\n.\n\n\nRelative\n..\n\n\nRelative\n./a/b\n\n\nRelative\n../a/b\n\n\nRelative\na/b\n\n\n\n\nيتم ترتيب الملفات شجريًّا.\nففي نظام ويندوز (Windows) تكون الشرطة خلفية (\\):\nC:\\\n└── Users\n    └── Adam\n        └── MyProject\n            ├── data\n            │   └── datafile.csv\n            └── scripts\n                └── analysis.py\nفالحرف الأوَّل في الأعلى (C:) يمثِّل مكان جهاز التخزين. وإن رأيت D: أو E: فيعني أن الملفات تخزن في جهازين آخرين.\nوقد تتساءل لماذا لم نبدأ بالحرف A: أو B:؟ وسبب ذلك تاريخي. وذلك أنَّهما كانا محجوزين للإشارة لجهاز تخزين عتيق يسمى القرص المرن (floppy disk)، ولم يعد يستعمل.\nأما في أنظمة لينكس (Linux) وماك (MacOS) فإن الأصل يعبَّر عنه لا بحرف، وإنما بالمسار الجذر: / على النحو التالي:\n/\n└── home\n    └── adam\n        ├── projects\n            └── myproject\n                ├── data\n                │   └── datafile.csv\n                └── scripts\n                    └── analysis.py\nوتسمى الملفات المتضمنة لملفات أخرى: دليل (Directory). وهو الذي يعبَّر عنه فيما ترى في الواجهة الرسومية على شكل مجلَّد (Folder).\n\n\n\nFolder Icon\n\n\nفإذًا الملفات على نوعين:\n\nملف (File): وهو الذي يحوي بيانات نصية أو ثنائية. مثل:\n\ndatafile.csv ملف بيانات جدولية \nanalysis.py ملف برنامج بايثون \n\nدليل (Directory): وهو قائمة من الملفات والأدلة. مثل:\n\ndata دليل / مجلد البيانات \nmyproject دليل / مجلد المشروع \n\n\nصيغة الملف (File Extension) تُعرَفُ بالحروف بعد آخر نقطة. مثل:\n\ndatafile.csv صيغة csv\nanalysis.py صيغة py",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#قراءة-وكتابة-الملفات",
    "href": "chapters/09_files_and_directories/a1_file_io.html#قراءة-وكتابة-الملفات",
    "title": "ملحق N — الملفات",
    "section": "قراءة وكتابة الملفات",
    "text": "قراءة وكتابة الملفات\nيتم فتح الملفات لغرض القراءة أو الكتابة بالإجراء open() هكذا:\nf = open(file='salam.txt', mode='r')\ncontent = f.read()\nf.close()\n\nprint(content)\n\nتم تحديد مسار الملف بالنسبة للملف الذي نحن فيه\nتم تحديد وضع القراءة: mode='r' عند الفتح (open())\nيتم قراءة المحتوى النصي للملف بالفعل: .read() المُسنَد إلى الملف file؛ ونعين قيمة ذلك في المتغير content\nيتم إغلاق الملف حتى يستطيع برنامج آخر أن يفتحه؛ إذ لا يجيز نظام التشغيل أن يُفتح الملف في نفس الوقت من برنامجين مختلفين\nتتم طباعة المحتوى الذي قُرئ\n\nأما فتحُ الملف لغرض القراءة، فيتم بتحديد وضعية القراءة open(mode='w') على النحو التالي:\ncontent = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\n\nf = open(file='salam.txt', mode='w')\nf.write(content)\nf.close()\n\nprint(content)\nانظر مرجع قراءة وكتابة الملفات.\nولأن الفتح والإغلاق مقترنان في الموارد (Resources) المتنازع عليها (والذي يديرها نظام التشغيل)؛ فلا بد من الإغلاق بعد كل فتح. ووضع في اللغة مفهوم مدير السياق حيث يستعمل معها جملة with: فيكون ما بداخلها يعمل في سياق توفر المورِد، فإذا انتهت القطعة أغلِق المورِد تلقائيًّا. وبالمثال يتضح المقال:\ncontents = ''\nwith open(file='salam.txt', mode='r') as f:\n    contents = f.read()\nprint(contents)\nلاحظ أننا لم نحتج لفعل الإغلاق: f.close() بل يتم ذلك بعد آخر جملة مضمَّنة داخل نطاق with.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#مكتبة-المسار-pathlib",
    "href": "chapters/09_files_and_directories/a1_file_io.html#مكتبة-المسار-pathlib",
    "title": "ملحق N — الملفات",
    "section": "مكتبة المسار (pathlib)",
    "text": "مكتبة المسار (pathlib)\n\nfrom pathlib import Path\n\nتعنى مكتبة المسار (pathlib) بجميع ما يخص المسار: إنشائه والبحث فيه والاستعلام عن مدلوله والسير فيه.\n\n\n\n\n\n\nملاحظة\n\n\n\nيجدر بالذكر أن مكتبة pathlib جاءت متأخرة في إصدار Python 3.4 لمعالجة الملفات بأسلوب البرمجة الشيئية (OOP)، بينما تستعمل مكتبة os التي سبقتها لأغراض متعددة فيما يخص نظام التشغيل (os = Operating System) من ضمنها خُصِّصَت os.path للتتعامل مع نظام الملفات إلا أنها كُتِبَت بأسلوب إجرائي تأسيًّا بلغة سي (C)، فهي منخفضة المستوى (تتعامل مباشرة مع bytes و str) بالمقارنة بالبرمجة الشيئية الأعلى في التجريد؛ وهو ما نفضله. انظر مقارنة pathlib بوحدات os و os.path.\n\n\nويستعمل المسار Path مكان النص بعد إنشائه على النحو التالي:\np = Path('salam.txt')\n\ncontents = ''\nwith open(file=p, mode='r') as f:\n    contents = f.read()\nprint(contents)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#الدليل-directory",
    "href": "chapters/09_files_and_directories/a1_file_io.html#الدليل-directory",
    "title": "ملحق N — الملفات",
    "section": "الدليل (Directory)",
    "text": "الدليل (Directory)\nأحيانًا نريد التعامل مع مجلَّد يحوي مجموعة ملفات، بنقلها أو نسخها أو حذفها ونحو ذلك.\nانظر قراءة الأدلة.\nلعرض قائمة الدليل، نستعمل المكرر الناتج من فعل .iterdir() ونكرر عليه، وهو بدورِه يُنتج في كل كرةٍ مساراً (x). وهذا المسار يُمكن التحقق من أنه يشير إلى دليل أو لا (x.is_dir()) على النحو التالي:\np = Path('.')\ndirs = [x for x in p.iterdir() if x.is_dir()]\ndirs\n\nجرب\nهل تريد أن تعرف حجم دليل التنزيلات (Downloads) في جهازك؟. لديك الفعل stat() للحصول على بيانات عن الدليل، والتي من ضمنها الحجم (st_size) هكذا:\np = Path.home() / 'Downloads'\nsize = p.stat().st_size\nprint(size, 'bytes')\nثم هذا الإجراء لتحويل الوِحدة من البايت إلى الكيلو والميجا والقيقا:\ndef format_size(size):\n    size_kb = size / 1024\n    size_mb = size_kb / 1024\n    size_gb = size_mb / 1024\n    if size_gb &gt; 0.1:\n        return f'{size_gb:.2f} GB'\n    elif size_mb &gt; 0.1:\n        return f'{size_mb:.2f} MB'\n    return f'{size_kb:.2f} KB'\n\nprint(format_size(size))",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#البحث-العام",
    "href": "chapters/09_files_and_directories/a1_file_io.html#البحث-العام",
    "title": "ملحق N — الملفات",
    "section": "البحث العام",
    "text": "البحث العام\nيستعمل البحث العام (Globbing) لمطابقة عدة ملفات تحت مسار معيَّن بنمط معيَّن.\nوهي لغة تنميط بسيطة جدًّا لا تقارن بتعقيد التعبيرات النمطية (Regular Expression) التي سبق ذكرها. وإليك تطبيقًا تفاعليًّا يجمع لك جميع مفاهيمها: globster.\nمثلاً: نبحث في المسار path/to/my/pictures/ عن جميع الصور (ذات الصيغة .jpg) في كل ما يتفرع عن ذلك المسار وإن نزل:\ntotal_size = 0\nfor p in Path('path/to/my/pictures/').glob('**/*.jpg'):\n    total_size += p.stat().st_size\n\nprint('Total size:', total_size, 'bytes')\nprint('Total size:', format_size(total_size))",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#المشي-على-جميع-ملفات-الشجرة",
    "href": "chapters/09_files_and_directories/a1_file_io.html#المشي-على-جميع-ملفات-الشجرة",
    "title": "ملحق N — الملفات",
    "section": "المشي على جميع ملفات الشجرة",
    "text": "المشي على جميع ملفات الشجرة\nنستعمل الفعل .walk() لطرق جميع فروع المسار:\n\np = Path('../../datasets/example_root/')\nfor dirpath, dirnames, filenames in p.walk(top_down=True):\n    print(dirpath)\n    for file in filenames:\n        print(f'\\t{file}')\n        # print('\\tFULL PATH:', Path(dirpath) / file)\n\n../../datasets/example_root\n    something.txt\n../../datasets/example_root/a\n    a.txt\n    A_domestic_cat.jpgZone.Identifier\n    zzz.txt\n    A_domestic_cat.jpg\n../../datasets/example_root/b\n    A_yellow_and_white_cat.jpgZone.Identifier\n    A_yellow_and_white_cat.jpg\n    b.txt\n    DSC0532_(9120523417).jpg\n    DSC0532_(9120523417).jpgZone.Identifier\n../../datasets/example_root/c\n    c.txt\n../../datasets/example_root/c/c_inner\n    inner.txt\n\n\nلاحظ أن .walk() يعطينا ثلاثة قيَم في كل كرة:\n\ndirpath: المسار الحالي للدليل.\ndirnames: قائمة بأسماء الأدلة التي يدل عليها.\nfilenames: قائمة بأسماء الملفات التي يدل عليها.\n\nلإظهار كامل المسار؛ أزل علامة التعليق # من السطر الأخير لتنفيذه.\nمصادر أخرى\n\nإذا كنت تريد قراءة الملفات وكتابتها بشكل بسيط انظر: open().\nوإذا كنت تريد التعامل مع الملفات المؤقتة فانظر: tempfile.\nوكثير من عمليات التعامل مع الملفات والأدلة تجدها في: shutil.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/11_oop/a1_oop.html",
    "href": "chapters/11_oop/a1_oop.html",
    "title": "ملحق O — البرمجة الكائنية",
    "section": "",
    "text": "التغليف\nالتغليف (Encapsulation) آلية لإخفاء عمليات تفصيلية معقدة على البيانات المكنونة خلف إجراءات بسيطة.\nفحينما عرفنا المتغير كصفة: count في الشيء Counter، أبرزنا من الإجراءات: increment فقط. وكأننا نقول: لا يمكن أن يعدِّل المستفيد على المتغير count إلا عن طريق الإجراء increment. وصحيح أنك تستطيع الوصول من الخارج إلى صفة المعيَّن: c1.count لتعديلها مباشرةً، إلا أن ذلك يخالف آلية التغليف.\nفي المثال التالي لا نريد للمستفيد أن يعدِّل على الرصيد balance إلا عن طريق الإجراء deposit الذي يضمن أمرين:\nيتم ذلك في بايثون عن طريق جعل الصفة نفسها (balance) مخفيَّة، ونبدلها بصفة محميَّة: __balance بشرطتين سفليتين متقدِّمة. ثم نُبرِزُ الصفة عن طريق فعل قراءة؛ وذلك باستعمال المعدِّل @property، وهو يجعل الفعل balance يبرز كصفة بلا قوسين للاستدعاء balance() وذلك يعني أن مجرَّد عملية الوصول إلى الصفة (بعلامة النقطة: .) هو في الحقيقة استدعاء لفعل يعود بقيمة، لا بالصفة التي يمكن تعديلها.\nclass Account:\n    def __init__(self, name, balance):\n        self.name = name\n        self.__balance = balance\n\n    # الإيداع\n    def deposit(self, amount):\n        # قبليات الإيداع\n        if amount &lt;= 0:\n            print(\"must be positive\")\n            return\n        \n        # الإيداع نفسه\n        self.__balance += amount\n\n        # بعديات الإيداع\n        print('time of deposit:', '2027-07-07')\n\n    @property\n    def balance(self):\n        return self.__balance\nنقوم الآن بإنشاء هذا الشيء الذي يمثِّل حساب المستخدم (Account)، ثم نصِل إلى الصفة بعلامة النقطة: a1.balance؛ فيكون ذلك استدعاءً للإجراء الذي تم وضع المعدِّل @property عليه ليكون الوصول إليه كالصفة:\na1 = Account('Adam', 100)\na1.balance\n\n100\nولو حاولت التغيير مباشرة على الصفة فإنك أصلاً لن تجد اسمها مُسندًا إلى الشيء:\na1.balance = 1000\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 a1.balance = 1000\n\nAttributeError: property 'balance' of 'Account' object has no setter\nلكن يجوز فقط قراءة الصفة (قيمتها) لا التعديل عليها، هكذا (بعد الإيداع مثلاً):\na1.deposit(100)\na1.balance\n\ntime of deposit: 2027-07-07\n\n\n200\nوليظهر أثر الحماية، نجرِّب إيداع مبلغ سالب، ولاحظ رسالة الخطأ:\na1.deposit(-44)\n\nmust be positive\nوهكذا نتصوَّر الشيء كأنه آلة مزوَّّدة بآليات عامَّة يسهل استعمالها في ظروف كثيرة بحيث تغير هذه الآليات من حالة الشيء في كل مرة ليؤدي وظائف معقَّدة لا تتم بسهول بمجرَّد إجراء ذو خطوات محددة دائمًا بتسلسل واحد.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>البرمجة الكائنية</span>"
    ]
  },
  {
    "objectID": "chapters/11_oop/a1_oop.html#التغليف",
    "href": "chapters/11_oop/a1_oop.html#التغليف",
    "title": "ملحق O — البرمجة الكائنية",
    "section": "",
    "text": "قبليات (pre-conditions): كاشتراط أن الزيادة تكون موجبة قبل البدء\nبعديات (post-conditions): ضمان تسجيل تاريخ العملية بعد التمام",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>البرمجة الكائنية</span>"
    ]
  },
  {
    "objectID": "chapters/11_oop/a1_oop.html#العرض",
    "href": "chapters/11_oop/a1_oop.html#العرض",
    "title": "ملحق O — البرمجة الكائنية",
    "section": "العَرض",
    "text": "العَرض\nنريد أن نعرِّف نوعًا جديدًا للإحداثيات (Point) ونريد أن نعرضها في جملة print بتمثيل يعبِّر عنها كإحداثيات.\nيستعمل الفعل الخاص __repr__، ويعني التمثيل (Representation) لتخصيص طريقة عرض الشيء؛ سواءٌ إذا تم تمرير في print أو في آخر سطر من الخلية. كل ما عليك هو إعادة قيمة نصيَّة من ذلك الفعل.\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\nوالآن إن عرفنا نقطة جديدة، ووضعناها على السطر لوحدها ، ستظهر لنا الإحداثيات، لا عنوانها في الذاكرة:\n\np = Point(3, 4)\np.move(7, 6)\np\n\nPoint(10, 10)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>البرمجة الكائنية</span>"
    ]
  },
  {
    "objectID": "chapters/11_oop/a1_oop.html#الإجراء-المثبت",
    "href": "chapters/11_oop/a1_oop.html#الإجراء-المثبت",
    "title": "ملحق O — البرمجة الكائنية",
    "section": "الإجراء المُثبَت",
    "text": "الإجراء المُثبَت\nالإجراء المُثبَت (Static Method): هو الإجراء المسند إلى النوع لا للمعيَّن.\nفيمكن إسناد الإجراء للجنس لا للشيء الواحد، وذلك بإضافة المعدِّل @staticmethod عليه. ونمثل لذلك بإجراء حساب المسافة بين نقطتين: distance. ولاحظ عدم وجود self فيه:\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2, distance_type='euclidean'):\n        if distance_type == 'euclidean':\n            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n        elif distance_type == 'manhattan':\n            return abs(p1.x - p2.x) + abs(p1.y - p2.y)\n\nثم يستعمل كأي إجراء، لكن بإسناده إلى النوع:\n\np1 = Point(3, 4)\np2 = Point(7, 6)\nd = Point.distance(p1, p2, 'manhattan')\nprint('distance:', d)\n\ndistance: 6",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>البرمجة الكائنية</span>"
    ]
  },
  {
    "objectID": "chapters/11_oop/a1_oop.html#المتغير-المثبت",
    "href": "chapters/11_oop/a1_oop.html#المتغير-المثبت",
    "title": "ملحق O — البرمجة الكائنية",
    "section": "المتغير المُثبَت",
    "text": "المتغير المُثبَت\nالمتغير المُثبَت (Static Variable): هو المتغير المسند إلى النوع لا للمعيَّن.\nيُسنَد المتغير للنوع بتعيينه بمحاذاة غيره من الإجراءات نحو ما فعلنا هنا بالمتغير decor. ولاحظ استعماله في الإجراء __repr__ في جملة if-else من غير استعمال self لأننا لا نشير إلى معيَّن.\n\nclass Point:\n    decor = '&lt;&gt;'\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        if Point.decor == '&lt;&gt;':\n            return f\"&lt;{self.x}, {self.y}&gt;\"\n        elif Point.decor == '[]':\n            return f\"[{self.x}, {self.y}]\"\n        else:\n            return f\"({self.x}, {self.y})\"\n\nفيمكن الآن تعديل المتغير decor للنوع:\n\np1 = Point(3, 4)\np2 = Point(7, 6)\nprint(p1, p2)\n\nPoint.decor = '[]'\nprint(p1, p2)\n\n&lt;3, 4&gt; &lt;7, 6&gt;\n[3, 4] [7, 6]",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>البرمجة الكائنية</span>"
    ]
  },
  {
    "objectID": "chapters/11_oop/a1_oop.html#هيكل-البيانات",
    "href": "chapters/11_oop/a1_oop.html#هيكل-البيانات",
    "title": "ملحق O — البرمجة الكائنية",
    "section": "هيكل البيانات",
    "text": "هيكل البيانات\nتختلف كفاءة استرجاع البيانات وكتابتها والتعديل عليها بحسب شكل هذه البيانات في الذاكرة وشكلها على جهاز التخزين فعليًّا. وهذا ما نسميه بهيكلة البيانات (Data Structure). ومن أمثلة ذلك:\n\nالمصفوفة (Array)\nالشجرة (Tree)\nالرسم (Graph)\n\nوغيرها كثير. وسنمثل على ذلك بتشكيل الكومة في بايثون:\n\nالكومة (Stack)\nنريد أن نعرِّف نوعًا من هياكل البيانات يسمى الكومة (Stack)، وكأنه يمثِّل مجموعة مكدسة من الأوراق؛ إذ له فعلين:\n\nوضع ورقة: push(item) وكأنك تضع ورقة فوق الأوراق السابقة\nسحب ورقة: pop() وكأنك تسحب ورقةً من الأعلى\nلمحة سريعة: peek() وكأنك تنظر إلى الورقة العليا دون سحبها\n\nوأقرب شيء له في بايثون هو القائمة (list) ولذلك ستكون هي تمثيلها الداخلي.\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        return self.items.pop()\n    \n    def peek(self):\n        return self.items[-1]\n    \n    def __len__(self):\n        return len(self.items)\n\n    def __repr__(self):\n        return f\"|{'|'.join(str(item) for item in self.items)}&gt;\"\n\n\nفعل الإنشاء يُسنِد قائمة فارغة إلى الشيء (self)\nفعل push يضيف إلى آخر هذه القائمة بالفعل append\nفعل pop يأخذ آخر عنصر من القائمة بالفعل pop (وهو إزالة مع أخذ)\nفعل __len__ لمعرفة عدد العنصار في هذا الهيكل\nفعل __repr__ يعطينا تمثيلاً للكومة بالاعتماد على تمثيل القائمة\n\nنجرب الآن أن ننشئها ثم نضع أربعة عناصر فيها ونظهرها:\n\ns = Stack()\ns.push(10)\ns.push(20)\ns.push(30)\ns.push(400)\nprint(s)\n\n|10|20|30|400&gt;\n\n\nوالآن نسحب عنصرًا (من الأخير)، ونظهرها:\n\ns.pop()\nprint(s)\n\n|10|20|30&gt;\n\n\nويمكن النظر في العنصر الأعلى دون سحبه بالفعل peek:\n\nprint(s.peek())\n\n30\n\n\nونستطيع أن نعدها:\n\nlen(s)\n\n3\n\n\n\nاستعمال الكومة\nإذا كان لديك نص تريد التحقق من توازن الأقواس فيه، بحيث يكون لكل قوسٍ مفتوح قوسٌ يغلقه، فالكومة تساعدك في حل مثل هذه المسألة (انظر التوكيدات في الأسفل):\n\ndef is_balanced(text: str) -&gt; bool:\n    \"\"\"Check if the text has balanced parentheses.\"\"\"\n    stack = Stack()\n    for character in text:\n        if character == '(':\n            stack.push(character)\n        elif character == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()    \n    return len(stack) == 0\n\n\nassert is_balanced('()')\nassert is_balanced('(())')\nassert not is_balanced('(()')\nassert not is_balanced('((()')\nassert not is_balanced('())))')",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>البرمجة الكائنية</span>"
    ]
  },
  {
    "objectID": "appendix/appendix_collections.html",
    "href": "appendix/appendix_collections.html",
    "title": "ملحق P — خريطة الجُمُوع",
    "section": "",
    "text": "classDiagram\n    class Container {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n    }\n\n    class Iterable {\n        &lt;&lt;abstract&gt;&gt;\n        +__iter__()\n    }\n\n    class Iterator {\n        &lt;&lt;abstract&gt;&gt;\n        +__next__()\n    }\n\n    class Reversible {\n        &lt;&lt;abstract&gt;&gt;\n        +__reversed__()\n    }\n\n    class Sized {\n        &lt;&lt;abstract&gt;&gt;\n        +__len__()\n    }\n\n    class Collection {\n        &lt;&lt;abstract&gt;&gt;\n    }\n\n    class Sequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +index()\n        +count()\n    }\n\n    class MutableSequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__setitem__()\n        +__delitem__()\n        +__len__()\n        +insert()\n        +append()\n        +clear()\n        +reverse()\n        +extend()\n        +pop()\n        +remove()\n        +__iadd__()\n    }\n\n    class Set {\n        &lt;&lt;abstract&gt;&gt;\n        +__le__()\n        +__lt__()\n        +__eq__()\n        +__ne__()\n        +__gt__()\n        +__ge__()\n        +__and__()\n        +__or__()\n        +__sub__()\n        +__xor__()\n        +isdisjoint()\n    }\n\n    class MutableSet {\n        &lt;&lt;abstract&gt;&gt;\n        +add()\n        +discard()\n        +clear()\n        +pop()\n        +remove()\n        +__ior__()\n        +__iand__()\n        +__ixor__()\n        +__isub__()\n    }\n\n    class Mapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +keys()\n        +items()\n        +values()\n        +get()\n        +__eq__()\n        +__ne__()\n    }\n\n    class MutableMapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__setitem__()\n        +__delitem__()\n        +pop()\n        +popitem()\n        +clear()\n        +update()\n        +setdefault()\n    }\n\n    class str {\n        ...\n    }\n\n    class bytes {\n        ...\n    }\n\n    Iterable &lt;|-- Iterator\n    Iterable &lt;|-- Reversible\n\n    Sized &lt;|-- Collection\n    Iterable &lt;|-- Collection\n    Container &lt;|-- Collection\n\n    Reversible &lt;|-- Sequence\n    Collection &lt;|-- Sequence\n    Sequence &lt;|-- MutableSequence\n    Collection &lt;|-- Mapping\n    Mapping &lt;|-- MutableMapping\n\n    MutableSequence &lt;-- list\n    Sequence &lt;-- tuple\n    Sequence &lt;-- range\n    Sequence &lt;-- str\n    Sequence &lt;-- bytes\n    MutableMapping &lt;-- dict\n\n    Collection &lt;|-- Set\n    Set &lt;|-- MutableSet\n    MutableSet &lt;-- set\n    Set &lt;-- frozenset\n\n\n\n\nشكل P.1: الأنواع المجردة حول الجمع (Collection)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>P</span>  <span class='chapter-title'>خريطة الجُمُوع</span>"
    ]
  }
]