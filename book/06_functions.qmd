---
title: الدوال
jupyter: python3
---

**Functions** are code blocks that can be called, each time with (possibly) different arguments. You can think of functions as small programs that do a specific task. They can take input, perform some operations, and return output.

We have actually been using **built-in** functions like: `print()`, `input()`, and `int()`. We have also seen some functions from the [`math`](https://docs.python.org/3/library/math.html) **standard library** module like: `math.sqrt()` and `math.pow()`.

## Why use functions?

Core ideas behind using functions are:

Firstly, **Abstraction**: hiding low-level details behind a simpler, higher-level idea with a name.

Secondly, **Modularity**: dividing a system into components, each of which can be designed, implemented, tested, reasoned about, and reused separately from the rest of the system.

Thirdly, **Composition**: combining these modular abstractions in various ways to create higher-level abstractions.

Python provides other constructs related to these ideas: functions (our topic today), classes, modules, and packages. We will cover these in later chapters.

## Function definition

Let's define a function that does something useful.

```{python}
def check_password_strength(password):
    if len(password) < 8:
        return "Weak"
    else:
        return "Strong"
```

Now let's call the function. Notice, the returned value is stored in the `result` variable.

```{python}
result = check_password_strength("shorty")
print('password is:', result)

result = check_password_strength('verylongpassword')
print('password is:', result)
```

The keyword `def` introduces a function definition. It must be followed by the function name and the parenthesized list of **formal parameters** (`password` here is a parameter). The statements that form the body of the function start at the next line, and must be indented.

When we **call** the function, we *input* the **actual parameters** (also called **arguments**). In the example above, `"shorty"` and `'verylongpassword'` are the arguments in the first and second calls to the same function. The `return` statement is used to *output* a value from the function.


## Return statement exits the function

If we have multiple `return` statements, only one of them will be executed. Once a `return` statement is executed, the function will exit immediately. Example:

```
def function_name(parameters):
    if cond == True:
        return 'A'
    else:
        return 'B'
    # any code inside the function after the return statement will never be executed
```


## Variable Scope

Let's make our function more complete by adding a translation feature. We will define a dictionary that maps the strength of the password to different languages.

```{python}
LANGUAGE = 'AR'

translation = {
    'Weak': {
        'AR': 'ضعيفة',
        'CN': '弱'
    },
    'Strong': {
        'AR': 'قوية',
        'CN': '强'
    }
}

def check_password_strength(password):
    minimum_length = 8 #<1>
    if len(password) < minimum_length: # <2>
        return translation['Weak'][LANGUAGE] # <3>
    else:
        return translation['Strong'][LANGUAGE]
```
1. `minimum_length` is a variable local to the function: **local variable**.
2. The function can access `len()` because it is built-in. And it can access `minimum_length` since it is a local variable.
3. The function can also access `LANGUAGE` and `translation` since both are **global variables** (not within any function)

If we try to access the local variable `minimum_length` outside the function, we will get an error:

```{python}
#| error: true
print(minimum_length)
```

If you prefer mneumonics, then, **LEGB** (Local, Enclosing, Global, Built-in) is a good one to remember to determine which variable to access when a name is encountered. It searches for variables in the following order:

1. Local scope: The current function's code block.
2. Enclosing scopes: Any functions or loops enclosing the current function.
3. Global scope: The module's global namespace. That is, code not inside any of the functions.
4. Built-in names: Python's predefined functions and variables.

See [9.2.1. Scopes and Namespaces Example | Python Docs](https://docs.python.org/3/tutorial/classes.html#scopes-and-namespaces-example) for more details on how to reference the different scopes and namespaces, and how [`global`](https://docs.python.org/3/reference/simple_stmts.html#global) and [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) affect variable binding


## Default arguments

We can also define functions that have default values for some parameters. These are called **default arguments**.

```{python}
def greet(name, greeting='Hello'):
    return f'{greeting.upper()}, {name}!'

print(greet('Adam'))
print(greet('Belal', 'good morning'))
```

Notice, how in the first call to `greet()`, we only passed one argument, so the default value for `greeting` was used. But, in the second call, we passed both arguments, so the default value was overridden.


## Positional and keyword arguments

We say that arguments are the values passed to a function's parameters. It may be provided either:

1. by positional order
2. by keyword (name)
3. first by positional order and then by keyword

The function signature [`pow(base, exp, mod=None)`](https://docs.python.org/3/library/functions.html#pow) tells us that it has three parameters: `base`, `exp`, and `mod` in that order. Note that the `mod` parameter is optional. If we don't provide it, the function will use the default value `None`. Thus, we can call it in different ways:

```python
pow(2, 4) # <1>
pow(2, exp=4) # <2>
pow(base=2, exp=4) # <3>
pow(exp=4, base=2) # <4>
```
1. Positional arguments passed in order. Here: `2 is base` and `4 is exp`
2. 1st is positional argument (`2 is base`) and the 2nd is a keyword argument (`exp = 4`)
3. Just keyword arguments
4. Keyword arguments in a different order

Likewise, we can call our own functions postionally or by keywords.

Let's first define a function.

```{python}
def calculate_bmi(weight, height, unit='metric'):
    """ Calculate the Body Mass Index (BMI)
        
        weight and height must be of the same unit.

        unit is either 'metric' or 'imperial'.
    """
    if unit == 'imperial':
        weight *= 0.453592
        height *= 0.0254
    bmi = weight / (height ** 2)
    return round(bmi, 2)
```

Now we can call the function in different ways. Note the assert here is used to check that the function returns the same value regardless of how the arguments are passed.

```{python}
w = 70   # kg
h = 1.75 # meters

print(calculate_bmi(w, h))

assert (
    calculate_bmi(w, h) ==
    calculate_bmi(w, height=h) ==
    calculate_bmi(weight=w, height=h) ==
    calculate_bmi(height=h, weight=w)
)
```

Likewise, for `imperial` units:

```{python}
w = 154 # pounds
h = 70  # inches

print(calculate_bmi(w, h, 'imperial'))

assert (
    calculate_bmi(w, h, 'imperial') ==
    calculate_bmi(w, h, unit='imperial')
)
```


## Docstrings

Python has a built-in function called `help()` that can be used to get information about a function. Let's ask for help on the `pow()` (power) built-in function. What we see is the **signature** (name and parameter list) as well as the **docstring** of the `pow()` function.

```{python}
help(pow)
```

We can do the same for our functions. A function's first statement can be a string literal known as a *docstring*, used for documentation. Tools can process these to create automated documentation or allow interactive browsing of code. Including docstrings is a good habit for better maintainability and usability.


```{python}
help(calculate_bmi)
```