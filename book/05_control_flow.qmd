---
title: تدفق التحكم
jupyter: python3
---

## الخوارزميات

**الخوارزمية (Algorithm)** تسلسل من التعليمات تعمل على مدخلات، تعالجها، وتنتج مخرجات.

يمكن وصف الخوارزميات باستخدام الأشكال؛ وتسمى هذه **خريطة التدفق (flowchart)**.

### شبيه الكود (Pseudocode)
 
توصف الخوارزمية كذلك بكود غير حقيقي وهذا ما نسميه **شبيه الكود (pseudocode)**. وسبب التسمية أنه لا يوجَد مفسِّر له لتنفيذه.

**والذكاء الصطناعي** اليوم قادر على ترجمته إلى كود بايثون! أو إلى لغات برمجية أخرى أعقد منها.
### كيف يتم تنفيذ الخوارزميات؟

**البرنامج الحاسوبي** ما هو إلا خوارزمية؛ لكنها مكتوبة بالمستوى التنفيذي للحاسوب؛ فهو مستوىً لا يحتاج لمزيد ترجمة.

فلغات البرمجة مثل بايثون لا تُفهم مباشرة من قبل مكونات الحاسوب الصلبة (الكهربائية). بل يتم ترجمة الكود بواسطة برنامج آخر إلى سلسلة من التعليمات ذات المستوى الأدنى والأكثر تفصيلاً حتى تتواءم مع بنية مكونات الحاسوب، ليتم فيما بعد تحميلها في وحدة المعالجة المركزية (CPU) وتنفيذها.

هذا ما يحدث خلف الكواليس عند تشغيل الكود.

## تدفق التحكم (Control Flow)

مصطلح التحكم هنا يشير للسطر أو رقم التعليمة التي نحن بصدد تشغيلها. فالتحكم قد يتدفق بشكل تسلسلي (تعليمات متوالية: الواحدة تلو الأخرى: 1 ، 2 ، 3 ...)، أو يختار من بين طريقين (أو أكثر)، أو يعود لرقم تعليمة سابقة (وهذا الذي يعطيه خاصية التكرار، لأنها متسلسلة). فنخلص من هذا أن **تدفق التحكم** في الخورازمية له ثلاثة عناصِر:
1. **التسلسل (sequencing)**
2. **الاختيار (selection)**
**التكرار (iteration)**

![تدفق التحكم في الهياكل الأساسية للتحكم. 
](https://www.researchgate.net/profile/Kay-Smarsly/publication/322509045/figure/fig1/AS:583153716215809@1516046088625/Control-flow-of-elementary-control-structures.png)

ولك أن تتصور **البرنامج المتوازي**: له مجموعة تدفقات تحكم متوازية. وعادة ما تجعل للتنفيذ المتوازي نقطة تلاقي لاعتبار الناتج من جميع خطوط التنفيذ المتوازية.

```{mermaid}
%%| fig-cap: "مثال لتدفقي تحكُّم متوازية"
graph LR
    A(Start)
    A -->|Task 1| B[Execution]
    A -->|Task 2| C[Execution]
    A -->|Task 3| D[Execution]
    B --> E[Join/Sync Point]
    C --> E
    D --> E
    E --> F[End]
```

## ترتيب التنفيذ

بايثون هي لغة برمجة ***إجرائية (Procedural)*** على عكس ***الوصفية (Declarative)***. هذا يعني أن الكود يُنفذ بالترتيب الذي يُكتب به. على سبيل المثال، إذا كتبنا الكود التالي:

```{python}
x = 5
x = 2
```

فالتعيين اللاحق ناسخٌ (ماحٍ) لما قبله.

## علاقة الإدخال بتدفق التحكُّم

نستخدم دالة `input()` حيث **تقطَع تدفق البرنامج (Interrupt)** فيتوقَّف لتمنح التحكم للمستخدم لتقديم بعض المدخلات، وتنتظر حتى يتم الضغط على مفتاح `Enter` للإشارة إلى أن الإدخال اكتمل ، ليعود التحكم للبرنامج كيف يُكمِل تدفقه.

```python
name = input("What's your name? ")
print(f"Salam, {name}!")
```

::: {.callout-note}
ملاحظة جانبية: قِس على هذا المدخلات الأخرى وكذلك المُخرجات. فعند أي مُدخَل (سواءً ملفٌّ يُقرأ ، أو بيانات قادمة من الشَّبكة أو من قاعدة بيانات محليَّة) فإنه يقطَعُ تدفُّقَ البرنامج لحين يتم تسجيله في الذاكرة (RAM) ، ثم يُتِمُّ البرنامج سيرَه. وكذلك الأمر عند أي عملية إنتاج مُخرجات؛ فهي عمليَّة كتابة تحتاج من البرنامج أن يجعل التحكم في يدِ نظام التشغيل لأنه المخوَّل بعمليَّات كهذه. ثم قد يعود على البرنامج برسالة خطأ، أو بالتمام إن تم كل شيء على أحسن حال. وهذا تفصيله يكون في تعدد خيوط التنفيذ (Multi-processing).
:::

#### تمرين

اطلب من المستخدم إدخال الاسم والعمر ثم أخبره كم سيكون عمره بعد 10 سنوات مناديًا له باسمه.

ملاحظة: استخدم دالة `int()` لتحويل المدخل إلى عدد صحيح قبل أن تتمكن من إجراء العمليات الحسابية عليه.

تلميح: تحقق من أن `type()` لمتغير العمر هو من نوع `int` قبل إجراء العمليات الحسابية.

```{python}
# try it
```

## التعبيرات المنطقية (Boolean Expressions)

التعبيرات المنطقية هي تعبيرات تؤول إما إلى `True` أو `False`. يتم استخدام العلامات التالية للمقارنة:

| العلامة | الوصف |
| --- | --- |
| `==` | يساوي |
| `!=` | لا يساوي |
| `>` | أكبر من |
| `<` | أصغر من |
| `>=` | أكبر من أو يساوي |
| `<=` | أصغر من أو يساوي |

لنستكشف سويًّا التعبيرات المنطقية وما يمكن بينها:

```{python}
b1 = 5 > 9
print(b1)
```

```{python}
b2 = len('12345') > len('123456789')
print(b2)
```

يمكن دمج التعبيرات المنطقية باستخدام العوامل `and`، `or`، و `not`:

```{python}
b3 = b1 and b2
print(b3)
```

```{python}
b4 = b1 or b2 or b3
print(b4)
```

```{python}
b5 = not b1
print(b5)
```

## العبارات الشرطية (Conditional Statements)

تُستخدم العبارات الشرطية لتنفيذ أجزاء مختلفة من الكود بناءً على قيمة تعبير منطقي (boolean expression). مثال:

```{python}
if b5:
    print('Inside')
print('Outside')
```

### المسافة البادئة (Indentation)

لاحظ أن **المسافة البادئة** (المسافات البيضاء أسفل كلمة `if`) في الكود أعلاه ليست لمجرد تسهيل قراءة الكود، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المسافة البادئة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال الكود.

لاحظ: بدون المسافة البادئة الصحيحة، سيظهر خطأ في الكود:

```{python}
#| error: true
#| 
if b5:
print('Inside')
print('Outside')
```

إذا قمت بزيادة المسافة البادئة لكل من جملتي `print()`، فسوف يعمل الكود بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع `Outside` عندما يكون في الواقع داخل اللَّبِنَة الشرطية.

```{python}
if b5:
    print('Inside')
    print('Outside')
```

يؤدي الكود السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المسافة البادئة في كتابة كود بايثون!

### تركيب الشروط

يمكنك دمج شروط متعددة باستخدام العوامل `and`، `or`، و `not`، لأنها تنتج قيمة منطقية (boolean value). على سبيل المثال:

```{python}
age = 20
height = 175

if age > 18 and height > 170:
  print("You are eligible to donate blood")
```

يمكننا استخدام الأقواس لتجميع الشروط معًا. كما أنها تزيل أي غموض في ترتيب العمليات:

```{python}
age = 16
temperature = 15
is_wearing_coat = True
rain = False

if age < 16 or (temperature < 20 and not is_wearing_coat):
  print("I suggest you don't go outside")
```

يُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون `True` أو `False` ولا بأس بتجزئته حينما يسهل بذلك الفهم:

```{python}
is_minor = age < 16
is_cold = temperature < 20
b = is_minor or (is_cold and not is_wearing_coat)

if b:
  print("I suggest you don't go outside")
```


#### تمرين

- اطلب `عرض (width)` و `ارتفاع (height)` المستطيل من المستخدم عن طريق دالة `input()`
- احسب مساحة المستطيل وخزنها في متغير `area`
- إذا كانت `area` أكبر من 100 و `width` أكبر من `height`، اطبع: `"المستطيل كبير وعريض"`
- إذا كانت `area` أكبر من 100 و `width` أقل من أو يساوي `height`، اطبع: `"المستطيل كبير وطويل"`

```{python}
# try it
```

### `if`، `elif`، و `else`

الصيغة الكاملة لجملة الشرط هي كما يلي:

```python
if <boolean expression>:
    <code>
elif <boolean expression>:
    <code>
else:
    <code>
```

قد يوجد [`elif`](https://docs.python.org/3/reference/compound_stmts.html#elif) واحدة أو أكثر، وقد توجد [`else`] واحدة فقط (https://docs.python.org/3/reference/compound_stmts.html#else). أما الكلمة `elif` فهي اختصار لـ `else if`. تسلسل `if` ... `elif` ... `elif` ... هو بديل لجمل `switch` أو `case` الموجودة في لغات أخرى.

جرب الكود التالي بقيم مختلفة لـ `x` وحاول تتبع تدفق التحكم:

- `x = -5`
- `x = 0`
- `x = 1`
- `x = 5`

```{python}
x = -5

if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')

print("Always:", x)
```

لاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.

#### تمرين

- استخدم دالة `input()` لطلب `اسم المستخدم (username)` و `كلمة المرور (password)` من المستخدم وخزن كل منهما في متغير مناسب
- إذا كان اسم المستخدم هو `"admin"` وكلمة المرور هي `"abc123"`، اطبع: `"Welcome admin"`
- أو إذا كان اسم المستخدم هو `"backdoor"` وكلمة المرور هي `"let me in"`، اطبع: `"Nobody knows!"`
- خلاف ذلك، اطبع: `"Access denied!"`

```{python}
#| eval: false
password = 
```

#### تمرين

نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:

| Mark | Grade |
|---|---|
| 90-100 | A |
| 80-89 | B |
| 70-79 | C |
| 60-69 | D |
| 0-59 | F |

ابحث عن الخطأ (أو الأخطاء) في الكود التالي وأصلحه. اختبره بدرجات (`score`) مختلفة للتأكد من صحته:

```{python}
#|eval: false
score = input("Enter your exam score: ")
score = int(score)

if score >= 90:
  print("A")
if score >= 80:
  print("B")  
if score >= 70:
  print("C")
if score >= 60:
  print("D")
print("F")
```

تلميحات:

- قد تجد أنه من المفيد تعليق السطرين الأولين (بعلامة التعليق: `#`) وتعيين قيمة `score` مباشرة لاختبار الكود بسرعة.
- الكود يفتقد إلى عبارات `elif` و `else`.
- لا تحتاج إلى إزالة أي عبارة `print`.

#### تمرين

- اطلب من المستخدم إدخال عمره
- حوّل المدخل إلى عدد صحيح باستخدام دالة `int()`
- إذا كان العمر أقل من 5، اطبع: `"Child"`
- إذا كان العمر بين 5 و 12، اطبع: `"Kid"`
- إذا كان العمر بين 12 و 18، اطبع: `"Adolesence"`
- إذا كان العمر بين 18 و 65، اطبع: `"Adult"`
- خلاف ذلك، اطبع: `"Senior"`

ملاحظة: استخدام `elif` يعلق الشرط بانتفاء الذي قبله.

```{python}
# try it
```

### التداخل في جمل الشرط

جمل الشرط المتداخلة (Nested `if` statements) هي جمل `if` داخل جمل `if` أخرى. على سبيل المثال:

```python
if <boolean expression>:
    if <boolean expression>:
        <code>
    else:
        <code>
else:
    <code>
```

- لاحظ أيضًا أن المسافة البادئة مهمة. يجب أن تكون جملة `if` الداخلية ذات مسافة بادئة أكثر من جملة `if` الخارجية.

#### مثال

افترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:

| Mark | Grade |
|---|---|
| 95-100 | A+ |
| 90-94  | A  |
| 85-89  | B+ |
| 80-84  | B  |
| 70-79  | C  |
| 60-69 | D |
| 0-59 | F |

```{python}
score = 95

if score >= 90:
  if score >= 95:
    print("Outstanding: A+")
  else:
    print("Excellent: A")

elif score >= 80:
  if score >= 85:
    print("Very Good: B+") 
  else:
    print("Good: B")

elif score >= 70:
  print("Okay: C")

elif score >= 60:
  print("Poor: D")

else:
  print("Failed: F")
```

## الحلقة المُطْلقة (Indefinite loop)

الحلقة المُطْلقة (وتُنشأ باستخدام `while`) هي حلقة لا تحتوي على نهاية محددة مسبقًا في الشرط نفسه ، بل يتم تحديدها في سطر آخر ، فتستمر في التكرار حتى يُستوفى شرطها.

صيغة حلقة `while` كما يلي:

```python
while <boolean expression>:
    <code>
```

يتم تكرار اللبنة الواقعة في نطاق جملة الشرط ما بقي الشرط (`True`). وإذا انتفى الشرط (`False`) في البداية، فلن يتم الدخول في اللبنة أصلاً.

```python
i = 0
while i < 5:
    print(i)
    i += 1
print('Done')
```
ونلاحظ هنا أنك إذا نسيت زيادة قيمة `i`، فإن الحلقة لن تنتهي أبدًا؛ وهذا ما يسمى **حلقة لانهائية (infinite loop)**.

لنلقِ نظرة على مخطط التدفق:

```{mermaid}
%%| fig-cap: "تدفق التحكم لحلقة while"
graph TD
    A[Start] --> B{Condition}
    B -- True --> C[Print i]
    C --> D[i += 1]
    D --> B
    B -- False --> E[End]
```

إذا فككنا الحلقة، فستبدو هكذا:

```{mermaid}
%%| fig-cap: "تدفق التحكم بعد فك الحلقة. الرسم صغير لكن القصد هو بيان أنها ستكون طويلة جدًّا عند الفك."
graph LR
    A[Start] --> B{0 < 5}
    B -- True --> C[Print 0]
    C --> D[0 += 1]
    D --> E{1 < 5}
    E -- True --> F[Print 1]
    F --> G[1 += 1]
    G --> H{2 < 5}
    H -- True --> I[Print 2]
    I --> J[2 += 1]
    J --> K{3 < 5}
    K -- True --> L[Print 3]
    L --> M[3 += 1]
    M --> N{4 < 5}
    N -- True --> O[Print 4]
    O --> P[4 += 1]
    P --> Q{5 < 5}
    Q -- False --> R[End]
```

لنقم بتتبع الخطوات عندما تكون `i = 0`:

1. `0 < 5` تؤول `True`، فنطبع `0` ونزيد `i` لتصبح 1
2. `1 < 5` تؤول `True`، فنطبع `1` ونزيد `i` لتصبح 2
3. `2 < 5` تؤول `True`، فنطبع `2` ونزيد `i` لتصبح 3
4. `3 < 5` تؤول `True`، فنطبع `3` ونزيد `i` لتصبح 4
5. `4 < 5` تؤول `True`، فنطبع `4` ونزيد `i` لتصبح 5
6. `5 < 5` تؤول `False`،فنخرج من الحلقة
7. نطبع `Done`

#### تمرين

- اطلب من المستخدم إدخال رقم
- إذا كان الرقم الذي أدخله المستخدم أقل من 1، اطبع: `"الرقم يجب أن يكون أكبر من 1"` ثم اطلب من المستخدم إعادة الإدخال
- أخيرًا اطبع مجموع الأرقام من 1 إلى الرقم الذي أدخله المستخدم

```{python}
# try it
```

#### عبارات `break` و `continue`

```{python}
i = 0
while i < 5:
    if i == 3:
        break
    print(i)
    i += 1
print('Done')
```

عبارة [`continue`](https://docs.python.org/3/reference/simple_stmts.html#continue) تقفز للتكرار القادم متخطِّيةً بقية خطوات التكرار الحالي.


```{python}
i = 0
while i < 5:
    if i == 3:
        i += 1
        continue
    print(i)
    i += 1
print('Done')
```


أما عبارة [`break`](https://docs.python.org/3/reference/simple_stmts.html#break) فتوقِف التكرار تمامًا. وإن كان لدينا تكرار متداخل (تكرار داخل تكرار) فإن الذي يتوقف هو التكرار الداخلي.


```{python}
i = 0
while i < 3:
    j = 0
    while j < 3:
        if i == 1:
            break
        print(i, j)
        j += 1
    i += 1
print('Done')
```