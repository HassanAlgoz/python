---
title: جريان التحكم
jupyter: python3
---

## Algorithms

### Definition

An **algorithm** is a sequence of instructions that takes some input, processes it, and produces some output.

Here is a more formal characterization of what an algorithm is:

> As an effective method, an algorithm can be expressed within a finite amount of space and time and in a well-defined formal language for calculating a function. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of well-defined successive states, eventually producing "output" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, incorporate random input. [Source](https://en.wikipedia.org/wiki/Algorithm)

Algorithms may be described loosely in English; that's what we call **pseudocode**.

Algorithms may also be described using shapes; these are called **flowcharts**.

It helps to use non-formal language to describe algorithms, and later we can translate them into a formal language that a computer can understand; i.e., a Python program. However, Python was written to be easy to read and write, so it is already a good language for describing algorithms.

### Algorithm Execution

A computer program is an algorithm written for a computer to execute. Programming languages like Python are not actually directly understood by computer hardware. Instead, the code is translated by another program (Python Interpreter) into a lower-level, more detailed sequence of instructions that match the architecture of the hardware of the computer, and are then loaded into the CPU and executed. Of course, we don't need to worry about this when we write Python code, but it's good to know that there is a lot going on behind the scenes when we run a Python program.

## Control Flow

Algorithms may specify statements that **follow one another**, or they may specify statements that are executed **based on a condition**, or they may specify statements that are **executed repeatedly**.

Thus, we say an algorithm is made up of three basic building blocks: **sequencing**, **selection**, and **iteration**.

![Control flow of elementary control structures. 
](https://www.researchgate.net/profile/Kay-Smarsly/publication/322509045/figure/fig1/AS:583153716215809@1516046088625/Control-flow-of-elementary-control-structures.png)


## Order of execution

Python is a ***procedural programming language*** (as opposed to ***Declarative***). This means that code is executed in the order that it is written. For example, if we write the following code:

```{python}
x = 5
x = 2
```

The last statement overwrites the value of `x` with `2`.

## User Input

We will be using the `input()` function which **interrupts** the flow of the program and hands control to the user to provide some input, waiting until the `Enter` key is pressed to signal that the input is complete.

```python
name = input("What's your name? ")
print(f"Salam, {name}!")
```

#### تمرين

اطلب من المستخدم إدخال `العمر (age)` وأخبره كم سيكون عمره بعد 10 سنوات.

Note: you have to convert the input to an integer using `int()` function, before you can perform arithmetic operations on it.

Hint: check that the `type()` of `age` is `int` before performing arithmetic operations.

```{python}
# try it
```

## Boolean Expressions

Boolean expressions are expressions that evaluate to either `True` or `False`. The following operators are used to compare values:

| Operator | Description |
| --- | --- |
| `==` | Equal to |
| `!=` | Not equal to |
| `>` | Greater than |
| `<` | Less than |
| `>=` | Greater than or equal to |
| `<=` | Less than or equal to |

Let's try few examples of boolean expressions:

```{python}
b1 = 5 > 9
print(b1)
```

```{python}
b2 = len('12345') > len('123456789')
print(b2)
```

Boolean expressions can be combined using the `and`, `or`, and `not` operators:

```{python}
b3 = b1 and b2
print(b3)
```

```{python}
b4 = b1 or b2 or b3
print(b4)
```

```{python}
b5 = not b1
print(b5)
```

## Conditional Statements

Conditional statements are used to execute different pieces of code depending on the value of a boolean expression. Example:

```{python}
if b5:
    print('Inside')
print('Outside')
```

### Indentation in Python

Notice the **indentation** (whitespaces just below the `if`) in the code above is not just for readability, it specifies the block of code that is executed if the condition is `True`. The indentation is usually 4 spaces, but can be any number of spaces or tabs, as long as it is consistent throughout the code block.

Without proper indentation, code will raise an error:

```{python}
#| error: true
#| 
if b5:
print('Inside')
print('Outside')
```

If you indent both `print` statements, the code will run unexpectedly opposite of what is intended, i.e., it will print `Outside` when it is actually inside the `if` block.

```{python}
if b5:
    print('Inside')
    print('Outside')
```

This results in a silent error that would never show up as bug and won't stop the program. So be cautious with indentation!

### Combining Conditions

You can combine multiple conditions using the `and`, `or`, and `not` operators, because they result in a boolean value. For example:

```{python}
age = 20
height = 175

if age > 18 and height > 170:
  print("You are eligible to donate blood")
```

We can use parenthesis to group conditions together. It also lifts any ambiguity in the order of operations:

```{python}
age = 16
temperature = 15
is_wearing_coat = True
rain = False

if age < 16 or (temperature < 20 and not is_wearing_coat):
  print("I suggest you don't go outside")
```

You can think of the whole condition as a single boolean value that is `True` or `False`. And you can break it down into smaller parts as well to make it easier to understand:

```{python}
is_minor = age < 16
is_cold = temperature < 20
b = is_minor or (is_cold and not is_wearing_coat)

if b:
  print("I suggest you don't go outside")
```

This goes back to the idea that expressions evaluate to a value, and that value can be used in other expressions. This idea is a powerful simplification tool when analyzing and composing complex programs.

#### تمرين

- اطلب `عرض (width)` و `ارتفاع (height)` المستطيل من المستخدم باستخدام `input()`
- احسب مساحة المستطيل وخزنها في متغير `area`
- إذا كانت `area` أكبر من 100 و `width` أكبر من `height`، اطبع: `"المستطيل كبير وعريض"`
- إذا كانت `area` أكبر من 100 و `width` أقل من أو يساوي `height`، اطبع: `"المستطيل كبير وطويل"`

```{python}
# try it
```

### Truth Value Testing

Any object can be tested for truth value in an `if` condition. Here are most of the built-in objects considered false:

1. constants defined to be false: `None` and `False`
2. zero of any numeric type: `0`, `0.0`, `0j`
3. empty sequences and collections: `''`, `()`, `[]`, `{}`

Example:

```{python}
if False or None or 0 or "":
    print("should never print")
```

Any other object value is considered `True`:

```{python}
if True or 1 or "abc":
    print("should always print")
```

#### Exercise

- Ask the user to enter their address
- If the address is not empty, print: `"Thank you for providing your address"`

```{python}
# try it
```

### `if`, `elif`, and `else`

The full syntax for a conditional statement is as follows:

```python
if <boolean expression>:
    <code>
elif <boolean expression>:
    <code>
else:
    <code>
```

There can be zero or more [`elif`](https://docs.python.org/3/reference/compound_stmts.html#elif) parts, and the [`else`](https://docs.python.org/3/reference/compound_stmts.html#else) part is optional. The keyword ‘`elif`’ is short for ‘else if’, and is useful to avoid excessive indentation. An `if` … `elif` … `elif` … sequence is a substitute for the `switch` or `case` statements found in other languages.

Test the following code block with different values for `x` and try to trace back the flow of control:
- `x = -5`
- `x = 0`
- `x = 1`
- `x = 5`

```{python}
x = -5

if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')

print("Always:", x)
```

Notice that the last statement is not indentented, so it is always executed.

#### Exercise

- Use the `input()` function to ask the user for `username` and `password` and store both in corresponding variables 
- If the username is `"admin"` and the password is `"abc123"`, print: `"Welcome admin"`
- Or the username is `"backdoor"` and the password is `"let me in"`, print: `"Nobody knows!"`
- Otherwise, print: `"Access denied!"`

```{python}
#| eval: false
password = 
```

#### Exercise

Say we want to assign a grade to a student based on their score, according to the following table:

| Mark | Grade |
|---|---|
| 90-100 | A |
| 80-89 | B |
| 70-79 | C |
| 60-69 | D |
| 0-59 | F |

Find the bug(s) in the following code and fix it (run it with different scores to test it):

```{python}
#|eval: false
score = input("Enter your exam score: ")
score = int(score)

if score >= 90:
  print("A")
if score >= 80:
  print("B")  
if score >= 70:
  print("C")
if score >= 60:
  print("D")
print("F")
```

Hint:
- you may find it useful to comment the first two lines, and assign the score directly to a value to test the code.
- the code is missing `elif` and `else` statements
- you don't need to remove any `print` statement

#### Exercise

- Ask the user to enter their age
- Convert the input to an integer using the `int()` function
- If the age is less than 5, print: `"Early childhood"`
- Else If the age is between 5 and 12, print: `"Childhood"`
- Else If the age is between 12 and 18, print: `"Teenager"`
- Else If the age is between 18 and 65, print: `"Adult"`
- Else print: `"Senior citizen"`

Note: using `elif` makes it possible to check ranges based on the previous condition.

```{python}
# try it
```

### Nested `if`s

Nested `if` statements are `if` statements inside other `if` statements. For example:

```python
if <boolean expression>:
    if <boolean expression>:
        <code>
    else:
        <code>
else:
    <code>
```

- Also note that the indentation is important. The inner `if` statement must be indented more than the outer `if` statement.
- The `else` clause belongs to the `if` statement at the same indentation level.

The following example assigns the letter grade for score ranges, and then prints an additional message depending on sub-ranges:

Say we want to assign a grade to a student based on their score, according to the following table:

| Mark | Grade |
|---|---|
| 95-100 | A+ |
| 90-94  | A  |
| 85-89  | B+ |
| 80-84  | B  |
| 70-79  | C  |
| 60-69 | D |
| 0-59 | F |

```{python}
score = 95

if score >= 90:
  if score >= 95:
    print("Outstanding: A+")
  else:
    print("Excellent: A")

elif score >= 80:
  if score >= 85:
    print("Very Good: B+") 
  else:
    print("Good: B")

elif score >= 70:
  print("Okay: C")

elif score >= 60:
  print("Poor: D")

else:
  print("Failed: F")
```

## Indefinite Loops

An **indefinite loop** is a loop that doesn't have a predetermined end specified in the condition itself (although it may be determined at some other line). It continues to execute until a certain condition is met. The `while` loop is used to create an indefinite loop.

The syntax of a `while` loop is as follows:

```python
while <boolean expression>:
    <code>
```

The code block is executed repeatedly as long as the boolean expression is `True`. If the condition is `False` in the first place, the code block is never executed.

```python
i = 0
while i < 5:
    print(i)
    i += 1
print('Done')
```

Note that: if you forget to increment `i`, the loop will never end; that's called an **infinite loop**

Let's look at the flowchart:

```{mermaid}
graph TD
    A[Start] --> B{Condition}
    B -- True --> C[Print i]
    C --> D[i += 1]
    D --> B
    B -- False --> E[End]
```

If we unfold the loop, it looks like this:

```{mermaid}
graph LR
    A[Start] --> B{0 < 5}
    B -- True --> C[Print 0]
    C --> D[0 += 1]
    D --> E{1 < 5}
    E -- True --> F[Print 1]
    F --> G[1 += 1]
    G --> H{2 < 5}
    H -- True --> I[Print 2]
    I --> J[2 += 1]
    J --> K{3 < 5}
    K -- True --> L[Print 3]
    L --> M[3 += 1]
    M --> N{4 < 5}
    N -- True --> O[Print 4]
    O --> P[4 += 1]
    P --> Q{5 < 5}
    Q -- False --> R[End]
```

Let's trace it step by step for when `i = 0`:

1. `0 < 5` is `True`, so we print `0` and increment `i` so it becomes 1
2. `1 < 5` is `True`, so we print `1` and increment `i` so it becomes 2
3. `2 < 5` is `True`, so we print `2` and increment `i` so it becomes 3
4. `3 < 5` is `True`, so we print `2` and increment `i` so it becomes 4
5. `4 < 5` is `True`, so we print `2` and increment `i` so it becomes 5
6. `5 < 5` is `False`, so we exit the loop
5. We print `Done`

#### تمرين

- اطلب من المستخدم إدخال رقم
- إذا كان الرقم الذي أدخله المستخدم أقل من 1، اطبع: `"الرقم يجب أن يكون أكبر من 1"` ثم اطلب من المستخدم إعادة الإدخال
- اطبع الأرقام من 1 إلى الرقم الذي أدخله المستخدم

```{python}
# try it
```

#### `break` and `continue` Statements

```{python}
i = 0
while i < 5:
    if i == 3:
        break
    print(i)
    i += 1
print('Done')
```

The [`continue`](https://docs.python.org/3/reference/simple_stmts.html#continue) statement continues with the next iteration of the loop:

```{python}
i = 0
while i < 5:
    if i == 3:
        i += 1
        continue
    print(i)
    i += 1
print('Done')
```


The [`break`](https://docs.python.org/3/reference/simple_stmts.html#break) statement breaks out of the innermost enclosing [`for`](https://docs.python.org/3/reference/compound_stmts.html#for) or [`while`](https://docs.python.org/3/reference/compound_stmts.html#while) loop:


```{python}
i = 0
while i < 3:
    j = 0
    while j < 3:
        if i == 1:
            break
        print(i, j)
        j += 1
    i += 1
print('Done')
```