---
title: التحكم في سير الأوامر
jupyter: python3
---

بايثون تنفذ الأوامر البرمجية بحسب ترتيبها من الأعلى للأسفل. فإذا كتبنا الكود التالي:

```{python}
x = 1
x = 2
print(x)
```

فالتعيين اللاحق ناسخٌ (ماحٍ) لما قبله.

الأصل في تنفيذ الأوامر البرمجية أن يكون بالترتيب من أوَّل سطر نزولاً إلى آخر سطر برمجي. لكن هناك حالات تستدعي تغيير هذا الترتيب:

1. **التنفيذ المشروط**: تعليق تنفيذ قطعة كود على حصول حالة (أو أحوال) معيَّنة
2. **حلقة التكرار**: الرجوع لسطر سابق (حلقة تكرار) إلى حين حصول الغرض من هذه الحلقة
3. **الانتقال من وإلى نطاق عملية**: ويتحقق هذا بنداء عمليَّة مُعرَّفة (وهي قطعة كود لها اسم) وقد سبق لنا استمعالها: (`print`, `len`, ...etc). وسيأتي الحديث عنها في الدرس القادم.
4. **حدوث خطأ**: التعامل مع حالات الخطأ المتوقعة

## التعبير المنطقي

أما الشروط فتستند إلى المنطق الرقمي الثنائي الذي نجد له في بايثون كلمتين من أصل اللغة هما: `True` (تساوي الرقم `1`) وتعبِّر عن تحقق الأمر، وكلمة: `False` (تساوي الرقم `0`) وتعبِّر عن عدم التحقق. وكلاهُما شيء من الصنف: **ثنائي**.

التعبيرات المنطقية هي تعبيرات تؤول إما إلى `True` أو `False`. ولذا فإن منها جُمل المقارنة:

| العلامة | الوصف |
| --- | --- |
| `a == b` | يساوي |
| `a != b` | لا يساوي |
| `a > b` | أكبر من |
| `a < b` | أصغر من |
| `a >= b` | أكبر من أو يساوي |
| `a <= b` | أصغر من أو يساوي |

لنستكشف سويًّا التعبيرات المنطقية وما يمكن بينها:

```{python}
b1 = 5 > 9
print(b1)
```

```{python}
b2 = len('12345') > len('123456789')
print(b2)
```

يمكن دمج التعبيرات المنطقية باستخدام العوامل `and`، `or`، و `not`:

| A | B | AND | OR  | XOR |
|----------|----------|----------|---------|------------------|
|     0    |     0    |    0     |    0    |        0        |
|     0    |     1    |    0     |    1    |        1        |
|     1    |     0    |    0     |    1    |        1        |
|     1    |     1    |    1     |    1    |        0        |

- AND (و): تُعطي النتيجة 1 فقط إذا كان كلا المدخلين 1.
- OR (أو): تُعطي النتيجة 1 إذا كان أحد المدخلين على الأقل 1.
- XOR (أو الحصرية): تُعطي النتيجة 1 إذا كان المدخلان مختلفين.
- NOT (ليس): يعكس المدخل (1 يصبح 0، و0 يصبح 1).

```{python}
b3 = b1 and b2
print(b3)
```

```{python}
b4 = b1 or b2 or b3
print(b4)
```

```{python}
b5 = not b1
print(b5)
```


## جملة التوكيد

تُدرَج جُملَ التوكيد في ثنايا الكود للتحقق من صحَّة التسلسل المنطقي. فالتوكيد يُحدثُ خطأ إذا كانت القيمة التي نؤكدها خاطئة. مثلاً:

```{python}
#| error: true
assert False
```

كما تُسحتب الكتابة بلغة البشر لما يجب أن يكون ، بعد الفاصلة، هكذا ، لتظهر في رسالة الخطأ واضحة:

```{python}
#| error: true
x = 10
y = 20
assert x > y, 'x should be greater than y'
```

أما إذا كانت العبارة صحيحة فلا خطأ:

```{python}
assert True
```

```{python}
x = 2 ** 4
y = pow(2, 4)
assert x == x, 'x should be equal to x'
```

هذه الجُمَل البسيطة تساعد في اختبار الكود وكشف الأخطاء في وقتٍ مبكِّر ، كما أنها تساعد في التعلُّم (الآن عرفت أن `**` هي عملية الأس `pow`) كما سنستخدمها الآن لأنها تحقق ما نحن بصدد التحقق منه. وهي تغنينا عن كثيرٍ من جُمَل `print()`.

## الجملة الشرطية

تُستخدم العبارات الشرطية لتنفيذ أجزاء مختلفة من الكود بناءً على قيمة تعبير منطقي. مثال:

```{python}
if b5:
    print('Inside')
print('Outside')
```

### المحاذاة العمودية (Indentation)

لاحظ أن **المحاذاة العمودية** (المسافات البيضاء أسفل كلمة `if`) في الكود أعلاه ليست لمجرد تسهيل قراءة الكود، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال الكود.

لاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في الكود:

```{python}
#| error: true
#| 
if b5:
print('Inside')
print('Outside')
```

إذا قمت بزيادة المحاذاة لكل من جملتي `print()`، فسوف يعمل الكود بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع `Outside` عندما يكون في الواقع داخل اللَّبِنَة الشرطية.

```{python}
if b5:
    print('Inside')
    print('Outside')
```

يؤدي الكود السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في كتابة كود بايثون!

### تركيب الشروط

يمكنك دمج شروط متعددة باستخدام العوامل `and`، `or`، و `not`، لأنها تنتج قيمة منطقية (boolean value). على سبيل المثال:

```{python}
age = 20
height = 175

if age > 18 and height > 170:
  print("You are eligible to donate blood")
```

يمكننا استخدام الأقواس لتجميع الشروط معًا. كما أنها تزيل أي غموض في ترتيب العمليات:

```{python}
age = 16
temperature = 15
is_wearing_coat = True

if age < 16 or (temperature < 20 and not is_wearing_coat):
  print("I suggest you don't go outside")
```

يُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون `True` أو `False` ولا بأس بتجزئته حينما يسهل بذلك الفهم:

```{python}
is_minor = age < 16
is_cold = temperature < 20
b = is_minor or (is_cold and not is_wearing_coat)

if b:
  print("I suggest you don't go outside")
```


### الجملة الشرطية المتكاملة

الصيغة المتكاملة للجملة الشرطية على النحو التالي:

```python
if <boolean expression>:
    <code>
elif <boolean expression>:
    <code>
else:
    <code>
```

قد يوجد [`elif`](https://docs.python.org/3/reference/compound_stmts.html#elif) واحدة أو أكثر، وقد توجد [`else`](https://docs.python.org/3/reference/compound_stmts.html#else) واحدة فقط. أما الكلمة `elif` فهي اختصار لـ `else if`. تسلسل `if` ... `elif` ... `elif` ... هو بديل لجمل `switch` أو `case` الموجودة في لغات أخرى.

جرب الكود التالي بقيم مختلفة لـ `x` وحاول تتبع تدفق التحكم:

- `x = -5`
- `x = 0`
- `x = 1`
- `x = 5`

```{python}
x = -5

if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')

print("Always:", x)
```

لاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.

### تضمين الجمل الشرطية

جمل الشرط المضمنة هي جمل `if` داخل جمل `if` أخرى. على سبيل المثال:

```python
if <boolean expression>:
    if <boolean expression>:
        <code>
    else:
        <code>
else:
    <code>
```

لاحظ أيضًا أن المحاذاة مهمة. يجب أن تكون جملة `if` الداخلية ذات محاذاة أكثر من جملة `if` الخارجية.

#### مثال

افترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:

| Mark | Grade |
|---|---|
| 95-100 | A+ |
| 90-94  | A  |
| 85-89  | B+ |
| 80-84  | B  |
| 70-79  | C  |
| 60-69 | D |
| 0-59 | F |

```{python}
score = 95

if score >= 90:
  if score >= 95:
    print("Outstanding: A+")
  else:
    print("Excellent: A")

elif score >= 80:
  if score >= 85:
    print("Very Good: B+") 
  else:
    print("Good: B")

elif score >= 70:
  print("Okay: C")

elif score >= 60:
  print("Poor: D")

else:
  print("Failed: F")
```

## التعيين النسبي

- `i = i + 1` تعادل `i += 1`
- `i = i - 1` تعادل `i -= 1`
- `i = i * 2` تعادل `i *= 2`
- `i = i / 2` تعادل `i /= 2`

ملاحظة جانبية: انظر [التعيين النسبي (Augmented assignment statements)](https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements) فإنها عند التدقيق تختلف.

جرب الكود أدناه لترى النتيجة:

```{python}
i = 0
print(i)
```

```{python}
i = i + 1
print(i)
```

```{python}
i += 1
print(i)
```

لاحظ أن `i++` تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:

```{python}
#| error: true
i++
print(i)
```


## الحلقة المُطْلقة

**الحلقة المُطْلقة** (لها كلمة `while`) هي مثل `if` لكن مكررة، فكلما انتهت العبارات المضمَّنة داخلها، تعود لسطر الشرط وتنفذه مرة أخرى؛ إلى حين انتفاء الشرط (`False`).

أما كونُها مطقلة يعني أن الكود المضمَّن داخل الحلقة هو الذي يحدد متى تتوقف. بينما المقيَّدة يكون التكرار فيها مُحددًّا بعدد معيَّن في نفس الجُملة، وهو على النحو التالي: (`for x in items`) سيأتي الحديث عنه إن شاء الله في درس قادم.

صيغة حلقة `while` كما يلي:

```python
while <boolean expression>:
    <code>
```

يتم تكرار اللبنة الواقعة في نطاق جملة الشرط ما بقي الشرط (`True`). وإذا انتفى الشرط (`False`) في البداية، فلن يتم الدخول في اللبنة أصلاً.

```python
i = 0
while i < 5:
    print(i)
    i += 1
print('Done')
```

ونلاحظ هنا أنك إذا نسيت زيادة قيمة `i`، فإن الحلقة لن تنتهي أبدًا؛ وهذا ما يسمى **حلقة لانهائية (infinite loop)**.

لنقم بتتبع الخطوات عندما تكون `i = 0`:

1. `0 < 5` تؤول `True`، فنطبع `0` ونزيد `i` لتصبح 1
2. `1 < 5` تؤول `True`، فنطبع `1` ونزيد `i` لتصبح 2
3. `2 < 5` تؤول `True`، فنطبع `2` ونزيد `i` لتصبح 3
4. `3 < 5` تؤول `True`، فنطبع `3` ونزيد `i` لتصبح 4
5. `4 < 5` تؤول `True`، فنطبع `4` ونزيد `i` لتصبح 5
6. `5 < 5` تؤول `False`،فنخرج من الحلقة
7. نطبع `Done`


نستخدم دالة `input()` حيث **تقطَع سير البرنامج (Interrupt)** فيتوقَّف لتمنح التحكم للمستخدم لتقديم بعض المدخلات، وتنتظر حتى يتم الضغط على مفتاح `Enter` للإشارة إلى أن الإدخال اكتمل ، ليعود التحكم للبرنامج كي يُكمِل سيره.

يمكن استعمال الحلقة المطلقة مثلاً لتكرار السؤال عن رقم حتى يتم تخمينه بشكل صحيح:

```python
num = "9"
guess = input("Guess the number (0-9): ")
while guess != num:
    guess = input("Try again: ")
print("You guessed it!")
```

وهكذا معظم البرامج كالخوادم (Servers) يكون في داخلها حلقة مطلقة وذلك لاستقبال طلبات المتسفيدين من البرنامج.

### قطع التكرار

- تستخدم كلمة [`break`](https://docs.python.org/3/reference/simple_stmts.html#break) لإيقاف التكرار تمامًا.
- تستخدم كلمة [`continue`](https://docs.python.org/3/reference/simple_stmts.html#continue) للانتقال إلى التكرار التالي متخطيةً بقية الخطوات في التكرار الحالي.

```{python}
i = 0
while i < 5:
    if i == 3:
        break
    print(i)
    i += 1
print('Done')
```

وهذا مثال لاستخدام `continue`:

```{python}
i = 0
while i < 5:
    if i == 3:
        i += 1
        continue
    print(i)
    i += 1
print('Done')
```

أما عبارة `break` المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط. وهذا مثال:

```{python}
i = 0
while i < 3:
    j = 0
    while j < 3:
        if i == 1:
            break
        print(i, j)
        j += 1
    i += 1
print('Done')
```

