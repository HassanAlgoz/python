---
title: العمليات
jupyter: python3
---


استعملنا في دروس سابقة **عمليَّات أساسية** مثل: `print()`, `input()`, و `int()`. وأيضًا من **المكتبة الأساسية** [`math`](https://docs.python.org/3/library/math.html) مثل: `math.sqrt()` و `math.pow()`. فإن نتيجة هذه العمليات يكون بحسب المدخلات. والآن جاء دورُنا لنضيف عمليات نحن نعرفها. فـ**العملية المعرَّفة** هي قطعة كود لها اسم. مخرجاتها مبنية على مدخلاتها.

ولكن قد تتساءل: ما هي الفائدة من تعريف عمليات إضافية؟ فنقول: قابلية العمليَّة للتعريف ثم الاستدعاء لاحقًا يعطيها خواص أساسية في البناء التراكمي للمنطق. منها ثلاثة عناصر:

**التفكيك**: وهو ضروري للتعامل مع المنطق المعقد، نفككه إلى أجزاء، ونربطها بعد برمجة كل جزء واختباره وإتقانه.

**التجريد**: يتم تركيب المكونات على نسق جديد. قد يكون بإخفاء تفاصيل كثيرة دقيقة تحت اسم بسيط يتطلب مدخلات ويعطيك مخرجات.

**تعدد الاستعمالات**: فإذا فككنا صار الأمر قابلاً للاستعمال في مواضع متعددة، ومن المتخصص وغير المتخصص. وهذا يختصر كثيرًا من التكرار، ويسهل التعامل مع الكود، ويقلل الأخطاء، ويسرع الإنتاج.

وتوجد في بايثون إلى جانب تعريف العمليات، تعريف الأشياء وهي: عمليات مع بيانات. وهذا يعني أننا نستطيع تعريف أشياء جديدة تحتوي على بيانات وعمليات تعمل على تلك البيانات. وهذا يعطينا قدرة أكبر على التجريد والتفكيك وتعدد الاستعمالات.

يكون تعريف العملية بكلمة `def` يتبعها اسم العملية، ثم بين الأقواس تكون المدخلات. أما المُخرجات فهي ما يتبع كلمة `return`. ولاحظ أن البرنامج بتنفيذ هذه العبارة سوف يخرج من نطاق العمليَّة.

وهذا مثال لعملية تحكم على قوة كلمة المرور:

```{python}
def check_password_strength(password):
    if len(password) > 8:
        return "Strong"
    elif len(password) > 4:
        return "Medium"
    else:
        return "Weak"
```

بعد التعريف، نريد استعمالها فنضع اسمها ثم بين القوسين نمرر المدخلات التي نريد، ونحصل على النتيجة مباشرة، فنعينها للمُعرَّف `result` في هذه الحالة:

```{python}
result = check_password_strength("shorty")
print('password is:', result)

result = check_password_strength('verylongpassword')
print('password is:', result)
```

العمليات لديها نطاقها الخاص. أي أن المعرَّفات المضمَّنة فيها غير معروفة إلا في نطاقها. ونحن حين نستدعي العملية باسمها فإن التنفيذ يقفز من السطر الذي نحن فيه ليدخل في نطاق العمليَّة، وينفذ الأوامر التي فيه حتى تنتهي أو حتى يرى كلمة `return` فيخرج التنفيذ ومعه النتيجة إلى النطاق السابق الذي استدعاها.

مثلاً هنا مُعرَّف داخل العمليَّة، وإذا حاولنا طباعته خارج نطاقها فإننا سنحصل على خطأ:

```{python}
def check_password_strength(password):
    minimum_password_length = 8
```

```{python}
#| error: true
print(minimum_password_length)
```

وهذا أمرٌ جيِّد لأننا سنستخدم عمليات كثيرة ويرد كثيرًا أننا نستخدم أسماء متشابهة ولا نريدها أن تختلط. فكل عملية لها مهمة محددة ويجب أن تركز على تلك المهمة فقط.

الأمر الآخر فيما يخصُّ نطاق المُعرَّفات هو أن النطاق الأخص (داخل العملية) يجد المعرَّفات في النطاق الأعم معروفة لديه. وذلك يتيح لنا استعمال دوال في النطاق العام مثل: `len` و `int` و `type` ونحوها.

يمكننا تعيين قيَم افتراضية للعوامل هكذا:

```{python}
def greet(name, greeting='Hello'):
    return greeting.upper() + " " + name + "!"

print(greet('Adam'))
print(greet('Belal', 'good morning'))
```

لاحظ كيف أنه في الاستدعاء الأول للعملية `greet()`، قمنا بتمرير عامل واحد فقط، لذلك تم استخدام القيمة الافتراضية لـ `greeting`. ولكن، في الاستدعاء الثاني، قمنا بتمرير كلا العاملين فنسخت القيمة الافتراضية.

## العوامل بين الترتيب والتسمية

نفهم من تعريف العملية [`pow(base, exp, mod=None)`](https://docs.python.org/3/library/functions.html#pow) أن لديها ثلاثة عوامل: `base`، `exp`، و `mod` بهذا الترتيب. لاحظ أن العامل `mod` اختياري (لوجود التعيين الافتراضي `mode=None`). هذا يعني أن العملية يمكن استعمالها بطرق مختلفة:

```{python}
print(pow(2, 4))
print(pow(2, exp=4))
print(pow(base=2, exp=4))
print(pow(exp=4, base=2))
```

فإن أردنا تعريف عوامل تستعمل بهذه الطريقة، فإننا نضعها في التعريف على النحو التالي: 

```{python}
def calculate_bmi(weight, height, unit='metric'):
    """ Calculate the Body Mass Index (BMI)
        
        weight and height must be of the same unit.

        unit is either 'metric' or 'imperial'.
    """
    if unit == 'imperial':
        weight *= 0.453592
        height *= 0.0254
    bmi = weight / (height ** 2)
    return round(bmi, 2)
```

الآن يمكننا استعمال العملية بطرق مختلفة. لاحظ أن استخدام `assert` هنا للتحقق من أن العملية تنتج نفس القيمة بغض النظر عن كيفية تمرير العوامل.

```{python}
w = 70   # kg
h = 1.75 # meters

print(calculate_bmi(w, h))

assert (
    calculate_bmi(w, h) ==
    calculate_bmi(w, height=h) ==
    calculate_bmi(weight=w, height=h) ==
    calculate_bmi(height=h, weight=w)
)
```

ونفس الأمر بالنسبة للعامل الذي عينت له قيمة افتراضية `units='imperial'`:

```{python}
w = 154 # pounds
h = 70  # inches

print(calculate_bmi(w, h, 'imperial'))

assert (
    calculate_bmi(w, h, 'imperial') ==
    calculate_bmi(w, h, unit='imperial')
)
```


## التعليق في مقدمة العملية

تحتوي بايثون على عملية أساسية تسمى `help()` تظهر معلومات عن عملية ما:

```{python}
help(pow)
```

كذلك يمكن استعمالها في أي عملية مُعرَّفة، فهي تأخذ التعليق الذي يبدأ بثلاثة علامات تنصيص (`"""`) بداية العملية (انظر كيف استعملناها في العملية `calculate_bmi`):

```{python}
help(calculate_bmi)
```

