[
  {
    "objectID": "03_hello.html",
    "href": "03_hello.html",
    "title": "4  أول سطر",
    "section": "",
    "text": "5 أنواع البيانات",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "03_hello.html#المتغيرات",
    "href": "03_hello.html#المتغيرات",
    "title": "4  أول سطر",
    "section": "5.1 المتغيرات",
    "text": "5.1 المتغيرات\nيأخذ التعيين القيم (والتعبيرات المقيمة) ويعينها لمتغير:\n\nnum = 10\nname = \"Alice\" + \" \" + \"Bob\"\nb = 9 &gt; 5\n\nprint(type(num))   # int\nprint(type(name))  # str\nprint(type(b))     # bool\n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt;\n\n\nيُظهر الكود التالي تعيين متغير:\n\nx هو متغير (variable)\n5 هو قيمة (value)\n= هو عامل التعيين (assignment operator)\n\n\nx = 5\n\nالقيمة 5 مخزنة في عنوان ذاكري (memory address) x حتى نتمكن من الوصول إليه لاحقًا.\n\nprint(x)\n\n5\n\n\nلاحظ أن سلسلة الأرقام ليست هي نفسها الرقم:\n\nالرقم 20 هو قيمة من نوع (type) int\nالسلسلة النصية \"20\" هي قيمة من نوع (type) str\n\nملاحظة جانبية: التنصيص المفرد ('A') والتنصيص المزدوج (\"A\") متكافئة في بايثون (Python).\n\nx = 20\ny = '20'\n\nprint(x, type(x))\nprint(y, type(y))\n\n20 &lt;class 'int'&gt;\n20 &lt;class 'str'&gt;\n\n\n\nprint(x + y)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[389], line 1\n----&gt; 1 print(x + y)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nنتوقع خطأ وراء هذا السطر لأننا نحاول إضافة سلسلة نصية (string) إلى رقم (number).\nيجب علينا تحويل السلسلة النصية إلى رقم قبل أن نتمكن من إضافتها إلى رقم آخر.\n\nz = int(y)\nprint(z, type(z))\nprint(x + z)\n\n20 &lt;class 'int'&gt;\n40",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "03_hello.html#أخذ-المدخلات-من-المستخدم",
    "href": "03_hello.html#أخذ-المدخلات-من-المستخدم",
    "title": "4  أول سطر",
    "section": "5.2 أخذ المدخلات من المستخدم",
    "text": "5.2 أخذ المدخلات من المستخدم\nيمكننا استخدام دالة input() لأخذ المدخلات من المستخدم. ستقوم دالة input() بطباعة رسالة على الشاشة ثم تنتظر من المستخدم أن يكتب شيئًا ويضغط على Enter. بمجرد أن يضغط المستخدم على Enter، ستعيد دالة input() ما كتبه المستخدم.\nملاحظة جانبية (لمستخدمي VS Code): ستظهر نافذة الإدخال في أعلى الشاشة.\nname = input(\"What is your name? \")\nيمكننا الآن استخدام المتغير name للترحيب بالمستخدم:\nprint(\"Welcome\", name, \"to the Python course\")\nيمكننا أيضًا أخذ الأرقام. ومع ذلك، نظرًا لأن دالة input تعيد دائمًا سلسلة نصية (string)، نحتاج إلى تحويل السلسلة النصية إلى رقم باستخدام دالة int():\n\npassword = input(\"Enter password: \")\n\nif password == \"pythonista\":\n    print(\"Welcome to the course\")\nelse:\n    print(\"Sorry, wrong password\")\n\n\n5.2.0.1 تمرين:\n\nاستخدم دالة input لطلب الاسم الأول من المستخدم وخزنه في متغير يسمى first_name\nاستخدم دالة input لطلب الاسم الأخير من المستخدم وخزنه في متغير يسمى last_name\nاطبع رسالة ترحيب للمستخدم باستخدام اسمه الأول والأخير\n\nاكتب الكود الخاص بك أدناه:\n\n# try it\n\n\n\n5.2.0.2 تمرين\nاحسب مساحة المستطيل:\n\nاستخدم دالة input لطلب عرض (width) المستطيل من المستخدم\nاستخدم دالة input لطلب ارتفاع (height) المستطيل من المستخدم\nاحسب مساحة المستطيل وخزنها في متغير يسمى مساحة (area)\nاطبع مساحة المستطيل\n\nملاحظة: يجب عليك تحويل العرض (width) و الارتفاع (height) إلى أرقام باستخدام دالة int().\n\n# try it\n\n\n\n5.2.0.3 تمرين\nاطلب من المستخدم إدخال العمر (age) وأخبره كم سيكون عمره بعد 10 سنوات.\n\n# try it\n\n\n\n5.2.1 قواعد تسمية المتغيرات\n\nالمتغيرات حساسة لحالة الأحرف (case-sensitive). مثال:\n\nmy_variable = 5\nMy_Variable = 10\n\nلا يمكن أن تبدأ أسماء المتغيرات برقم. مثال:\n\n2my_variable = 5\n\nلا يمكنك استخدام الكلمات المحجوزة (reserved keywords). مثال:\n\nclass = 5\nTrue = 1\nbreak = True\n\nيُكره استخدام أسماء الدوال المبنية في اللغة (built-in function names). مثال:\n\nsum = 5\nmax = 10\nlist = [10, 20, 30]\n\n\n5.2.2 الكلمات المحجوزة\n\n\n\n\n\n\n\n\nالفئة (Category)\nالكلمة المحجوزة (Keyword)\nالوصف (Description)\n\n\n\n\nعوامل منطقية (Logical operators)\nand, or, not, is\nعوامل تستخدم لدمج التعبيرات البوليانية (Boolean expressions).\n\n\nعبارات شرطية (Conditional statements)\nif, elif, else\nكلمات محجوزة تستخدم لإنشاء عبارات شرطية.\n\n\nالحلقات (Loops)\nwhile, for, break, continue\nكلمات محجوزة تستخدم لإنشاء الحلقات.\n\n\nمعالجة الاستثناءات (Exception handling)\ntry, except, finally\nكلمات محجوزة تستخدم لمعالجة الاستثناءات.\n\n\nالدوال والفئات (Functions and classes)\ndef, class, return, yield, lambda\nكلمات محجوزة تستخدم لتعريف الدوال والفئات.\n\n\nأنواع البيانات (Data types)\nNone, True, False\nكلمات محجوزة تستخدم لتمثيل أنواع بيانات خاصة.\n\n\nأخرى (Other)\nimport, from, as, assert, global, nonlocal, with, pass\nكلمات محجوزة أخرى تستخدم لأغراض متنوعة.\n\n\n\nالخلية التالية تحتوي على أسماء متغيرات لا معنى لها. نقدم بديلاً أفضل أدناه ونلاحظ الفرق.\n\nx2 = 35\ny = 12.50\nmne = x2* y\nprint(mne)\n\n437.5\n\n\nيجب علينا استخدام أسماء ذات معنى، مثل:\n\nhours = 35\nrate = 12.50\npay = hours * rate\nprint(pay)\n\n437.5\n\n\nالنية من الكود الآن أصبحت أوضح بكثير.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "03_hello.html#نظرة-عامة-على-أنواع-البيانات-data-types-overview",
    "href": "03_hello.html#نظرة-عامة-على-أنواع-البيانات-data-types-overview",
    "title": "4  أول سطر",
    "section": "8.2 نظرة عامة على أنواع البيانات (Data Types: Overview)",
    "text": "8.2 نظرة عامة على أنواع البيانات (Data Types: Overview)\nتمثل أنواع البيانات (Data types) نوع القيمة التي تخبرنا ما هي العمليات التي يمكن إجراؤها على بيانات معينة. على سبيل المثال:\n\nيمكن جمع الأرقام وطرحها وضربها\nيمكن دمج السلاسل النصية (strings) مع سلسلة نصية أخرى.\n\nإليك جدول بأكثر أنواع البيانات شيوعًا في بايثون (Python):\n\n\n\n\n\n\n\n\nالنوع (Type)\nنوع بايثون (Python Type)\nمثال على التعيين (Assignment Example)\n\n\n\n\nنص (Text)\nstr\nmessage = \"Hello, world!\"\n\n\nرقمي (Numeric)\nint, float, complex\nnumber = 10, pi = 3.14, complex_number = 1 + 2j\n\n\nتسلسل (Sequence)\nlist, tuple, range\nmy_list = [1, 2, 3, 4, 5], my_tuple = (1, 2, 3, 4, 5), my_range = range(10)\n\n\nتعيين (Mapping)\ndict\nmy_dict = {\"name\": \"Adam\", \"age\": 25}\n\n\nمجموعة (Set)\nset, frozenset\nmy_set = {1, 2, 3, 4, 5}, my_frozenset = frozenset({1, 2, 3, 4, 5})\n\n\nمنطقي (Boolean)\nbool\nis_true = True, is_false = False\n\n\nثنائي (Binary)\nbytes, bytearray, memoryview\nmy_bytes = b\"Hello, world!\", my_bytearray = bytearray(b\"Hello, world!\"), my_memoryview = memoryview(b\"Hello, world!\")\n\n\nلا شيء (None)\nNoneType\nnone = None\n\n\n\nتوثيق أنواع البيانات: https://docs.python.org/3/library/datatypes.html",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "5  خلاصة",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>خلاصة</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "المراجع",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "المساعدة",
      "المراجع"
    ]
  },
  {
    "objectID": "03_hello.html#القيم-والأنواع",
    "href": "03_hello.html#القيم-والأنواع",
    "title": "4  أول سطر",
    "section": "5.1 القيم والأنواع",
    "text": "5.1 القيم والأنواع\nهنا:\n\n10 يعتبر قيمة (value) من نوع (type) int\n\"Adam\" تعتبر قيمة (value) من نوع (type) str\n\n\ntype(10)\n\nint\n\n\n\ntype(\"Adam\")\n\nstr\n\n\nنخزن القيم في متغيرات (variables). المتغير هو اسم يشير إلى قيمة. يمكننا استخدام عامل = لتعيين قيمة لمتغير.\n\nx = 10\n\nالآن، يعيد type(x) نوع القيمة التي تحتوي عليها x.\n\ntype(x)\n\nint",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "03_hello.html#نظام-الكتابة-في-بايثون-ديناميكي",
    "href": "03_hello.html#نظام-الكتابة-في-بايثون-ديناميكي",
    "title": "4  أول سطر",
    "section": "5.2 نظام الكتابة في بايثون ديناميكي",
    "text": "5.2 نظام الكتابة في بايثون ديناميكي\nعلى عكس لغات التنويع الثابت (Static Typing)، تسمح لك بايثون بتغيير نوع المتغير بعد تعيينه. يُسمى هذا بالتنويع الديناميكي (Dynamic Typing).\n\nx = 1         # int\nx = 'hello'   # -&gt; str\nx = [1, 2, 3] # -&gt; list\n\n\ntype(x)\n\nlist\n\n\n\n5.2.0.1 تمرين\n\nما نوع 3.14؟\nما نوع \"5\" + \"5\"؟\n\n\n# try it\n\nتذكر:\n\nالتعبيرات (Expressions) تنتج قيمة (value)\nكل قيمة (value) لها نوع (type)\n\n\ntype(4 + 2)\n\nint\n\n\n\ntype(\"Adam\" + \" \" + \"Basel\")\n\nstr\n\n\n\ntype(9 &gt; 5)\n\nbool\n\n\n\n\n5.2.0.2 تمرين\nما نوع التعبيرات التالية؟\n\n10 + 5\n\"Adam\" + \"Basel\"\nTrue or False\n\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "03_hello.html#الكلمات-المحجوزة",
    "href": "03_hello.html#الكلمات-المحجوزة",
    "title": "4  أول سطر",
    "section": "8.1 الكلمات المحجوزة",
    "text": "8.1 الكلمات المحجوزة\n\n\n\n\n\n\n\n\nالفئة (Category)\nالكلمة المحجوزة (Keyword)\nالوصف (Description)\n\n\n\n\nعوامل منطقية (Logical operators)\nand, or, not, is\nعوامل تستخدم لدمج التعبيرات البوليانية (Boolean expressions).\n\n\nعبارات شرطية (Conditional statements)\nif, elif, else\nكلمات محجوزة تستخدم لإنشاء عبارات شرطية.\n\n\nالحلقات (Loops)\nwhile, for, break, continue\nكلمات محجوزة تستخدم لإنشاء الحلقات.\n\n\nمعالجة الاستثناءات (Exception handling)\ntry, except, finally\nكلمات محجوزة تستخدم لمعالجة الاستثناءات.\n\n\nالدوال والفئات (Functions and classes)\ndef, class, return, yield, lambda\nكلمات محجوزة تستخدم لتعريف الدوال والفئات.\n\n\nأنواع البيانات (Data types)\nNone, True, False\nكلمات محجوزة تستخدم لتمثيل أنواع بيانات خاصة.\n\n\nأخرى (Other)\nimport, from, as, assert, global, nonlocal, with, pass\nكلمات محجوزة أخرى تستخدم لأغراض متنوعة.\n\n\n\nالخلية التالية تحتوي على أسماء متغيرات لا معنى لها. نقدم بديلاً أفضل أدناه ونلاحظ الفرق.\n\nx2 = 35\ny = 12.50\nmne = x2* y\nprint(mne)\n\n437.5\n\n\nيجب علينا استخدام أسماء ذات معنى، مثل:\n\nhours = 35\nrate = 12.50\npay = hours * rate\nprint(pay)\n\n437.5\n\n\nالنية من الكود الآن أصبحت أوضح بكثير.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "العشرون البايثونية",
    "section": "",
    "text": "تمهيد\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "تمهيد"
    ]
  },
  {
    "objectID": "env_setup.html",
    "href": "env_setup.html",
    "title": "Appendix A — بيئة الترميز",
    "section": "",
    "text": "النشاط: تعرف على بيئة التطوير (20 دقيقة)\nالأهداف:\n\nتعرف على كيفية عمل دفاتر الملاحظات التفاعلية مع Python\nتعرف على كيفية العمل مع Google Colab\n\nالأسئلة\nنظرة عامة على Colaboratory:\n\nما هو Colaboratory وكيف يفيد علماء البيانات؟\nوصف الخطوات اللازمة لتحميل ملف من جهازك المحلي إلى Colaboratory.\nكيف يمكنك تثبيت حزم Python في Colaboratory؟ قدم مثالاً.\nاشرح كيفية تثبيت Google Drive في Colaboratory ولماذا قد يكون مفيدًا.\n\nدليل Markdown:\n\nما هو Markdown ولماذا هو مفيد في دفاتر ملاحظات Colaboratory؟\nقم بإدراج ثلاثة خيارات أساسية لتنسيق النص في Markdown وقدم مثالاً لكل منها.\nكيف يمكنك إنشاء جدول باستخدام Markdown في دفتر ملاحظات Colaboratory؟ قدم جدولاً نموذجيًا.\nاشرح كيفية إضافة صور إلى دفتر ملاحظات Colaboratory باستخدام Markdown.\n\nالموارد:\n\nنظرة عامة على Colaboratory\nدليل Markdown\nالنحو الأساسي لـ Markdown",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>بيئة الترميز</span>"
    ]
  },
  {
    "objectID": "01_hello.html",
    "href": "01_hello.html",
    "title": "2  أول سطر",
    "section": "",
    "text": "2.1 أنواع البيانات",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "01_hello.html#القيم-والأنواع",
    "href": "01_hello.html#القيم-والأنواع",
    "title": "3  أول سطر",
    "section": "4.1 القيم والأنواع",
    "text": "4.1 القيم والأنواع\nهنا:\n\n10 يعتبر قيمة (value) من نوع (type) int\n\"Adam\" تعتبر قيمة (value) من نوع (type) str\n\n\ntype(10)\n\nint\n\n\n\ntype(\"Adam\")\n\nstr\n\n\nنخزن القيم في متغيرات (variables). المتغير هو اسم يشير إلى قيمة. يمكننا استخدام عامل = لتعيين قيمة لمتغير.\n\nx = 10\n\nالآن، يعيد type(x) نوع القيمة التي تحتوي عليها x.\n\ntype(x)\n\nint",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "01_hello.html#نظام-الكتابة-في-بايثون-ديناميكي",
    "href": "01_hello.html#نظام-الكتابة-في-بايثون-ديناميكي",
    "title": "3  أول سطر",
    "section": "4.2 نظام الكتابة في بايثون ديناميكي",
    "text": "4.2 نظام الكتابة في بايثون ديناميكي\nعلى عكس لغات التنويع الثابت (Static Typing)، تسمح لك بايثون بتغيير نوع المتغير بعد تعيينه. يُسمى هذا بالتنويع الديناميكي (Dynamic Typing).\n\nx = 1         # int\nx = 'hello'   # -&gt; str\nx = [1, 2, 3] # -&gt; list\n\n\ntype(x)\n\nlist\n\n\n\n4.2.0.1 تمرين\n\nما نوع 3.14؟\nما نوع \"5\" + \"5\"؟\n\n\n# try it\n\nتذكر:\n\nالتعبيرات (Expressions) تنتج قيمة (value)\nكل قيمة (value) لها نوع (type)\n\n\ntype(4 + 2)\n\nint\n\n\n\ntype(\"Adam\" + \" \" + \"Basel\")\n\nstr\n\n\n\ntype(9 &gt; 5)\n\nbool\n\n\n\n\n4.2.0.2 تمرين\nما نوع التعبيرات التالية؟\n\n10 + 5\n\"Adam\" + \"Basel\"\nTrue or False\n\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "01_hello.html#الكلمات-المحجوزة",
    "href": "01_hello.html#الكلمات-المحجوزة",
    "title": "3  أول سطر",
    "section": "7.1 الكلمات المحجوزة",
    "text": "7.1 الكلمات المحجوزة\n\n\n\n\n\n\n\n\nالفئة (Category)\nالكلمة المحجوزة (Keyword)\nالوصف (Description)\n\n\n\n\nعوامل منطقية (Logical operators)\nand, or, not, is\nعوامل تستخدم لدمج التعبيرات البوليانية (Boolean expressions).\n\n\nعبارات شرطية (Conditional statements)\nif, elif, else\nكلمات محجوزة تستخدم لإنشاء عبارات شرطية.\n\n\nالحلقات (Loops)\nwhile, for, break, continue\nكلمات محجوزة تستخدم لإنشاء الحلقات.\n\n\nمعالجة الاستثناءات (Exception handling)\ntry, except, finally\nكلمات محجوزة تستخدم لمعالجة الاستثناءات.\n\n\nالدوال والفئات (Functions and classes)\ndef, class, return, yield, lambda\nكلمات محجوزة تستخدم لتعريف الدوال والفئات.\n\n\nأنواع البيانات (Data types)\nNone, True, False\nكلمات محجوزة تستخدم لتمثيل أنواع بيانات خاصة.\n\n\nأخرى (Other)\nimport, from, as, assert, global, nonlocal, with, pass\nكلمات محجوزة أخرى تستخدم لأغراض متنوعة.\n\n\n\nالخلية التالية تحتوي على أسماء متغيرات لا معنى لها. نقدم بديلاً أفضل أدناه ونلاحظ الفرق.\n\nx2 = 35\ny = 12.50\nmne = x2* y\nprint(mne)\n\n437.5\n\n\nيجب علينا استخدام أسماء ذات معنى، مثل:\n\nhours = 35\nrate = 12.50\npay = hours * rate\nprint(pay)\n\n437.5\n\n\nالنية من الكود الآن أصبحت أوضح بكثير.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "01_hello.html#نظرة-عامة-على-أنواع-البيانات-data-types-overview",
    "href": "01_hello.html#نظرة-عامة-على-أنواع-البيانات-data-types-overview",
    "title": "3  أول سطر",
    "section": "7.2 نظرة عامة على أنواع البيانات (Data Types: Overview)",
    "text": "7.2 نظرة عامة على أنواع البيانات (Data Types: Overview)\nتمثل أنواع البيانات (Data types) نوع القيمة التي تخبرنا ما هي العمليات التي يمكن إجراؤها على بيانات معينة. على سبيل المثال:\n\nيمكن جمع الأرقام وطرحها وضربها\nيمكن دمج السلاسل النصية (strings) مع سلسلة نصية أخرى.\n\nإليك جدول بأكثر أنواع البيانات شيوعًا في بايثون (Python):\n\n\n\n\n\n\n\n\nالنوع (Type)\nنوع بايثون (Python Type)\nمثال على التعيين (Assignment Example)\n\n\n\n\nنص (Text)\nstr\nmessage = \"Hello, world!\"\n\n\nرقمي (Numeric)\nint, float, complex\nnumber = 10, pi = 3.14, complex_number = 1 + 2j\n\n\nتسلسل (Sequence)\nlist, tuple, range\nmy_list = [1, 2, 3, 4, 5], my_tuple = (1, 2, 3, 4, 5), my_range = range(10)\n\n\nتعيين (Mapping)\ndict\nmy_dict = {\"name\": \"Adam\", \"age\": 25}\n\n\nمجموعة (Set)\nset, frozenset\nmy_set = {1, 2, 3, 4, 5}, my_frozenset = frozenset({1, 2, 3, 4, 5})\n\n\nمنطقي (Boolean)\nbool\nis_true = True, is_false = False\n\n\nثنائي (Binary)\nbytes, bytearray, memoryview\nmy_bytes = b\"Hello, world!\", my_bytearray = bytearray(b\"Hello, world!\"), my_memoryview = memoryview(b\"Hello, world!\")\n\n\nلا شيء (None)\nNoneType\nnone = None\n\n\n\nتوثيق أنواع البيانات: https://docs.python.org/3/library/datatypes.html",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  مقدمة",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "01_hello.html#أنواع-البيانات",
    "href": "01_hello.html#أنواع-البيانات",
    "title": "2  أول سطر",
    "section": "",
    "text": "2.1.1 القيم والأنواع\nهنا:\n\n10 يعتبر قيمة (value) من نوع (type) int\n\"Adam\" تعتبر قيمة (value) من نوع (type) str\n\n\ntype(10)\n\nint\n\n\n\ntype(\"Adam\")\n\nstr\n\n\nنخزن القيم في متغيرات (variables). المتغير هو اسم يشير إلى قيمة. يمكننا استخدام عامل = لتعيين قيمة لمتغير.\n\nx = 10\n\nالآن، يعيد type(x) نوع القيمة التي تحتوي عليها x.\n\ntype(x)\n\nint\n\n\n\n\n2.1.2 التويع الديناميكي (Dynamic Typing)\nعلى عكس لغات التنويع الثابت (Static Typing)، تسمح لك بايثون بتغيير نوع المتغير بعد تعيينه. يُسمى هذا بالتنويع الديناميكي (Dynamic Typing).\n\nx = 1         # int\nx = 'hello'   # -&gt; str\nx = [1, 2, 3] # -&gt; list\n\n\ntype(x)\n\nlist\n\n\n\n2.1.2.1 تمرين\n\nما نوع 3.14؟\nما نوع \"5\" + \"5\"؟\n\n\n# try it\n\nتذكر:\n\nالتعبيرات (Expressions) تنتج قيمة (value)\nكل قيمة (value) لها نوع (type)\n\n\ntype(4 + 2)\n\nint\n\n\n\ntype(\"Adam\" + \" \" + \"Basel\")\n\nstr\n\n\n\ntype(9 &gt; 5)\n\nbool\n\n\n\n\n2.1.2.2 تمرين\nما نوع التعبيرات التالية؟\n\n10 + 5\n\"Adam\" + \"Basel\"\nTrue or False\n\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "01_hello.html#المتغيرات",
    "href": "01_hello.html#المتغيرات",
    "title": "2  أول سطر",
    "section": "2.2 المتغيرات",
    "text": "2.2 المتغيرات\nيأخذ التعيين القيم (والتعبيرات المقيمة) ويعينها لمتغير:\n\nnum = 10\nname = \"Adam\" + \" \" + \"Basel\"\nb = 9 &gt; 5\n\nprint(type(num))   # int\nprint(type(name))  # str\nprint(type(b))     # bool\n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt;\n\n\nيُظهر الكود التالي تعيين متغير:\n\nx هو متغير (variable)\n5 هو قيمة (value)\n= هو عامل التعيين (assignment operator)\n\n\nx = 5\n\nالقيمة 5 مخزنة في عنوان ذاكري (memory address) x حتى نتمكن من الوصول إليه لاحقًا.\n\nprint(x)\n\n5\n\n\nلاحظ أن سلسلة الأرقام ليست هي نفسها الرقم:\n\nالرقم 20 هو قيمة من نوع (type) int\nالسلسلة النصية \"20\" هي قيمة من نوع (type) str\n\nملاحظة جانبية: التنصيص المفرد ('A') والتنصيص المزدوج (\"A\") متكافئة في بايثون (Python).\n\nx = 20\ny = '20'\n\nprint(x, type(x))\nprint(y, type(y))\n\n20 &lt;class 'int'&gt;\n20 &lt;class 'str'&gt;\n\n\n\nprint(x + y)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[45], line 1\n----&gt; 1 print(x + y)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nنتوقع خطأ وراء هذا السطر لأننا نحاول إضافة سلسلة نصية (string) إلى رقم (number).\nيجب علينا تحويل السلسلة النصية إلى رقم قبل أن نتمكن من إضافتها إلى رقم آخر.\n\nz = int(y)\nprint(z, type(z))\nprint(x + z)\n\n20 &lt;class 'int'&gt;\n40",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "01_hello.html#أخذ-المدخلات-من-المستخدم",
    "href": "01_hello.html#أخذ-المدخلات-من-المستخدم",
    "title": "3  أول سطر",
    "section": "3.3 أخذ المدخلات من المستخدم",
    "text": "3.3 أخذ المدخلات من المستخدم\nيمكننا استخدام دالة input() لأخذ المدخلات من المستخدم. ستقوم دالة input() بطباعة رسالة على الشاشة ثم تنتظر من المستخدم أن يكتب شيئًا ويضغط على Enter. بمجرد أن يضغط المستخدم على Enter، ستعيد دالة input() ما كتبه المستخدم.\nملاحظة جانبية (لمستخدمي VS Code): ستظهر نافذة الإدخال في أعلى الشاشة.\nname = input(\"What is your name? \")\nيمكننا الآن استخدام المتغير name للترحيب بالمستخدم:\nprint(\"Welcome\", name, \"to the Python course\")\nيمكننا أيضًا أخذ الأرقام. ومع ذلك، نظرًا لأن دالة input تعيد دائمًا سلسلة نصية (string)، نحتاج إلى تحويل السلسلة النصية إلى رقم باستخدام دالة int():\n\npassword = input(\"Enter password: \")\n\nif password == \"pythonista\":\n    print(\"Welcome to the course\")\nelse:\n    print(\"Sorry, wrong password\")\n\n\n3.3.0.1 تمرين:\n\nاستخدم دالة input لطلب الاسم الأول من المستخدم وخزنه في متغير يسمى first_name\nاستخدم دالة input لطلب الاسم الأخير من المستخدم وخزنه في متغير يسمى last_name\nاطبع رسالة ترحيب للمستخدم باستخدام اسمه الأول والأخير\n\nاكتب الكود الخاص بك أدناه:\n\n# try it\n\n\n\n3.3.0.2 تمرين\nاحسب مساحة المستطيل:\n\nاستخدم دالة input لطلب عرض (width) المستطيل من المستخدم\nاستخدم دالة input لطلب ارتفاع (height) المستطيل من المستخدم\nاحسب مساحة المستطيل وخزنها في متغير يسمى مساحة (area)\nاطبع مساحة المستطيل\n\nملاحظة: يجب عليك تحويل العرض (width) و الارتفاع (height) إلى أرقام باستخدام دالة int().\n\n# try it\n\n\n\n3.3.0.3 تمرين\nاطلب من المستخدم إدخال العمر (age) وأخبره كم سيكون عمره بعد 10 سنوات.\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "01_hello.html#قواعد-في-تسمية-المتغيرات",
    "href": "01_hello.html#قواعد-في-تسمية-المتغيرات",
    "title": "2  أول سطر",
    "section": "2.3 قواعد في تسمية المتغيرات",
    "text": "2.3 قواعد في تسمية المتغيرات\nالقاعدة الأولى: المتغيرات حساسة لحالة الأحرف (case-sensitive). مثال:\nmy_variable = 5\nMy_Variable = 10\nجرب تشغيل الخلية أعلاه وستحصل على قيمتين مختلفتين. لذلك، يجب أن تكون حذرًا عند تسمية المتغيرات.\nالقاعدة الثانية: لا يمكن أن تبدأ أسماء المتغيرات برقم. مثال:\n2my_variable = 5\nجرب تشغيل الخلية أعلاه وستحصل على خطأ. لذلك، يجب أن تبدأ أسماء المتغيرات بحرف.\nالقاعدة الثالثة: لا يمكنك استخدام الكلمات المحجوزة (reserved keywords). مثال:\nclass = 5\nTrue = 1\nbreak = True\nجرب تشغيل الخلية أعلاه وستحصل على خطأ. لذلك، يجب تجنب استخدام الكلمات المحجوزة كأسماء للمتغيرات.\n\n2.3.1 الكلمات المحجوزة\n\n\n\n\n\n\n\n\nالفئة (Category)\nالكلمة المحجوزة (Keyword)\nالوصف (Description)\n\n\n\n\nعوامل منطقية (Logical operators)\nand, or, not, is\nعوامل تستخدم لدمج التعبيرات البوليانية (Boolean expressions).\n\n\nعبارات شرطية (Conditional statements)\nif, elif, else\nكلمات محجوزة تستخدم لإنشاء عبارات شرطية.\n\n\nالحلقات (Loops)\nwhile, for, break, continue\nكلمات محجوزة تستخدم لإنشاء الحلقات.\n\n\nمعالجة الاستثناءات (Exception handling)\ntry, except, finally\nكلمات محجوزة تستخدم لمعالجة الاستثناءات.\n\n\nالدوال والفئات (Functions and classes)\ndef, class, return, yield, lambda\nكلمات محجوزة تستخدم لتعريف الدوال والفئات.\n\n\nأنواع البيانات (Data types)\nNone, True, False\nكلمات محجوزة تستخدم لتمثيل أنواع بيانات خاصة.\n\n\nأخرى (Other)\nimport, from, as, assert, global, nonlocal, with, pass\nكلمات محجوزة أخرى تستخدم لأغراض متنوعة.\n\n\n\nالقاعدة الرابعة: يُكره استخدام أسماء الدوال المبنية في اللغة (built-in function names). مثال:\nsum = 5\nmax = 10\nlist = [10, 20, 30]\nيسبب هذا ما يُعرف بـ تعارض الأسماء (naming conflict)، وهو يجعل الكود أقل فهمًا وأقل قابلية للصيانة. وهو سبب لنوع من أخطر أنواع الأخطاء وهي الأخطاء الصامتة (silent errors) ، إذ لا تظهر رسالة الخطأ وإن ظهرت فإنها غير دالة على السبب الحقيقي للخطأ.\nالخلية التالية تحتوي على أسماء متغيرات لا معنى لها. نقدم بديلاً أفضل أدناه ونلاحظ الفرق.\n\nx2 = 35\ny = 12.50\nmne = x2* y\nprint(mne)\n\n437.5\n\n\nيجب استخدام أسماء ذات معنى، مثل:\n\nhours = 35\nrate = 12.50\npay = hours * rate\nprint(pay)\n\n437.5\n\n\nالغرض من الكود أصبح واضحًا.\n\n\n2.3.2 نظرة عامة على أنواع البيانات\nتمثل أنواع البيانات (Data types) نوع القيمة التي تخبرنا ما هي العمليات التي يمكن إجراؤها على بيانات معينة. على سبيل المثال:\n\nيمكن جمع الأرقام وطرحها وضربها\nأما السلاسل النصية (Strings)، فيمكننا دمجها وتكرارها\n\nوهذا تشجير غير مستوفي لأنواع البيانات في بايثون:\n\n\n\n\n\ngraph LR\n    A[Object]\n    \n    A --&gt; A1[None]\n\n    A --&gt; A2[numbers.Number]\n    A2 --&gt; A21[numbers.Integral]\n    A21 --&gt; A211[Integers: int]\n    A21 --&gt; A212[Booleans: bool]\n    A2 --&gt; A22[numbers.Real: float]\n    A2 --&gt; A23[numbers.Complex: complex]\n    \n    A --&gt; A3[Sequences]\n    A3 --&gt; A31[Immutable Sequences]\n    A31 --&gt; A311[Strings]\n    A31 --&gt; A312[Tuples]\n    A31 --&gt; A313[Bytes]\n    A3 --&gt; A32[Mutable Sequences]\n    A32 --&gt; A321[Lists]\n    A32 --&gt; A322[Byte Arrays]\n    \n    A --&gt; A4[Set Types]\n    A4 --&gt; A41[Sets]\n    A4 --&gt; A42[Frozen Sets]\n\n    A --&gt; A5[Mappings]\n    A5 --&gt; A51[dict]\n\n    A --&gt; A6[Callable Types]\n    A6 --&gt; A61[Functions]\n    A6 --&gt; A62[Classes]\n    A62 --&gt; A7[Instances]\n\n\n\n\n\n\nالكائنات (Objects) هي تجريدات بايثون (Python) للبيانات. جميع البيانات في برنامج بايثون يتم تمثيلها بواسطة كائنات وعلاقات بينها. (وفقًا لنموذج فون نيومان (Von Neumann) لـ “الكمبيوتر المخزن للبرنامج”، يتم تمثيل الكود أيضًا بواسطة كائنات.)\nإليك جدول بأكثر أنواع البيانات شيوعًا في بايثون (Python):\n\n\n\n\n\n\n\n\nالنوع\nالنوع في بايثون\nمثال\n\n\n\n\nنص (Text)\nstr\nmessage = \"Hello, world!\"\n\n\nرقمي (Numeric)\nint, float, complex\nnumber = 10, pi = 3.14, complex_number = 1 + 2j\n\n\nتسلسل (Sequence)\nlist, tuple, range\nmy_list = [1, 2, 3, 4, 5], my_tuple = (1, 2, 3, 4, 5), my_range = range(10)\n\n\nربط (Mapping)\ndict\nmy_dict = {\"name\": \"Adam\", \"age\": 25}\n\n\nمجموعة (Set)\nset, frozenset\nmy_set = {1, 2, 3, 4, 5}, my_frozenset = frozenset({1, 2, 3, 4, 5})\n\n\nبولي (Boolean)\nbool\nis_true = True, is_false = False\n\n\nثنائي (Binary)\nbytes, bytearray, memoryview\nmy_bytes = b\"Hello, world!\", my_bytearray = bytearray(b\"Hello, world!\"), my_memoryview = memoryview(b\"Hello, world!\")\n\n\nلا شيء (None)\nNoneType\nnone = None\n\n\n\nانظر: توثيق أنواع البيانات",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "03_numbers.html",
    "href": "03_numbers.html",
    "title": "3  الأرقام",
    "section": "",
    "text": "3.1 وظيفة الأرقام في لغة البرمجة\nx = 5\ny = 3.0\nz = -10\nb = True\nc = 1 + 2j\nprint(type(x))\nprint(type(y))\nprint(type(z))\nprint(type(b))\nprint(type(c))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'int'&gt;\n&lt;class 'bool'&gt;\n&lt;class 'complex'&gt;",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "03_numbers.html#دوال-رياضية",
    "href": "03_numbers.html#دوال-رياضية",
    "title": "3  الأرقام",
    "section": "3.2 دوال رياضية",
    "text": "3.2 دوال رياضية\n\n3.2.1 دوال مبنية\n\n# الدوال المدمجة للأرقام (Numeric built-in functions)\nprint(abs(z)) # القيمة المطلقة (Absolute value)\nprint(pow(x,y)) # القوة (x to the power of y)\nprint(max(x,y)) # القيمة العظمى (Maximum of x and y)\nprint(min(x,y)) # القيمة الصغرى (Minimum of x and y)\nprint(round(y)) # التقريب (Round to nearest integer)\n\n10\n125.0\n5\n3.0\n3\n\n\nللوصول إلى دوال رياضية إضافية: نقوم بـ import math، ثم نستخدم البادئة math. للوصول إلى الدوال.\n\nimport math\n\n# حساب المسافة بين نقطتين\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\nلمعرفة الدوال المتاحة في وحدة math، يمكنك استخدام دالة dir():\n\ndir(math)\n\n['__doc__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'acos',\n 'acosh',\n 'asin',\n 'asinh',\n 'atan',\n 'atan2',\n 'atanh',\n 'cbrt',\n 'ceil',\n 'comb',\n 'copysign',\n 'cos',\n 'cosh',\n 'degrees',\n 'dist',\n 'e',\n 'erf',\n 'erfc',\n 'exp',\n 'exp2',\n 'expm1',\n 'fabs',\n 'factorial',\n 'floor',\n 'fma',\n 'fmod',\n 'frexp',\n 'fsum',\n 'gamma',\n 'gcd',\n 'hypot',\n 'inf',\n 'isclose',\n 'isfinite',\n 'isinf',\n 'isnan',\n 'isqrt',\n 'lcm',\n 'ldexp',\n 'lgamma',\n 'log',\n 'log10',\n 'log1p',\n 'log2',\n 'modf',\n 'nan',\n 'nextafter',\n 'perm',\n 'pi',\n 'pow',\n 'prod',\n 'radians',\n 'remainder',\n 'sin',\n 'sinh',\n 'sqrt',\n 'sumprod',\n 'tan',\n 'tanh',\n 'tau',\n 'trunc',\n 'ulp']\n\n\n\n3.2.1.1 تمرين\nاكتب برنامجًا يحسب مساحة الدائرة باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nقم بتعيين نصف القطر إلى متغير.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\nتلميح: يمكنك استخدام الثابت math.pi للحصول على قيمة \\(\\pi\\).\n\n\n3.2.1.2 تمرين\nاكتب برنامجًا يقبل نصف قطر الدائرة من المستخدم ويحسب المساحة والمحيط:\n\n# your code here",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "03_numbers.html#تمثيل-الأعداد",
    "href": "03_numbers.html#تمثيل-الأعداد",
    "title": "3  الأرقام",
    "section": "3.3 تمثيل الأعداد",
    "text": "3.3 تمثيل الأعداد\n\n# Hexadecimal\nassert 0xA == 10\nassert 0xB == 0xb\n\n\n# الدوال المدمجة (Built-in functions)\nprint(hex(x)) # التمثيل الست عشري (Hex representation)\nprint(oct(x)) # التمثيل الثماني (Octal representation)\nprint(bin(x)) # التمثيل الثنائي (Binary representation)\nprint(~x) # عكس (bitwise NOT)\n\n0x5\n0o5\n0b101\n-6\n\n\nHere’s the table you requested, with the bitwise operations sorted in ascending priority:\n\n\n\nOperation\nResult\n\n\n\n\n~x\nThe bits of x inverted\n\n\nx &lt;&lt; n\nx shifted left by n bits\n\n\nx &gt;&gt; n\nx shifted right by n bits\n\n\nx & y\nBitwise AND of x and y\n\n\nx ^ y\nBitwise XOR (exclusive or) of x and y\n\n\nx | y\nBitwise OR of x and y",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "03_numbers.html#المقارنة",
    "href": "03_numbers.html#المقارنة",
    "title": "3  الأرقام",
    "section": "3.4 المقارنة",
    "text": "3.4 المقارنة\nالأرقام المنطقية (Booleans) تنتج من عمليات المقارنة:\n\n# العمليات المقارنة (Comparison operations)\nprint(x == y) # يساوي (Equal to)\nprint(x != y) # لا يساوي (Not equal to)\nprint(x &gt; y) # أكبر من (Greater than)\nprint(x &lt; y) # أصغر من (Less than)\nprint(x &gt;= y) # أكبر من أو يساوي (Greater than or equal to)\nprint(x &lt;= y) # أصغر من أو يساوي (Less than or equal to)\n\nFalse\nTrue\nTrue\nFalse\nTrue\nFalse",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "03_numbers.html#دوال-مساعدة",
    "href": "03_numbers.html#دوال-مساعدة",
    "title": "3  الأرقام",
    "section": "3.5 دوال مساعدة",
    "text": "3.5 دوال مساعدة\n\nprint(sum([x,y,z])) # مجموع الأرقام في القائمة (Sum of all numbers in list)\n\n-2.0",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "03_numbers.html#وظيفة-الأرقام-في-لغة-البرمجة",
    "href": "03_numbers.html#وظيفة-الأرقام-في-لغة-البرمجة",
    "title": "3  الأرقام",
    "section": "",
    "text": "الأعداد الصحيحة (Integers) للفهرسة والعد: ..., -2, -1, 0, 1, 2, ...\nالأعداد العشرية (Floats) لتمثيل الكميات مثل المال، المسافة، والوقت: 3.14, 2.718, 0.0, 15.0\nالأعداد المركبة (Complex) في الرياضيات والهندسة: (1 + 2j), (1.0 - 2.0j)\nالقيم المنطقية (Booleans) لتمثيل قيم الحقيقة: True, False\n\n\n\n\n3.1.1 العمليات الحسابية\n\n# العمليات الحسابية (Arithmetic operations)\nprint(x + y) # الجمع (Addition)\nprint(x - y) # الطرح (Subtraction)\nprint(x * y) # الضرب (Multiplication)\nprint(x / y) # القسمة (Division)\nprint(x % y) # باقي القسمة (Remainder)\nprint(x ** y) # الأس (Exponentiation)\n\n8.0\n2.0\n15.0\n1.6666666666666667\n2.0\n125.0\n\n\n\n\n3.1.2 ماذا تعني صفة العددية؟\nالاشتراك في صفة العددية يعني أنها تقبل العمليات الحسابية ، مع ملاحظة أن النوع الأقل دقة يتحول إلى النوع الأعلى دقة:\n\nفمثلاً: int + float = float\nوكذلك: int / int = float\nوأيضًا: bool * int = int\nوهكذا: int * complex = complex\n\n\nprint(x + z)\nprint(x + y)\nprint(y * z)\nprint(b * x)\nprint(c + x)\n\n-5\n8.0\n-30.0\n5\n(6+2j)\n\n\nلاحظ أن قسمة الصحيح تقوم بتقريب النتيجة إلى الأقرب:\n\nprint(7 / 2)  # قسمة صحيحٍ تنتج عشريًا\nprint(7 // 2) # قسمة صحيح تنتج صحيحًا\n\n3.5\n3\n\n\n\n3.1.2.1 تمرين\nتحقق من نوع كل من التعبيرين السابقين باستخدام الدالة type(). هل يمكنك استخراج قاعدة من هذه الأمثلة؟\n\n7 / 2\n7 // 2\n7.0 / 2\n7 / 2.0\n\n\n# try it\n\nجرب الآتي حتى تستكشف ماذا يحصل لو:\n\nint + bool\nint * str\nstr * int\nstr + str\nint + str (لاحظ أن هذه العملية ستفشل)\n\n\ni = 5\nb = True\ns1 = '5'\ns2 = '11'\n\nprint(i + b)  # int + bool\n# ... أكمل البقية ...\n\n6\n\n\nوبهذا يتبين أن النوع يؤثر في طبيعة العملية فمثلاً:\n\n\"5\" + \"5\" -&gt; \"55\" وهو الدمج بين النصين وإن كانا أرقامًا\n5 + 5 -&gt; 10 وهو الجمع المعروف\n\n\n\n\n3.1.3 ترتيب العمليات (Operator precedence)\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس\nالأسس\nالضرب والقسمة\nالجمع والطرح\n\nللتفصيل الشامل انظر: Evaluation order\n\n3.1.3.1 تمرين\nأضف أقواس لتغيير النتيجة لتطابق التوكيد:\n\nassert 3 + 2 * 5 == 25\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 assert 3 + 2 * 5 == 25\n\nAssertionError: \n\n\n\nالحل:\n\nassert (3 + 2) * 5 == 25\n\nمثال آخر:\n\nassert 8 - 4 / 2 == 2\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 assert 8 - 4 / 2 == 2\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n\n# try it\n\nمثال أخير:\n\nassert 2 ** 3 * 4 == 4096\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 assert 2 ** 3 * 4 == 4096\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "03_numbers.html#الدوال-الرياضية-المضمنة",
    "href": "03_numbers.html#الدوال-الرياضية-المضمنة",
    "title": "3  الأرقام",
    "section": "3.2 الدوال الرياضية المضمّنة",
    "text": "3.2 الدوال الرياضية المضمّنة\n\nprint(abs(z)) # القيمة المطلقة (Absolute value)\nprint(pow(x,y)) # القوة\nprint(max(x,y)) # القيمة العظمى\nprint(min(x,y)) # القيمة الصغرى\n\n10\n125.0\n5\n3.0\n\n\nللوصول إلى دوال رياضية إضافية: نقوم بـ import math، ثم نستخدم البادئة math. للوصول إلى الدوال.\n\nimport math\n\n# حساب المسافة بين نقطتين\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\n\nimport math\n\nprint(round(y, 2)) # تقريب إلى رقمين بعد الفاصلة\nprint(math.floor(y)) # تقريب لأقرب عدد صحيح أصغر\nprint(math.ceil(y)) # تقريب لأقرب عدد صحيح أكبر\nprint(math.trunc(y)) # حذف ما بعد الفاصلة\n\n3.0\n3\n3\n3\n\n\n\n3.2.0.1 تمرين\nيمكننا حساب مساحة المستطيل باستخدام الصيغة التالية:\n\\[\narea = length \\times width\n\\]\n\n# Calculate the area of a rectangule\nlength, width = 10, 5\narea = length * width\n\nprint(area)\n\n50\n\n\n\n\n3.2.0.2 تمرين\nاكتب برنامجًا ليعرف رقمين ثم اطبع مجموعهما، الفرق بينهما، حاصل ضربهما، خارج القسمة، وباقي القسمة. استخدم أسماء متغيرات وتعليقات مناسبة.\n\n# try it\n\n\n\n3.2.0.3 تمرين\nاحسب مساحة المكعب باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\n\nقم بتعيين العرض (width)، الطول (length)، والارتفاع (height) إلى متغيرات.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\n\n# try it\n\n\n\n3.2.0.4 تمرين\nاكتب برنامجًا يطلب من المستخدم إدخال عدد الساعات (hours) ومعدل الأجر لكل ساعة (rate per hour) لحساب الأجر الإجمالي (gross pay).\n\n# your code here\n\n\n\n3.2.0.5 تمرين\nاكتب برنامجًا يطلب من المستخدم درجة الحرارة بالسلسيوس (Celsius)، ثم يحول درجة الحرارة إلى فهرنهايت (Fahrenheit)، ويطبع درجة الحرارة المحولة.\n\n# your code here\n\n\n\n3.2.0.6 تمرين\nاكتب برنامجًا يحسب مساحة الدائرة باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nقم بتعيين نصف القطر إلى متغير.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\nتلميح: يمكنك استخدام الثابت math.pi للحصول على قيمة \\(\\pi\\).\n\n# your code here",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "03_numbers.html#العمليات-على-مستوى-البت",
    "href": "03_numbers.html#العمليات-على-مستوى-البت",
    "title": "3  الأرقام",
    "section": "3.3 العمليات على مستوى البت",
    "text": "3.3 العمليات على مستوى البت\n\n\n\n\n\ngraph LR\n    A[Object]\n\n    A --&gt; A2[Number]\n    A2 --&gt; A21[Integral]\n    A21 --&gt; A211[Integers: int]\n    A21 --&gt; A212[Booleans: bool]\n\n\n\n\n\n\nالعمليات على مستوى البت (Bitwise operations) تكون منطقية فقط للأعداد الصحيحة (Integral).\n\n\n\nعشري (Decimal)\nست عشري (Hexadecimal)\nثنائي (Binary)\n\n\n\n\n0\n0\n00000000\n\n\n1\n1\n00000001\n\n\n2\n2\n00000010\n\n\n3\n3\n00000011\n\n\n4\n4\n00000100\n\n\n5\n5\n00000101\n\n\n6\n6\n00000110\n\n\n7\n7\n00000111\n\n\n8\n8\n00001000\n\n\n9\n9\n00001001\n\n\n10\na\n00001010\n\n\n11\nb\n00001011\n\n\n12\nc\n00001100\n\n\n13\nd\n00001101\n\n\n14\ne\n00001110\n\n\n15\nf\n00001111\n\n\n16\n10\n00010000\n\n\n\nيمكن عرض الأعداد الصحيحة بالتمثيل الثنائي أو الست عشري:\n\nx = 6\nprint(bin(x)) # ثنائي\nprint(hex(x)) # ست عشري\n\nx = 16\nprint(bin(x)) # ثنائي\nprint(hex(x)) # ست عشري\n\n0b110\n0x6\n0b10000\n0x10\n\n\nيسرد هذا الجدول العمليات على مستوى البت مرتبة حسب الأولوية التصاعدية:\n\n\n\nالعملية\nالنتيجة\n\n\n\n\n~x\nعكس جميع بتات x\n\n\nx &lt;&lt; n\nإزاحة x إلى اليسار بمقدار n بتات\n\n\nx &gt;&gt; n\nإزاحة x إلى اليمين بمقدار n بتات\n\n\nx & y\nعملية AND على مستوى البت بين x و y\n\n\nx ^ y\nعملية XOR (exclusive or) على مستوى البت بين x و y\n\n\nx | y\nعملية OR على مستوى البت بين x و y",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأرقام</span>"
    ]
  },
  {
    "objectID": "02_hello.html",
    "href": "02_hello.html",
    "title": "2  أول سطر",
    "section": "",
    "text": "2.1 أنواع البيانات",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "02_hello.html#أنواع-البيانات",
    "href": "02_hello.html#أنواع-البيانات",
    "title": "2  أول سطر",
    "section": "",
    "text": "2.1.1 القيم والأنواع\nهنا:\n\n10 يعتبر قيمة (value) من نوع (type) int\n\"Adam\" تعتبر قيمة (value) من نوع (type) str\n\n\ntype(10)\n\nint\n\n\n\ntype(\"Adam\")\n\nstr\n\n\nنخزن القيم في متغيرات (variables). المتغير هو اسم يشير إلى قيمة. يمكننا استخدام عامل = لتعيين قيمة لمتغير.\n\nx = 10\n\nالآن، يعيد type(x) نوع القيمة التي تحتوي عليها x.\n\ntype(x)\n\nint\n\n\n\n\n2.1.2 التويع الديناميكي (Dynamic Typing)\nعلى عكس لغات التنويع الثابت (Static Typing)، تسمح لك بايثون بتغيير نوع المتغير بعد تعيينه. يُسمى هذا بالتنويع الديناميكي (Dynamic Typing).\n\nx = 1         # int\nx = 'hello'   # -&gt; str\nx = [1, 2, 3] # -&gt; list\n\n\ntype(x)\n\nlist\n\n\n\n2.1.2.1 تمرين\n\nما نوع 3.14؟\nما نوع \"5\" + \"5\"؟\n\n\n# try it\n\nتذكر:\n\nالتعبيرات (Expressions) تنتج قيمة (value)\nكل قيمة (value) لها نوع (type)\n\n\ntype(4 + 2)\n\nint\n\n\n\ntype(\"Adam\" + \" \" + \"Basel\")\n\nstr\n\n\n\ntype(9 &gt; 5)\n\nbool\n\n\n\n\n2.1.2.2 تمرين\nما نوع التعبيرات التالية؟\n\n10 + 5\n\"Adam\" + \"Basel\"\nTrue or False\n\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "02_hello.html#المتغيرات",
    "href": "02_hello.html#المتغيرات",
    "title": "2  أول سطر",
    "section": "2.2 المتغيرات",
    "text": "2.2 المتغيرات\nيأخذ التعيين القيم (والتعبيرات المقيمة) ويعينها لمتغير:\n\nnum = 10\nname = \"Adam\" + \" \" + \"Basel\"\nb = 9 &gt; 5\n\nprint(type(num))   # int\nprint(type(name))  # str\nprint(type(b))     # bool\n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt;\n\n\nيُظهر الكود التالي تعيين متغير:\n\nx هو متغير (variable)\n5 هو قيمة (value)\n= هو عامل التعيين (assignment operator)\n\n\nx = 5\n\nالقيمة 5 مخزنة في عنوان ذاكري (memory address) x حتى نتمكن من الوصول إليه لاحقًا.\n\nprint(x)\n\n5\n\n\nلاحظ أن سلسلة الأرقام ليست هي نفسها الرقم:\n\nالرقم 20 هو قيمة من نوع (type) int\nالسلسلة النصية \"20\" هي قيمة من نوع (type) str\n\nملاحظة جانبية: التنصيص المفرد ('A') والتنصيص المزدوج (\"A\") متكافئة في بايثون (Python).\n\nx = 20\ny = '20'\n\nprint(x, type(x))\nprint(y, type(y))\n\n20 &lt;class 'int'&gt;\n20 &lt;class 'str'&gt;\n\n\n\nprint(x + y)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 print(x + y)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nنتوقع خطأ وراء هذا السطر لأننا نحاول إضافة سلسلة نصية (string) إلى رقم (number).\nيجب علينا تحويل السلسلة النصية إلى رقم قبل أن نتمكن من إضافتها إلى رقم آخر.\n\nz = int(y)\nprint(z, type(z))\nprint(x + z)\n\n20 &lt;class 'int'&gt;\n40",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "02_hello.html#قواعد-في-تسمية-المتغيرات",
    "href": "02_hello.html#قواعد-في-تسمية-المتغيرات",
    "title": "2  أول سطر",
    "section": "2.3 قواعد في تسمية المتغيرات",
    "text": "2.3 قواعد في تسمية المتغيرات\nالقاعدة الأولى: المتغيرات حساسة لحالة الأحرف (case-sensitive). مثال:\nmy_variable = 5\nMy_Variable = 10\nجرب تشغيل الخلية أعلاه وستحصل على قيمتين مختلفتين. لذلك، يجب أن تكون حذرًا عند تسمية المتغيرات.\nالقاعدة الثانية: لا يمكن أن تبدأ أسماء المتغيرات برقم. مثال:\n2my_variable = 5\nجرب تشغيل الخلية أعلاه وستحصل على خطأ. لذلك، يجب أن تبدأ أسماء المتغيرات بحرف.\nالقاعدة الثالثة: لا يمكنك استخدام الكلمات المحجوزة (reserved keywords). مثال:\nclass = 5\nTrue = 1\nbreak = True\nجرب تشغيل الخلية أعلاه وستحصل على خطأ. لذلك، يجب تجنب استخدام الكلمات المحجوزة كأسماء للمتغيرات.\n\n2.3.1 الكلمات المحجوزة\n\n\n\n\n\n\n\n\nالفئة (Category)\nالكلمة المحجوزة (Keyword)\nالوصف (Description)\n\n\n\n\nعوامل منطقية (Logical operators)\nand, or, not, is\nعوامل تستخدم لدمج التعبيرات البوليانية (Boolean expressions).\n\n\nعبارات شرطية (Conditional statements)\nif, elif, else\nكلمات محجوزة تستخدم لإنشاء عبارات شرطية.\n\n\nالحلقات (Loops)\nwhile, for, break, continue\nكلمات محجوزة تستخدم لإنشاء الحلقات.\n\n\nمعالجة الاستثناءات (Exception handling)\ntry, except, finally\nكلمات محجوزة تستخدم لمعالجة الاستثناءات.\n\n\nالدوال والفئات (Functions and classes)\ndef, class, return, yield, lambda\nكلمات محجوزة تستخدم لتعريف الدوال والفئات.\n\n\nأنواع البيانات (Data types)\nNone, True, False\nكلمات محجوزة تستخدم لتمثيل أنواع بيانات خاصة.\n\n\nأخرى (Other)\nimport, from, as, assert, global, nonlocal, with, pass\nكلمات محجوزة أخرى تستخدم لأغراض متنوعة.\n\n\n\nالقاعدة الرابعة: يُكره استخدام أسماء الدوال المبنية في اللغة (built-in function names). مثال:\nsum = 5\nmax = 10\nlist = [10, 20, 30]\nيسبب هذا ما يُعرف بـ تعارض الأسماء (naming conflict)، وهو يجعل الكود أقل فهمًا وأقل قابلية للصيانة. وهو سبب لنوع من أخطر أنواع الأخطاء وهي الأخطاء الصامتة (silent errors) ، إذ لا تظهر رسالة الخطأ وإن ظهرت فإنها غير دالة على السبب الحقيقي للخطأ.\nالخلية التالية تحتوي على أسماء متغيرات لا معنى لها. نقدم بديلاً أفضل أدناه ونلاحظ الفرق.\n\nx2 = 35\ny = 12.50\nmne = x2* y\nprint(mne)\n\n437.5\n\n\nيجب استخدام أسماء ذات معنى، مثل:\n\nhours = 35\nrate = 12.50\npay = hours * rate\nprint(pay)\n\n437.5\n\n\nالغرض من الكود أصبح واضحًا.\n\n\n2.3.2 نظرة عامة على أنواع البيانات\nتمثل أنواع البيانات (Data types) نوع القيمة التي تخبرنا ما هي العمليات التي يمكن إجراؤها على بيانات معينة. على سبيل المثال:\n\nيمكن جمع الأرقام وطرحها وضربها\nأما السلاسل النصية (Strings)، فيمكننا دمجها وتكرارها\n\nوهذا تشجير غير مستوفي لأنواع البيانات في بايثون:\n\n\n\n\n\ngraph LR\n    A[Object]\n    \n    A --&gt; A1[None]\n\n    A --&gt; A2[numbers.Number]\n    A2 --&gt; A21[numbers.Integral]\n    A21 --&gt; A211[Integers: int]\n    A21 --&gt; A212[Booleans: bool]\n    A2 --&gt; A22[numbers.Real: float]\n    A2 --&gt; A23[numbers.Complex: complex]\n    \n    A --&gt; A3[Sequences]\n    A3 --&gt; A31[Immutable Sequences]\n    A31 --&gt; A311[Strings]\n    A31 --&gt; A312[Tuples]\n    A31 --&gt; A313[Bytes]\n    A3 --&gt; A32[Mutable Sequences]\n    A32 --&gt; A321[Lists]\n    A32 --&gt; A322[Byte Arrays]\n    \n    A --&gt; A4[Set Types]\n    A4 --&gt; A41[Sets]\n    A4 --&gt; A42[Frozen Sets]\n\n    A --&gt; A5[Mappings]\n    A5 --&gt; A51[dict]\n\n    A --&gt; A6[Callable Types]\n    A6 --&gt; A61[Functions]\n    A6 --&gt; A62[Classes]\n    A62 --&gt; A7[Instances]\n\n\n\n\n\n\nالكائنات (Objects) هي تجريدات بايثون (Python) للبيانات. جميع البيانات في برنامج بايثون يتم تمثيلها بواسطة كائنات وعلاقات بينها. (وفقًا لنموذج فون نيومان (Von Neumann) لـ “الكمبيوتر المخزن للبرنامج”، يتم تمثيل الكود أيضًا بواسطة كائنات.)\nإليك جدول بأكثر أنواع البيانات شيوعًا في بايثون (Python):\n\n\n\n\n\n\n\n\nالنوع\nالنوع في بايثون\nمثال\n\n\n\n\nنص (Text)\nstr\nmessage = \"Hello, world!\"\n\n\nرقمي (Numeric)\nint, float, complex\nnumber = 10, pi = 3.14, complex_number = 1 + 2j\n\n\nتسلسل (Sequence)\nlist, tuple, range\nmy_list = [1, 2, 3, 4, 5], my_tuple = (1, 2, 3, 4, 5), my_range = range(10)\n\n\nربط (Mapping)\ndict\nmy_dict = {\"name\": \"Adam\", \"age\": 25}\n\n\nمجموعة (Set)\nset, frozenset\nmy_set = {1, 2, 3, 4, 5}, my_frozenset = frozenset({1, 2, 3, 4, 5})\n\n\nبولي (Boolean)\nbool\nis_true = True, is_false = False\n\n\nثنائي (Binary)\nbytes, bytearray, memoryview\nmy_bytes = b\"Hello, world!\", my_bytearray = bytearray(b\"Hello, world!\"), my_memoryview = memoryview(b\"Hello, world!\")\n\n\nلا شيء (None)\nNoneType\nnone = None\n\n\n\nانظر: توثيق أنواع البيانات",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>أول سطر</span>"
    ]
  },
  {
    "objectID": "04_sequences.html",
    "href": "04_sequences.html",
    "title": "4  السلاسل",
    "section": "",
    "text": "4.1 Character Encoding\nCharacter encoding is the process of assigning numbers to graphical characters, especially the written characters of human language, allowing them to be stored, transmitted, and transformed using digital computers.\nASCII codes represent text in digital devices. ASCII has just 128 code points, of which only 95 are printable characters (English-only). The set of available punctuation had significant impact on the syntax of computer languages and text markup.\nANSII contain further characters from 128 to 255, which differ based on language.\nUnicode has over a million code points, but the first 128 of these are the same as ASCII",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_sequences.html#character-encoding",
    "href": "04_sequences.html#character-encoding",
    "title": "4  السلاسل",
    "section": "",
    "text": "4.1.0.1 Question: How many languages are covered by Unicode?\nAnswer: all of the languages that can be written in the following widely-used scripts: Latin, Greek, Cyrillic, Armenian, Hebrew, Arabic, Syriac, Thaana, Devanagari, Bengali, Gurmukhi, Oriya, Tamil, Telugu, Kannada, Malayalam, Sinhala, Thai, Lao, Tibetan, Myanmar, Georgian, Hangul, Ethiopic, Cherokee, Canadian Aboriginal Syllabics, Khmer, Mongolian, Han (Japanese, Chinese, Korean ideographs), Hiragana, Katakana, and Yi. Source\nFigure below: showing that if we try to save Arabic text (Unicode) using ASCII (a subset of it), we get warning, and we lose our work.\n\nError reads: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_sequences.html#indexing-and-slicing",
    "href": "04_sequences.html#indexing-and-slicing",
    "title": "4  السلاسل",
    "section": "4.3 Indexing and Slicing",
    "text": "4.3 Indexing and Slicing\n\nA string is a sequence of characters\nSequences can be indxed using []\n\n1st element is at index 0\n2nd element is at index 1\nlast element is at index -1\n\n\n\ntitle = \"Pythonista\"\n\n\n\nprint(title[2:]) # thonista\n\nthonista\n\n\n\nprint(title[0] == 'P')\nprint(title[-1] == title[9] == 'a')\n# title[10] # IndexError: string index out of range\n\nTrue\nTrue\n\n\n\n# TODO: weired case that needs to be understood\n# print(title[None:-4:-1])\n\n\n4.3.1 Slicing\nSequences can also be sliced using [start:end]\n\n\ntitle[0] == title[0:1] == 'P'\n\nTrue\n\n\n\n\nprint(title[2:5]) #\nprint(title[:5])\nprint(title[-4:])\nprint(title[-4:None])\n\ntho\nPytho\nista\nista\n\n\n\n4.3.1.1 Exercise\nEx: Given that name = \"Johnson\" What is the value of name[0]? name[1]? name[-1]? name[-2]?\n\n# try it\n\n\n\n4.3.1.2 Exercise\nEx: try name[1:3] and name[3:5]\n\n# try it\n\n\n\n\n4.3.2 We can also add a step to slicing [start:end:step]\n\ns = \"ABCDEF\"\n\n\ns[0:len(s):1] == s[0:None:1] == s[::] # default values\n\nTrue\n\n\n\ns[::-1]\n\n'FEDCBA'\n\n\nWe can also omit the start or end of the slice, which would implicitly mean the beginning or end of the string:\n\ns[0::2]\n\n'ACE'\n\n\n\n# s = \"ABCDEF\"\n# s[None:0:-1] # TODO: understand this weird case\n\n\ns[-1:0:-2]\n\n'FDB'\n\n\nEx: run and try to understand the following code\nname = \"Johnson\"\nprint(name[::2])\nprint(name[::-1])\nprint(name[1:5:2])\n\n# try it\n\nEx: For each of the following, specify the start, end, and step:\n\nname[::2]\nname[::-1]\nname[1:5:2]\n\nAnswer: …\n\n4.3.2.1 Exercise\nEx: Write a program that takes a string and prints the string in reverse.\n\n# try it\n\nEx: Write a program that takes a string and prints every other character in the string. Example: abcdef -&gt; bdf\n\n# try it\n\nEx: Write a program that takes a string and prints the string in reverse order, but only every other character. It also must capitalize it. Example: abcdef -&gt; ECA\n\n# try it\n\nEx: Count the number of o in the string hello world. Hint: use the .count() method.\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_sequences.html#string-formatting",
    "href": "04_sequences.html#string-formatting",
    "title": "4  السلاسل",
    "section": "4.4 String formatting",
    "text": "4.4 String formatting\n(Main) docs reference: printf-style String Formatting\nThere are 3 different ways to concatenate strings in Python:\n\nJoining individual strings with + operator\nformat string method\nf-strings\n\n\n# Using the + operator\nname = \"John\"\nage = 30\n\nx1 = \"My name is \" + name + \" and my age is \" + str(age)\nx2 = \"My name is {} and my age is {}\".format(name, age)\nx3 = f\"My name is {name} and my age is {age}\"\nprint(x1 == x2 == x3)\nprint(x1)\n\nTrue\nMy name is John and my age is 30\n\n\n\n4.4.0.1 Exercise\n\nconcatenate the strings first_name and last_name using the + operator\nconcatenate the strings first_name and last_name using the format method\nconcatenate the strings first_name and last_name using f-strings\n\n\n# try it\n\nEx: Use f-strings to print Hello, my name is John Doe. and I am 30 years old. Using the variables first_name, last_name, and age.\n\n# try it\n\nCheckout: PyFormat for more.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_sequences.html#numbers-formatting",
    "href": "04_sequences.html#numbers-formatting",
    "title": "4  السلاسل",
    "section": "4.5 Numbers formatting",
    "text": "4.5 Numbers formatting\n\n# Thousands separator to integers\nassert 1_000_000 == 1000000\n\nbig_num = 1_000_000 # syntactic sugar\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n1000000\n1,000,000\n\n\n\n# Scientific Notation\nassert 1e-4 == 0.0001\n\nsmall_num = 1e-4\nprint(f\"{small_num:.2e}\")\n\n1.00e-04\n\n\n\n# Number of decimal places\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\n# Format currency (USD)\nprice = 2978.95\nprint(f\"${price:,.2f}\")\n\n$2,978.95\n\n\nCheckout: PyFormat for more.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_sequences.html#السلاسل-النصية-strings",
    "href": "04_sequences.html#السلاسل-النصية-strings",
    "title": "4  السلاسل",
    "section": "4.2 السلاسل النصية (Strings)",
    "text": "4.2 السلاسل النصية (Strings)\nالسلسلة النصية (String) هي تسلسل من القيم التي تمثل نقاط الشيفرة في نظام Unicode. يمكن تمثيل جميع نقاط الشيفرة في النطاق U+0000 - U+10FFFF داخل سلسلة نصية. لا يوجد في Python نوع خاص بالحرف (char)، بل يتم تمثيل كل نقطة شيفرة في السلسلة النصية ككائن سلسلة بطول 1.\nالدالة المدمجة ord() تقوم بتحويل نقطة الشيفرة من شكلها النصي إلى عدد صحيح ضمن النطاق 0 - 10FFFF؛ بينما تقوم الدالة chr() بتحويل عدد صحيح ضمن النطاق 0 - 10FFFF إلى كائن سلسلة نصية بطول 1.\nيمكن استخدام str.encode() لتحويل سلسلة نصية (str) إلى bytes باستخدام ترميز النص المحدد، ويمكن استخدام bytes.decode() لتحقيق العكس.\n\n# ASCII (English-only) characters are represented by numbers between 0 and 127\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nلنستكشف السلاسل عن طريق حزمة string:\n\nimport string\n\nprint(string.ascii_letters)\nprint(string.punctuation)\n\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n!\"#$%&'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~\n\n\nالكود التالي يعرض نقاط الشيفرة للحروف اللاتينية والعلامات الترقيمية (سنتعلم كيف نفهم for in في الدروس القادمة):\n\nimport string\n\nprint([ord(x) for x in string.ascii_letters])\nprint([ord(x) for x in string.punctuation])\n\n[97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]\n[33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 58, 59, 60, 61, 62, 63, 64, 91, 92, 93, 94, 95, 96, 123, 124, 125, 126]\n\n\nنلاحظ أن الحروف اللاتينية تبدأ من 65 وتنتهي بـ 90، ثم من 97 إلى 122 بينما تبدأ العلامات الترقيمية من 33 وتنتهي بـ 47 ثم من 58 وتنتهي بـ 64. ثم من 91 وتنتهي بـ 96. وأخيرًا من 123 وتنتهي بـ 126.\nماذا عن الحروف العربية؟ أين تقع في شفرة Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nSee Wikipedia: Arabic script in Unicode for details.\nخلاصة: السلاسل في بايثون تمثل الحروف سواءً الإنجليزية أو العربية أو غيرها.\nوالأمر الآخر: أن الحروف في الأصل أرقام مخزنة لكن يتم عرضها بشكل نصي للمستخدم.\nCommon use cases for strings:\n\nStrings can be used to represent text, such as:\n\nnames\naddresses\nmessages\n\nTextual data in Python is handled with str objects, or strings.\nStrings are immutable sequences of Unicode code points.\n\nPython has great support for strings:\n\nname = 'Adam' # String literals can use single quotes\naddress = \"Riyadh, Saudi Arabia\" # or double quotes; it does not matter\n\n\n# Triple quoted strings may span multiple lines.\n# All associated whitespace will be included in the string literal.\nmessage = \"\"\"Hello everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\nprint(message)\n\nHello everyone,\nI hope you are enjoying the course,\n\nThank you.\n\n\n\nNote: there is no separate “character” type\n\ntype('a')\n\nstr\n\n\nLength of a string:\n\nphone = \"123456789\"\nlen(phone)\n\n9\n\n\n\n4.2.0.1 Exercise\n\nfind the length of the variable phone\nfind the length of the variable message\n\n\n\n4.2.1 membership operator: in\nThe in operator is used to check if a value is present in a sequence (str, list, range, etc.).\n\nvowels = \"aeiou\"\nprint(\"a\" in vowels)\n\nTrue\n\n\n\n# same as above\n# since both are sequences in Python\nvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nprint(\"a\" in vowels)\n\nTrue\n\n\nIn Python, Strings are objects.\n\nObjects have attributes that can be accessed with the . operator.\nObjects have methods that can be called using the . operator and the () parenthesis:\n… more on objects later.\n\n\nprint(\"hello\".upper())\nprint(\"HeLLO\".lower())\n\nHELLO\nhello\n\n\n\nname = \"john doe\"\n\nprint(name.capitalize())\nprint(name.title())\n\nJohn doe\nJohn Doe\n\n\n\nhelp(str.title)\n# str.title? # in Jupyter\n\nHelp on method_descriptor:\n\ntitle(self, /) unbound builtins.str method\n    Return a version of the string where each word is titlecased.\n\n    More specifically, words start with uppercased characters and all remaining\n    cased characters have lower case.\n\n\n\n\n# Check case\nprint(name.islower())\nprint(name.isupper())\n\nTrue\nFalse\n\n\n\n# Count occurrences\nname = \"john doe\"\n\nprint(name.count('o'))\nprint(name.find('o')) # fist occurrence\nprint(name.replace('o', 'w'))\n\n2\n1\njwhn dwe\n\n\n\n# 3rd argument is `count`\n# Maximum number of occurrences to replace.\n# -1 (the default value) means replace all occurrences\nprint(name.replace('o', 'w', 1))\n\njwhn doe\n\n\n\n\n4.2.2 Whitespace Characters\n\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\n\n# note that this will remove leading and trailing whitespace,\n# but not whitespace in the middle of the string\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\n\n# Strip whitespaces\nprint(text.strip())\n\nhello    world\n\n\n\n# Split\nprint(\"Hello, world\".split()) # default is space\n\n['Hello,', 'world']\n\n\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\n\n# `maxsplit` argument: Maximum number of splits to do.\n# -1 (the default value) means no limit.\nprint(\"Hello, world\".split(\"l\", 1)) # 1 means split only once\n\n['He', 'lo, world']\n\n\nSee: Splitlines\n\n# multi-line string\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\n\n# displays the string as is (showing whitespace characters)\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\n\n# follows control characters and prints visible characters\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\n\n# Join\nnames = [\"Adam\", \"Belal\", \"Camal\"]\nseperator = ','\nprint(seperator.join(names)) \n\nAdam,Belal,Camal\n\n\n\n''.join(names)\n\n'AdamBelalCamal'\n\n\n\n' + '.join(names)\n\n'Adam + Belal + Camal'\n\n\n\n# String formatting\n\nname = \"John\"\n\nprint(\"Name: {name}\")\nprint(f\"Name: {name}\")\n\nName: {name}\nName: John\n\n\n\n# Alignment\nprint(name.ljust(15)) \nprint(name.center(15))\n\nJohn           \n      John     \n\n\n\n# Padding\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\nnum = 100\nprint(f'{num:5}')\n\n       100\n      1000\n     10000\n  100\n\n\n\n# Check start/end\nname = 'mr. john.jpg'\nprint(name.startswith('mr. '))\nprint(name.endswith('jpg'))\n\nTrue\nTrue\n\n\nA fun way to decorate a string using center method:\n\nname = 'John'\nwidth = 20\ndecorator = '*'\n\nprint(decorator * width)\nprint(name.center(width, decorator))\nprint(decorator * width)\n\n********************\n********John********\n********************\n\n\n\n4.2.2.1 Exercise\n\nChange the above code to print your name, in all uppercase\nchange the width\nChange the decorator to some other character like #",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_sequences.html#references",
    "href": "04_sequences.html#references",
    "title": "4  السلاسل",
    "section": "4.7 References",
    "text": "4.7 References\nPython Docs: Text Sequence Type — str - String methods - Text Processing Services - Common string operations",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_sequences.html#convert-fromto-string-to-other-types",
    "href": "04_sequences.html#convert-fromto-string-to-other-types",
    "title": "4  السلاسل",
    "section": "4.6 Convert from/to string to other types",
    "text": "4.6 Convert from/to string to other types\nRepeating strings\n\ns = \"Salam \" * 3\nprint(s)\n\nSalam Salam Salam \n\n\n\nzeros = \"0\" * 8\nx = \"1\" + zeros\ntype(x), x\n\n(str, '100000000')\n\n\n\nx + x\n\n'100000000100000000'",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html",
    "href": "04_strings.html",
    "title": "4  السلاسل",
    "section": "",
    "text": "4.1 Character Encoding\nCharacter encoding is the process of assigning numbers to graphical characters, especially the written characters of human language, allowing them to be stored, transmitted, and transformed using digital computers.\nASCII codes represent text in digital devices. ASCII has just 128 code points, of which only 95 are printable characters (English-only). The set of available punctuation had significant impact on the syntax of computer languages and text markup.\nANSII contain further characters from 128 to 255, which differ based on language.\nUnicode has over a million code points, but the first 128 of these are the same as ASCII",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#character-encoding",
    "href": "04_strings.html#character-encoding",
    "title": "4  السلاسل",
    "section": "",
    "text": "4.1.0.1 Question: How many languages are covered by Unicode?\nAnswer: all of the languages that can be written in the following widely-used scripts: Latin, Greek, Cyrillic, Armenian, Hebrew, Arabic, Syriac, Thaana, Devanagari, Bengali, Gurmukhi, Oriya, Tamil, Telugu, Kannada, Malayalam, Sinhala, Thai, Lao, Tibetan, Myanmar, Georgian, Hangul, Ethiopic, Cherokee, Canadian Aboriginal Syllabics, Khmer, Mongolian, Han (Japanese, Chinese, Korean ideographs), Hiragana, Katakana, and Yi. Source\nFigure below: showing that if we try to save Arabic text (Unicode) using ASCII (a subset of it), we get warning, and we lose our work.\n\nError reads: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#السلاسل-النصية-strings",
    "href": "04_strings.html#السلاسل-النصية-strings",
    "title": "4  السلاسل",
    "section": "4.3 السلاسل النصية (Strings)",
    "text": "4.3 السلاسل النصية (Strings)\nString can represent anything; literally as a sequence of symbols. However, they are mostly used with textual data such as: - names (short) - addresses (long) - messages (multiline)\n\nname = 'Adam' # String literals can use single quotes\naddress = \"Riyadh, Saudi Arabia\" # or double quotes; it does not matter\n\n\n# Triple quoted strings may span multiple lines.\n# All associated whitespace will be included in the string literal.\nmessage = \"\"\"Hello everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\nprint(message)\n\nHello everyone,\nI hope you are enjoying the course,\n\nThank you.\n\n\n\nNote: there is no separate “character” type\n\ntype('a')\n\nstr\n\n\nLength of a string:\n\nphone = \"123456789\"\nlen(phone)\n\n9",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#indexing-and-slicing",
    "href": "04_strings.html#indexing-and-slicing",
    "title": "4  السلاسل",
    "section": "4.4 Indexing and Slicing",
    "text": "4.4 Indexing and Slicing\n\nA string is a sequence of characters\nSequences can be indxed using []\n\n1st element is at index 0\n2nd element is at index 1\nlast element is at index -1\n\n\n\ntitle = \"Pythonista\"\n\n\n\nprint(title[2:]) # thonista\n\nthonista\n\n\n\nprint(title[0] == 'P')\nprint(title[-1] == title[9] == 'a')\n# title[10] # IndexError: string index out of range\n\nTrue\nTrue\n\n\n\n# TODO: weired case that needs to be understood\n# print(title[None:-4:-1])\n\n\n4.4.1 Slicing\nSequences can also be sliced using [start:end]\n\n\ntitle[0] == title[0:1] == 'P'\n\nTrue\n\n\n\n\nprint(title[2:5]) #\nprint(title[:5])\nprint(title[-4:])\nprint(title[-4:None])\n\ntho\nPytho\nista\nista\n\n\n\n4.4.1.1 Exercise\nEx: Given that name = \"Johnson\" What is the value of name[0]? name[1]? name[-1]? name[-2]?\n\n# try it\n\n\n\n4.4.1.2 Exercise\nEx: try name[1:3] and name[3:5]\n\n# try it\n\n\n\n\n4.4.2 We can also add a step to slicing [start:end:step]\n\ns = \"ABCDEF\"\n\n\ns[0:len(s):1] == s[0:None:1] == s[::] # default values\n\nTrue\n\n\n\ns[::-1]\n\n'FEDCBA'\n\n\nWe can also omit the start or end of the slice, which would implicitly mean the beginning or end of the string:\n\ns[0::2]\n\n'ACE'\n\n\n\n# s = \"ABCDEF\"\n# s[None:0:-1] # TODO: understand this weird case\n\n\ns[-1:0:-2]\n\n'FDB'\n\n\nEx: run and try to understand the following code\nname = \"Johnson\"\nprint(name[::2])\nprint(name[::-1])\nprint(name[1:5:2])\n\n# try it\n\nEx: For each of the following, specify the start, end, and step:\n\nname[::2]\nname[::-1]\nname[1:5:2]\n\nAnswer: …\n\n4.4.2.1 Exercise\nEx: Write a program that takes a string and prints the string in reverse.\n\n# try it\n\nEx: Write a program that takes a string and prints every other character in the string. Example: abcdef -&gt; bdf\n\n# try it\n\nEx: Write a program that takes a string and prints the string in reverse order, but only every other character. It also must capitalize it. Example: abcdef -&gt; ECA\n\n# try it\n\nEx: Count the number of o in the string hello world. Hint: use the .count() method.\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#string-formatting",
    "href": "04_strings.html#string-formatting",
    "title": "4  السلاسل",
    "section": "4.7 String formatting",
    "text": "4.7 String formatting\nWe look at 3 most commonly used ways to concatenate strings in Python:\nFirstly, joining individual strings via the + operator (as we did above). - Basic, but no control over the format - Also you have to convert numbers to strings using str()\nSecondly, using the .format() method.\nWhere replacement fields are delimited by braces {}. Each replacement field contains either:\n\nthe numeric index of a positional argument (starting from 0), or\nthe name of a keyword argument (if the argument is a dictionary).\n\nThirdly, using f-strings.\n\nA formatted string literal or f-string is a string literal that is prefixed with ‘f’ or ‘F’. These strings may contain replacement fields, which are expressions delimited by curly braces {}. While other string literals always have a constant value, formatted strings are really expressions evaluated at run time. Docs\n\n\nname = \"John\"\nlvl = 300\n\nx1 = \"My name is \" + name + \" and I want to reach level \" + str(lvl) # + operator\nx2 = \"My name is {} and I want to reach level {}\".format(name, lvl)  # .format() method\nx3 = f\"My name is {name} and I want to reach level {lvl}\"            # f-strings\nassert x1 == x2 == x3\nprint(x1)\n\nMy name is John and I want to reach level 300\n\n\n\n4.7.0.1 Exercise\nPrint \"Hello, my name is John Doe. and I am 30 years old\". Using the variables first_name, last_name, and age via all three approaches mentioned above:\n\n# try it\n\n\n\n4.7.1 Alignment and padding\n\nprint(name.ljust(15)) \nprint(name.center(15))\n\nJohn           \n      John     \n\n\nA fun way to decorate a string using center method:\n\nprint('*' * 20)\nprint('Adam'.center(20, \"*\"))\nprint('*' * 20)\n\n********************\n********Adam********\n********************\n\n\n\n4.7.1.1 Exercise\nRefactor the above code snippet to define three variables and use them in decorating the name:\n\nname\nwidth\ndecorator\n\n\n# try it\nname = 'Adam'\n\nPadding numbers:\n\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\n       100\n      1000\n     10000",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#numbers-formatting",
    "href": "04_strings.html#numbers-formatting",
    "title": "4  السلاسل",
    "section": "4.6 Numbers formatting",
    "text": "4.6 Numbers formatting\n\n# Thousands separator to integers\nassert 1_000_000 == 1000000\n\nbig_num = 1_000_000 # syntactic sugar\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n1000000\n1,000,000\n\n\n\n# Scientific Notation\nassert 1e-4 == 0.0001\n\nsmall_num = 1e-4\nprint(f\"{small_num:.2e}\")\n\n1.00e-04\n\n\n\n# Number of decimal places\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\n# Format currency (USD)\nprice = 2978.95\nprint(f\"${price:,.2f}\")\n\n$2,978.95\n\n\nCheckout: PyFormat for more.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#convert-fromto-string-to-other-types",
    "href": "04_strings.html#convert-fromto-string-to-other-types",
    "title": "4  السلاسل",
    "section": "4.7 Convert from/to string to other types",
    "text": "4.7 Convert from/to string to other types\nRepeating strings\n\ns = \"Salam \" * 3\nprint(s)\n\nSalam Salam Salam \n\n\n\nzeros = \"0\" * 8\nx = \"1\" + zeros\ntype(x), x\n\n(str, '100000000')\n\n\n\nx + x\n\n'100000000100000000'",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#references",
    "href": "04_strings.html#references",
    "title": "4  السلاسل",
    "section": "4.9 References",
    "text": "4.9 References\n\nText Sequence Type — str\nString methods\nText Processing Services\nCommon string operations\nprintf-style String Formatting\nPyFormat",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#string-formatting-1",
    "href": "04_strings.html#string-formatting-1",
    "title": "4  السلاسل",
    "section": "4.4 String formatting",
    "text": "4.4 String formatting\n(Main) docs reference: printf-style String Formatting\nThere are 3 different ways to concatenate strings in Python:\n\nJoining individual strings with + operator\nformat string method\nf-strings\n\n\n# Using the + operator\nname = \"John\"\nage = 30\n\nx1 = \"My name is \" + name + \" and my age is \" + str(age)\nx2 = \"My name is {} and my age is {}\".format(name, age)\nx3 = f\"My name is {name} and my age is {age}\"\nprint(x1 == x2 == x3)\nprint(x1)\n\nTrue\nMy name is John and my age is 30\n\n\n\n4.4.0.1 Exercise\n\nconcatenate the strings first_name and last_name using the + operator\nconcatenate the strings first_name and last_name using the format method\nconcatenate the strings first_name and last_name using f-strings\n\n\n# try it\n\nEx: Use f-strings to print Hello, my name is John Doe. and I am 30 years old. Using the variables first_name, last_name, and age.\n\n# try it\n\nCheckout: PyFormat for more.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "string_methods.html",
    "href": "string_methods.html",
    "title": "Appendix B — Python Common String Methods and Built-in Functions",
    "section": "",
    "text": "B.0.1 Must-Know String Methods\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\n.upper()\nConverts a string to uppercase.\n\n\n.lower()\nConverts a string to lowercase.\n\n\n.find()\nFinds the index of a substring within a string.\n\n\n.replace()\nReplaces occurrences of a substring within a string.\n\n\n.startswith()\nChecks if a string starts with a specified prefix.\n\n\n.endswith()\nChecks if a string ends with a specified suffix.\n\n\n.count()\nCounts the number of occurrences of a substring within a string.\n\n\n.split()\nSplits a string into a list of substrings based on a delimiter.\n\n\n.join()\nJoins elements of an iterable into a string using a separator.\n\n\n.strip()\nRemoves leading and trailing whitespace from a string.\n\n\n\n\n\nB.0.2 Good-to-Know String Methods\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\n.encode()\nEncodes a string using a specified encoding.\n\n\n.translate()\nReplaces characters in a string using a translation table.\n\n\n.capitalize()\nCapitalizes the first character of a string.\n\n\n.center()\nCenters a string within a specified field width.\n\n\n.casefold()\nConverts a string to a casefolded version for case-insensitive comparisons.\n\n\n.expandtabs()\nExpands tab characters in a string.\n\n\n.index()\nFinds the index of a substring within a string, raising an exception if not found.\n\n\n.format()\nCreates a formatted string using placeholders.\n\n\n.format_map()\nFormats a string using substitutions from a mapping.\n\n\n.__contains__()\nChecks if a substring is contained within a string (using the in operator).\n\n\n\n\n\nB.0.3 Miscellaneous String Methods\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\n.isalnum()\nChecks if a string consists only of alphanumeric characters.\n\n\n.isalpha()\nChecks if a string consists only of alphabetic characters.\n\n\n.isdecimal()\nChecks if a string consists only of decimal characters.\n\n\n.isdigit()\nChecks if a string consists only of digit characters.\n\n\n.isidentifier()\nChecks if a string is a valid Python identifier.\n\n\n.islower()\nChecks if all cased characters in a string are lowercase.\n\n\n.isnumeric()\nChecks if a string consists only of numeric characters.\n\n\n.isprintable()\nChecks if a string consists only of printable characters.\n\n\n.isspace()\nChecks if a string consists only of whitespace characters.\n\n\n.istitle()\nChecks if a string is in title case.\n\n\n.isupper()\nChecks if all cased characters in a string are uppercase.\n\n\n.rjust()\nRight-justifies a string within a specified field width.\n\n\n.ljust()\nLeft-justifies a string within a specified field width.\n\n\n.swapcase()\nSwaps the case of characters in a string.\n\n\n.partition()\nSplits a string into three parts based on a separator.\n\n\n.splitlines()\nSplits a string into a list of lines.\n\n\n.title()\nConverts a string to title case.\n\n\n.zfill()\nFills a string with zeros on the left to a specified width.\n\n\n\n\n\nB.0.4 Built-in Functions Working with Strings\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nlen()\nReturns the length of a string.\n\n\nascii()\nReturns a string representation of an object, escaping non-ASCII characters.\n\n\nbool()\nConverts an object to a Boolean value.\n\n\nbytearray()\nCreates a bytearray object from a string.\n\n\nbytes()\nCreates a bytes object from a string.\n\n\nord()\nReturns the Unicode code point of a character.\n\n\nenumerate()\nCreates an iterator that produces tuples of indices and values from a sequence.\n\n\nfloat()\nConverts a string to a floating-point number.\n\n\nhash()\nReturns the hash value of a string.\n\n\nid()\nReturns the unique identifier of an object.\n\n\nint()\nConverts a string to an integer.\n\n\nmap()\nApplies a function to each element of an iterable.\n\n\nprint()\nPrints a value to the console.\n\n\nslice()\nCreates a slice object representing a range of indices.\n\n\ntype()\nReturns the type of an object.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Python Common String Methods and Built-in Functions</span>"
    ]
  },
  {
    "objectID": "04_strings.html#string-methods",
    "href": "04_strings.html#string-methods",
    "title": "4  السلاسل",
    "section": "4.4 String Methods",
    "text": "4.4 String Methods\n\nStrings are objects, just like everything else in Python.\nObjects have methods that can be called using the . operator followed by () (parenthesis):\n\n… We will delve into this in more detail in upcoming lessons.\nThere are numerous functions available to operate on strings in Python. The table below provides an overview of the most commonly used string methods:\nMust-Know String Methods\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\n.upper()\nConverts a string to uppercase.\n\n\n.lower()\nConverts a string to lowercase.\n\n\n.find()\nFinds the index of a substring within a string.\n\n\n.replace()\nReplaces occurrences of a substring within a string.\n\n\n.startswith()\nChecks if a string starts with a specified prefix.\n\n\n.endswith()\nChecks if a string ends with a specified suffix.\n\n\n.count()\nCounts the number of occurrences of a substring within a string.\n\n\n.split()\nSplits a string into a list of substrings based on a delimiter.\n\n\n.join()\nJoins elements of an iterable into a string using a separator.\n\n\n.strip()\nRemoves leading and trailing whitespace from a string.\n\n\n\nSee the appendix for more details.\nLet’s try some string methods:\n\nprint(\"hello\".upper())\nprint(\"HeLLO\".lower())\n\nHELLO\nhello\n\n\n\nname = \"adam ibraheem\"\n\nprint(name.capitalize())\nprint(name.title())\n\nAdam ibraheem\nAdam Ibraheem\n\n\nيمكن التعرف على الدوال المدمجة للسلسلة عن طريق الدالة help:\n\nhelp(str.title)\n# str.title? # in Jupyter\n\nHelp on method_descriptor:\n\ntitle(self, /) unbound builtins.str method\n    Return a version of the string where each word is titlecased.\n\n    More specifically, words start with uppercased characters and all remaining\n    cased characters have lower case.\n\n\n\n\n4.4.1 count, find, and replace\n\n# Count occurrences\nname = \"Adam Ibraheem\"\n\nprint(name.count('a'))\nprint(name.find('a')) # fist occurrence\nprint(name.replace('a', 'x'))\n\n2\n2\nAdxm Ibrxheem\n\n\n\n# 3rd argument is `count`\n# Maximum number of occurrences to replace.\n# -1 (the default value) means replace all occurrences\nprint(name.replace('a', 'x', 1))\n\nAdxm Ibraheem\n\n\n\n\n4.4.2 Whitespace Characters\nPrintable characters include: - ascii_letters - digits - punctuation\n\nimport string\nstring.printable\n\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n\n\nNon-printable characters are called whitespace. This includes the characters: 1. space 2. tab 3. linefeed 4. return 5. formfeed 6. vertical tab\n\nimport string\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\nLet’s look at three whitespace characters: space, tab, and linefeed.\n\n# Tab character: \"\\t\"\nprint('A\\tB')\n\nA   B\n\n\n\n# Newline character: '\\n'\nprint('A\\nB')\n\nA\nB\n\n\nNotice the length of a string is the number of characters in the string, both printable and whitespace.\n\nprint(len('A B'))\nprint(len('A\\tB'))\nprint(len('A\\nB'))\n\n3\n3\n3\n\n\nIn general, if we take a string and add to it these characters, we get the same length plus 3:\n\ns = 'Salam'\nassert len(s + '\\n\\t ') == len(s) + 3\n\n\n\n4.4.3 .strip()\n\n# note that this will remove leading and trailing whitespace,\n# but not whitespace in the middle of the string\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\n\n# Strip whitespaces\nprint(text.strip())\n\nhello    world\n\n\n\n\n4.4.4 .split()\nSee: Splitlines\n\n# multi-line string\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\n\n# displays the string as is (showing whitespace characters)\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\n\n# follows control characters and prints visible characters\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\n\n# Split\nprint(\"Hello, world\".split()) # default is space\n\n['Hello,', 'world']\n\n\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\n\n# `maxsplit` argument: Maximum number of splits to do.\n# -1 (the default value) means no limit.\nprint(\"Hello, world\".split(\"l\", 1)) # 1 means split only once\n\n['He', 'lo, world']\n\n\n\n\n4.4.5 .join()\n\nnames = [\"Adam\", \"Belal\", \"Camal\"]\nseperator = ','\nprint(seperator.join(names)) \nprint(''.join(names))\nprint(' + '.join(names))\n\nAdam,Belal,Camal\nAdamBelalCamal\nAdam + Belal + Camal",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#strings-and-numbers",
    "href": "04_strings.html#strings-and-numbers",
    "title": "4  السلاسل",
    "section": "4.4 Strings and Numbers",
    "text": "4.4 Strings and Numbers\nHere is a simplified version of Python’s object-model tree:\n\n\n\n\n\ngraph LR\n    A[Object]\n    A --&gt; A1[None]\n    A --&gt; A2[numbers.Number]\n    A --&gt; A3[Sequences]\n    A3 --&gt; A31[Strings]\n\n\n\n\n\n\n\n4.4.1 Repetition\nRule: str * int -&gt; str\nExample:\n\ns = \"Salam \" * 3\nprint(s)\n\nSalam Salam Salam \n\n\n\nzeros = \"0\" * 8\nx = \"1\" + zeros\nprint(x)\n\n100000000\n\n\n\nx + x\n\n'100000000100000000'\n\n\n\nWe expected 100000000, but we got 100000000100000000. Why?\nBecause x is a string, and + operator concatenates strings.\n\nLet’s convert x to an integer using int():\n\nz = int(x)\nz + z\n\n200000000",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#repetition-1",
    "href": "04_strings.html#repetition-1",
    "title": "4  السلاسل",
    "section": "4.5 Repetition",
    "text": "4.5 Repetition\n\ns = \"Salam \" * 3\nprint(s)\n\nSalam Salam Salam \n\n\n\nzeros = \"0\" * 3\nx = \"1\" + zeros\nprint(x)\n\n1000\n\n\n\nx + x\n\n'10001000'\n\n\n\nWe expected 1000, but we got 10001000. Why?\nBecause x is a string, and + operator concatenates strings.\n\nLet’s convert x to an integer using int():\n\nz = int(x)\nz + z\n\n2000",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#concatenation",
    "href": "04_strings.html#concatenation",
    "title": "4  السلاسل",
    "section": "4.6 Concatenation",
    "text": "4.6 Concatenation\nWe want to be able to write:\n\nlvl = 20\nsentence = \"I want to reach level \" + lvl\nprint(sentence)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[227], line 2\n      1 lvl = 20\n----&gt; 2 sentence = \"I want to reach level \" + lvl\n      3 print(sentence)\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nIt raises an error! Why? .. the error message tells use that we cannot concatenate a string with an integer.\nHow do we solve that? We convert the integer to a string using str():\n\nage = 40\nsentence = \"My name is Adam and I am \" + str(age) + \" years old.\"\nprint(sentence)\n\nMy name is Adam and I am 40 years old.\n\n\nNotice that we add two space characters, one after “am” and one before “years” to make the sentence readable.\nTry doing this for the previous sentence with lvl:\n\n# try it",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#formatting-numbers",
    "href": "04_strings.html#formatting-numbers",
    "title": "4  السلاسل",
    "section": "4.8 Formatting numbers",
    "text": "4.8 Formatting numbers\n\n4.8.1 Thousands separator\n\nbig_num = 10000\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n10000\n10,000\n\n\n\n\n4.8.2 Scientific Notation\n\nsmall_num = 1e-4\nprint(f\"{small_num:.2e}\")\n\n1.00e-04\n\n\n\n\n4.8.3 Decimals\n\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\n4.8.3.1 Example: currency\nHere we use 2 components inside the curly braces and the $ prefix: - $ sign is added before the number (not part of the formatted number at all) - , adds the thousands separator - .2f round the number to 2 decimal places\n\nprice = 2978.95\nprint(f\"${price:,.2f}\")\n\n$2,978.95\n\n\n\n\n\n4.8.4 Parametrized formats\nWe can also make both the number n and the padding p to be variables:\n\nn = 100\np = 5\nprint(f'{n:{p}}')\n\n  100\n\n\nBy default the number is right-aligned. We can left-align it by adding &lt;. Notice the difference between the two expressions below:\n\nprint(f'{n:&gt;{p}}')\nprint(f'{n:&lt;{p}}')\n\n  100\n100  \n\n\nCheckout: PyFormat for more.\n\n\n4.8.5 Number literal formats\nLiterals are notations for constant values of some built-in types. Example: 42 is an integer literal and 3.14 is a floating-point literal.\nPython allows more readable ways in writing number literals: - underscores _ in numbers separate them for better readability - e or E can be used to represent scientific notation - 0b or 0B for binary numbers - 0o or 0O for octal numbers - 0x or 0X for hexadecimal numbers - j or J for complex numbers\n\nassert 1e-4 == 0.0001\nassert 1_000_000 == 1000000\nassert 0b1010 == 10\nassert 0o10 == 8\nassert 0x10 == 16\nassert 1 + 2j == 2j + 1",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#code-points",
    "href": "04_strings.html#code-points",
    "title": "4  السلاسل",
    "section": "4.2 Code Points",
    "text": "4.2 Code Points\nالسلسلة النصية (String) هي تسلسل من القيم التي تمثل نقاط الشيفرة في نظام Unicode. يمكن تمثيل جميع نقاط الشيفرة في النطاق U+0000 - U+10FFFF داخل سلسلة نصية. لا يوجد في Python نوع خاص بالحرف (char)، بل يتم تمثيل كل نقطة شيفرة في السلسلة النصية ككائن سلسلة بطول 1.\nالدالة المدمجة ord() تقوم بتحويل نقطة الشيفرة من شكلها النصي إلى عدد صحيح ضمن النطاق 0 - 10FFFF؛ بينما تقوم الدالة chr() بتحويل عدد صحيح ضمن النطاق 0 - 10FFFF إلى كائن سلسلة نصية بطول 1.\nيمكن استخدام str.encode() لتحويل سلسلة نصية (str) إلى bytes باستخدام ترميز النص المحدد، ويمكن استخدام bytes.decode() لتحقيق العكس.\n\n# ASCII (English-only) characters are represented by numbers between 0 and 127\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nلنستكشف السلاسل عن طريق حزمة string:\n\nimport string\n\nprint(string.ascii_letters)\nprint(string.punctuation)\n\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n!\"#$%&'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~\n\n\nالكود التالي يعرض نقاط الشيفرة للحروف اللاتينية والعلامات الترقيمية (سنتعلم كيف نفهم for in في الدروس القادمة):\n\nimport string\n\nprint([ord(x) for x in string.ascii_letters])\nprint([ord(x) for x in string.punctuation])\n\n[97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]\n[33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 58, 59, 60, 61, 62, 63, 64, 91, 92, 93, 94, 95, 96, 123, 124, 125, 126]\n\n\nنلاحظ أن الحروف اللاتينية تبدأ من 65 وتنتهي بـ 90، ثم من 97 إلى 122 بينما تبدأ العلامات الترقيمية من 33 وتنتهي بـ 47 ثم من 58 وتنتهي بـ 64. ثم من 91 وتنتهي بـ 96. وأخيرًا من 123 وتنتهي بـ 126.\nماذا عن الحروف العربية؟ أين تقع في شفرة Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nSee Wikipedia: Arabic script in Unicode for details.\nخلاصة: السلاسل في بايثون تمثل الحروف سواءً الإنجليزية أو العربية أو غيرها.\nوالأمر الآخر: أن الحروف في الأصل أرقام مخزنة لكن يتم عرضها بشكل نصي للمستخدم.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  },
  {
    "objectID": "04_strings.html#repetition",
    "href": "04_strings.html#repetition",
    "title": "4  السلاسل",
    "section": "4.5 Repetition",
    "text": "4.5 Repetition\n\ns = \"Salam \" * 3\nprint(s)\n\nSalam Salam Salam \n\n\n\nzeros = \"0\" * 3\nx = \"1\" + zeros\nprint(x)\n\n1000\n\n\n\nx + x\n\n'10001000'\n\n\n\nWe expected 1000, but we got 10001000. Why?\nBecause x is a string, and + operator concatenates strings.\n\nLet’s convert x to an integer using int():\n\nz = int(x)\nz + z\n\n2000",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>السلاسل</span>"
    ]
  }
]