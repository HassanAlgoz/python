# الخطأ التشغيلي: الاستثناء

::: {.callout-tip}
أنصح بمراجعة هذا الفصل مرة أخرى بعد ممارسة البرمجة وبناء التطبيقات، لأنه سيكون حينها أوضح وأقرب للتطبيق.
:::


[الاستثناء](https://docs.python.org/3.13/tutorial/errors.html) (Exception) هو خروج البرنامج عن المسار المثالي. ويسمى خطأً (Error).

مثل أن يؤمَر بقراءة ملف .. والواقع أن هذا الملف غير موجود! أو أن يطلب من المستخدم رقمًا فيعطيه كلاماً! أو أن يطلب من الشبكة شيئًا .. فتنقطع الشبكة! فكل هذه تعتبر مسارات غير مثالية لكنها تحصل في ظروف واقعيَّة. فيجب كتابة قطع في البرنامج تتعامل معها. ولذا فإن بعض الممارسين لا يفضلون استعمال كلمة استثناء لأنَّ مثل ذلك يحصل كثيرًا فهو ليس خارجًا عن العادة؛ بل من الطبيعي أن يحصل ذلك في الواقع.

تصوَّر أن البرنامج سلسلة من الأفعال بحيث يختص كل فعل بمهمة معيَّنة (بناءً على مدخلاته يُعطي مخرجاته) فإننا نتعمَّد أن يكون وعيُه محدودًا بمدخلاته حتى نقلل من تشابك قطع النص البرمجي حتى نيسِّر على أنفسنا التحقق من صحَّة المنطق. وهذه فكرة **ظرف التنفيذ** الذي سبق الحديث عنها في [باب الفعل](../04_functions/a1_functions.qmd).

فللخطأ حالتان -لا غير- في علاقتها مع من يتعامل معه:

1. **يستوعبه السياق**: أن يكون في وعي الفعل (الظرف) ما يمكن به معالجته
2. **لا يستوعبه السياق**: ألا يكون كذلك فيرفعه (يرجع به) للفعل المستدعي له (الذي هو أكثرُ وَعيًا منه) ليعالجه
	- وهذا يتسلسل حتى يصل إلى الإنسان (سواءً المستفيد أو المبرمج): برسالة تفيد في العثور عليه والتعامل معه.

ومنشؤ الخطأ أحد أمرين:

1. **خطأ مرفوع**: تم رفعه من فعل مستدعى في السياق الحالي. 
2. **خطأ جديد**: تم اكتشاف حالة تتوقف تكملة الفعل على إصلاحها.

وللتعامل مع الخطأ حين يستوعبه السياق طريقتان:

1. **الوقاية**: توقُّع حالات الخطأ والتحقق من عدمها قبل الإقدام على العملية.
2. **التدارك**: ترك العملية لترجع بالخطأ؛ ثم نتعامل معه بحسبه.

## الفرق بين الوقاية والتدارك

هذا الفعل مسؤول عن تهيئة البرنامج، ومن خطواته أنه يقرأ ملف الضبط المخصص `custom_config.json`. وفي هذه الحالة قد يحصل خطأ. إذْ قد لا يكون الملف موجودًا أصلا!

```python
def initialize_program():
    # ... code before
    file = open('custom_config.json')
    # ... code after
```

ففي هذه الحالة يحصل استثناء من نوع `FileNotFoundError`.

فإذا اخترنا طريق **الوقاية** فإننا أولاً نلتمس وجوده قبل فتحه. ونتعامل مع حالة الخطأ هذه (أي: عدمه)، بأن -مثلاً- نقرأ ملف الضبط الافتراضي `default.json` بدلاً من الملف المطلوب. والفرق بين هذا الملف والذي قبله أننا موقنون بوجوده، والأوَّل وجوده مظنون إذْ الذي يضعه هو المستخدم.

```python
def initialize_program():
    # ... code before
    if os.path.exists('custom_config.json'):
        file = open('custom_config.json')
    else:
        file = open('default.json')
    # ... code after
```

وقد تقول، حسنًا ماذا يكون لو عُدم ملف `default.json` أيضًا؟ فنقول: لا بأس أن يحصل خطأ يوقف البرنامج. إذْ ذاك يعتبر خطأ منطقيًّا يجب إصلاحه بإضافة الملف، وليس ثمة مجال لأن يصلحه النص البرمجي بنفسه.

أما **التدارك** فيكون بجملة `try-except` على النحو التالي:

```python
def initialize_program():
    # ... code before
    try:
        file = open('custom_config.json')
    except FileNotFoundError:
        file = open('default.json')
    # ... code after
```

أما استعمال الوقاية ففيه شك بوجود **فجوة زمنية** بين عملية التحقق من وجود الملف وبين قراءته. فالحاسب تتوارد عليه البرمجيات، ولا يستأثر به برنامج واحد. فإذا تغيَّر الحال في هذه الفجوة الزمنية وعاد بالنقض على التحقق بعد حصوله انتفت الفائدة منه. لذا **فالتدارك أضمن**.

### الحالة الأولى: أن يستوعبه السياق

#### فإن كان خطأ جديدًا

مثاله ما لو لم تكن أحد الصفات محددة، فيمكن تعيينها بقيمة ابتدائية، ولا يلزمنا تصعيد الخطأ:

```python
def save_user(user: dict):
    if 'language' not in user:
        user['language'] = 'ar'
    # ... rest of the code
    save_to_database(user)
```

#### وإن كان خطًا مرفوعًا

وقد مثلنا له بفتح الملف، ونمثل له بمثال آخر:

```{python}
def get_user_guess() -> int:
    print('Please enter a number')
    guess = input()
    try:
        guess = int(guess)
    except ValueError:
        print(f'The value "{guess}" is not a number')
        guess = get_user_guess() # recursive call
    return guess
```

### الحالة الثانية: ألا يستوعبه السياق

#### فإن كان خطأ جديدًا

في هذا المثال يجب أن تكون الوحدة إحدى القيم المسموحة: `C` أو `F`. وإلا فلا حيلة للفعل أن يتم وظيفته. لذا نرفع خطأ جديدًا بجملة `raise`.

```python
def convert_temperature(value: float, unit: str) -> float:
    if unit not in {'C', 'F'}:
        raise ValueError(f"Invalid unit: {unit}")
    
    if unit == 'C':
        return value * 9/5 + 32
    elif unit == 'F':
        return (value - 32) * 5/9
```

#### وإن كان خطًا مرفوعًا

ففي هذا المثال عملية قسمة قد يحصل فيها قسمة على صفر في `(a / b)`، فيرتفع خطأ اسمه `ZeroDivisionError` من تلك العملية. والحقيقة أننا في هذا السياق ليس لنا أن نعدِّل الرقم، بل نريد لمن استدعى الفعل أن يعلم بالخطأ، ولسنا نريد إضافة معلومة أخرى فوق ذلك. لذا نسكت عنه (أي: لا نضع `try-except`) وهذا يجعله ينتقل مباشرة للفعل المستدعي.

```python
def divide_lists(list1: list, list2: list) -> list:
    result = []
    for a, b in zip(list1, list2):
        result.append(a / b)
    return result
```

فإن من الأخطاء ما **يتعذر على البرنامج معالجته بنفسه**:

- إذا كانت المشكلة بامتلاء الذاكرة في الجهاز؛ فإن البرنامج ليس له إلا أن يخرج برسالة للمستخدم أو المسؤول عن الجهاز .. وليس للبرنامج أن يمسح بيانات المستخدم!
- أما إذا كانت المشكلة في تأخر الإجابة من الخادم مثلاً، فقد نعيد المحاول مرة أخرى بعد ثوانٍ، ونعيدها لعددٍ محدد من المرات، أملاً في الحصول على إجابة. ثم بعد ذلك لا يمكن إلا أن نظهر رسالة خطأ إن نفدت جميع المحاولات.

## إلتقاط جميع الأخطاء

من الخطأ في المنطق البرمجي إلتقاط جميع الأخطاء في الأفعال باستعمال `except Exception` وهو النوع الشامل لجميع الأخطاء. فهذه الطريقة لا تخبرنا بنوع الخطأ وبالتالي لا نتعامل معه بحسبه، وإنما غاية ما تحقق هو منع تصعيد الخطأ لأعلى طبقة، إذْ حين يحصل ذلك توقف بايثون البرنامج (وعندها تظهر سلسلة الطلبات).

لكن يجوز ذلك في قطع النص البرمجي التي يُراد لها الاستمرار، وإن فشلَ شيئٌ فيها. مثلاً: لا تريد للخادم أن يتوقف تمامًا بمجرد حصول خطأ واحد في أحد خيوط التنفيذ الخاصة بخدمة أحد الطلبات. ففي مثل ذلك يسوغ استخدام `except Exception` الشاملة. انظر مثلاً [قطعة النص البرمجي في إطار الويب فلاسك المسؤول عن استقبال الطلبات](https://github.com/pallets/flask/blob/2fec0b206c6e83ea813ab26597e15c96fab08be7/src/flask/app.py#L893-L900).

## تدفق الخطأ

شكل جملة التعامل مع الخطأ على هذا النحو:

```python
def do_something():
    print('enter')
    try:
        # حاول تشغيل هذه القطعة
    except Exception as e:
        # شغل هذه القطعة عند الخطأ
    else:
        # وإن لم يحصل فهذه القعطة
    finally:
        # وهذه تشتغل سواء حصل الخطأ أم لا
        # وفائدتها أنها تعمل قبل رجوع الخطأ لموضع النداء
    print('return')
```

## أنواع الاستثناء في بايثون

وقد تم تعريف أنواع من الأخطاء في بايثون بحسب الحالة، وتم تقسيمها هكذا:

### `SyntaxError`  
**السبب**: خطأ نحوي في صياغة اللغة:

- كلمة غير صحيحة: خطأ في الإملاء 
- في وضع كلمة صحيحة في غير سياقها
- محاذاة غير متسقة (`IndentationError`)

**الحل**: اقرأ رسالة الخطأ وستدلُّك على السبب والموضع الذي حصل فيه الخطأ.

### `TypeError`

**السبب**:

1. طلب فعل بعدد أكثر أو أقل من العوامل الواجبة (مثل: `len(1, 2)`)
2. طلب فعل بعوامل لا تطابق النوع المحدد في تعريفه (مثل: `math.sqrt('nine')` أو `5 + '5'`)

**الحل**: الوقاية بـ `type()` أو `isinstance()` أو بالتأكد من تحويل النوع مسبقًا.

```python
a = 5
b = input('Enter a number: ')
result = a + int(b)
```
    
### `ValueError` 

**السبب**: أن يكون النوع صحيحًا (فلا يحصُل `TypeError`) لكن القيمة غير مقبولة.

- مثلاً: طلب فعل بقيمة نوعها عددي لكنَّها سالبة وهو لا يقبل إلا الموجبة. نحو: `math.sqrt(-16)` فالجذر التربيعي لا يقبل السالب. 

**الحل**: الوقاية بفحص مدى القيمة ، نحو: `if x >=0: math.sqrt(x)`


### `IndexError` & `KeyError`  

**السبب**: الرقم الذي استعمل في عملية الإشارة `[index]list` (قائمة) أو `dict[key]` (قاموس) يشير لما هو خارج المجموعة.

نحو:

```{python}
#| error: true
my_list = [10, 20, 30]
idx = 3
value = my_list[idx]
```

الحل بالوقاية:

```python
if idx < len(my_list):
    value = my_list[idx]
else:
    # do something else
```

أو بالتدارك:

```python
try:
    value = my_list[idx]
except IndexError:
    # do something else
```

وكذلك في القاموس، نحو:

```{python}
#| error: true
my_dict = {'A': 10, 'B': 20, 'C': 30}
key = 'Z'
value = my_dict[key]
```

الحل بالوقاية

```python
if key in my_dict:
    value = my_dict[key]
else:
    # do something else
```

أو هكذا (تعيين قيمة ابتدائية):

```python
value = my_dict.get(key, 0)
```

أو بالتدارك:

```python
try:
    value = my_dict[key]
except KeyError:
    # do something else
```

### `AttributeError` & `NameError`

**السبب**: استعمال متغير أو فعل قبل تعريفه.

- فإن أسنِد إلى كائن؛ وقع `AttributeError`
- وإلا وقع `NameError`



```{python}
#| error: true
a = 10
a + X
```



```{python}
#| error: true
some_function(55)
```

```{python}
#| error: true
class A:
    pass

a = A()
a.x
```


```{python}
#| error: true
a.do_something()
```

### `ModuleNotFoundError`  
**السبب**: فشل جُملة الاستيراد `import numpy`  

**الحل**: 

- تأكد من صحة الإملاء 
- تأكد من تثبيت الوحدة في البيئة التي يعمل فيها البرنامج: `pip install numpy`


## تعريف أخطاء جديدة

تعريف الخطأ يكون بتعريف نوع جديد يرث من النوع `Exception`، وهذا ما يحققه السطر الأول بين القوسين. وتستطيع أن ترث ممن يرث، فتتكون لديك فروع من هذا الخطأ:

```{python}
class ParentError(Exception):
    pass

class XError(ParentError):
    pass

class YError(ParentError):
    pass
```

```{mermaid}
flowchart TD
    A[ParentError] --> B[XError]
    A --> C[YError]
```

وهذا الفعل يحصل فيه الخطأ بطريقة مصطنعة لكنها توضح ما نريد، وهو الخطأ الفرعي `XError` الذي يرث من الخطأ الأصلي `ParentError`:

```{python}
def do_something():
    raise XError('Something went wrong')
```

ثم حين نفحص، تسطيع أن نطابق بالأصل أو الفرع:

```{python}
try:
    do_something()
except ParentError as e:
    print("caught you:", e)
```

## منظور آخر للخطأ

فائدة: لدينا طريقتان في التعامل مع الخطأ الواقعي، واختارت بايثون طريقة الاستثناء:

الأولى: **رفع قيمة الخطأ بالاسثناء**: لغات مثل C++ (1979)، Java (1998)، Python (1991) و JavaScript (1995) ترمي/ترفع الاستثناءات باستعمال عبارة مثلة `raise` أو عبارة `throw` على حسب اللغة. وتكون معالجة الخطأ بجملة `try-catch` أو `try-except`.

الثانية: **الرجوع بقيمة الخطأ**: اللغات الحديثة مثل Go (2009) و Rust (2015) ببساطة تعيد الخطأ كشيء (قيمة) عند حدوثه باستعمال جملة `return` التي في الفعل. وتكون معالجة الخطأ بجملة شرطية عاديَّة نحو: `if error == error_type`

وبعض اللغات مثل: C (1978) وكذلك C++ (1985) تخلط بين النوعين!

----

**المراجع**:

- [Python Tutorial: Exceptions](https://docs.python.org/3.13/tutorial/errors.html)
- Miguel Grinberg: [The Ultimate Guide to Error Handling in Python](https://blog.miguelgrinberg.com/post/the-ultimate-guide-to-error-handling-in-python)



## المصطلحات

| العربية | الإنجليزية |
|------------------|---------------------|
| الاستثناء | Exception |
| خطأ | Error |
| ظرف التنفيذ | Execution Frame |
| الوقاية | If-else |
| التدارك | Try-except |
| خطأ نحوي | Syntax Error |
| خطأ في المحاذاة | Indentation Error |
| خطأ في النوع | Type Error |
| خطأ في القيمة | Value Error |
| خطأ في المؤشر الرقمي | Index Error |
| خطأ في المؤشر المرقوم | Key Error |
| خطأ في الخاصية | Attribute Error |
| خطأ في الاسم | Name Error |
| خطأ في استيراد الوحدة | Module Not Found Error |
| خطأ القسمة على صفر | Zero Division Error |
| رفع الخطأ | Raise Exception |
| إلتقاط الخطأ | Catch Exception |
| تدفق الخطأ | Error Flow |

