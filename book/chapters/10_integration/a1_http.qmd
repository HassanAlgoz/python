# الاستفادة من الخدمات البرمجية

ترتبط البرمجيات ببعضها عن طريق الشبكة. ويملك بعض الناس بيانات أو معالجة من نوعٍ ما لا يملكه الآخرون، فيتبادل الناس بينهم بالبيع والشراء كمفيدين ومستفيدين.

- فأما **المفيد** فيسمى المزوِّد (provider) أو الخادم (server) باعتبار المنتج أو الخدمة البرمجية.
وقد يسمى مؤلف (author) أو راعي (maintainer) باعتبار أنه القائم على كتابة البرمجية وصيانتها.
- وأما **المستفيد** فيسمى المستخدم (user) أو العميل (client) أو المستهلك (consumer).

## لغة التخاطب بين المخدوم والخادم

وإذا عرفنا أن لغات البشر تصل إلى الآلاف؛ والناس تلجأ إلى لغة وسيطة للتواصل بينهم مثل الإنجليزية أو الأوردية أو العربية الفصيحة، فالحال -من باب أولى- يصعب على الآلات الصماء التي تتبع أوامر بشكلٍ حرفيّ أن تتخاطَب إلا بتوحيد طريقة التواصل؛ ويجب أن تكون مضبوطة بقواعد صارمة، ويتفق الجميع على التخاطب بها ولو اختلفت لغات البرمجة.

ولهذا اختُرِعَت **لغة نقل النص التشعُّبي** HTTP (Hyper-text Transfer Protocol). والمقصود بالتشعُّب وجود الروابِط في صفحات الانرتنت التي تنقلك من نصٍّ إلى نصّ. وهذه النصوص ما هي إلا وصفٌ لمحتويات الصفحة التي تظهر أمامك؛ يُفسِّرُها البرنامج المتصفِّح الذي تستعمله على جهازك، لتظهر لك الفقرات والخطوط العريضة والألوان والتنسيق والصور التوضيحية والجداول والمقاطع والملفات ونصوص البرمجيات الملوَّنة والملفات المضمَّنة والمبدَّفة ... وكل ما رأيت قطُّ في صفحة على الانرتنت. واللغة هذه تسمَّى **لغة وصف النص التشعُّبي**: HTML (Hyper-text Markup Language)
وكذلك ما رأيت قط داخل أي تطبيقٍ من شاشة جوالٍ أو لوحي؛ فهي موصوفةٌ بنفس الطريقة بلغة أشمل معروفة بالأقواس المثلثة `<XML>`  اسمها XML.

لكن الذي يهمُّنا أن لغة نقل النص التشعبي؛ لم تقتصر على النصوص ذات الروابط، بل وُظِّفَت لنقل أي نوع من البيانات عبر الشبكة بما فيها النصوص التي لا تحتوي على أية روابط (تشعبات). فإن البرمجيات تصوغ رسائلها بينها بلغة HTTP لتتواصل فيما بينها ويتم بينها التخادُم (مستفيد ومفيد). ومضمون الرسائل التي بينها عادةً ما يكون نصًّا مُصاغًا بصيغة XML أو JSON .. وقد يكون ملفًّا ثنائيًّا يحوي صورةً أو مقطعًا أو نصًّا. 

### العنوان الموحد للمورِد

واصطلاح **عنوان المورِد الموحَّد** URL (Uniform Resource Locator) هو الذي نقصده عندما نقول **رابط** (Link أو Hyper-link reference وتختصر `href`) لأن صياغة الروابط عادةً ما تتبع هذه الصيغة الموحَّدة. وهي التي تتضمَّنُ عادةً جزئيَّة `com.` أو `net.` ونحوهما؛ وتتضمن بعدها مسارًا فرعيًّا. ونمثل على ذلك: [`https://github.com/HassanAlgoz/python`](https://github.com/HassanAlgoz/python) .. وفيه:

- اللغة / الشكل: `https`
- عنوان الاستضافة: `github.com`
- المسار الفرعي: `HassanAlgoz/`
- المورِد: `python`

ومصطلح **المورِد** (Resource) عامٌّ يشمل شيئًا مُجرَّدًا يتم الوصول إليه بعنوان مُصاغٍ بصيغة متفقٍ عليها. سواءٌ كان موجودًا قبل الوصول إليه، أو يتمُّ إنتاجه متى طُلِب.

ويكون الرابط على النحو التالي:

```
https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash
```

```
┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
(All spaces in the "" line should be ignored. They are purely for formatting.) 
```

المصدر: [https://nodejs.org/api/url.html#url-strings-and-url-objects](https://nodejs.org/api/url.html#url-strings-and-url-objects)

ونشبِّه الرابط باستدعاء الدالة في بايثون على النحو التالي:

```{python}
import math

math.pow(2, 3)
```


| الوحدة | الدالة | المعاملات |
|---|---|---|
| `math` | `pow` | `2, 3` |
| `https://example.com` | `/p/a/t/h` | `?query1=value1&query2=value2` |

- فكما أننا نطلب الفعل `pow` من الوحدة `math` ونمرر العوامل `2, 3` إليه
- فكذلك نطلب المورِد `/p/a/t/h` من الموقع `https://example.com` ونمرر العوامل `?query1=value1&query2=value2` إليه
    - العامل الأوَّل يبتدأ بعلامة الاستفهام `?` ثم اسم العامل `query1` وقيمته `value1`
    - وكل عامل بعده مبدوء بعلامة `&` ثم اسم العامل `query2` وقيمته `value2`

فالطريقة الأولى تستخدم في لغات البرمجة، والثانية هي مثيلتها في لغة التخاطب الموحَّدة HTTP.

### الوسطاء

وقد وصفنا أن الطلب مخرجه من جهاز المستفيد ومدخله إلى جهاز المفيد؛ وذلك باعتبار المآل. لكن على وجه التفصيل؛ هو يمر عن طريق شبكة الانترنت عبر عدة **وسطاء** (proxy) حتى يصل إلى موقعه، وهو ما تنظِّمه مؤسسات الاتصالات والشبكات والمعلومات عبر الجغرافيات. وقد تكون هذه وسطاء تجارية،

![الوسطاء بين الخادم والمخدوم](https://mdn.github.io/shared-assets/images/diagrams/http/overview/client-server-chain.svg)

ومن وظائفها:

- التخزين (caching) لتسريع خدمة الطلبات المتكررة
- الترشيح (filtering) للوقاية من الفيروسات أو التحكم بالمحتوى المسموح
- توزيع الجهد (load balancing) وعادة ما يكون هذا الوسيط أقرب شيء إلى مجموعة خوادم متماثلة، يتم توزيع الطلبات المتكاثرة بينها لتتعاون في خدمتها ولا يتأخر جواب أحد منها
- التحقق (authentication) السماح المشروط بتسجيل أو اشتراك أو مكان معين
- التسجيل (logging) لمتابعة جميع الطلبات لغرض الكشف عن المشاكل أو معرفة الاختراقات أو الانتهاكات للأنظمة

### الطلب والجواب

ومن مفاهيم لغة التخاطب عبر تطبيقات الشبكة (HTTP) أيضًا:

**الطلب** (request) وهو الرسالة التي تشمل:

- **محتوى**: `body / content`
- **العميل** (المُرسِل): `user-agent`
- **المستضيف** (المُرسَل إليه): `Host`

**نوع الطلب** (method) وأهمها:

- `GET` لطلب الحصول على مورِد معيَّن
- `DELETE` لطلب حذف مورِد معيَّن

ففيهما يتمُّ تحديد عنوان المورِد.

ثم لدينا:

- `POST` لطلب إنشاء مورِد؛ يتمُّ تحديد تفاصيل الإنشاء في محتوى الرسالة
- `PUT` لطلب تعديل مورِد؛ يتمُّ تحديد تفاصيل التعديل في محتوى الرسالة

**الرؤوس** (headers) هي معلومات عن المعلومات التي في الطلب نفسه أو محتواه؛ بعضها أصلي وبعضها إضافي.

- مثلاً: `Content-Type: text/csv` تعني أن البيانات المرسلة عبارة عن ملف بصيغة CSV. وهو أصلي.
- أما الإضافي فيبدأ بحرف `X` على هذا النحو: `x-api-key: 1234567890` هو مفتاح التطبيق الذي يسمح للطلب بالتعريف بصاحب الحساب لإتاحة الخدمة له.

**المحتوى** (body) هي البيانات المُرْسَلة أو المُسْتَلَمة؛ سواءٌ في الطلب أو جوابه.

- مثلاً: `{"name": "John", "age": 30}` هي بيانات عبارة عن قاموس بصيغة JSON.

**جواب الطلب** (response) وهو مثل الطلب في خصائصه؛ إلا أنَّه موجَّه بالعكس .. من الخادم إلى المخدوم.

**رمز حالة الطلب** (status code) وتنقسِم إلى نطاقات، وكثيرٌ منها مُهمَل غير مُستعمل:

- نطاق `100-199` (فقط للعلم - ولا تهمنا)
- نطاق `200-299` تعني أن الطلب تمُّ إنجازه بنجاح.
- نطاق `300-399` إعادة توجيه
- نطاق `400-499` إشكال من جهة العميل
    - `400 -> Bad Request` البيانات المُرسلة ليست صالحة
    - `401 -> Unauthorized` المفتاح مفقود أو غير صالح
    - `403 -> Forbidden` المفتاح صالح لكن ليس كافيًا للوصول
    - `404 -> Not Found` ما طلبته غير موجود
- نطاق `500-599` إشكال من جهة الخادم

فصيغة الطلب النصية تبدو هكذا:

```
GET /cats.csv HTTP/1.1
Host: example.com
x-api-key: 1234567890
```

- نوع الطلب: `GET`
- المسار: `/cats.csv`
- نوع اللغة: `HTTP/1.1` (وقد يكون `HTTP/2` أو `HTTP/3`)
- العنوان الرئيسي: `example.com` (وهو الموقع الذي يوجد عليه الملف)
- الرؤوس: `x-api-key: 1234567890` (وهو مفتاح التطبيق الذي يسمح للطلب بالوصول إلى الخدمة)

فيأتي الجواب هكذا مثلاً بصيغة `JSON` كقائمة فيها عُنصران:

```
HTTP/1.1 200 OK
Content-Type: application/json

[
    { 
        "id": "1",
        "name": "Whiskers",
        "age": 10
    },
    { 
        "id": "2",
        "name": "Fluffy",
        "age": 20
    }
]
```

لكننا سنستعمل بايثون لتسهيل صياغة الطلب وتفسير جوابه في هذا الدرس.

لمزيد من التفاصيل راجع: [HTTP overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview).

## الواجهة البرمجية للتطيبقات

وبفضل تراكم الجهود في البرمجة؛ فقد سُهِّل التخطاب بين البرمجيات بما يُعرف بصفة عامة بمصطلح **الواجهة البرمجية للتطبيقات** (API - Application Programming Interface)؛ فهي تُجرِّدُ تفاصيل لغة التخاطب إلى حدٍّ كبير. 
ويُطلق أحيانًا تجوُّزًا على المكتبة (library) والحزمة (package) بأنَّها واجهة API أو أن لها واجهة .. وإن لم تتصل بالشبكة أصلاً. لكنَّ المتبادر للذهن عند استعمال مصطلح API هي الواجهة البرمجية التي يزوِّدُها خادمٌ لعميلٍ عبر الشبكة.

فأحد طرق التعامل مع الخدمات البرمجية، أن توفِّر هذه الخدمة مكتبةً للاتصال بها، تبدوا كأنها أفعال مُعرَّفة عاديَّة، لكنَّ تفاصيلها تتضمَّن إرسال طلب للخادم المزوِّد ثم الرجوع بجوابه كقيمة لموضع الاستدعاء.

### المثال الأوَّل

ونمثل على ذلك بمكتبة [`GeoPy`](https://geopy.readthedocs.io/en/stable/) حيث كُتِب في الوصف:

> جيوباي هي عميل بايثوني لمجموعة من خدمات شائعة على الشبكة للترميز الجغرافي. فهو يسهل تحديد إحداثيات العناوين والمدن والبلدان والمعالم في جميع أنحاء العالم باستخدام برامج ترميز جغرافي خارجية ومصادر بيانات أخرى.

وننبه مرة أخرى إلى أنها عميل (client) لخدمات خارجية (external services)، وليسَت هي بذاتها متصلة بخدمة؛ فلا توجد خدمة اسمها geopy، وإنما هي مكتبة وسيطة فقط. انظر: [geopy is not a service](https://geopy.readthedocs.io/en/stable/#geopy-is-not-a-service).

أولاً تثبيت المكتبة باستعمال `uv`:

```bash
uv add geopy
```

ثم نستطيع استيرادها في بايثون:

```{python}
from geopy.geocoders import Nominatim
```

ونستعمل الفعل المُنشئ `Nominatim` الذي يتصل بمزوِّد خدمة خارجية، وهو مزوِّد خدمة جغرافية عالمية تسمى `OpenStreetMap`

```{python}
geolocator = Nominatim(user_agent="pythonia")
```

يطلب منَّا الفعل المنشئ أن نعرِّف بأنفسنا بتعيين `user_agent`، وهذا بحسب ما ورد في توثيق المكتبة. فنكتب أي اسم يدلُّ على التطبيق الذي نعمل عليه الآن.

نفترض أننا نريد معرفة إحداثيات مدينة الدمام، وهذا هو عمل الفعل `geocode`:

```{python}
dammam_location = geolocator.geocode("Dammam, Saudi Arabia")
```

قد يبدوا الفعل عاديًّا، لكنه في الواقع يتصل بالخادم المزوِّد ويطلب منه إرجاع إحداثيات المدينة؛ وهي القيمة التي تخرج لنا فنزلها في متغير `dammam_location`.

```{mermaid}
sequenceDiagram
    UserCode -->> GeoPy: .geocode("...")
    GeoPy -->> OpenStreetMap: Request
    OpenStreetMap -->> GeoPy: Response
    GeoPy -->> UserCode: Return
```


وكذلك لمدينة أخرى مثل البحرين:

```{python}
bahrain_location = geolocator.geocode("Bahrain")
```

ثم بعد أن حصلنا على المعلومات، نستخرج الإحداثيات من المتغيرات التي حصلنا عليها:

```{python}
dammam_coords = (dammam_location.latitude, dammam_location.longitude)
bahrain_coords = (bahrain_location.latitude, bahrain_location.longitude)
```

ثم نحسب المسافة بين المدينتين، باستعمال فعل موجود في وحدة `geopy.distance`، وهو `geodesic`:

```{python}
from geopy.distance import geodesic

distance = geodesic(dammam_coords, bahrain_coords)
print(f"Between Dammam and Bahrain is {distance.kilometers:.2f} km")
```

وهكذا نكون قد حسبنا المسافة بين المدينتين بالكيلومترات.

#### مفتاح الواجهة البرمجية (`API_KEY`)

![[geopy and geocoding services](https://geopy.readthedocs.io/en/stable/#geopy-is-not-a-service)](https://geopy.readthedocs.io/en/stable/_images/geopy_and_geocoding_services.svg){width="100%"}

فإن أردت تغيير مزوِّد الخدمة (إما لعدم دقتها أو عدم توفر المعلومات أو أي سبب آخر)، فما عليك إلا استعمال استيراد `Geocoder` آخر، مثلاً؛ مثلاً `TomTom`:

```python
from geopy.geocoders import TomTom

geolocator = TomTom(user_agent="pythonia", api_key="...")
```

لكن هذا يتطلَّب شيئًا إضافيًّا وهو الحصول على مفتاح متعلِّق بحساب مسجَّل على موقع [TomTom](https://developer.tomtom.com/) نفسه. ثم وضع هذا الفتاح هنا. وبهذا المفتاح المرتبط بهذا الحِساب يتمُّ تعبئة الاشتراك والصرف من رصيده. وهكذا تربح الشركة التي وفَّرت هذا النظام المعلوماتي.

### المثال الثاني: التخاطب عبر `httpx`

ماذا لو لم تتوفَّر مكتبة خاصَّة بمزوِّد الخدمة؟ 
في هذه الحالة سنكتب نحن تفاصيل الاتصال بالخادم المزوِّد.
وذلك يتطلب معرفة لغة التخاطب بين الخادم والعميل (HTTP).

يجب علينا أولاً تثبيت مكتبة [`httpx`](https://www.python-httpx.org/) باستعمال `uv`:

```bash
uv add httpx
```

ونمثل لمزود خدمة معلومات عن القطط ([The Cat API](https://thecatapi.com/))، وقد حصلنا على مفتاح التطبيق (API KEY) من خلال التسجيل في الموقع.

ولمعرفة الاستفادة من أي مزود خدمة، فإننا ندخل إلى صفحة المطورين، وتسمى ([API Documentation](https://developers.thecatapi.com/)). ومنها نعرف أن المسار الذي يجب أن نطلبه هو `https://api.thecatapi.com/v1/images/search`، وهو يعطينا صورة قط عشوائية.

أما المفتاح، فنضعه في الرؤوس (headers) تحت عنوان `x-api-key` كما يلي:

```{python}
import httpx

response = httpx.get(
    url="https://api.thecatapi.com/v1/images/search",
    headers={"x-api-key": "live_9Cj8P0h75D5h2D7Y2H8MYEuuTmTXjT412xNlbVBouHxn2sEnAjr1dr4JMfIn4Mr4"}
)
print(response.status_code)
```

غالبًا ستظهر لك النتيجة `200` وهي تعني `OK` أي أن كل شيء سار على ما يرام.

وإذا نظرت إلى النصّ الموجود في الرد (`response.text`) فإنك ستلاحظ أنه نصُّ مقوْلَب بصيغة JSON التي سبق الحديث عنها:


```{python}
print(type(response.text))
print(response.text)
```

```{mermaid}
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: GET /cats.csv HTTP/1.1
        note right of Server: Request headers: x-api-key
    activate Server
    Server->>+Client: HTTP/1.1 200 OK
        note right of Server: Response headers: Content-Type: application/json
        note right of Server: Response body: [ { ... } ]
    deactivate Server
```

ولكن هذا النص لا يمكن التعامل معه كما هو، لذلك نستخدم الفعل `json()` لتحويله إلى قائمة بالمعلومات:

```{python}
data = response.json()
print(type(data))
print(data)
```

الآن أصبح في هيكل بيانات يمكن التعامل معه. فنريد استخراج رابط الصورة منه:

```{python}
image_url = data[0]["url"]
print(image_url)
```

لعرض الصورة في صفحة الكتاب نستخدم المكتبة `IPython` على النحو التالي:

```{python}
from IPython.display import Image, display

display(Image(url=image_url))
```

وهكذا نكون قد حصلنا على صورة قط عشوائية.

### المثال الثالث

لنأخذ مثالاً آخر على استخدام خدمة برمجية، وهي خدمة الطقس من [OpenWeatherMap](https://openweathermap.org/api/one-call-3). هذه الخدمة تتيح لنا معرفة حالة الطقس في أي مدينة في العالم.

أولاً، نحتاج إلى مفتاح API من الموقع (يمكنك الحصول عليه مجاناً بعد التسجيل). ثم نستخدم مكتبة `httpx` للاتصال بالخدمة.

ففي [صفحة التوثيق](https://openweathermap.org/api/one-call-3) قالوا إن طريقة الطلب هي على النحو التالي:

```
https://api.openweathermap.org/data/3.0/onecall?lat={lat}&lon={lon}&exclude={part}&appid={API key}
```

نشرح الرابط حتى تتبين أجزاؤه ليسهل عليك بعد ذلك قراءة أية رابط:

- `https://api.openweathermap.org/data/3.0/onecall` هو الرابط الأساسي للخدمة
- `?` هي فاصلة أوَّل عامِل (وهو `lat` في هذا المثال،و كان من الممكن أن يكون `lon`)
- `lat={lat}` هو تعيين للعامل الأوَّل بقيمة `lat` خط العرض
- `lon={lon}` هو تعيين للعامل الثاني بقيمة `lon` خط الطول
- `exclude={part}` هو الجزء الذي نريد إهماله من النتائج (سنتركه فارغًا)
- `appid={API key}` هو مفتاح التطبيق الذي يسمح للطلب بالوصول إلى الخدمة

ونحن نكتبها في بايثون مع مكتبة `httpx` على النحو التالي:

```{python}
import httpx

lat = 24.7136
lon = 46.6753

request = httpx.get(
    url="https://api.openweathermap.org/data/3.0/onecall",
    params={
        "lat": round(lat, 4),
        "lon": round(lon, 4),
        "exclude": "minutely,hourly,daily,alerts", 
        "appid": "4a5417dd3a781b7f64f05178ed423a23"
    }
)
```

لاحظ تحديد الرابط `url` والمعاملات `params` التي ستوضع في الرابط نفسه.

### انطلق بالتطبيق

**وبهذا تكون قادرًا على التعامل مع أي برمجيَّة توفِّر خدماتها عبر الشبكة. تحتاج فقط أن تُقدِم وتجرِّب حتى تأخذ يدك على الأمر!**