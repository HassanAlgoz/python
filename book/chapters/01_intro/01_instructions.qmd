---
og:title: intro_01
---

# النص البرمجي {.unnumbered}

يتألف **النص البرمجي** (Software Code) من **قِطَع** (Snippets) هي عبرة عن **جُمَل** (Statements) متتابعة تعبِّر عن **أوامِر** (Instructions) يفسرها الحاسب وينفذها.

فمثلاً هذا الأمر، يحسب ناتج جمع العددين ويطبعه على الشاشة:

```{python}
print(5 + 3)
```

وتتتابع الأوامر سطرًا بعد سطر:

```{python}
print(3 + 7)
print(10 - 2)
print(2 * 2)
```

وتَتَّبِعُ لغات البرمجة بما فيها لغة بايثون **قَواعِدَ نَحْوِيَّة صارمة** حتى لا يشتبه عليه تفسيرها عند تحويلها لتعليمات مفصَّلة على لغة المنطق الرقمي للآلات المكون منها الحاسب لتنفذها.

فلا يجوز أن تقول مثلاً:

```python
print 3 plus 7
```

لأن هذا ليس من لغة بايثون.
والغرض من تحديد اللغة تقليل الاحتمال، مما يجعل التفسير أسرع، ويجعل التعبير أدقَّ في إصابة المقصود؛ وهذا دأب الرياضيين.

## الاسم

يحتاج المبرمج للإشارة لبعض القيَم بأسماء تدل على معناها،
وهذا مثال على أربعة أوامر نشرحها بمحاذاة النص بعد علامة (`#`) التي تجعل ما بعدها تعليقًا لا تضر قراءته إذْ لا يتم تفسيره:

```{python}
money = 10000      # تعيين قيمة للمتغير
zakat = money / 40 # تعيين حاصل نتيجة العملية للمتغير الآخر
print(zakat)       # طباعة النتيجة
```

**فالمُتَغَيِّر** (**Variable**) هو ما تُسنَدُ إليه **قيمة** (**Value**)، أو **تعبيرًا** (**Expression**) يؤول إلى قيمة.

ولدينا في المثال السابق:

1. المتغير `money` وقد أسندنا إليه قيمة: `10000`
2. المتغير `zakat` وقد أسندنا إليه التعبير: `money / 40` الذي يؤول إلى القيمة؛ وهي: `250`

ويجوز أن يكون المتغير من حرفٍ واحد:

```{python}
x = 10
y = 20
z = x + y
print(z)
```

ووجب التنبيه إلى أن علامة `=` تسمى **عامل التعيين** (**Assignment Operator**)، وليست علامة المساواة كما نستعملها في الرياضيات. فمعنى ذلك أن التعيين اللاحق ناسخٌ لما قبله:

```{python}
x = 10
x = 20
print(x)
```

لاحظ أن القيمة الظاهر في الطباعة هي للتعيين التالي وليس الأول.

بينما يمتنع هذا في الرياضيات أصلاً.

## العامل

ومن [**العوامل** (*Operators*)](https://docs.python.org/3/reference/lexical_analysis.html#operators):

- عامل الجمع: `+` (Addition)
- عامل الطرح: `-` (Subtraction)
- عامل الضرب: `*` (Multiplication)
- عامل القسمة: `/` (Division)
- عامل باقي القسمة: `%` (Modulus)
- عامل الأُس: `**` (Exponentiation)

فتجري على الأعداد على النحو التالي:

```{python}
x = 10
y = 2

print(x + y)  # الجمع
print(x - y)  # الطرح
print(x * y)  # الضرب
print(x / y)  # القسمة
print(x % y)  # باقي القسمة
print(x ** y) # الأس
```

## النوع

ولكل قيمة **نوع** (Type) يحدد ما يجري عليه من العوامل وما يمتنع.
وحتى تكون مبرمجًا جيدًا يجب أن يعرف نوع كل قيمة؛ وبالتالي نوع كل متغير، فإن نوعه نوع قيمته.

ومن الأنواع في لغة بايثون التي من **صنف العدد** (`Number`):

1. **العدد الصحيح**؛ ويرمز له بالكلمة `int` (تعني: Integer). ويستعمل في الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك.
2. **العدد ذي الفاصلة العائمة** (يقابل العدد العشري)؛ ويرمز له بالكلمة `float` (تعني: Floating Point). ويستعمل في تمثيل الكميات مثل المال، المسافة، والوقت.

فإذا تأمَّلت النص التالي وجدت جميع هذه القيَم من نوع العدد الصحيح (`int`) إذ لا وجود للفاصلة العشرية:

```{python}
age = 20
level = 3
index = -2
start = 0
```

أما التالي فهو من نوع العدد ذي الفاصلة العائمة (`float`) إذ يوجد فيه الفاصلة العشرية:

```{python}
distance = 100.0
price = 10.5
time = 1.5
temperature = 36.6
difference = 0.001
```

ومن أكثر الأنواع استعمالاً في بايثون؛ **النص** (`str`)؛ وهو سلسلة من الأحرف .
ويُعرَفُ بعلامتي التنصيص سواء المفردة (`'`) أو المزدوجة (`"`) على النحو التالي:

```{python}
name = 'Adam'
city = "Al-Madinah"
```

فيجوز دمج النصوص بعلامة الجمع كالتالي:

```{python}
sentence = "hello, I am " + name + " and I live in " + city
print(sentence)
```

لاحظ أن كلمة `name` وكلمة `city` كلاهم خارج التنصيص؛ لذا فهما يشيران إلى المتغيرين الذين تم تعريفها سابقًا.

لكن يمتنع الجمع بين النص والعدد.
فلو حاولت تشغيل التالي فستظهر لك رسالة خطأ:

```{python}
# | error: True
sentence = name + " is " + age + " years old"
```

ولحل المشكلة السابقة، يجب أولاً تحويل نوع العدد إلى نوع النص باستعمال الدالة `str(x)` على النحو التالي:

```{python}
sentence = name + " is " + str(age) + " years old"
print(sentence)
```

ولمعرفة نوع المتغير، نستعمل الدالة `type(x)` بتمرير القيمة أو المتغير عوضًا عنها.

```{python}
print(type(5))
print(type(5.0))
print(type("Hello"))
```

تأمل ناتج عمليات طباعة النوع لكل من المتغيرات السابقة:

```{python}
print(type(age))
print(type(distance))
print(type(name))
print(type(city))
```

وكثيرًا ستضطر إلى معرفة نوع المتغير الذي تتعامل معه.
فبعض محررات النص البرمجي تُظهر لك النوع بمجرد تحليق المؤشر على اسم المتغير.

## الإدخال

يستمعل أمر الإدخال (`input(message)`) للحصول على قيمة من المستخدم.
وتفسر هذه القيمة على أنها سلسلة من الأحرف؛ أي: أنها من نوع النص (`str`)،
ولو كان المستخدم أدخل عددًا، فإنه سيفسر على أنه حروف العدد وليس قيمةً من نوع العدد.

تأمل المثال التالي:

```python
msg = "Enter your age: "
age = input(msg)
print(age, type(age))
```

يتم تنفيذ هذه التعليمات على النحو التالي:

1. تعيين القيمة النصيَّة للمتغير `msg`
2. تعيين حاصل القيمة المدخلة من المستخدم للمتغير `age`
   - هذا يعني أن البرنامج سيتوقف، ليظهر للمستخدم السؤال `Enter your age: ` (إذا كنت في محرر VS Code فسيظهر في الأعلى)
   - ثم إذا أدخل المستخدم فيه شيئًا ثم ضغط على زر `Enter` فسيتم تخزين القيمة المدخلة في المتغير `age` لكن كقيمة نصية
3. لإثبات أن ما تم إدخاله نص؛ نقوم بطباعة قيمة المتغير ثم نوعه

والآن لدينا خياران في تحويل قيمة المتغير النصيَّة إلى قيمة عددية، وذلك أننا عرفنا نوعين من الأعداد: الصحيح (`int`) والعشري (`float`).
وكلاهما يتم تحويلهما باستعمال الدالة `int(x)` أو `float(x)` على النحو التالي:

```{python}
x = int(age)
print(x, type(x))

y = float(age)
print(y, type(y))
```

وعادةً ما نحتاج لمثل هذا التحويل عند قراءة بيانات من الخارج، **فتنبه!**

ولتثبيت الفكرة، نضرب مثالاً واضحًا بمتغيرين أحدهما عددي والآخر نصي:

```{python}
x = 10
y = "10"
```

فلو حاولت خطأً (وهذا يقع كثيرًا) الجمع بينهما فستظهر لك رسالة خطأ:

```{python}
# | error: True
print(x + y)
```

ولو كانا كلاهما من النوع النصي، فإن نتيجة الجمع ستكون بدمج النصين لا بجمع العددين.
تأمل المثال التالي:

```{python}
x = "10"
y = "20"

print(x + y)
```

وهذا وإن لم يظهر برسالة خطأ فإنه ليس مقصودنا؛ لذلك فهو خطأ منطقي وإن كان من حيث البنية اللغوية صحيحًا.

فيجب استعمال التحويل اللازم في مثل هذه الحالات إن كان القصد أن يكون المتغير من النوع العددي.

