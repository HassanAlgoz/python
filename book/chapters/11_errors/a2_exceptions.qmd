
## الخطأ الواقعي: الاستثناء

[الاستثناء](https://docs.python.org/3.13/tutorial/errors.html) (Exception) هو خروج البرنامج عن المسار المثالي. مثل أن يؤمَر بقراءة ملف .. والواقع أن هذا الملف غير موجود! أو أن يطلب من المستخدم رقمًا فيعطيه كلاماً! أو أن يطلب من الشبكة شيئًا .. فتنقطع الشبكة!

فكل هذه تعتبر مسارات غير مثالية لكنها تحصل في ظروف واقعيَّة. فيجب كتابة قطع في البرنامج تتعامل معها. ولذا فإن بعض الممارسين لا يفضلون استعمال كلمة استثناء لأنَّ مثل ذلك يحصل كثيرًا فهو ليس خارجًا عن العادة؛ بل عادة ما يحصل.

ومنها ما **يتعذر على البرنامج معالجته بنفسه**:

- إذا كانت المشكلة بامتلاء الذاكرة في الجهاز؛ فإن البرنامج ليس له إلا أن يخرج برسالة للمستخدم أو المسؤول عن الجهاز .. وليس للبرنامج أن يمسح بيانات المستخدم!
- أما إذا كانت المشكلة في تأخر الإجابة من الخادم مثلاً، فقد نعيد المحاول مرة أخرى بعد ثوانٍ، ونعيدها لعددٍ محدد من المرات، أملاً في الحصول على إجابة. ثم نظهر رسالة خطأ إن نفدت جميع المحاولات.

ولدينا آليتان في لغات البرمجة للتعبير عن حدوث الخطأ الواقعي:

- **رفع قيمة الخطأ بالاسثناء**: لغات مثل C++ (1979)، Java (1998)، Python (1991) و JavaScript (1995) ترمي/ترفع الاستثناءات باستعمال عبارة مثلة `raise` أو عبارة `throw` على حسب اللغة.
	- فتكون معالجة الخطأ بجملة `try-catch` أو `try-except` كما سنرى.
- **الرجوع بقيمة الخطأ**: اللغات الحديثة مثل Go (2009) و Rust (2015) ببساطة تعيد الخطأ كشيء (قيمة) عند حدوثه باستعمال جملة `return` التي في الإجراء.
	- فتكون معالجة الخطأ بجملة شرطية عاديَّة نحو: `if error`

فلو تخيَّلنا أطر التنفيذ (سلسلة الاستدعاءات) فإن كل استدعاء يرجع للذي قبله؛ فإن لم يجد جملة تنظر في الخطأ، فإنه يرجع للذي قبله .. وهلم جرا. وعند **إهمال** معالجة الخطأ فإن البرنامج يقف ويُظهر رسالة الخطأ التي تفاقمت.

لنأخذ مثالًا لنرى كيف يتم التعامل مع الاستثناءات في بايثون.

#### مثال

نريد في بداية البرنامج قراءة ملف تكوين `custom_config.json` لتهيئة حالة البرنامج:

```{python}
#| error: true

file = open('custom_config.json')
```

لكن الواقع أن الملف غير موجود. وهذا يجعل الإجراء `open` يرفع استثناءً من نوع `FileNotFoundError`. وفي موضع الاستدعاء أمامنا خياران:

1. إهمال الخطأ: يؤدي إلى إيقاف البرنامج.
2. معالجة الخطأ: أي نكتب له مسارًا برمجيًّا.

نعدنا الآن نعالج الخطأ:

```python
try:
    file = open('custom_config.json')
except FileNotFoundError:
    print("The file does not exist. Falling back to default configuration.")
    file = open('default.json')
```

#### مثال آخر

دعونا نلقي نظرة على مثال آخر، قد يحصل فيه حالة خطأ بسبب تنوع مدخلات المستخدم:

```{python}
choices = ['bus', 'train', 'plane', 'boat'] 
print("Choose an option:")
for i, choice in enumerate(choices, start=1):
    print(f"{i}. {choice}")

# choice = input(f"Choose a number from 1 to {len(choices)}: ")
```

ما هي حالات الخطأ الممكنة؟:

- قد يدخل المستخدم رقمًا خارج النطاق: `0` أو `9`
- قد يدخل المستخدم قيمة غير صحيحة: `three`

نحتاج إلى التعامل مع هذه الاستثناءات. يمكننا استخدام كتلة `try-except` للتعامل مع الاستثناءات.

دعونا نرى ما هو الاستثناء الذي يتم رفعه في الحالة الأولى:

```{python}
#| error: true
choices[9]
```

الاستثناء هو `IndexError`.

ماذا عن الحالة الثانية؟ لنرى:

```{python}
#|error: true
choices['three']
```

الاستثناء هو `TypeError`.

الآن بعد أن عرفنا الحالات، دعونا نتعامل معها.

```{python}
c = '9'

retry_message = "Please enter a digit between 1 and 4"

try:
    c = int(c)
    print('User chooses to:', choices[c-1])
except IndexError:
    print(retry_message)
except ValueError:
    print(retry_message)
```

يمكن تجميع الاستثناءات على النحو التالي:

```{python}
try:
    c = int(c)
    print('User chooses to:', choices[c-1])
except (IndexError, ValueError):
    print(retry_message)
```

## رفع الاستثناءات

إذا كنت تريد رفع استثناء، يمكنك استخدام الكلمة `raise`.

- إذا كان نوع العامل خاطئًا، يجب رفع `TypeError`
- وإلا، فتحقق من القيمة؛ فإن كانت خارج نطاق الإدخال المقبول، يجب رفع `ValueError`

ملاحظة: علينا استيراد `numbers` للتحقق من نوع الإدخال `x` باستخدام الإجراء المضمَّن: `isinstance(x, numbers.Number)` على النحو التالي:

```{python}
import numbers

def square_root(x):
    # Validation
    if not isinstance(x, numbers.Number):
        raise TypeError("Argument must be a number")
    if x < 0:
        raise ValueError("Cannot calculate square root of a negative number")
    # Now that we have checked the input, we can calculate the square root
    result = x ** 0.5
    return result
```

لنختبر حالتي الخطأ:

```{python}
#| error: true
square_root('16')
```

```{python}
#| error: true
square_root(-99)
```

لنختبر الآن المسار السعيد:

```{python}
square_root(16)
```


## الأخطاء الشائعة: أسباب وحلول

فيما يلي بعض أنواع الأخطاء الشائعة وكيفية إصلاحها:

### `TypeError`

**السبب**:

1. استدعاء إجراء بعدد أكثر أو أقل من العوامل الواجبة (مثل: `len(1, 2)`)
2. استدعاء إجراء بعوامل لا تطابق النوع المحدد في تعريفه (مثل: `math.sqrt('nine')` أو `5 + '5'`)

**الحل**: الوقاية باستعمال `type()` أو `isinstance()` للتحقق من تطابق أنواع البيانات المستخدمة مع متطلبات العملية.  
    
### `ValueError`  

**السبب**:

ألا يحصل `TypeError` لكنَّ القيمة خارج مدى الإجراء. كتمرير عدد سالب إلى مكان يُتوقع فيه أعداد موجبة فقط. مثل: `math.sqrt(-16)` فالجذر التربيعي لا يقبل عددًا سالبًا.

**الحل**: تحقق من مدى القيمة قبل استدعاء الإجراء بها.

### `IndexError` و `KeyError`  

**السبب**: الرقم الذي استعمل في عملية الإشارة `[index]list` (قائمة) أو `dict[key]` (قاموس) يشير لما هو خارج المجموعة. 

**الحل**:

- بالنسبة للقائمة: معرفة طول المجموعة قبل الإشارة بالمؤشر (استخدم `len()`) أو
- بالنسبة للقاموس:
	- بتصدير الشرط `if key in dict` لتعليق تنفيذ الجملة على وجود الرقم قبل الإشارة به أو
	- باستعمال `dict.get(key, default)` التي تُرجِع `default` في حالة عدم الرقم
- استعمال `try-except` للتعامل معها `IndexError` أو `KeyError` بعد وقوعها أو
- في بعض الحالات، يكون التكرار بـ`for` مانعًا من حصوله أصلاً

### `AttributeError`  و `NameError`

**السبب**: استعمال متغير أو إجراء قبل تعريفه.

- فإن أسنِد إلى كائن؛ وقع `AttributeError`
- وإلا وقع `NameError`

**الحل**:

- تأكد من صحة ترتيب الخطوات
- تأكد من صحة الإملاء

### `ModuleNotFoundError`  
**السبب**: فشل جُملة الاستيراد `import numpy`  

**الحل**: 

- تأكد من صحة الإملاء 
- تأكد من تثبيت الوحدة في البيئة التي يعمل فيها البرنامج: `pip install numpy`

### `SyntaxError`  
**السبب**: خطأ نحوي قد يكون:

- في وضع كلمة صحيحة في غير سياقها
- خطأ في الإملاء
- توقُّع الكثير من مترجم بايثون 

**الحل**: اتبع ما تقوله لك رسالة الخطأ.

### كيفية إصلاح الأخطاء المقعدة؟

قد تتطلب الأخطاء المقعدة المزيد من التصحيح وفهم الكود. لذا، من المهم تعلم كيفية قراءة رسالة الخطأ التي تنتجها Python. يتكون الخطأ من ثلاثة أجزاء: **نوع الخطأ**، **رسالة الخطأ**، و **سلسلة النداءات** (stack trace).

أولاً، اقرأ السطر الأخير. فذلك يخبرك بأمرين:

1. `ErrorType` الذي يمكنك استخدامه في كتلة `try-catch` إذا لزم الأمر
2. يتبعه رسالة خطأ بلغة إنجليزية بسيطة توضح ما حدث

تدرج سلسلة النداءات (stack trace) الاستدعاءات (الإجراءات التي تستدعي إجراءات أخرى). وبالتالي، فإن الكود الذي رفع الخطأ سيكون الأخير (في الأسفل)، في حين أن الإجراء التي بدأت ذلك ستكون الأولى (في الأعلى).

اعتبر سلسلة الاستدعاءات حيث تستدعي `func_app` الإجراء `func_library_1` التي تستدعي الإجراء `func_library_2`. يُفترض أن الدالتين الأخريين هما مكتبات مستوردة. مثال: نعرّف إجراءات في تطبيقنا تستدعي مكتبة `pandas` التي تستدعي مكتبة `numpy`.

قد يتم رفع استثناء في مكان ما، ونريد تطبيق ما تعلمناه أعلاه لقراءته وإصلاحه.

```{python}
#|error: true

def func_library_2(c):
    if len(c) == 0:
        raise ValueError("Empty input")
    z = c
    return z

def func_library_1(b, c):
    if not isinstance(c, str):
        raise TypeError("c must be a string")
    y = func_library_2(c)
    return b + y

def func_app(a, b, c):
    x = func_library_1(b, c)
    return a + x

func_app('a', 'b', '')
```

لنقرأ رسالة الخطأ. تقول: `"ValueError: Empty input"`. حسنًا، ما الذي تسبب في ذلك؟ دعونا نلقي نظرة على سلسلة النداءات (stack trace) من الأعلى (للعثور على إجراءاتنا الخاصة). نجد:

```
File c:\Users\thund\OneDrive\3-Teach\DS-AI\2. Py\book\11_errors.qmd:17
     14     x = func_library_1(b, c)
     15     return a + x
---> 17 func_app('a', 'b', '')
```
هي أول استدعاء في سلسلة السببية. لنقرأ ماذا يأتي بعدها:

```
File c:\Users\thund\OneDrive\3-Teach\DS-AI\2. Py\book\11_errors.qmd:14
     13 def func_app(a, b, c):
---> 14     x = func_library_1(b, c)
     15     return a + x
```

الآن هذه هي الاستدعاء الثاني، والأخير في تطبيقنا. بعد هذه النقطة، يكون خارج نطاق سيطرتنا. بما أننا نحافظ على كودنا الخاص `func_app`، فمن الأرجح أننا ارتكبنا الخطأ. يمكننا إصلاحه عن طريق التحقق من الإدخال قبل أن يغادر كودنا إلى `func_library_1`.

```{python}
func_app('a', 'b', 'c')
```

تم الإصلاح. انتهى.

إذا كان الخطأ في الواقع في `func_library_1`، فعلينا التواصل مع القائمين على صيانة المكتبة لإصلاحه. ربما يمكننا إصلاحه بأنفسنا وتقديم طلب سحب (pull request) على GitHub. هكذا تتحسن البرمجيات مفتوحة المصدر.

وأنصح من قد شرع في كتابة التطبيقات أن يقرأ هذه الصفحة بعنوان: [The Ultimate Guide to Error Handling in Python](https://blog.miguelgrinberg.com/post/the-ultimate-guide-to-error-handling-in-python).