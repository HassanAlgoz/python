---
og:title: numbers
---

# الأعداد

شجرة أنواع [الأرقام](https://docs.python.org/3/reference/datamodel.html#numbers-number) في بايثون:

```{mermaid}
flowchart BT
  Number
  Integral -- "is a" --> Number
  Real(float) -- "is a" --> Number
  Complex(complex) -- "is a" --> Number
  int -- "is a" --> Integral
  bool -- "is a" --> Integral
```

الإجراءات العامة المتعلقة بنوع العدد:


| الإجراء                    |                                      عمله |
|:---------------------------|------------------------------------------:|
| `abs(x)`                   |                            القيمة المطلقة |
| `float(x)`                 |          تحويل إلى عدد عشري (فاصلة عائمة) |
| `int(x)`                   |                        تحويل إلى عدد صحيح |
| `pow(base, exp)`           |                    القوة: رفع الأساس للأس |
| `round(number[, ndigits])` | تقريب العدد باعتبار تحديد المنازل العشرية |

للمزيد راجع [صفحة المكتبة الأساسية لوحدات الأرقام والرياضيات](https://docs.python.org/3/library/numeric.html).

## الحساب والمقارنة

الأعداد هي الحجر الأساس في أي برنامج. بل يُبنى عليها فهم البرنامج للنصوص المكتوبة والأصوات والصور وجميع أنواع البيانات. ولذلك وجب معرفة أساسياتها.

**ملاحظة**: كل ما بعد علامة `#` يعتبر تعليقًا يتجاهله الحاسب ولا يفسره. فنستخدمه للملاحظات والشرح في ثنايا القطعة البرمجية.

## الحساب والمقارنة

```{python}
x = 5
y = 10

print(x + y) # الجمع
print(x - y) # الطرح
print(x * y) # الضرب
print(x / y) # القسمة
print(x % y) # باقي القسمة
print(x ** y) # الأس
```

المقارنة بين الأعداد:

```{python}
x = 5
y = 10

print(x == y) # التطابق
print(x != y) # الاختلاف
print(x > y) # أكبر
print(x < y) # أصغر
print(x <= y) # أصغر أو يساوي
print(x >= y) # أكبر أو يساوي
```

## ترتيب العمليات

ترتيب العمليات هو نفسه كما في الرياضيات:

1. الأقواس: `()`
2. الأسس: `**`
3. الضرب والقسمة: `*` و `/`
4. الجمع والطرح: `+` و `-`

للتفصيل الشامل انظر: [ترتيب التقييم](https://docs.python.org/3/reference/expressions.html#evaluation-order)

إليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه. ولاحظ أننا نستعمل **جملة التوكيد** (`assert`) التي تسكُت إن كان الشيء الذي أمامها جملة منطقية صحيحة؛ وإلا فهي تظهر رسالة خطأ. وسترى أننا نستعملها بكثرة لتقرير لوازم ما نبينه في الدرس:

```{python}
assert 3 + 2 * 5 == 13
assert (3 + 2) * 5 == 25
```

```{python}
assert 8 - 4 / 2 == 6
assert (8 - 4) / 2 == 2
```

```{python}
assert 2 ** 3 * 4 == 32
assert (2 ** 3) * 4 == 32
```

## التعيين النسبي

كثيرًا ما نريد زيادة العدد أو إنقاصه؛ لذلك وضعت بايثون ما يسمى **التعيين النسبي** (Augmented Assignment).
فجمل التعيين التالية متكافئة:

- `x = x + 1` تعادل `x += 1`
- `x = x - 1` تعادل `x -= 1`
- `x = x * 2` تعادل `x *= 2`
- `x = x / 2` تعادل `x /= 2`

جرب النص البرمجي أدناه لترى النتيجة:

```{python}
i = 0
i = i + 1
i += 1
print(i)
```

**التعيين المتعدد** (Multiple Assignment):

```{python}
start, end = -5, 10
left, middle, right = 3, 5, 7
```

## وحدة الرياضيات (`math`)

```{python}
import math

x = 5.4
```

كل هذه الطرق الثلاث يتم فيها حساب الأس:

- الأولى `pow` فعل مبني
- الثانية `math.pow` فعل من وحدة الرياضيات
- الثالثة `x ** 2` عن طريق العامل `**`

$$
x^2 = x \times x
$$

```{python}
assert(
    pow(x, 2) ==
    math.pow(x, 2) ==
    x ** 2 ==
    x * x
)
```

وكذلك الجذر التربيعي:

$$
\sqrt{x} = x^{1/2}
$$

- الأولى `math.sqrt` فعل من وحدة الرياضيات
- الثانية `x ** 0.5` عن طريق العامل `**`

```{python}
assert (
    math.sqrt(x) ==
    x ** 0.5
)
```

تقريب لأقرب عدد صحيح أصغر:

$$
\text{floor}(x) = \lfloor x \rfloor
$$

```{python}
math.floor(5.4)
```

تقريب لأقرب عدد صحيح أكبر:

$$
\text{ceil}(x) = \lceil x \rceil
$$

```{python}
math.ceil(5.4)
```

حذف ما بعد الفاصلة:

```{python}
math.trunc(5.4)
```

تقريب إلى رقمين بعد الفاصلة:

```{python}
round(5.436, 2)
```

ملاحظة: الإجراء الأخير `round` ليس مستوردًا من `math` وإنما هو مُضمَّن في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.


## مجموعة الأعداد

أما التعامل مع المجموعات (كمجموعة الأعداد) فسيأتي في [باب المجموعات المرتبة](../05_sequences/a_sequences.qmd). لكننا نعرض لمثال بسيط للتعامل مع المجموعات العددية:

```{python}
xs = [10, 20, 30, 40, 50]
```

توفر بايثون الدوال التالية للمجموعة العددية:

- الطول (عدد العناصر): `len` (من كلمة length)
- مجموع العناصر: `sum`
- العنصر الأكبر: `max`
- العنصر الأصغر: `min`

```{python}
print('length:', len(xs))
print('total:', sum(xs))
print('average:', sum(xs) / len(xs))
print('maximum:', max(xs))
print('minimum:', min(xs))
```

### الإحصاء

ونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:

- المتوسط الحسابي: `statistics.mean`
- الوسيط: `statistics.median`
- المنوال: `statistics.mode`
- الانحراف المعياري: `statistics.stdev`

```{python}
import statistics

xs = [
    20, 21, 22, 23, 20, 22, 20,
    18, 24, 18, 21, 23, 19, 20,
    20, 21, 22, 23, 20, 22, 20,
    18, 24, 18, 21, 23, 19, 20
]

print('mean:', statistics.mean(xs))
print('median:', statistics.median(xs))
print('mode:', statistics.mode(xs))
print('standard deviation:', statistics.stdev(xs))
```


## أنواع العدد في بايثون

- **العدد الصحيح** ([int](https://docs.python.org/3/library/functions.html#int))
- **القيمة المنطقية** ([bool](https://docs.python.org/3/library/stdtypes.html#boolean-type-bool))
- **العدد العشري** ([float](https://docs.python.org/3/library/functions.html#float))
- **العدد المركب** ([complex](https://docs.python.org/3/library/functions.html#complex))

صفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالإجراء فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.

**فالتمثيل الداخلي** للأعداد له أثر:

1. في مساحة التخزين
2. دقة العدد؛ وبالتالي صحة الحساب
3. سرعة الحساب

لكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.

### العدد الصحيح (`int`)

**الوظيفة**: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك

```{python}
age = 20
level = 3
index = -2
start, end = -5, 10
left, middle, right = 3, 5, 7
```

يؤتى بالإجراء `type` لمعرفة نوع المتغير:

```{python}
assert int == type(age) 
assert int == type(level) 
assert int == type(index) 
assert int == type(start) == type(end)
assert int == type(left) == type(middle) == type(right)
```

**المجال**: نقصد بالمجال هو أعلى قيمة ممكنة وأقل قيمة ممكنة للنوع.
فنوع العدد الصحيح (`int` ويرمز له بالرياضي $\mathbb{Z}$) هو في واقع الحواسيب محكوم بعدد الخانات (Bits) التي يتم استعمالها في تمثيله.
ورغم أن بايثون تخفي عنا عدد الخانات؛ إلا أنها تتعامل مع هذا الواقع، ولذلك وجب معرفته:

- 8-بت: $\{x \in \mathbb{Z} \mid -2^7 \leq x < 2^7\} = \{-128, \ldots, 127\}$ أي أن أقل عدد ممكن في 8 خانات: $-128$ وأعلى عدد ممكن: $127$. وهلم جرا.
- 16-بت: $\{x \in \mathbb{Z} \mid -2^{15} \leq x < 2^{15}\}$
- 32-بت: $\{x \in \mathbb{Z} \mid -2^{31} \leq x < 2^{31}\}$
- 64-بت: $\{x \in \mathbb{Z} \mid -2^{63} \leq x < 2^{63}\}$
- 128-بت: $\{x \in \mathbb{Z} \mid -2^{127} \leq x < 2^{127}\}$

::: {.callout-note collapse="true"}

لاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)

:::

### القيمة المنطقية (`bool`)

وهي مجموعة العددين: $\{0, 1\}$ الذين يمثل لهما بالكلمتين: `True` و `False` وذلك لتبيين وظيفتهما المنطقية.

```{python}
assert True  == bool(1) == 1
assert False == bool(0) == 0
```

**الوظيفة**: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.

نلجئ الكلام عنها إلى  [باب الشرط والتكرار](../03_control_flow/a_control_flow.qmd).

### العدد العشري (`float`)

**الوظيفة**: تمثيل الكميات مثل المال، المسافة، والوقت

```{python}
distance = 100.0
price = 10.5
time = 1.5
temperature = 36.6
difference = 0.001
```

نفحص أنواعها:

```{python}
assert float == type(distance)
assert float == type(price)
assert float == type(time)
assert float == type(temperature)
assert float == type(difference)
```

**المجال**: يعبر الرمز $\mathbb{R}$ عن مجموعة الأعداد العشرية (`float`). وهي تتبع نظام التمثيل [IEEE 754](https://ryanstutorials.net/binary-tutorial/binary-floating-point.php).

- 32-بت: $\{x \in \mathbb{R} \mid -2^{31} \leq x < 2^{31}\} = \{-3.4 \times 10^9, \ldots, 3.4 \times 10^9\}$
- 64-بت: $\{x \in \mathbb{R} \mid -2^{63} \leq x < 2^{63}\} = \{-1.8 \times 10^{19}, \ldots, 1.8 \times 10^{19}\}$
- 128-بت: $\{x \in \mathbb{R} \mid -2^{127} \leq x < 2^{127}\} = \{-1.2 \times 10^{38}, \ldots, 1.2 \times 10^{38}\}$

## اختلاف نوع العدد

إذا اختلف النوع تُقدَّرُ الترقيةُ للأشمل، وذلك بحسب ناتج العملية:

- جمع صحيح وعشري = عشري: `int + float = float`
- قسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): `int / int = float`
- **القسمة الصحيحة** بين صحيح وصحيح = صحيح: `int // int = int`

المثال الأول: جمع عدد صحيح وعدد عشري:

```{python}
a = 1 + 1.0
print(a)
assert type(a) == float
```

المثال الثاني: قسمة عدد صحيح على عدد عشري:

```{python}
c = 1 / 2
print(c)
assert type(c) == float
```

المثال الثالث: استعمال القسمة الصحيحة `//`:

```{python}
b = 9 // 2
print(b)
assert type(b) == int
```

س: لماذا النتيجة `4`؟ 

ج: لأن قسمة `9` على `2` تُنتِج `4.5` ولكن بايثون تقربها لأقرب عدد صحيح أصغر وهو `4`؛ وذلك لأننا اخترنا القسمة الصحيحة بالعلامة `//` وليس القسمة العشرية بالعلامة `/`.

## الفرق بين النوع العددي والنوع النصي للعدد

تأمل المتغيرين

```{python}
a = 50
b = '50'
```

- الأول: عدد صحيح (`int`)
- الثاني: حرفان (`str`)

نستعمل جمل التوكيد لبيان ذلك:

```{python}
assert type(a) == int
assert type(b) == str
assert type(a) != type(b)
```

ومقتضى ذلك: **امتناع عملية الجمع**: `a + b`

```{python}
#| error: true
'5' + 5
```

بل يجب التحويل أولاً باستعمال الإجراء `int` الذي يفسر الأحرف كعدد صحيح:

```{python}
a = 5
b = '5'

b = int(b)

assert a + b == 10
```


## كتابة القيَم العددية

[**الحروفيَّة**](https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals) (Literals) هي رموز للقيم لبعض الأنواع المدمجة. مثال: `42` هو حرفيُّ عدد صحيح و `3.14` هو حرفيُّ عدد عشري.

وتخصيص الحرفيّ `True` للعدد `1` و `False` للعدد `0` ليس من قبيل الضرورة في اللغة وإنما من قبيل التسهيل (وفوق ذلك فإن بايثون تجعل له نوعًا خاصًّا وعمليات مصاحبة).

```{python}
assert True  == bool(1) == 1
assert False == bool(0) == 0
```

كذلك خصصت بايثون `e` أو `E` للترميز العلمي (وجاء الحرف `e` من كلمة: Exponent) المخصص للأعداد العشرية الكبيرة والصغيرة.

```{python}
assert 1e2 == 100
assert 1e9 == 1E9
assert 1e-4 == 0.0001
```

ويجوز استعمال الشرطة السفلية `_` لفاصلة الألوف:

```{python}
assert 1_000_000 == 1000000
```

وأما إن كنت تهتم بالتمثيل الثنائي أو الثماني أو الست عشري فذلك أيضًا له تعبيرات مخصصة:

- `0b` أو `0B` للأرقام الثنائية
- `0o` أو `0O` للأرقام الثمانية
- `0x` أو `0X` للأرقام الست عشرية

وإليك تطبيق ذلك:

```{python}
assert 0b1010 == 10
assert 0o10 == 8
assert 0x10 == 16
```

وأخيرًا يمكن استعمال `j` أو `J` للأعداد المركبة:

```{python}
assert 1 + 2j == 2j + 1
```

## خلاصة

عرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.

ننتقل الآن [لباب الشرط والتكرار](../03_control_flow/a_control_flow.qmd) حيث الجمل الشرطية والتعيين المشروط.
