# الأعداد

## الحساب والمقارنة

```{python}
x = 5
y = 10

print(x + y) # الجمع
print(x - y) # الطرح
print(x * y) # الضرب
print(x / y) # القسمة
print(x % y) # باقي القسمة
print(x ** y) # الأس
```

المقارنة بين الأعداد:

```{python}
x = 5
y = 10

print(x == y) # التطابق
print(x != y) # الاختلاف
print(x > y) # أكبر
print(x < y) # أصغر
print(x <= y) # أصغر أو يساوي
print(x >= y) # أكبر أو يساوي
```

## ترتيب العمليات

ترتيب العمليات هو نفسه كما في الرياضيات:

1. الأقواس: `()`
2. الأسس: `**`
3. الضرب والقسمة: `*` و `/`
4. الجمع والطرح: `+` و `-`

للتفصيل الشامل انظر: [ترتيب التقييم](https://docs.python.org/3/reference/expressions.html#evaluation-order)

إليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه. ولاحظ أننا نستعمل **جملة التوكيد** (`assert`) التي تسكُت إن كان الشيء الذي أمامها جملة منطقية صحيحة؛ وإلا فهي تظهر رسالة خطأ. وسترى أننا نستعملها بكثرة لتقرير لوازم ما نبينه في الدرس:

```{python}
assert 3 + 2 * 5 == 13
assert (3 + 2) * 5 == 25
```

```{python}
assert 8 - 4 / 2 == 6
assert (8 - 4) / 2 == 2
```

```{python}
assert 2 ** 3 * 4 == 32
assert (2 ** 3) * 4 == 32
```

## التعيين النسبي

يراجع: [التعيين النسبي](https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements).

لأن التعيين النسبي يستعمل بكثرة، فوجب علينا التعرف عليه، وأحيانًا نحتاج لاستعماله. فجمل التعيين التالية متكافئة:

- `i = i + 1` تعادل `i += 1`
- `i = i - 1` تعادل `i -= 1`
- `i = i * 2` تعادل `i *= 2`
- `i = i / 2` تعادل `i /= 2`

جرب الكود أدناه لترى النتيجة:

```{python}
i = 0
i = i + 1
i += 1
print(i)
```

لاحظ أن `i++` تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:

```{python}
#| error: true
i++
print(i)
```

## وحدة الرياضيات

```{python}
import math

x = 5.4
```

كل هذه الطرق الثلاث يتم فيها حساب الأس:

- الأولى `pow` فعل مبني
- الثانية `math.pow` فعل من وحدة الرياضيات
- الثالثة `x ** 2` عن طريق المعامل `**`

$$
x^2 = x \times x
$$

```{python}
assert(
    pow(x, 2) ==
    math.pow(x, 2) ==
    x ** 2 ==
    x * x
)
```

وكذلك الجذر التربيعي:

$$
\sqrt{x} = x^{1/2}
$$

- الأولى `math.sqrt` فعل من وحدة الرياضيات
- الثانية `x ** 0.5` عن طريق المعامل `**`

```{python}
assert (
    math.sqrt(x) ==
    x ** 0.5
)
```

تقريب لأقرب عدد صحيح أصغر:

$$
\text{floor}(x) = \lfloor x \rfloor
$$

```{python}
math.floor(x)
```

تقريب لأقرب عدد صحيح أكبر:

$$
\text{ceil}(x) = \lceil x \rceil
$$

```{python}
math.ceil(x)
```

حذف ما بعد الفاصلة:

```{python}
math.trunc(x)
```

تقريب إلى رقمين بعد الفاصلة:

```{python}
round(x, 2)
```

ملاحظة: الفعل الأخير `round` ليس مستوردًا من `math` وإنما هو مُضمَّن في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.


## مجموعة الأعداد

أما التعامل مع المجموعات (كمجموعة الأعداد) فسيأتي في [باب المجموعات المرتبة](../05_sequences/a_sequences.qmd). لكننا نعرض لمثال بسيط للتعامل مع المجموعات العددية:

```{python}
xs = [10, 20, 30, 40, 50]
```

توفر بايثون الدوال التالية للمجموعة العددية:

- الطول (عدد العناصر): `len` (من كلمة length)
- مجموع العناصر: `sum`
- العنصر الأكبر: `max`
- العنصر الأصغر: `min`

```{python}
print('length:', len(xs))
print('total:', sum(xs))
print('average:', sum(xs) / len(xs))
print('maximum:', max(xs))
print('minimum:', min(xs))
```

### الإحصاء

ونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:

- المتوسط الحسابي: `statistics.mean`
- الوسيط: `statistics.median`
- المنوال: `statistics.mode`
- الانحراف المعياري: `statistics.stdev`

```{python}
import statistics

xs = [
    20, 21, 22, 23, 20, 22, 20,
    18, 24, 18, 21, 23, 19, 20,
    20, 21, 22, 23, 20, 22, 20,
    18, 24, 18, 21, 23, 19, 20
]

print('mean:', statistics.mean(xs))
print('median:', statistics.median(xs))
print('mode:', statistics.mode(xs))
print('standard deviation:', statistics.stdev(xs))
```


## أنواع العدد في بايثون

- **العدد الصحيح** ([int](https://docs.python.org/3/library/functions.html#int))
- **القيمة المنطقية** ([bool](https://docs.python.org/3/library/stdtypes.html#boolean-type-bool))
- **العدد العشري** ([float](https://docs.python.org/3/library/functions.html#float))
- **العدد المركب** ([complex](https://docs.python.org/3/library/functions.html#complex))

صفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالفعل فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.

**فالتمثيل الداخلي** للأعداد له أثر:

1. في مساحة التخزين
2. دقة العدد؛ وبالتالي صحة الحساب
3. سرعة الحساب

لكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.

### العدد الصحيح

**الوظيفة**: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك

```{python}
age = 20
level = 3
index = -2
start, end = -5, 10
left, middle, right = 3, 5, 7
```

يؤتى بالفعل `type` لمعرفة نوع المتغير:

```{python}
assert int == type(age) 
assert int == type(level) 
assert int == type(index) 
assert int == type(start) == type(end)
assert int == type(left) == type(middle) == type(right)
```

**المجال**: يختلف مجال العدد الصحيح باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:

- يعبر الرمز $\mathbb{Z}$ عن مجموعة العدد الصحيح
- 8-بت: $\{x \in \mathbb{Z} \mid -2^7 \leq x < 2^7\} = \{-128, \ldots, 127\}$
- 16-بت: $\{x \in \mathbb{Z} \mid -2^{15} \leq x < 2^{15}\}$
- 32-بت: $\{x \in \mathbb{Z} \mid -2^{31} \leq x < 2^{31}\}$
- 64-بت: $\{x \in \mathbb{Z} \mid -2^{63} \leq x < 2^{63}\}$
- 128-بت: $\{x \in \mathbb{Z} \mid -2^{127} \leq x < 2^{127}\}$

::: {.callout-note collapse="true"}

لاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)

:::

### القيمة المنطقية

وهي كناية عن مجموعة مشتملة هي العددان: $\{0, 1\}$ الذيان يمثل لهما بالكلمتين: `True` و `False` وذلك لتبيين وظيفتهما المنطقية.

```{python}
assert True  == bool(1) == 1
assert False == bool(0) == 0
```

**الوظيفة**: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.

نلجئ الكلام عنها إلى  [باب الشرط والتكرار](../03_control_flow/a_control_flow.qmd).

### العدد العشري

**الوظيفة**: تمثيل الكميات مثل المال، المسافة، والوقت

```{python}
distance = 100.0
price = 10.5
time = 1.5
temperature = 36.6
difference = 0.001
```

نفحص أنواعها:

```{python}
assert float == type(distance)
assert float == type(price)
assert float == type(time)
assert float == type(temperature)
assert float == type(difference)
```

**المجال**: يختلف مجال العدد العشري باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:

- يعبر الرمز $\mathbb{R}$ عن مجموعة العدد العشري
- 32-بت: $\{x \in \mathbb{R} \mid -2^{31} \leq x < 2^{31}\} = \{-3.4 \times 10^9, \ldots, 3.4 \times 10^9\}$
- 64-بت: $\{x \in \mathbb{R} \mid -2^{63} \leq x < 2^{63}\} = \{-1.8 \times 10^{19}, \ldots, 1.8 \times 10^{19}\}$
- 128-بت: $\{x \in \mathbb{R} \mid -2^{127} \leq x < 2^{127}\} = \{-1.2 \times 10^{38}, \ldots, 1.2 \times 10^{38}\}$

## اختلاف نوع العدد

إذا اختلف النوع تُقدَّرُ الترقيةُ للأشمل، وذلك بحسب ناتج العملية:

- جمع صحيح وعشري = عشري: `int + float = float`
- قسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): `int / int = float`
- **القسمة الصحيحة** بين صحيح وصحيح = صحيح: `int // int = int`

المثال الأول: جمع عدد صحيح وعدد عشري:

```{python}
a = 1 + 1.0
print(a)
assert type(a) == float
```

المثال الثاني: قسمة عدد صحيح على عدد عشري:

```{python}
c = 1 / 2
print(c)
assert type(c) == float
```

المثال الثالث: استعمال القسمة الصحيحة `//`:

```{python}
b = 1 // 2
print(b)
assert type(b) == int
```

## الفرق بين النوع العددي والنوع النصي للعدد

تأمل المتغيرين

```{python}
a = 50
b = '50'
```

- الأول: عدد صحيح (`int`)
- الثاني: حرفان (`str`)

نستعمل جمل التوكيد لبيان ذلك:

```{python}
assert not (a == b)
assert type(a) != type(b)
assert type(a) == int
assert type(b) == str
```

ومقتضى ذلك: **امتناع عملية الجمع**: `a + b`

```{python}
#| error: true
'5' + 5
```

بل يجب التحويل أولاً باستعمال الفعل `int` الذي يفسر الأحرف كعدد صحيح:

```{python}
a = 5
b = '5'

b = int(b)

assert a + b == 10
```


## كتابة القيَم العددية

[**الحروفيَّة**](https://docs.python.org/3/reference/lexical_analysis.html#literals) هي رموز للقيم لبعض الأنواع المدمجة. مثال: `42` هو حرفيُّ عدد صحيح و `3.14` هو حرفيُّ عدد عشري.

وتخصيص الحرفيّ `True` للعدد `1` و `False` للعدد `0` ليس من قبيل الضرورة في اللغة وإنما من قبيل التسهيل (وفوق ذلك فإن بايثون تجعل له نوعًا خاصًّا وعمليات مصاحبة).

```{python}
assert True  == bool(1) == 1
assert False == bool(0) == 0
```

كذلك خصصت بايثون `e` أو `E` للترميز العلمي (وجاء الحرف `e` من كلمة: Exponent) المخصص للأعداد العشرية الكبيرة والصغيرة.

```{python}
assert 1e2 == 100
assert 1e9 == 1E9
assert 1e-4 == 0.0001
```

ويجوز استعمال الشرطة السفلية `_` لفاصلة الألوف:

```{python}
assert 1_000_000 == 1000000
```

وأما إن كنت تهتم بالتمثيل الثنائي أو الثماني أو الست عشري فذلك أيضًا له تعبيرات مخصصة:

- `0b` أو `0B` للأرقام الثنائية
- `0o` أو `0O` للأرقام الثمانية
- `0x` أو `0X` للأرقام الست عشرية

وإليك تطبيق ذلك:

```{python}
assert 0b1010 == 10
assert 0o10 == 8
assert 0x10 == 16
```

وأخيرًا يمكن استعمال `j` أو `J` للأعداد المركبة:

```{python}
assert 1 + 2j == 2j + 1
```

## خلاصة

عرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.

ننتقل الآن [لباب الشرط والتكرار](../03_control_flow/a_control_flow.qmd) حيث الجمل الشرطية والتعيين المشروط.
