# الأعداد

## الحساب والمقارنة

```{python}
x = 5
y = 10

print(x + y) # الجمع
print(x - y) # الطرح
print(x * y) # الضرب
print(x / y) # القسمة
print(x % y) # باقي القسمة
print(x ** y) # الأس
```

المقارنة بين الأعداد:

```{python}
x = 5
y = 10

print(x == y) # التطابق
print(x != y) # الاختلاف
print(x > y) # أكبر
print(x < y) # أصغر
print(x <= y) # أصغر أو يساوي
print(x >= y) # أكبر أو يساوي
```

## ترتيب العمليات

ترتيب العمليات هو نفسه كما في الرياضيات:

1. الأقواس: `()`
2. الأسس: `**`
3. الضرب والقسمة: `*` و `/`
4. الجمع والطرح: `+` و `-`

للتفصيل الشامل انظر: [ترتيب التقييم](https://docs.python.org/3/reference/expressions.html#evaluation-order)

إليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه:

```{python}
assert 3 + 2 * 5 == 13
assert (3 + 2) * 5 == 25
```

```{python}
assert 8 - 4 / 2 == 6
assert (8 - 4) / 2 == 2
```

```{python}
assert 2 ** 3 * 4 == 32
assert (2 ** 3) * 4 == 32
```

## التعيين النسبي

يراجع: [التعيين النسبي](https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements).

لأن التعيين النسبي يستعمل بكثرة، فوجب علينا التعرف عليه، وأحيانًا نحتاج لاستعماله. فجمل التعيين التالية متكافئة:

- `i = i + 1` تعادل `i += 1`
- `i = i - 1` تعادل `i -= 1`
- `i = i * 2` تعادل `i *= 2`
- `i = i / 2` تعادل `i /= 2`

جرب الكود أدناه لترى النتيجة:

```{python}
i = 0
i = i + 1
i += 1
print(i)
```

لاحظ أن `i++` تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:

```{python}
#| error: true
i++
print(i)
```

## وحدة الرياضيات

```{python}
import math

x = 5.4
```

كل هذه الطرق الثلاث يتم فيها حساب الأس:

- الأولى `pow` دالة مدمجة
- الثانية `math.pow` دالة من الوحدة الرياضيات
- الثالثة `x ** 2` عن طريق المعامل `**`

$$
x^2 = x \times x
$$

```{python}
assert(
    pow(x, 2) ==
    math.pow(x, 2) ==
    x ** 2 ==
    x * x
)
```

وكذلك الجذر التربيعي:

$$
\sqrt{x} = x^{1/2}
$$

- الأولى `math.sqrt` دالة من الوحدة الرياضيات
- الثانية `x ** 0.5` عن طريق المعامل `**`

```{python}
assert (
    math.sqrt(x) ==
    x ** 0.5
)
```

تقريب لأقرب عدد صحيح أصغر:

$$
\text{floor}(x) = \lfloor x \rfloor
$$

```{python}
math.floor(x)
```

تقريب لأقرب عدد صحيح أكبر:

$$
\text{ceil}(x) = \lceil x \rceil
$$

```{python}
math.ceil(x)
```

حذف ما بعد الفاصلة:

```{python}
math.trunc(x)
```

تقريب إلى رقمين بعد الفاصلة:

```{python}
round(x, 2)
```

ملاحظة: الدالة الأخيرة `round` ليست مستوردة من `math` وإنما هي مُضمَّنة في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.


## مجموعة الأعداد

لتعريف مجموعة مرتبة من الأعداد نستعمل القوسين المربعين `[]` هكذا:

```{python}
xs = [10, 20, 30, 40, 50]
```

توفر بايثون الدوال التالية للمجموعة العددية:

- الطول (عدد العناصر): `len` (من كلمة length)
- مجموع العناصر: `sum`
- العنصر الأكبر: `max`
- العنصر الأصغر: `min`

```{python}
print('length:', len(xs))
print('total:', sum(xs))
print('average:', sum(xs) / len(xs))
print('maximum:', max(xs))
print('minimum:', min(xs))
```

### الإحصاء

ونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:

- المتوسط الحسابي: `statistics.mean`
- الوسيط: `statistics.median`
- المنوال: `statistics.mode`
- الانحراف المعياري: `statistics.stdev`

```{python}
import statistics

print('mean:', statistics.mean(xs))
print('median:', statistics.median(xs))
print('mode:', statistics.mode(xs))
print('standard deviation:', statistics.stdev(xs))
```


## أنواع العدد في بايثون

- **العدد الصحيح** ([int](https://docs.python.org/3/library/functions.html#int))
- **القيمة المنطقية** ([bool](https://docs.python.org/3/library/stdtypes.html#boolean-type-bool))
- **العدد العشري** ([float](https://docs.python.org/3/library/functions.html#float))
- **العدد المركب** ([complex](https://docs.python.org/3/library/functions.html#complex))

صفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالأمر فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.

**فالتمثيل الداخلي** للأعداد له أثر:

1. في مساحة التخزين
2. دقة العدد؛ وبالتالي صحة الحساب
3. سرعة الحساب

لكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.

### العدد الصحيح

**الوظيفة**: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك

```{python}
age = 20
level = 3
index = -2
start, end = -5, 10
left, middle, right = 3, 5, 7
```

نستعمل الدالة `type` للتحقق من نوع المتغير:

```{python}
assert int == type(age) 
assert int == type(level) 
assert int == type(index) 
assert int == type(start) == type(end)
assert int == type(left) == type(middle) == type(right)
```

**المجال**: يختلف مجال العدد الصحيح باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:

- يعبر الرمز $\mathbb{Z}$ عن مجموعة العدد الصحيح
- 8-بت: $\{x \in \mathbb{Z} \mid -2^7 \leq x < 2^7\} = \{-128, \ldots, 127\}$
- 16-بت: $\{x \in \mathbb{Z} \mid -2^{15} \leq x < 2^{15}\} = \{-32768, \ldots, 32767\}$
- 32-بت: $\{x \in \mathbb{Z} \mid -2^{31} \leq x < 2^{31}\} = \{-2147483648, \ldots, 2147483647\}$
- 64-بت: $\{x \in \mathbb{Z} \mid -2^{63} \leq x < 2^{63}\} = \{-9223372036854775808, \ldots, 9223372036854775807\}$
- 128-بت: $\{x \in \mathbb{Z} \mid -2^{127} \leq x < 2^{127}\} = \{-170141183460469231731687303715884105728, \ldots, 170141183460469231731687303715884105727\}$

::: {.callout-note collapse="true"}

لاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)

:::

### القيمة المنطقية

وهي كناية عن مجموعة مشتملة هي العددان: $\{0, 1\}$ الذيان يمثل لهما بالكلمتين: `True` و `False` وذلك لتبيين وظيفتهما المنطقية.

```{python}
assert True == 1
assert False == 0
```

**الوظيفة**: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.

نلجئ الكلام عنها إلى  [باب الشرط والتكرار](chapters/03_control_flow/a_conditions.qmd).

### العدد العشري

**الوظيفة**: تمثيل الكميات مثل المال، المسافة، والوقت

```{python}
distance = 100.0
price = 10.5
time = 1.5
temperature = 36.6
difference = 0.001
```

نستعمل الدالة `type` للتحقق من نوع المتغير:

```{python}
assert float == type(distance)
assert float == type(price)
assert float == type(time)
assert float == type(temperature)
assert float == type(difference)
```

**المجال**: يختلف مجال العدد العشري باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:

- يعبر الرمز $\mathbb{R}$ عن مجموعة العدد العشري
- 32-بت: $\{x \in \mathbb{R} \mid -2^{31} \leq x < 2^{31}\} = \{-3.4 \times 10^9, \ldots, 3.4 \times 10^9\}$
- 64-بت: $\{x \in \mathbb{R} \mid -2^{63} \leq x < 2^{63}\} = \{-1.8 \times 10^{19}, \ldots, 1.8 \times 10^{19}\}$
- 128-بت: $\{x \in \mathbb{R} \mid -2^{127} \leq x < 2^{127}\} = \{-1.2 \times 10^{38}, \ldots, 1.2 \times 10^{38}\}$

## اختلاف نوع العدد

إذا اختلف النوع فإن بايثون ترقي النوع المشتمل إلى النوع الأشمل، وذلك بحسب ناتج العملية:

- جمع صحيح وعشري = عشري: `int + float = float`
- قسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): `int / int = float`
- **القسمة الصحيحة** بين صحيح وصحيح = صحيح: `int // int = int`

المثال الأول: جمع عدد صحيح وعدد عشري:

```{python}
a = 1 + 1.0
print(a)
assert type(a) == float
```

المثال الثاني: قسمة عدد صحيح على عدد عشري:

```{python}
c = 1 / 2
print(c)
assert type(c) == float
```

المثال الثالث: استعمال القسمة الصحيحة `//`:

```{python}
b = 1 // 2
print(b)
assert type(b) == int
```

## الفرق بين النوع العددي والنوع النصي للعدد

تأمل المتغيرين

```{python}
a = 50
b = '50'
```

- الأول: عدد صحيح (`int`)
- الثاني: حرفان (`str`)

نستعمل جمل التوكيد لبيان ذلك:

```{python}
assert not (a == b)
assert type(a) != type(b)
assert type(a) == int
assert type(b) == str
```

ومقتضى ذلك: **امتناع عملية الجمع**: `a + b`

```{python}
#| error: true
'5' + 5
```

بل يجب التحويل أولاً باستعمال الدالة `int` التي تفسر الأحرف كعدد صحيح:

```{python}
a = 5
b = '5'

b = int(b)

assert a + b == 10
```

## خلاصة

عرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.

ننتقل الآن [لباب الشرط والتكرار](chapters/03_control_flow/a_conditions.qmd) حيث الجمل الشرطية والتعيين المشروط.