# الأصناف

تتخذ بايثون نموذجًا في البرمجة يسمى **البرمجة الشيئية**؛ بحيث تكون العناصر المسماة التي تقبل التخزين في متغيرات أشياء: فالرقم شيء، والنص شيء، والقائمة شيء، والمصفوفة شيء، وهلم جرا.

و**الشيء** ما تُسند إليه:

1. المتغيرات وتسمَّى: **صفات**
2. الإجراءات وتسمَّى: **أفعال**

أما **الحروف** نحو: `+`, `=`, `.`, `[ ]`, `for`, `in` فهي واسطة **لأفعال مخصصة** ويُرمزُ لتعريفها بشرطتين سفليتين مثل:

- الجمع فعله المخصص `__add__`
- والإشارة مع التعيين نحو  (`s[i] = x`)، فعلها المخصص: `(index, value)__setitem__` 

وكلُّ شيءٍ له **صنف** أو أكثر بحسب الاعتبار. فنقول إن **المتسلسلة** (Sequence) نوع من **المجموعة** (Collection) باعتبارات ثلاث (انظر: خريطة المجموعات @fig-collections-tree):

1. كونها تقبل العضويَّة: `x in s` وفعلها هو: `__contains__`
2. كونها تقبل التكرار: `for x in s` وفعلها هو: `__iter__` 
3. كونها تقبل العد: `len(s)` وفعلها هو: `__len__`

ومن وجهٍ آخر فهي (المتسلسلة) تعتبر من صنف **القابل للعكس** (Reversible) لكونها تقبل الإجراء `reversed` الذي فعله: `__reversed__`.

## تعريف الإجراء

يُعرَّف الإجراء بالكلمة `class` ويُبتدأُ غالبًا بتعريف إجراء الإنشاء `__init__` ليتم تعيين الصفات فيه بالإسناد للاسم `self` الذي يشير إلى الشيء المعين من هذا النوع.

أما تعريف الأفعال فكالإجراءات مثل `def move` بزيادة `self` في الابتداء.

تأمل المثال:
```{python}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
```

والآن نستطيع إنشاء معيَّنات من هذا الصنف ونمرر القيم `x, y` بحسب ما هو موجود في [الإجراء المخصص للإنشاء: `__init__`](https://docs.python.org/3/reference/datamodel.html#object.__init__) على النحو التالي:

```{python}
p1 = Point(3, 4)
p2 = Point(7, 1)
```

نستعمل حرف النقطة `.`  بعد اسم المعيَّن للإشارة لصفةٍ أو فعل:

```{python}
x_diff = abs(p1.x - p2.x)
y_diff = abs(p1.y - p2.y)
print(f"The difference between the x-coordinates is {x_diff} and between the y-coordinates is {y_diff}.")
```

وهذا مثال لاستدعاء الفعل:

```{python}
p1.move(4, 4)
print(p1.x, p1.y)
```

لو أردنا طباعة النقطة، كيف تظهر؟

```{python}
print(p1)
```

لتخصيص طريقة عرض الشيء، بحيث لو طبعناه أو ذكرناه في آخر السطر يظهر البشكل الذي نريده، يمكن تغيير الإجراء المخصص `__repr__` (Representation) أي: التمثيل .. هكذا:

```{python}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
```

والآن إن عرفنا نقطة جديدة، ووضعناها على السطر لوحدها ، ستظهر لنا الإحداثيات، لا عنوانها الذاكري:

```{python}
p = Point(3, 4)
p.move(7, 6)
p
```

**الإجراء الثابت** هو ما يُسنَدُ للصنف نفسه لا للأعيان. ويتم تثبيت الإجراء بعلامة **المزيِّن** `@staticmethod`. لاحظ عدم وجود `self` في الإجراء الجديد `distance` لأنه ثابت:

```{python}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
				
    @staticmethod
    def distance(p1, p2):
        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5
```

ويتم استدعاؤه بذكر اسم الصنف والنقطة `.`:

```{python}
a = Point(0, 1)
b = Point(1, 0)

Point.distance(a, b)
```

كذلك يُجعل المتغير من النوع الثابت بتعيينه بمحاذاة غيره من الإجراءات نحو ما فعلنا هنا بالمتغير `distance_type`. ولاحظ استعماله في الإجراء `distance` في جملة `if-else` من غير استعمال `self` لأننا لا نشير إلى معيَّن:

```{python}
class Point:
    distance_type = 'euclidean'

    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    @staticmethod
    def distance(p1, p2):
        if Point.distance_type == 'euclidean':
            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5
        elif Point.distance_type == 'manhattan':
            return abs(p1.x - p2.x) + abs(p1.y - p2.y)
```

ماذا عن العمليات التي تكون بين الأشياء من نفس النوع، وتكون مثل الجمع والطرح والضرب والقسمة ونحوها؟ (انظر [توثيق بايثون لمحاكاة العمليات الرقمية](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types)). في هذا المثال إضافتان:

1. تطبيق عملية الجمع المخصصة بالإجراء `__add__`
2. تطبيق عملية الطرح المخصصة بالإجراء `__sub__`

```{python}
class Point:
    distance_type = 'euclidean'

    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    @staticmethod
    def distance(p1, p2):
        if Point.distance_type == 'euclidean':
            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5
        elif Point.distance_type == 'manhattan':
            return abs(p1.x - p2.x) + abs(p1.y - p2.y)
    
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Point(self.x - other.x, self.y - other.y)
```

تبحث بايثون عن `__add__` كلما وجدت علامة الجمع `+`، وكذلك تبحث عن `__sub__` كلما وجدت علامة الطرح `-`. فلنجرب الآن. لاحظ أن نتيجة الجمع نقطة جديدة، وكذلك نتيجة الطرح.

```{python}
p1 = Point(0, 1)
p2 = Point(1, 0)
print(p1 + p2)
print(p1 - p2)
```

في الجزء التالي ننظر في التركيب والتخصيص.
