# الوقاية والعلاج

::: {.callout-tip}
خشيةً الإملال أقول لعلك تعود بعد بناء برنامجٍ أو اثنين لهذه المقالة لأنها مفصَّلة إلى حدٍّ لم نصل إليه بعد (لكني أبقيتها هنا لاتصالها بالباب). فإن علمت من نفسك قدرةً فأهلا.
:::

تصوَّر أن البرنامج سلسلة من الإجراءات بحيث يختص كل فعل بمهمة معيَّنة (بناءً على مدخلاته يُعطي مخرجاته) فإننا نتعمَّد أن يكون وعيُه محدودًا بمدخلاته حتى نقلل من تشابك قطع النص البرمجي حتى نيسِّر على أنفسنا التحقق من صحَّة المنطق. وهذه فكرة **ظرف التنفيذ** الذي سبق الحديث عنها في [باب الإجراء](../04_functions/a1_functions.qmd).

فللخطأ حالتان -لا غير- في علاقتها مع من يتعامل معه:

1. **يستوعبه السياق**: أن يكون في وعي الإجراء (الظرف) ما يمكن به معالجته
2. **لا يستوعبه السياق**: ألا يكون كذلك فيرفعه (يرجع به) للإجراء المستدعي له (الذي هو أكثرُ وَعيًا منه) ليعالجه
	- وهذا يتسلسل حتى يصل إلى الإنسان (سواءً المستفيد أو المبرمج): برسالة تفيد في العثور عليه والتعامل معه.

ومنشؤ الخطأ أحد أمرين:

1. **خطأ مرفوع**: تم رفعه من فعل مستدعى في السياق الحالي. 
2. **خطأ جديد**: تم اكتشاف حالة تتوقف تكملة الإجراء على إصلاحها.

وللتعامل مع الخطأ حين يستوعبه السياق طريقتان:

1. **الوقاية**: توقُّع حالات الخطأ والتحقق من عدمها قبل الإقدام على العملية.
2. **العلاج**: ترك العملية لترجع بالخطأ؛ ثم نتعامل معه بحسبه.

## الفرق بين الوقاية والعلاج

هذا الإجراء مسؤول عن تهيئة البرنامج، ومن خطواته أنه يقرأ ملف الضبط المخصص `custom_config.json`. وفي هذه الحالة قد يحصل خطأ. إذْ قد لا يكون الملف موجودًا أصلا!

```python
def initialize_program():
    # ... code before
    file = open('custom_config.json')
    # ... code after
```

ففي هذه الحالة يحصل استثناء من نوع `FileNotFoundError`.

فإذا اخترنا طريق **الوقاية** فإننا أولاً نلتمس وجوده قبل فتحه. ونتعامل مع حالة الخطأ هذه (أي: عدمه)، بأن -مثلاً- نقرأ ملف الضبط الافتراضي `default.json` بدلاً من الملف المطلوب. والفرق بين هذا الملف والذي قبله أننا موقنون بوجوده، والأوَّل وجوده مظنون إذْ الذي يضعه هو المستخدم.

```python
def initialize_program():
    # ... code before
    if os.path.exists('custom_config.json'):
        file = open('custom_config.json')
    else:
        file = open('default.json')
    # ... code after
```

وقد تقول، حسنًا ماذا يكون لو عُدم ملف `default.json` أيضًا؟ فنقول: لا بأس أن يحصل خطأ يوقف البرنامج. إذْ ذاك يعتبر خطأ منطقيًّا يجب إصلاحه بإضافة الملف، وليس ثمة مجال لأن يصلحه النص البرمجي بنفسه.

أما **العلاج** فيكون بجملة `try-except` على النحو التالي:

```python
def initialize_program():
    # ... code before
    try:
        file = open('custom_config.json')
    except FileNotFoundError:
        file = open('default.json')
    # ... code after
```

أما استعمال الوقاية ففيه شك بوجود **فجوة زمنية** بين عملية التحقق من وجود الملف وبين قراءته. فالحاسب تتوارد عليه البرمجيات، ولا يستأثر به برنامج واحد. فإذا تغيَّر الحال في هذه الفجوة الزمنية وعاد بالنقض على التحقق بعد حصوله انتفت الفائدة منه. لذا **فالعلاج أضمن**.

ولا نستطيع أن نقول أن "الوقاية خير من العلاج"، بل بحسب الحالة يختار المبرمج الأفضل.

### الحالة الأولى: أن يستوعبه السياق

#### فإن كان خطأ جديدًا

مثاله ما لو لم تكن أحد الصفات محددة، فيمكن تعيينها بقيمة ابتدائية، ولا يلزمنا تصعيد الخطأ:

```python
def save_user(user: dict):
    if 'language' not in user:
        user['language'] = 'ar'
    # ... rest of the code
    save_to_database(user)
```

#### وإن كان خطًا مرفوعًا

وقد مثلنا له بفتح الملف، ونمثل له بمثال آخر:

```{python}
def get_user_guess() -> int:
    print('Please enter a number')
    guess = input()
    try:
        guess = int(guess)
    except ValueError:
        print(f'The value "{guess}" is not a number')
        guess = get_user_guess() # recursive call
    return guess
```

### الحالة الثانية: ألا يستوعبه السياق

#### فإن كان خطأ جديدًا

في هذا المثال يجب أن تكون الوحدة إحدى القيم المسموحة: `C` أو `F`. وإلا فلا حيلة للإجراء أن يتم وظيفته. لذا نرفع خطأ جديدًا بجملة `raise`.

```python
def convert_temperature(value: float, unit: str) -> float:
    if unit not in {'C', 'F'}:
        raise ValueError(f"Invalid unit: {unit}")
    
    if unit == 'C':
        return value * 9/5 + 32
    elif unit == 'F':
        return (value - 32) * 5/9
```

#### وإن كان خطًا مرفوعًا

ففي هذا المثال عملية قسمة قد يحصل فيها قسمة على صفر في `(a / b)`، فيرتفع خطأ اسمه `ZeroDivisionError` من تلك العملية. والحقيقة أننا في هذا السياق ليس لنا أن نعدِّل الرقم، بل نريد لمن استدعى الإجراء أن يعلم بالخطأ، ولسنا نريد إضافة معلومة أخرى فوق ذلك. لذا نسكت عنه (أي: لا نضع `try-except`) وهذا يجعله ينتقل مباشرة للإجراء المستدعي.

```python
def divide_lists(list1: list, list2: list) -> list:
    result = []
    for a, b in zip(list1, list2):
        result.append(a / b)
    return result
```

فإن من الأخطاء ما **يتعذر على البرنامج معالجته بنفسه**:

- إذا كانت المشكلة بامتلاء الذاكرة في الجهاز؛ فإن البرنامج ليس له إلا أن يخرج برسالة للمستخدم أو المسؤول عن الجهاز .. وليس للبرنامج أن يمسح بيانات المستخدم!
- أما إذا كانت المشكلة في تأخر الإجابة من الخادم مثلاً، فقد نعيد المحاول مرة أخرى بعد ثوانٍ، ونعيدها لعددٍ محدد من المرات، أملاً في الحصول على إجابة. ثم بعد ذلك لا يمكن إلا أن نظهر رسالة خطأ إن نفدت جميع المحاولات.

## إلتقاط جميع الأخطاء

من الخطأ في المنطق البرمجي إلتقاط جميع الأخطاء في الإجراءات باستعمال `except Exception` وهو النوع الشامل لجميع الأخطاء. فهذه الطريقة لا تخبرنا بنوع الخطأ وبالتالي لا نتعامل معه بحسبه، وإنما غاية ما تحقق هو منع تصعيد الخطأ لأعلى طبقة، إذْ حين يحصل ذلك توقف بايثون البرنامج (وعندها تظهر سلسلة الطلبات).

لكن يجوز ذلك في قطع النص البرمجي التي يُراد لها الاستمرار، وإن فشلَ شيئٌ فيها. مثلاً: لا تريد للخادم أن يتوقف تمامًا بمجرد حصول خطأ واحد في أحد خيوط التنفيذ الخاصة بخدمة أحد الطلبات. ففي مثل ذلك يسوغ استخدام `except Exception` الشاملة. انظر مثلاً [قطعة النص البرمجي في إطار الويب فلاسك المسؤول عن استقبال الطلبات](https://github.com/pallets/flask/blob/2fec0b206c6e83ea813ab26597e15c96fab08be7/src/flask/app.py#L893-L900).

## منظور آخر للخطأ

فائدة: لدينا طريقتان في التعامل مع الخطأ الواقعي، واختارت بايثون طريقة الاستثناء:

الأولى: **رفع قيمة الخطأ بالاسثناء**: لغات مثل C++ (1979)، Java (1998)، Python (1991) و JavaScript (1995) ترمي/ترفع الاستثناءات باستعمال عبارة مثلة `raise` أو عبارة `throw` على حسب اللغة. وتكون معالجة الخطأ بجملة `try-catch` أو `try-except`.

الثانية: **الرجوع بقيمة الخطأ**: اللغات الحديثة مثل Go (2009) و Rust (2015) ببساطة تعيد الخطأ كشيء (قيمة) عند حدوثه باستعمال جملة `return` التي في الإجراء. وتكون معالجة الخطأ بجملة شرطية عاديَّة نحو: `if error == error_type`

وبعض اللغات مثل: C (1978) وكذلك C++ (1985) تخلط بين النوعين!


----

**المراجع**:

- Miguel Grinberg: [The Ultimate Guide to Error Handling in Python](https://blog.miguelgrinberg.com/post/the-ultimate-guide-to-error-handling-in-python)
