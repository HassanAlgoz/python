---
og:title: sequences
---

# التسلسل

![تسلسل أحرف](../../assets/sequence.png)

كثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، ...إلخ من العمليات التي تعمل على جميع عناصر المجموعة.

## الجمع (`Collection`)

**الجمع** ([`Collection`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection)) ضد **المفرد** (Atomic). وهو ما يقبل الإجراءات التالية:

::: {.callout-note}
نرمز للمفرد بـ`x` ولما يدل على الجمع بـ`c`.
:::

-   العضوية: `x not in c`
-   العد: `len(c)`
-   التكرار: `for x in c`

انظر خريطة الجموع @fig-collections-tree حيث يتبين أنه مكون من ثلاثة:

-   الحاوي: `Container` (لقبوله العضوية)
-   ذو الحجم: `Sized` (لقبوله العد)
-   المكرر: `Iterable` (لقبوله التكرار)

ويتفرع منه ثلاثة:

-   التسلسل: `Sequence`
-   المجموعة: `Set`
-   الدالة: `Mapping`

فالأول موضوع هذا الباب، والآخران في الباب التالي إن شاء الله.

## التسلسل (`Sequence`)

**التسلسل** ([`Sequence`](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)) جمع مرتب من الأشياء.

- **جمع**: يعني قبوله الإجراءات الثلاثة السابق ذكرها (العضوية والعد والتكرار).
- **مرتب**: يعني أن لكل عنصرٍ موضعًا بالنسبة لبدايته. 

ويبدأ ترقيم المواضع بالنسبة لبداية التسلسل
لذلك نجعل للعنصر الأوَّل الموضِع `0`، إذ نسبةُ ذلك لبداية التسلسل. ويكون موضع الثاني `1` بالنسبة لبداية التسلسل، وللثالث `2`، وهكذا إلخ.

ومن أمثلة المجموعات المرتبة:

-   قائمة الرسائل، إذ هي مرتبة بالوقت واحدة تتلو الأخرى
-   مجموعة الحروف في اللغة العربية، إذ تبدأ بالألف وتنتهي بالياء وما بينهما كلٌّ له ما قبله وما بعده
-   قائمة الانتظار التي تعطي الأولويَّة لمن يأتي أوَّلاً للدخول على الطبيب

والمشترك في هذه الأمثلة الثلاثة: أن العناصر لها موضِعٌ بالنسبة لبعضها (مرتَّبة).

والأنواع الأربعة التي من جنس التسلسل هي:

1.  **القائمة** ([`list`](https://docs.python.org/3/library/stdtypes.html#list)) ويُعبَّرُ عنه بالقوسين المربعين `[]`.
2.  **الصف** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)) ويُعبَّرُ عنه بالقوسين الهلاليين `()`.
3.  **المجال** ([`range`](https://docs.python.org/3/library/stdtypes.html#range)) ويُعبَّرُ عنه بالإجراء المنشئ `range()`.
4.  **النص** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) ويُعبَّرُ عنه بالتنصيص المفرد `''` أو المزدوج `""`

<div class="ltr">

```{mermaid}
%% | label: fig-sequences
%% | fig-cap: شجرة أنواع التسلسل
flowchart TD
    Collection[<b>الجمع</b> <br> <code>Collection</code>]
    Collection --> Sequence[<b>التسلسل</b> <br> <code>Sequence</code>]
    Sequence --> MutableSequence[<b>التسلسل المتغير</b> <br> <code>MutableSequence</code>]
    MutableSequence --> list[<b>القائمة</b> <br> <code>list</code>]
    Sequence --> tuple[<b>الصف</b> <br> <code>tuple</code>]
    Sequence --> range[<b>المجال</b> <br> <code>range</code>]
    Sequence --> str[<b>النص</b> <br> <code>str</code>]
```

</div>

وراجع خريطة المجموعات: @fig-collections-tree


فهذه الأربعة تقبل الإجراءات التالية (المتغير `s` هو التسلسل هنا):

-   الإشارة:
    -   بالموضع: `s[i]`
    -   بالقطعة: `s[i:j]`
    -   بالقطعة مع خطوة: `s[i:j:k]`
-   معرفة موضع شيء (إن وجد): `s.index(x)`
-   عد تكرارات شيء: `s.count(x)`
-   البحث عن الأصغر والأكبر: `min(s)` و `max(s)`

وتقبل من إجراءات الإنشاء:

-   الدمج: `s1 + s2`
-   التكرار: `s * n`

أما تخصيص حرف `+` للدمج (لا للجمع) ، وحرف `*` للتكرار (لا للضرب)؛ فسيأتي معنا -إن شاء الله- في فصل تعريف الإجراءات المخصوصة في [باب الأنواع](../12_oop/a1_objects.qmd).

## الصف (`tuple`)

[**الصف**](https://docs.python.org/3/library/stdtypes.html#tuple) تسلسل جامد.

**فالجامد** هو ما لا يقبل التغيير بعد إنشائه.

### الإنشاء

يكون إنشاء الصف بالقوسين الهلاليين `()` على النحو التالي:

- الفرد: `(x,)` وهو صف بعنصر واحد
- الزوج: `(x, y)` وهو صف بعنصرين
- الثلاثي: `(x, y, z)` وهو صف بثلاثة عناصر
- ...إلخ.

ولا يشترط **تجانس العناصر**؛ بل يجوز أن تكون أنواعها مختلفة:

```{python}
s = (10, 20, 'hello', True, (300, 400))
print(s)
```

وقد يتألف الإنشاء بالتكرار بعلامة `*`:

```{python}
s = (10, 20) * 3
print(s)
```

أو الدمج، بعلامة `+`:

```{python}
s = (10, 20) + (30, 40)
print(s)
```

نستعرض هنا العضوية والعد والتكرار:

```{python}
s = (100, 200, 300)

assert 100 in s
assert 400 not in s
assert len(s) == 3

for x in s:
    print(x)
```

### الإشارة

تستعمل الإشارة الموضعية لقراءة عنصر من التسلسل.

```{python}
s = (10, 20, 30, 40, 50)
assert s[0] == 10
assert s[-1] == 50
assert s[len(s) // 2] == 30
```

```         
 0    1    2    3    4    5     
 +----+----+----+----+----+
 | 10 | 20 | 30 | 40 | 50 |
 +----+----+----+----+----+
-5   -4   -3   -2   -1
```

ويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل.

فهذا يفشل لأن المؤشر ليس رقمًا صحيحًا:

```{python}
#| error: true
s = (10, 20, 30, 40, 50)
s['3']
```

وكذلك هذا لأنه يتجاوز نطاق التسلسل (`0 - 4`):

```{python}
#| error: true
s = (10, 20, 30, 40, 50)
s[5]
```


شكل الإشارة بالقطعة (`slice`) على نحو: `s[start : end : step]`. والقيم الابتدائية عند الإغفال هي: `s[0:len(s):1]`.

```         
 0    1    2    3    4    5     
 +----+----+----+----+----+
 | 10 | 20 | 30 | 40 | 50 |
 +----+----+----+----+----+
-5   -4   -3   -2   -1
```

```{python}
s = (10, 20, 30, 40, 50)
assert s[1:3] == (20, 30)
assert s[::2] == (10, 30, 50)
assert s[::-1] == (50, 40, 30, 20, 10)
assert s[1:4:2] == (20, 40) == s[-4:-1:2]
assert s[1:4:2] == s[slice(1,4,2)] == (20, 40)
```

لاحظ استعمال الإجراء المنشئ `slice()` في الإشارة بالقطعة، وقد جعلت بايثون علامة `:` بديلاً عنه.

وإذا جعلته صفًّا من صفوف؛ صار مصفوفة:

```{python}
matrix = (
    (10, 20, 30),
    (40, 50, 60),
    (70, 80, 90)
)

assert matrix[0] == (10, 20, 30)
assert matrix[-1] == (70, 80, 90)
```

وتستعمل الإشارة مرتين للإشارة إلى العدد، مثلاً للإشارة إلى العنصر الثاني في الصف الثاني:

```{python}
assert matrix[1][1] == 50
```


```         
 0              1              2              3
 +--------------+--------------+--------------+
 | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |
 +--------------+--------------+--------------+
-3             -2             -1
```

الإشارة لعناصر الصف الواحد:

```         
 0    1    2    3
 +----+----+----+
 | 10 | 20 | 30 |
 +----+----+----+
-3   -2   -1
```

```         
 0    1    2    3 
 +----+----+----+
 | 40 | 50 | 60 |
 +----+----+----+
-3   -2   -1
```

```         
 0    1    2    3
 +----+----+----+
 | 70 | 80 | 90 |
 +----+----+----+
-3   -2   -1
```

عناصر نصوص:

```{python}
ss = ("Apple", "Banana", "Orange", "Lemon")
assert ss[1] == "Banana"
assert ss[-1][0] == "L"
```

```         
 0       1        2        3       4
 +-------+--------+--------+-------+
 | Apple | Banana | Orange | Lemon |
 +-------+--------+--------+-------+
-4      -3       -2       -1
```

الإشارة لصف الأحرف في النص الواحد:

```         
 0   1   2   3   4   5
 +---+---+---+---+---+
 | L | e | m | o | n |
 +---+---+---+---+---+
-5  -4  -3  -2  -1
```

وسيأتي التفصيل في [باب النص](../07_strings/a1_strings.qmd).

### البحث

البحث عن موضع العنصر (`s.index(x)`) وعد تكراره (`s.count(x)`):

```{python}
s = ('Python', 'Python', 'Go')
assert s.index('Go') == 2
assert s.count('Python') == 2
```

البحث عن الأصغر والأكبر:

```{python}
s = (30, 20, 40, 10, 50)
assert s.index(min(s)) == 3
assert s.index(max(s)) == 4
```

## القائمة (`list`)

**القائمة** ([`list`](https://docs.python.org/3/library/stdtypes.html#list)) تسلسل متغير.

انظر [MutableSequence](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence) في خريطة المجموعات: @fig-collections-tree.

### التغير

فالأنواع على قسمين من حيث قبول التغير بعد الإنشاء:

- **متغير** (Mutable: قابل للتغيير): يعني قبوله الإضافة والحذف والتعديل على عناصرها بعد الإنشاء.
- **جامد** (Immutable: غير قابل للتغيير): لا يقبل التغير. ومن جهة كونها عوامل للإجراء؛ فإن الجامد لا يقبل أن يكون محل عمل الإجراء.

::: {.callout-note}
التغير والجمود مفهومان يتكرران كثيرًا في البرمجة. للمزيد راجع: [بناء البرمجيات: الفصل التاسع، الجمود (MIT-6.005)](https://web.mit.edu/6.005/www/fa15/classes/09-immutability/){target="_blank"}
:::

[**التغير**](https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types) هي الخاصية التي تختلف فيها القائمة عن قسيماتها التسلسلية (الصف والمجال والنص). ومعناه قبولها الإجراءات التالية (نستعمل في المثال حرف `l` للقائمة):

-   الاستبدال:
    -   لموضع: `l[i] = x`
    -   لقطعة: `l[i:j] = t`
    -   لقطعة بخطوة: `l[i:j:k] = t`
-   الحذف:
    -   لموضع: `del l[i]`
    -   لقطعة: `del l[i:j]`
    -   لقطعة بخطوة: `del l[i:j:k]`
-   الإزالة: `l.remove(x)` لحذف أول ورود للعنصر
-   النزع: `l.pop([i])` أخذ العنصر من الموضع (مع حذفه من ذلك الموضع)
    -   إن لم يحدد الموضع: نزع الأخير. إذ القوسان `[i]` هنا في التعريف يعبران عن عامل اختياري وهو الموضع `i`
-   الإدراج: `l.insert(i, x)` لإضافة عنصر في موضع محدد
-   الإلحاق: `l.append(x)` لإضافة عنصر في النهاية
-   الترتيب: `l.sort()` أو بالإجراء المبني `sorted(l)`
-   العكس: `l.reverse()` أو بالإجراء المبني `reversed(l)`

لاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين الهلاليين `()`، إذْ هو جامد لا يقبل التغير:

```{python}
#| error: true
t = (10, 20, 30, 40, 50)
t[0] = 100
print(t)
```

لكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين `[]`، لأنها متغيرة:

```{python}
l = [10, 20, 30, 40, 50]
l[0] = 100
print(l)
```

الاستبدال بالموضع والحذف منه:

```{python}
l = [10, 20, 30, 40, 50]
l[0] = 100
assert l == [100, 20, 30, 40, 50]

del l[0]
assert 100 not in l
```

الاستبدال بالقطعة والحذف منها

```{python}
l = [10, 20, 30, 40, 50]
l[1:3] = [200, 300]
assert l == [10, 200, 300, 40, 50]

del l[1:3]
assert l == [10, 40, 50]
```

الإدراج:

```{python}
l = [10, 20, 30, 40, 50]
l.insert(1, 100)
assert l == [10, 100, 20, 30, 40, 50]
```

الإزالة:

```{python}
l = [10, 20, 30, 40, 50]
l.remove(20)
assert l == [10, 30, 40, 50]
```

الإلحاق:

```{python}
l = [10, 20, 30, 40, 50]
l.append(60)
assert l == [10, 20, 30, 40, 50, 60]
```

الترتيب والعكس:

```{python}
l = [30, 40, 10, 20, 50]
l.sort()
assert l == [10, 20, 30, 40, 50]

l.reverse()
assert l == [50, 40, 30, 20, 10]
```

نزع العنصر الأخير:

```{python}
l = [10, 20, 30, 40, 50]
x = l.pop()
assert x == 50
assert 50 not in l
```

## النطاق (`range`)

يمثل **النطاق** ([`range`](https://docs.python.org/3/library/functions.html#func-range){target="_blank"}) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فثلاثة عوامل تحدده:

1.  **البداية** (`start=0`):
    -   مشمولة
    -   قيمتها الابتدائية `0` (إذا أهملت)
2.  **النهاية** (`stop`):
    -   غير مشمولة
    -   وهي واجبة (إهمالها ممتنع)
3.  **الخطوة** (`step=1`):
    -   مقدار الزيادة أو النقص للعدد في كل كرة
    -   قيمتها الابتدائية `1` (إذا أهملت)

دعونا الآن نلقي نظرة على التعريف كما هو موجود في مراجع بايثون، وذلك لنتعلم كيف نقرؤ التعريف. [ادخل الرابط](https://docs.python.org/3/library/stdtypes.html#range) وتأمل معي ..

-   `class range(stop)`
-   `class range(start, stop[, step])`

أولا: تدل كلمة `class` على أنها معرَّفة كنوع، فيكون طلب الإجراء بنفس الاسم `range` للإنشاء.

ثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما يكون؟

نجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو `stop` وتأخذ البداية والخطوة قيمتهما الابتدائية: `start=0` و `step=1` حسب ما كُتب:

> If the step argument is omitted, it defaults to 1.
>
> If the start argument is omitted, it defaults to 0

```{python}
for i in range(5):
    print(i)
```

أما التعريف الثاني فيجب تفكيكه لنفهمه: `class range(start, stop[, step])`.

وجود الأقواس المربعة `[ ]` يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو `start, stop`؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الابتدائية `step=1`.

```{python}
for i in range(5, 10):
    print(i)
```

أما إذا عينت الثلاثة جميعًا فسيكون الأول `start` والثاني `stop` والثالث `step`:

```{python}
for i in range(0, 10, 2):
    print(i)
```

ولك أن تعكس النطاق بتعيين `step` بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:

```{python}
for i in range(10, 0, -1):
    print(i)
```

### التكرار والإشارة

```{python}
xs = [10, 20, 30, 40, 50, 60]
```

**ويُسرَد** التسلسل بكلمة `for`، على النحو التالي:

```{python}
for x in xs:
    print(x)
```

أو بسرد **النطاق** (حيث النهاية تكون: `len(xs)` أي: طول التسلسل) واستعمال **الإشارة بالموضع** (`xs[i]`)، نحو:

```{python}
for i in range(len(xs)):
    print(xs[i])
```

فهذا يفيد في التحكم في السرد، فلو أردنا كل عنصرٍ ثانٍ، نجعل الخطوة `2` ابتداء من العنصر الثاني `1`، فنكتبها هكذا:

```{python}
for i in range(1, len(xs), 2):
    print(xs[i])
```

أو أردنا قراءة الموضع والذي قبله، فهكذا:

```{python}
for i in range(1, len(xs), 2):
    print(xs[i-1], xs[i])
```

فإن جوَّزنا التداخل، جعلنا الخطوة `1`، هكذا:

```{python}
for i in range(1, len(xs), 1):
    print(xs[i-1], xs[i])
```

وهلم جرا..

### تأجيل النتيجة

ويجدر بالذكر أن **النطاق** لا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وهو كالصف لا يقبل التعديل.

نستعمل فعل الإنشاء `range()` لإنشاء **نطاق**:

```{python}
r = range(0, 20, 2)
r
```

فحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:

```{python}
print(11 in r)
print(10 in r)
```

كذلك الإجراء عند البحث عن موضع رقمٍ ما:

```{python}
print(r.index(10))
```

والإشارة لموضع ما أو قطعة كذلك:

```{python}
print(r[5])
print(r[:5])
print(r[-1])
```

### تحقيق النطاق

المولِّد لا تتحقق عناصره إلا عند الحاجة إليها؛ أي: عند قراءتها. فإذا جعلناه عاملاً في جملة الإنشاء `list`؛ تولَّدَت جميع عناصره ووُضِعَت في قائمة:

```{python}
evens = list(range(0, 10, 2))
odds = list(range(1, 10, 2))
print(evens)
print(odds)
```

## ضم التسلسلات المرتبطة (`zip`)

هذان تسلسلان مرتبطان:

```{python}
students = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']
marks = [90, 80, 75, 85, 95]

assert len(students) == len(marks)
```

ويُمكن ضمُّ السلسلتين بحيث ينتج في التكرار عُنصران في كل مرة؛ وذلك بفعل **الضم** [`zip()`](https://docs.python.org/3/library/functions.html#zip) الذي يُنتج **مُكَرَّرًا** -بفتح الراء- ([`Iterable`](https://docs.python.org/3/glossary.html#term-iterable)). فإذا ضممنا سلسلتين، خرج لنا في كل كرَّة زوج (`x, y`):

```{python}
for x, y in zip(students, marks):
    print(x, y)
```

```{mermaid}
flowchart LR
    students --> zip
    marks --> zip
    zip --> for
    for --> x
    for --> y
```

### ضم المكررات

ولاحظ فيما يلي أن:

-   نوع `students` قائمة (`list`)
-   ونوع `marks` نطاق (`range`)
-   ونوع `classes` صف (`tuple`)

ومع ذلك فإنه يجوز ضمُّها لأن الإجراء يقبلُ كُل ما هو مُكَرَّر:

```{python}
students = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']
marks = range(75, 95+1, 5)
classes = ('A-1', 'A-1', 'A-2', 'A-1', 'A-2')

assert list == type(students)
assert tuple == type(classes)
assert range == type(marks)

for x, y, z in zip(students, marks, classes):
    print(x, y, z)
```

### القراءة بالموضع المشترك

ويكون قراءة التسلسلات المرتبطة أيضًا بسرد مُكَرَّر النطاق، والإشارة إلى كل عنصر بالموضع:

```{python}
for i in range(len(students)):
    x, y, z = students[i], marks[i], classes[i]
    print(x, y, z)
```

## الإنشاء المختصر: الجملة الثلاثية

مما تميزت به لغة بايثون عن غيرها: [**مختصرة الإنشاء**](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) (Comprehension)؛ وهي جملة تُنشئ مجموعة مستمَدَّة من مكرر في ثلاث جُمَل في سطرٍ واحدٍ -غالبًا- ووظيفتها: **إنشاء مجموعة مستمَدَّة من مكرر**.

وليسَت زيادتها في اللغة من باب الضرورة وإنما من باب التحسين. إذْ فيها قوة في التعبير عن جمل كثيرة في مساحة صغيرة. فهذا المثال يعبر عن إنشاء قائمة كل عنصرٍ فيها مربَّعٌ من المكرر `range(10)` في سطرٍ واحد:

```{python}
squares = [x ** 2 for x in range(10)]
squares
```

فهي جملة إنشاء مركَّبة من ثلاث جمل:

1.  **تعبير** (`x ** 2`) ، الذي يشتمل غالبًا على متغير التكرار (`x`)
2.  **تكرار**: (`for x in range(10)`)
3.  و**شرط**: والشرطُ ليسَ بشرط؛ لذا جاز إهماله في هذا المثال

فهي مكافئة للقطعة التالية:

```{python}
squares = []
for x in range(10):
    squares.append(x ** 2)
squares
```

ولو أردنا ترشيح الأعداد الزوجية من قائمة، نستطيع استعمال **جملة الشرط** في الاختصار على النحو التالي:

```{python}
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
evens = [x for x in numbers if x % 2 == 0]
evens
```

1.  التعبير: (`x`) فقط
2.  التكرار: (`for x in numbers`)، وتذكر أن القائمة مُكرَّر
3.  الشرط: (`if x % 2 == 0`)

وهي مكافئة للقطعة التالية:

```{python}
evens = []
for x in numbers:
    if x % 2 == 0:
        evens.append(x)
evens
```

وأما القوسان المربعان `[ ]` -في كلا المثالين- فلإنشاء قائمة. وبحسب ما يُراد إنشاؤه تختلف الأقواس:

-   `[expression for item in iterable if condition]` للقائمة (`list`)
-   `(expression for item in iterable if condition)` للمولِّد ([Generator](https://docs.python.org/3.13/tutorial/classes.html#generator-expressions))
-   `{expression for item in iterable if condition}` لمجموعة الفرائد (`set`) وسيأتي الكلام عنها في الباب القادم
-   `{expression: expression for item in iterable if condition}` للقاموس (`dict`) وسيأتي الكلام عنه في الباب القادم
