# المجموعة المرتبة

كثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، ...إلخ من العمليات التي تعمل على جميع عناصر المجموعة.

وكل ما هو من جنس **المجموعة** (`Collection`) فإنه يقبل الأفعال التالية:

- العضوية: `x not in s`
- العد: `len(s)`
- التكرار: `for x in s`

انظر [Collection](https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection) في خريطة المجموعات: @fig-collections-tree.

## التسلسل

**التسلسل** ([`Sequence`](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)) هو أي مجموعة مرتبة من الأشياء.

- قولنا (**مجموعة**) يعني قبوله الأفعال الثلاثة السابق ذكرها.
- قولنا (**مرتبة**) يعني أن لكل عنصر موضعًا فيها، وله ما قبله وما بعده.

وسوف نرمز للمفرد بـ`x` ولما يدل على التسلسل بـ`s`.

والأنواع الأربعة التي من جنس التسلسل هي:

1. **القائمة** ([`list`](https://docs.python.org/3/library/stdtypes.html#list)) ويُعبَّرُ عنه بالقوسين المربعين `[]`.
2. **الصف** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)) ويُعبَّرُ عنه بالقوسين المنحنيين `()`.
3. **المجال** ([`range`](https://docs.python.org/3/library/stdtypes.html#range)) ويُعبَّرُ عنه بالإجراء المنشئ `range()`.
4. **النص** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) ويُعبَّرُ عنه بالتنصيص المفرد `''` أو المزدوج `""`.

فهذه الأربعة تقبل الأفعال التالية:

- الإشارة:
    - بالموضع: `s[i]`
    - بالقطعة: `s[i:j]`
    - بالقطعة مع خطوة: `s[i:j:k]`
- معرفة موضع شيء (إن وجد): `s.index(x)`
- عد تكرارات شيء: `s.count(x)`
- البحث عن الأصغر والأكبر: `min(s)` و `max(s)`

وتقبل من أفعال الإنشاء:

- الدمج: `s1 + s2`
- التكرار: `s * n`

ومن هذه الأنواع **المتغير**، ومنها ما لا يقبل التغير وهو **الجامد**؛ وسيأتي بيانه في موضعه -إن شاء الله-.

### الإنشاء

- ينشأ الصف بوضع العناصر بين القوسين المنحنيين `()` أو باستعمال الإجراء المنشئ [`tuple()`](https://docs.python.org/3/library/stdtypes.html#tuple)
- تنشأ القائمة بوضع العناصر بين القوسين المربعين `[]` أو باستعمال الإجراء المنشئ [`list()`](https://docs.python.org/3/library/stdtypes.html#list)

```{python}
s = (10, 20, 30) + (40, 50)
s = s * 2
print(s)
```

ويقبل إنشاء مجموعة من العناصر مختلفة النوع، بما في ذلك القائمة والصف كعنصر:

```{python}
s = (10, 'A', 2.0, True, ['B', 30])
print(s)
```

نستعرض هنا العضوية والعد والتكرار

```{python}
s = [100, 200, 300]

assert 100 in s
assert 400 not in s
assert len(s) == 3

for x in s:
    print(x)
```


### الإشارة

تستعمل الإشارة الموضعية لقراءة عنصر من التسلسل. ويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل على النحو التالي:

```{python}
s = [10, 20, 30, 40, 50]
assert s[0] == 10
assert s[-1] == 50
assert s[len(s) // 2] == 30
```

```
 0    1    2    3    4    5     
 +----+----+----+----+----+
 | 10 | 20 | 30 | 40 | 50 |
 +----+----+----+----+----+
-5   -4   -3   -2   -1
```

شكل الإشارة بالقطعة على نحو: `s[start : end : step]`. والقيم الافتراضية عند الإغفال هي: `s[0:len(s):1]`.

```{python}
s = [10, 20, 30, 40, 50]
assert s[1:3] == [20, 30]
assert s[::2] == [10, 30, 50]
assert s[::-1] == [50, 40, 30, 20, 10]
assert s[1:4:2] == [20, 40] == s[-4:-1:2]
assert s[1:4:2] == s[slice(1,4,2)] == [20, 40]
```

لاحظت استعمال الإجراء المنشئ `slice()` في الإشارة بالقطعة، وقد جعلت بايثون علامة `:` بديلاً عنه.

وجاز للعنصر الواحد أن يكون مجموعة؛ ومثاله المصفوفة (صفٌّ من صفوف):

```{python}
matrix = (
    (10, 20, 30),
    (40, 50, 60),
    (70, 80, 90)
)

assert matrix[0] == (10, 20, 30)
assert matrix[-1] == (70, 80, 90)
assert matrix[1][1] == 50
```

```
 0              1              2               
 +--------------+--------------+--------------+
 | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |
 +--------------+--------------+--------------+
-3             -2             -1
```

الإشارة لعناصر الصف الواحد:

```
 0    1    2            
 +----+----+----+
 | 10 | 20 | 30 |
 +----+----+----+
-3   -2   -1
```

```
 0    1    2            
 +----+----+----+
 | 40 | 50 | 60 |
 +----+----+----+
-3   -2   -1
```

```
 0    1    2            
 +----+----+----+
 | 70 | 80 | 90 |
 +----+----+----+
-3   -2   -1
```

عناصر نصوص:

```{python}
ss = ["Apple", "Banana", "Orange", "Lemon"]
assert ss[1] == "Banana"
assert ss[-1][0] == "L"
```

```
 0       1        2        3       4
 +-------+--------+--------+-------+
 | Apple | Banana | Orange | Lemon |
 +-------+--------+--------+-------+
-4      -3       -2       -1
```

الإشارة لصف الأحرف في النص الواحد:

```
 0   1   2   3   4
 +---+---+---+---+---+
 | L | e | m | o | n |
 +---+---+---+---+---+
-5  -4  -3  -2  -1
```

وسيأتي التفصيل في [باب النص](../07_string/a1_strings.qmd).

### البحث

```{python}
s = ('A', 'B', 'A')
assert s.index('B') == 1
assert s.count('A') == 2
```

```{python}
s = (30, 20, 40, 10, 50)
assert min(s) == 10
assert max(s) == 50
```

## القائمة

**القائمة** ([`list`](https://docs.python.org/3/library/stdtypes.html#list)) تسلسل متغير. وهذا يعني:

- قولنا (**متغيرة**) يعني أنها تقبل الإضافة والحذف والتعديل على عناصرها
- قولنا (**مرتبة**) يعني أن لكل عنصر موضعًا فيها، وله ما قبله وما بعده.
    - ويترتب عليه قبولها الإشارة بالموضع `i` أو بالقطعة `[i:j]` أو بالقطعة بالخطوة `[i:j:k]`

انظر [MutableSequence](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence) في خريطة المجموعات: @fig-collections-tree.

### التغير

[**التغير**](https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types) هي الخاصية التي تختلف فيها القائمة عن  قسيماتها التسلسلية. ومعناه قبولها الأفعال التالية (نستعمل في المثال حرف `l` للقائمة):

- الاستبدال:
    - لموضع: `l[i] = x`
    - لقطعة: `l[i:j] = t`
    - لقطعة بخطوة: `l[i:j:k] = t`
- الحذف:
    - لموضع: `del l[i]`
    - لقطعة: `del l[i:j]`
    - لقطعة بخطوة: `del l[i:j:k]`
- الإزالة: `l.remove(x)` لحذف أول ورود للعنصر
- النزع: `l.pop([i])` حذف العنصر من الموضع وإرجاعه
    - إن لم يحدد الموضع: نزع الأخير. إذ القوسان `[i]` هنا في التعريف يعبران عن عامل اختياري وهو الموضع `i`
- الإدراج: `l.insert(i, x)` لإضافة عنصر في موضع محدد
- الإلحاق: `l.append(x)` لإضافة عنصر في النهاية
- الترتيب: `l.sort()` أو بالإجراء المدمج `sorted(l)`
- العكس: `l.reverse()` أو بالإجراء المدمج `reversed(l)`

لاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين المنحنيين `()`:

```{python}
#| error: true
t = (10, 20, 30, 40, 50)
t[0] = 100
print(t)
```

لكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين `[]`:

```{python}
l = [10, 20, 30, 40, 50]
l[0] = 100
print(l)
```

الاستبدال بالموضع والحذف منه:

```{python}
l = [10, 20, 30, 40, 50]
l[0] = 100
assert l == [100, 20, 30, 40, 50]

del l[0]
assert 100 not in l
```

الاستبدال بالقطعة والحذف منها

```{python}
l = [10, 20, 30, 40, 50]
l[1:3] = [200, 300]
assert l == [10, 200, 300, 40, 50]

del l[1:3]
assert l == [10, 40, 50]
```

الإدراج:

```{python}
l = [10, 20, 30, 40, 50]
l.insert(1, 100)
assert l == [10, 100, 20, 30, 40, 50]
```

الإزالة:

```{python}
l = [10, 20, 30, 40, 50]
l.remove(20)
assert l == [10, 30, 40, 50]
```

الإلحاق:

```{python}
l = [10, 20, 30, 40, 50]
l.append(60)
assert l == [10, 20, 30, 40, 50, 60]
```

الترتيب والعكس:

```{python}
l = [30, 40, 10, 20, 50]
l.sort()
assert l == [10, 20, 30, 40, 50]

l.reverse()
assert l == [50, 40, 30, 20, 10]
```

نزع العنصر الأخير وإرجاعه:

```{python}
l = [10, 20, 30, 40, 50]
x = l.pop()
assert x == 50
assert 50 not in l
```

## التسلسلات المرتبطة

هذان تسلسلان مرتبطان:

```{python}
students = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']
marks = [90, 80, 75, 85, 95]

assert len(students) == len(marks)
```

لو أردنا أن نمر على التسلسلين في نفس الوقت نستعمل الإجراء المدمج `zip()` الذي يظل يولد صفًا عناصره من كل تسلسل:

```{python}
for x, y in zip(students, marks):
    print(x, y)
```


## النطاق

يمثل **النطاق** ([`range`](https://docs.python.org/3/library/functions.html#func-range)) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فهي ثلاثة عوامل تحدده:

1. **البداية** (`start`): مشمول ، وقيمته الافتراضية `0`.
2. **النهاية** (`stop`): غير مشمول ، وتم تعريف النطاق بحيث لا يُمكن إهمال النهاية.
3. **الخطوة** (`step`): مقدار الزيادة أو النقص للعدد التالي ، وقيمته الافتراضية `1` (أي: الزيادة بواحد).

دعونا الآن نلقي نظرة على التعريف كما هو موجود في وثائق بايثون، وذلك لنتعلم كيف نقرؤ التعريف. [ادخل الرابط](https://docs.python.org/3/library/stdtypes.html#range) وتأمل معي ..

- `class range(stop)`
- `class range(start, stop[, step])`

أولاً: نلاحظ كلمة `class` في الابتداء وهذا يعني أنه صِنف وليس إجراءً.

ثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما تعمل به بايثون؟

نجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو `stop` وتأخذ البداية والخطوة فيمتهما الافتراضية: `start=0` و `step=1` حسب ما كُتب:

> If the step argument is omitted, it defaults to 1.
>
> If the start argument is omitted, it defaults to 0

```{python}
for i in range(5):
    print(i)
```

أما التعريف الثاني فيجب تفكيكه لنفهمه:  `class range(start, stop[, step])`.

وجود الأقواس المربعة `[ ]` يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو `start, stop`؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الافتراضية `step=1`.

```{python}
for i in range(5, 10):
    print(i)
```

أما إذا عينت الثلاثة جميعًا فسيكون الأول `start` والثاني `stop` والثالث `step`:

```{python}
for i in range(0, 10, 2):
    print(i)
```

ولك أن تعكس النطاق بتعيين `step` بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:

```{python}
for i in range(10, 0, -1):
    print(i)
```

### التكرار والإشارة

يستعمل النطاق في التكرار على متواليات هكذا:

```{python}
xs = [10, 20, 30, 40, 50]
for i in range(len(xs)):
    print(xs[i])
```

ففي كل مرة يشير `i` للموضع التالي في المتوالية، ويستعمل في معامل الإشارة `xs[i]` لقراءة العنصر.

### تأجيل النتيجة

ويجدر بالذكر أن **النطاق** لا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وهو كالصف لا يقبل التعديل.

نستعمل إجراء الإنشاء `range()` لإنشاء نطاق:

```{python}
r = range(0, 20, 2)
r
```

فحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:

```{python}
print(11 in r)
print(10 in r)
```

كذلك الأمر عند البحث عن موضع رقمٍ ما:

```{python}
print(r.index(10))
```

والإشارة لموضع ما أو قطعة كذلك:

```{python}
print(r[5])
print(r[:5])
print(r[-1])
```

### تحويل النطاق

بمجرد تحويل النطاق إلى نوعٍ متحقق (كالقائمة أو الصف) ؛ يتم توليد جميع الأرقام التي في النطاق حالًا. نستعمل التركيب: `list(range())` للإنشاء والتحويل:

```{python}
evens = list(range(0, 10, 2))
odds = list(range(1, 10, 2))
print(evens)
print(odds)
```


## الإنشاء المختصر: الجملة الثلاثية

مما تميزت به لغة بايثون عن غيرها: [**مختصرة الإنشاء**](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) (Comprehension)؛ وهي جملة تُنشئ مجموعة مستمَدَّة من متوالية في ثلاث جُمَل في سطرٍ واحدٍ (غالبًا). فالمتوالية قد تكون قائمة أو مجموعة فريدة أو مجموعة روابط. ومن استخداماتها:

1. تحويل عناصر من المتوالية
2. ترشيح عناصر من متوالية

وليسَت زيادتها في اللغة من باب الضرورة وإنما من باب التحسين. إذْ فيها قوة في التعبير عن جمل كثيرة في مساحة صغيرة. فهي جملة مركَّبة من ثلاث جمل: **تعبير وتكرار وشرط** (والشرطُ ليسَ بشرطٍ). وبحسب ما يُراد إنشاؤه تختلف الأقواس: القائمة، ومجموعة الفرائدة والقاموس والمولِّد:

- `[expression for item in iterable if condition]` List
- `{expression for item in iterable if condition}` Set
- `{expression: expression for item in iterable if condition}` Dict
- `(expression for item in iterable if condition)` [Generator](https://docs.python.org/3.13/tutorial/classes.html#generator-expressions)

افترض أننا نريد حساب مربع كل عدد في قائمة، نستطيع كتابة ذلك المنطق بالشكل التالي:

```{python}
squares = []
for x in range(10):
    squares.append(x ** 2)
squares
```

إذا أردنا تفكيك ذلك فنقول: المُدخل قائمة، والمخرج قائمة. إذًا يمكن كتابة ذلك باختصار في سطرٍ واحد على النحو: قوس مربع متبوعًا بعبارة ناتجة متبوعًا بقطعة `for` وقد يكون متبوعًا بمرة أو أكثر من قطع `for` (للتكرار أكثر) أو `if` (للترشيح). وهذا مثال: 

```{python}
squares = [x ** 2 for x in range(10)]
```

لو أردنا ترشيح الأعداد الزوجية من القائمة، نستطيع استعمال قطعة `if` في الاختصار على النحو التالي:

```{python}
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
evens = [x for x in numbers if x % 2 == 0]
```

ندمج القطعتين (عبارة الناتج من التكرار مع قطعة التشريح `if`) لنحصل على مربع الأعداد الزوجية فقط:


```{python}
squared_evens = [x ** 2 for x in numbers if x % 2 == 0]
```

فهذه ثلاثة جمل:

1. جملة الناتج: `x ** 2`
2. جملة التكرار: `for x in numbers`
3. جملة الترشيح: `if x % 2 == 0`
