# مسارات المعالجة

## الفعل غير المسمى

**الفعل غير المسمى** (anonymous) هو فعل مُعرَّف بلا اسمٍ؛ ويكون تعريفه -في بايثون- بكلمة [`lambda`](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions) لا بكلمة `def`.
ولا يقبل إلا جملة واحدةً وتكونُ هي جُملة الرجوع (`return`).

وإضافته إلى اللغة ليس ضروريًّا لكنه من باب تعريف ما لن نحتاج إلا ذكره لاحقًا. وهو مستعملٌ بكثرة في البرمجة.

وطريقته على النحو التالي:

```python
lambda parameters: returned_expression
```

ونمثل له بما قد سبق تعريفه في الفعل داخل الفعل المنشئ `make_power` الذي كان شكله هكذا:

```{python}
def make_power(n):
    def power(x):
        return x ** n
    return power
```
فيمكننا أن نعرِّف الفعل الذي في الداخل بلا اسمٍ فنختصر العبارة هكذا:

```{python}
def make_power(n):
    return lambda x: x ** n
```
وهكذا يكون استعماله كما تقدَّم:

```{python}
square = make_power(2)
cube = make_power(3)

assert square(2) == 4
assert cube(2) == 8
```

## فعل التحويل `map`

**فعل التحويل** ([`map`](https://docs.python.org/3/library/functions.html#map)) يأخذُ فِعلاً ليطبِّقَهُ على مُكرَّر -بفتح الراء- أو أكثر (لوجود النجمة: `*`) ويُنتِجُ مُكرِّرًا -بكسر الراء- ([`Iterator`](https://docs.python.org/3/glossary.html#term-iterator)). وتعريفُه هكذا:

```python
map(function, iterable, *iterables) -> iterator
```

ووجب أن نعرف أن المُكرِّرَ -بكسر الراء- من جنس المُكرَّر -بكسرها-. 
ومرَّ معنا أن القائمة، والصف، والقاموس، والنص كل ذلك من جنس المُكرَّر. وقد تقدَّم أنها مما يقبل التكرار.

راجع شجرة الجموع في الملحق: @fig-collections-tree.

```{mermaid}
flowchart TD
    Iterable --> Collection
    Iterable --> Iterator

    Collection --> list
    Collection --> tuple
    Collection --> dict
    Collection --> str
    Collection --> range
```

ونمثل بمثالٍ فيه أخذ قائمة من الأرقام كمُكرِّر، وتحويل الفعل الذي أنشأناه:

```{python}
xs = [2, 4, 6]
squared = map(square, xs)
print(squared)
```

لكن لاحظ أننا عند طباعة النتيجة، فإن الذي يظهرُ شيءٌ من النوع `map` وليست قائمة بتربيع الأعداد. وذلك لأن الفعل مؤجَّل. وقد مرَّ معنا في باب الجمع المرتَّب أنَّ الفعل `range` أيضًا من الأفعال المؤجَّلة. وسيتم شرحه مرة أخرى. لكننا الآن نقول: لتعجيل النتيجة نستخدم فعل الإنشاء `list(squared)` ليتمَّ إنشاء قائمة من المُكرَّر الناتج من عملية التحويل.

```{python}
list(squared)
```

وبهذا نرى النتيجة.


وقد يجري استعمال فعل التحويل على فعلٍ لم نسمِّه، كهذا المثال:

```{python}
xs = [2, 4, 6]
plus = map(lambda x: x + 100, xs)
list(plus)
```

فأوَّلُ عاملٍ لفعل التحويل هو الذي قبل الفاصلة: `lambda x: x + 100` وهو كما لو عرَّفنا الفعل باسم على النحو التالي:

```{python}
def f(x):
    return x + 100
```

لكننا وضعنا ذلك باختصارٍ في تعيين العامل في فعل التحويل.

ثم العامل الثاني `xs` المُكرَّرُ الذي يجري عليه التحويل.


### تمرير التحويل إلى تحويل ثاني

يمكن تكوين مسار من العمليات على المكرر بتمرير كل مُكرِّر ناتج عن التحويل للتحويل التالي. نحو:

```{python}
xs = [2, 4, 6]
plus = map(lambda x: x + 100, xs)
mult = map(lambda x: x * 2, plus)
```

فإذا جئنا للتكرار عليها فإننا نرى النتيجة:

```{python}
for x in mult:
    print(x)
```

## إنشاء مسار معالجة

تتكون **مسارات المعالجة** (pipelines) من ثلاثة أفعال عالية:

1. **فعل التحويل**: [`map`](https://docs.python.org/3/library/functions.html#map)
2. **فعل الترشيح**: [`filter`](https://docs.python.org/3/library/functions.html#filter)
3. **فعل التجميع**: [`reduce`](https://docs.python.org/3/library/functools.html#functools.reduce)

فتُنسَج بها المسارات على النحو التالي:

```{python}
step_0 = range(1, 5+1) # إنشاء مُكرَّر أعداد
step_1 = map(lambda x: x ** 2, step_0) # تحويل
step_2 = map(lambda x: x + 100, step_1) # تحويل
step_3 = filter(lambda x: x % 2 == 0, step_2) # ترشيح
```

فإذا ما استعملنا التكرار على المكرِّر الأخير، فإن إنشاء المكرر في الخطوة الأولى يبدأ بإنشاء عناصرها شيئًا فشيئًا؛ فتدخُل إلى التحويل ثم التحويل ثم الترشيح شيئًا فشيئًا، ويتمُّ طباعتها كذلك:

```{python}
for result in step_3:
    print(result)
```

وبعد نفاذها، فإنك لو حاول سرد المُكرِّر الأخير مرة أخرى فإنك ستارهُ فارغًا:

```{python}
for result in step_3:
    print(result)
```

وأما فعل التجميع فيكون للعمليَّة التي تنظر في جميع العناصر وليست معالجتها لكلِّ عنصرٍ على حده (كما هو الحال في التحويل والترشيح).
ويجب أن نجلبها من المكتبة الأساسية حتى نستعملها بخلاف السابقيْن:

```{python}
from functools import reduce

step_0 = range(1, 5+1) # إنشاء مُكرَّر أعداد
step_1 = map(lambda x: x ** 2, step_0) # تحويل
step_2 = map(lambda x: x - 10, step_1) # تحويل
step_3 = filter(lambda x: x > 0, step_2) # ترشيح
total = reduce(lambda x, y: x + y, step_3, 0) # تجميع (يبدأ من القيمة 0 ويضم إليها)
total
```

وفيما يلي تصوير لمسار المعالجة هذا:

```{mermaid}
graph TD
    A[1, 2, 3, 4, 5] -->|map| B[1, 4, 9, 16, 25]
    B -->|map| C[-9, -6, -1, 6, 15]
    C -->|filter| D[6, 15]
    D -->|reduce| E[21]
```

ونمثل له بمثال أقبر للواقع، في متجر:

```{python}
from functools import reduce

prices = {
    'apple': 15.25,
    'banana': 10.50,
    'orange': 5.75,
    'cantaloupe': 40.00
}

basket = ['apple', 'apple', 'banana', 'orange', 'banana']

# تحويل الأسماء في السلة إلى أسعارها في القائمة
prices_in_basket = map(lambda fruit: prices[fruit], basket)

# تطبيق خصم 10% على الأسعار
discounted_in_basket = map(lambda price: price * 0.9, prices_in_basket)

# تجميع الأسعار لمعرفة المجموع، وباعتبار أن الزبون مديون للمتجر بـ 10 ريالات
total = reduce(lambda x, y: x + y, discounted_in_basket, 10)

print(round(total, 2))
```


## الفعل المؤجَّل

**الفعل المؤجَّل** -بعكس الفعل العادي الذي نتيجته عاجلة تأتي عند طلبه- فإن نتيجته لا تحصُل إلا عند الحاجة إليها. وذلك للاقتصاد في المعالجَة والذاكرة إلى حين حدوث أحد أمرين: طلب قراءة أو طلب كتابة. وذلك يتمثل في:

- الإشارة إلى عنصرٍ منه بالتكرار: `for x in xs` وحينها فإنَّ الذي يُحسبُ حقيقةً هو ما وصل إليه التكرار، ولا يُحسب ما بعده إلا عند الوصول إليه.
- السؤال عن العضويَّة في المُكرر: `x in xs`
- الإشارة (بالموضِع أو بالشريحة): `xs[1]` أو `xs[2:4]`
- الإنشاء منه: `list(xs)` أو `set(xs)` ونحوهما

وسنختار أحد هذه الطرق لمعرفة النتيجة بالإنشاء منه:

```{python}
list(squared)
```

ولعل علَّة الاقتصاد في خطوات المعالجة ومساحة الذاكرة غير مبررة بهذا المثال البسيط. لكنَّ لو أردنا معالجة قائمة مكونة من عشرة آلاف رابط من الصُّور عالية الدقَّة كبيرة الحجم؛ فإن إمكانيات الحاسب قد لا تتحمل؛ وحينها يجب الاقتصاد.

```{mermaid}
graph TD
    A[URL1, URL2, URL3, ...] -->|download| B[image1, image2, image3, ...]
    B -->|filter| C[image1, image2, image3 ...]
    C -->|resize| D[image10, image5, ...]
    D -->|rename| E[image10, image5, ...]
    E -->|save| F[image10, image5, ...]
```
