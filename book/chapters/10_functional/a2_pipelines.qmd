# مسارات المعالجة

## الفعل غير المسمى

**الفعل غير المسمى** (anonymous) هو فعل مُعرَّف بلا اسمٍ؛ ويكون تعريفه -في بايثون- بكلمة [`lambda`](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions) لا بكلمة `def`.
ولا يقبل إلا جملة واحدةً وتكونُ هي جُملة الرجوع (`return`).

وإضافته إلى اللغة ليس ضروريًّا لكنه من باب تعريف ما لن نحتاج إلا ذكره لاحقًا. وهو مستعملٌ بكثرة في البرمجة.

وطريقته على النحو التالي:

```python
lambda parameters: returned_expression
```

ونمثل له بما قد سبق تعريفه في الفعل داخل الفعل المنشئ `make_power` الذي كان شكله هكذا:

```{python}
def make_power(n):
    def power(x):
        return x ** n
    return power
```
فيمكننا أن نعرِّف الفعل الذي في الداخل بلا اسمٍ فنختصر العبارة هكذا:

```{python}
def make_power(n):
    return lambda x: x ** n
```
وهكذا يكون استعماله كما تقدَّم:

```{python}
square = make_power(2)
cube = make_power(3)

assert square(2) == 4
assert cube(2) == 8
```

## فعل التطبيق `map`

**فعل التطبيق** ([`map`](https://docs.python.org/3/library/functions.html#map)) يأخذُ فِعلاً ليطبِّقَهُ على متوالية أو أكثر (لوجود النجمة: `*`) ويُنتِجُ مُكرِّرًا ([`Iterator`](https://docs.python.org/3/glossary.html#term-iterator)). وتعريفُه هكذا:

```
map(function, iterable, *iterables) -> iterator
```

ومرَّ معنا أن القائمة، والصف، والقاموس، والنص كل ذلك من جنس المتواليات. وقد تقدَّم أنها مما يقبل التكرار.

ونمثل بمثالٍ فيه أخذ قائمة من الأرقام كمتوالية، وتطبيق الفعل الذي أنشأناه:


```{python}
xs = [2, 4, 6]
squared = map(square, xs)
print(squared)
```

لكن لاحظ أننا عند طباعة النتيجة، فإن الذي يظهرُ شيءٌ من النوع `map` وليست قائمة بتربيع الأعداد. وذلك لأن الفعل مؤجَّل. وقد مرَّ معنا في باب الجمع المرتَّب أنَّ الفعل `range` أيضًا من الأفعال المؤجَّلة. وسيتم شرحه مرة أخرى. لكننا الآن نقول: لتعجيل النتيجة نستخدم فعل الإنشاء `list(squared)` ليتمَّ إنشاء قائمة من المُكرَّر الناتج من عملية التطبيق.

```{python}
list(squared)
```

وبهذا نرى النتيجة.


وقد يجري استعمال فعل التطبيق على فعلٍ لم نسمِّه، كهذا المثال:

```{python}
xs = [2, 4, 6]
plus = map(lambda x: x + 100, xs)
list(plus)
```

فأوَّلُ عاملٍ لفعل التطبيق هو الذي قبل الفاصلة: `lambda x: x + 100` وهو كما لو عرَّفنا الفعل باسم على النحو التالي:

```{python}
def f(x):
    return x + 100
```

لكننا وضعنا ذلك باختصارٍ في تعيين العامل في فعل التطبيق.

ثم العامل الثاني `xs` فهو المتوالية (المُكرَّرُ) الذي يجري عليه التطبيق.


### تمرير التطبيق إلى تطبيق ثاني

يمكن تكوين مسار من العمليات على المتوالية بتمرير كل مُكرِّر ناتج عن التطبيق كمتوالية في تطبيق تالي. نحو:

```{python}
xs = [2, 4, 6]
plus = map(lambda x: x + 100, xs)
mult = map(lambda x: x * 2, plus)
```

فإذا جئنا للتكرار عليها فإننا نرى النتيجة:

```{python}
for x in mult:
    print(x)
```

## إنشاء مسار معالجة

تتكون **مسارات المعالجة** (pipelines) من ثلاثة أفعال عالية:

1. **فعل التطبيق**: [`map`](https://docs.python.org/3/library/functions.html#map)
2. **فعل الترشيح**: [`filter`](https://docs.python.org/3/library/functions.html#filter)
3. **فعل التجميع**: [`reduce`](https://docs.python.org/3/library/functools.html#functools.reduce)

فتُنسَج بها المسارات على النحو التالي:

```{python}
step_0 = range(1, 5+1) # إنشاء متوالية
step_1 = map(lambda x: x ** 2, step_0) # تطبيق
step_2 = map(lambda x: x + 100, step_1) # تطبيق
step_3 = filter(lambda x: x % 2 == 0, step_2) # ترشيح
```

فإذا ما استعملنا التكرار على المكرِّر الأخير، فإن إنشاء المتوالية في الخطوة الأولى يبدأ بإنشاء عناصرها شيئًا فشيئًا؛ فتدخُل إلى التطبيق ثم التطبيق ثم الترشيخ شيئًا فشيئًا، ويتمُّ طباعتها كذلك:

```{python}
for result in step_3:
    print(result)
```

وبعد نفاذها، فإنك لو حاول سرد المُكرِّر الأخير مرة أخرى فإنك ستارهُ فارغًا:

```{python}
for result in step_3:
    print(result)
```

وأما فعل التجميع فيكون للعمليَّة التي تنظر في جميع العناصر وليست معالجتها لكلِّ عنصرٍ على حده (كما هو الحال في التطبيق والترشيح).
ويجب أن نجلبها من المكتبة الأساسية حتى نستعملها بخلاف السابقيْن:

```{python}
from functools import reduce

step_0 = range(1, 5+1) # إنشاء متوالية
step_1 = map(lambda x: x ** 2, step_0) # تطبيق
step_2 = map(lambda x: x - 10, step_1) # تطبيق
step_3 = filter(lambda x: x > 0, step_2) # ترشيح
total = reduce(lambda x, y: x + y, step_3, 0) # تجميع (يبدأ من القيمة 0 ويضم إليها)
total
```

وفيما يلي تصوير لمسار المعالجة هذا:

```{mermaid}
graph TD
    A[1, 2, 3, 4, 5] -->|map| B[1, 4, 9, 16, 25]
    B -->|map| C[-9, -6, -1, 6, 15]
    C -->|filter| D[6, 15]
    D -->|reduce| E[21]
```


## الفعل المؤجَّل

**الفعل المؤجَّل** -بعكس الفعل العادي الذي نتيجته عاجلة تأتي عند طلبه- فإن نتيجته لا تحصُل إلا عند الحاجة إليها. وذلك للاقتصاد في المعالجَة والذاكرة إلى حين حدوث أحد أمرين: طلب قراءة أو طلب كتابة. وذلك يتمثل في:

- الإشارة إلى عنصرٍ منه بالتكرار: `for x in xs` وحينها فإنَّ الذي يُحسبُ حقيقةً هو ما وصل إليه التكرار، ولا يُحسب ما بعده إلا عند الوصول إليه.
- السؤال عن العضويَّة في المتوالية: `x in xs`
- الإشارة (بالموضِع أو بالشريحة): `xs[1]` أو `xs[2:4]`
- الإنشاء منه: `list(xs)` أو `set(xs)` ونحوهما

وسنختار أحد هذه الطرق لمعرفة النتيجة بالإنشاء منه:

```{python}
list(squared)
```

ولعل علَّة الاقتصاد في خطوات المعالجة ومساحة الذاكرة غير مبررة بهذا المثال البسيط. لكنَّ لو أردنا تحويل قائمة مكونة من عشرة آلاف رابط من الصُّور عالية الدقَّة كبيرة الحجم؛ وجَبَ الاقتصاد. وذلك على النحو التالي:


```{python}
import requests 
from IPython.display import display, Image

pictures = [
    "https://picsum.photos/200/300",
    "https://picsum.photos/200/300",
    "https://picsum.photos/200/300",
    "https://picsum.photos/200/300",
    "https://picsum.photos/200/300",
]

downloaded = map(lambda url: requests.get(url).content, pictures)
for content in downloaded:
    display(Image(content))
```

ملاحظة: موقع https://picsum.photos يعطي صورة عشوائيَّة في كُلِّ مرَّة نرسل إليه طلب `get` بمكتبة `requests`، ولذلك تظهر صُوَر مختلفة مع أن الرابط مكرر. وإنما وضعناه هكذا للتمثيل على قائمةٍ هي من عندك. وسيأتي الكلام عن مكتبة `requests` والوصول إلى الشبكة في موضعه إن شاء الله.

## أفعال التحقق: `any` و `all`

ويُلحق بالبرمجة الفعليَّة أفعال التحقق:

- فعل **أي** (`any`) يتحقق بوجود عنصرٍ واحد متحقق على الأقل:
- فعل **كل** (`all`) يتحقق بتحقق جميع العناصر كلها:

وننظر إلى المثال التالي لتوضيح الفائدة.
نفترض أننا نريد أن نعرف هل أحد هذه الكلمات يبدأ بالحرف: `ال`:

```{python}
words = ["السلام", "ثلاثة", "دعسوقة", "السيف"]
checks = map(lambda s: s.startswith("ال"), words)
```

ثم نعجِّل بنتيجتها بالفعل المنشيء `list` ثم نفحص:

```{python}
mask = list(checks)
print(mask)
```

ونريد أن نستعمل فعليْ التحقق:

```{python}
print("أي منها يبدأ بالحرف: ال", any(mask))
print("كلها يبدأ بالحرف: ال", all(mask))
```
