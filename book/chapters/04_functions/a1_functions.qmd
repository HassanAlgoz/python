# الأفعال

**الفعل** أو **الدالة** (Function): قطعة نص برمجي مخزَّنة مسمَّاة. عادة ما يكون لها عوامل متغيرة.
ويسمى الإجراء (Procedure) أو الروتين (Routine) أو البرنامج الجزئي (Sub-Program).

- نحو: `int(x)` لإنشاء العدد الصحيح من النص. مثل: `int("12")` ينتج: `12`.
- أو نحو: `abs(x)` للقيمة المطلقة مثل: `abs(-10)` ينتج: `10`.

وقد يأخذ عاملين:

- نحو: `round(x, n)` مثل: `round(10.259, 2)` ينتج: `10.26`.
- أو نحو: `pow(x, y)` لرفع العدد `x` إلى القوة `y`. مثل: `pow(2, 3)` ينتج: `8`.


وقد يأخذ عاملاً واحدًا لكنَّهُ قائمة:

- نحو: `sum(numbers)` مثل: `sum([1, 2, 3, 4, 5])` ينتج: `15`.
- أو نحو: `max(numbers)` لأكبر عدد في القائمة. مثل: `max([1, 2, 30, 4, 5])` ينتج: `30`.

وقد يكون عدد عوامله لا محدودًا:

- نحو: `print(*values)`. فعلامة النجمة (`*`) تشير لقبول **عدد مطلق من العوامل**. مثل:

```{python}
name = "Adam"
age = 25
print("My name is", name, "and I'm", age, "years old")
```

فإن `print` قبلت خمسة عوامل:

1. النص: `"My name is"`
2. قيمة المتغير: `name`
3. النص: `"and I'm"`
4. قيمة المتغير: `age`
5. النص: `"years old"`

ولدينا الفعل `help(func)` يطلب مساعدة الفعل المعيَّن، بلا أقواس، هكذا:

```{python}
help(sum)
```

وقد عرفت أن **طلب التنفيذ** يكون بالقوسين بعد اسمه `()`، وتوضَع العوامل فيهما وهي ضربان:

1. **عامل مؤثر**
2. **عامل متأثر**

وفي كل ما سبق كانت العوامل من النوع المؤثر؛ لأنها كانت تؤثر في النتيجة ولا تتأثر بها.

أما المتأثر فنحو فعل الترتيب من مكتبة القائمة: `list.sort(xs)` فإن المتأثر به القائمة نفسها، مثل:

```{python}
xs = [40, 20, 10, 30]
list.sort(xs)
```

فأما جملة `list.sort` فإننا حددنا اسم النوع `list` وأردنا منه الفعل `sort`، وأتينا بالقوسين لطلب تنفيذه، ووضعنا المتأثر `xs` فيه.

ومع أننا لم نعيِّن النتيجة (بجملة التعيين `=`)، فقد تغيَّرت (تأثرت) القائمة بالفعل:

```{python}
print(xs)
```

بعكس الترتيب بالفعل الذي ليس من النطاق العام: `sorted(xs)` فإنَّ القائمة فيه ليست متأثرًا؛ إذْ يُنتِجُ الفعلُ قائمةً جديدةً ولا يغير القائمة المُدخلة:

```{python}
xs = [40, 20, 10, 30]
ys = sorted(xs)
print(xs, "لم يعمل الفعل في القائمة نفسها")
print(ys, "هي قائمة جديدة")
```

وقد تتساءل ما الفائدة من وجود طريقتين وكلاهما يعمل نفس العمل؟

1. الطريقة الأولى: `list.sort(xs)` لا ترجع بشيء بل تعدل نفس القائمة
2. الطريقة الثانية: `sorted(xs)` ترجع قائمة جديدة

فأما الطريقة الأولى فأصغر في الذاكرة لأنها لا تُنشئ نُسخة كما تفعل الطريقة الثانية. لكن الطريقة الثانية مفيدة إن أردت أن تُبقي القائمة الأصلية كما هي.

والأمر كذلك في الفعلين:

1. `list.reverse(xs)`
2. `reversed(xs)`

ويجتمع المؤثر والمتأثر في نحو:

```{python}
list.append(xs, 50)
```

فالفعل `list.append` يأخذ القائمة، ويضيف إليها القيمة `50`. ولذلك نقول الأوَّل متأثر والثاني مؤثر.

```{python}
print(xs)
```

وقد وضعت اللغات **الشيئية** (Object-Oriented) مثل بايثون صياغة خاصَّةً: **للفِعْل المُقَدَّمِ مفعولُه**. ونقصد بالمفعول الشيئ المتأثر؛ فهكذا.
وبذلك يتحصل لدينا طريقتان كلتاهما تؤديان نفس المعنى:

- إسناد الفعل للنوع: `list.append(xs, 25)`
- إسناد الفعل للمفعول: `xs.append(25)`

ومثاله أيضًا في الفعل `list.sort` للترتيب وكذلك في `list.append` للإضافة:

```{python}
xs = [20, 10, 30, 40]
ys = [20, 10, 30, 40]

list.sort(xs)
ys.sort()
assert xs == ys

list.append(xs, 50)
ys.append(50)
assert xs == ys
```

وقد تُعَيَّنُ العوامل بأحد طريقتين:

1. **تعيين بالموضع**: نحو: `round(3.14159, 2)`
2. **تعيين بالاسم**: نحو: `round(number=3.14159, ndigits=2)` فلا يشترط فيه ترتيب العوامل.

ويجوز استعمال الطريقتين معًا في نحو: `list.sort(numbers, reverse=True)` ويشترط فيه تقدم التعيين بالموضع ليكون في مكانه، ثم يتبعه التعيين بالاسم حيث لا يشترط الترتيب فيه.

## التعريف والتفاصيل والتنفيذ

نذلف الآن لإنشاء أفعال جديدة.

يعرَّف الفعل بـ `def` ويتكون من ثلاثة أجزاء:

1. **اسم الفعل**: الذي يُطلَبُ به
2. **العوامل**: سميت كذلك لأن نتيجة الفعل تتغير بتغيرها. ويتم تعيينها لاحقًا
3. **التفاصيل**: وهي القطعة البرمجية التي جُعِلَ اسمه عنوانًا لها

أما **جملة الرجوع** `return` فإنَّها مخرج الفعل بالنتيجة **لموضع الطلب**.

```{python}
def calculate_grade(score):
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
```

وعند طلب التنفيذ نعين العوامل ..

فينتج لنا بطلب `calculate_grade(95)` نسخة معيَّنة من تفاصيل الفعل، نسمّيها [**ظرف التنفيذ**](https://docs.python.org/3/reference/executionmodel.html#structure-of-a-program) ؛ يكون فيه المتغير `score=95` كأنه هكذا:

```python
if 95 >= 90:
    return "A"
elif 95 >= 80:
    return "B"
elif 95 >= 70:
    return "C"
elif 95 >= 60:
    return "D"
else:
    return "F"
```

وبطلب تنفيذ `calculate_grade(80)` يكون الظرف هكذ:

```python
if 80 >= 90:
    return "A"
elif 80 >= 80:
    return "B"
elif 80 >= 70:
    return "C"
elif 80 >= 60:
    return "D"
else:
    return "F"
```

لاحظ أن نتيجة السطرين بحسب الظرفين المختلفين:

```{python}
print(calculate_grade(95))
print(calculate_grade(80))
```

وقد نعدد عوامل كثيرة، نحو:

```{python}
def weather_condition(temperature, humidity, wind_speed):
    if temperature >= 30 and humidity >= 60 and wind_speed >= 10:
        return "Rainy"
    elif temperature >= 20 and humidity >= 50 and wind_speed >= 5:
        return "Cloudy"
    elif temperature >= 10 and humidity >= 30 and wind_speed >= 0:
        return "Sunny"
    return "Normal"
```

ويكون طلبها بالطريقتين كما تقدَّم، بالموضع أو بالاسم (ولا يشترط في الثانية الترتيب):

```{python}
cond = weather_condition(30, wind_speed=10, humidity=60)

if cond == "Rainy":
    print("Don't forget your umbrella!")
```

## العوامل الجائزة

الأصل في العوامل المعرَّفة الوجوب؛ إلا ما عُيِّن عند التعريف، ولو بالقيمة العدميَّة `None` أو ما يوازيها من القيَم الصفرية. وينسخُ ذلك التعيينَ التعيينُ عند طلب الفعل.

لو أردنا للفعل أن يتكيَّف بحسب المؤثر المعيَّن، بحيث:

- لو عينت السلزيوس فالتحويل لفهرنهايت: `convert_temperature(celsius=32)`
- لو عينت الفهرنهايت فالتحويل لسلزيوس: `convert_temperature(fahrenheit=89.6)`

وإليك معادلة التحويل بين نوعيْ درجة الحرارة:

$$
F = \frac{9}{5} C + 32
$$

فنعرِّفُ العوامل بقيَم عدميَّة، ونفحص وجودها بالشرط `is not None` لنُعمِلَها أو نهملها:

```{python}
def convert_temperature(celsius = None, fahrenheit = None):
    if celsius is not None:
        fahrenheit = (9 / 5) * celsius + 32
        return fahrenheit
    elif fahrenheit is not None:
        celsius = (fahrenheit - 32) * (5 / 9)
        return celsius
```

نتأكد:

```{python}
assert convert_temperature(celsius=32) == 89.6
assert convert_temperature(fahrenheit=89.6) == 32
```


## التصريح بالنوع

وجاز في بايثون ذكر أنواع العوامل والنواتج، وليس بلازِم ولا مُلزِم. فوجودُها وضوحٌ للمبرمِجين ولا يُلزِمُك بها المفسِّر. نحو:

```python
def do_something(a: int = 0, b: str = '') -> float:
    # ...
```

فعبارة: `a: int = 0` تتكون من ثلاثة أجزاء:

- اسم العامل: `a`
- نوعه: `int`
- القيمة الابتدائية: `0`

وكذلك `b: str = ''` مثلها.

وبعد السهم نوع ناتج الفعل: `-> float`

ومن الأنواع المبنيَّة في بايثون:

- `int` الأعداد الصحيحة، نحو: `10`
- `float` الأعداد العشرية، نحو: `10.5`
- `str` وهي نوع النص، نحو: `"Salam"`
- `list` قائمة وإن شئت تحديد نوع العنصر الواحد فيها؛ فإنك تضعه بين القوسين المربعين، نحو:
    - `list[int]`
    - `list[float]`
    - `list[str]`


## نطاق التسمية

ومن خصائصها أن المتغيرات في الداخل لا تظهر للخارج.

```{python}
def calculate_bmi(weight: float, height: float) -> float:
    bmi = weight / (height ** 2)
    return round(bmi, 2)
```

فنتوقع وقوع خطأ هنا لأن `bmi` غير معرفة إلا في نطاق الفعل:

```{python}
#| error: true

print(bmi)
```

وعلى العكس فإن المعرَّفات الخارجة معروفة في الداخل؛ فيمكن أن تكون عاملة في الفعل:

```{python}
max_length = 8

def check_password_strength(password: str) -> str:
    if len(password) > max_length:
        return "strong"
    elif len(password) > max_length // 2:
        return "medium"
    return "weak"
```

![مستويات نطاق التسمية](../../assets/LEGB.png)

والنصيحة العامة: أن يكون الاستعمال تاليًا لأخص نطاق، ما أمكن. أي: أن تكون الإشارة اللاحقة للفعل قريبةً من تعريفه.

## ثمرة الفعل

تُخرج الأفعال نتائج معالجتها بإحدى طريقتين:

- **الرجوع**: حيث ترجِع النتيجة بجملة `return` لموضع طلب الفعل، وغالبًا ما يتم تعيينه نحو: `y = sqrt(x)`
- **العمل في مفعول**:
    - **مذكور**، نحو: `list.sort(xs)` حيث تعدَّل القيمة التي يشير إليها المتغير `xs`
    - **محذوف**، نحو: `print(...)` حيث وُضِعَت لمفعوله قيمة ابتدائية `file=sys.stdout` لذا تُكتَبُ النتيجة على الشاشة

والفعل دائمًا يرجع بنهاية آخر جملة فيه، لكن الذي لا يصرَّحُ فيه بكلمة الرجوع `return` تُقدَّر له القيمة العدمية: `None` ويسمى الفعل حنيها **خاويًا** (void).

تأمل المثال التالي الذي يأخذ عوامل ثم لا يرجع بشيء، لكنه يُظهر النتيجة على الشاشة، وقد كتبنا فيه جملة الرجوع `return None` لكنها مقدَّرة على أية حال، ولا يلزمنا أن نضعها:

```{python}
def print_decorated(message: str, n: int) -> None:
    print("=" * n)
    print(message)
    print("=" * n)
    return None

print_decorated("Salam alykom", 15)
```

## إطلاق عدد المعمولات

قد تتساءل كيف تعمل `print` وهي تأخذ عددًا لا محدودًا من المعمولات؟ حتى نجيب عن ذلك ننظر في **عملية فك الأقواس** وهي علامة النجمة `*` قبل المتغيِّر المشير لمجموعة، على النحو التالي:

```{python}
t = (10, 20, 30)
print(t)
print(*t)
```

لاحظ الفرق بين الطلب الأول والثاني:

1. الأوَّل يطبع المتغير `t` ككل، أي: كصف
2. يُمرر واحدًا تلوَ الآخر للفعل `print` بعد فك الأقواس كأنك كتبت: `print(10, 20, 30)`

وحين تستعمل علامة النجمة في تعريف عوامل الفعل، فإن أي عامل موضعي زائد عن العدد، يكونُ فيه كصفّ (وسيأتي الكلام عن الصف في [باب المجموعة المرتبة](../05_sequences/a_sequences.qmd)). وبالمثال يتضح المقال. وقد اصطُلح على تسميته `args` وهي اختصار كلمة Arguments:

```{python}
def show(a, *args):
    print(a)
    print(type(args), args)
    print('print:', *args)

show(1, 2, 3, 4, 5)
```

وكذلك المعمولات المعيَّنة بالاسم، لكن بالنجمتين `**` وتكون قاموسًا (وسيأتي الكلام عنه في [باب المجموعة المرقومة](../06_mapping/a_mapping.qmd)) ومعنى الكلمة `kwargs` هو: Keyword Arguments:

```{python}
def show(a, **kwargs):
    print(a)
    print(type(kwargs), kwargs)
    print('print:', *kwargs)

show(a=1, b=2, c=3, d=4, e=5)
```

وقد يجتمعان في نفس الفعل `*args` و `**kwargs` نحو:

```{python}
def show(x, y, *args, **kwargs):
    print(x, y)
    print(type(args), args)
    print(type(kwargs), kwargs)

show(1, 2, 3, 4, 5, a=1, b=2, c=3)
```

ولا بد من تقديم الموضعية قبل الاسمية.

للمزيد راجع [المعمولات الخاصة في التوثيق](https://docs.python.org/3/tutorial/controlflow.html#special-parameters).


## المصطلحات

| العربية | الإنجليزية |
|----------|------------|
| فعل | Function |
| عامل | Parameter |
| عامل مؤثر | Input Parameter |
| عامل متأثر | Output Parameter |
| نطاق | Scope |
| نطاق محلي | Local Scope |
| نطاق عام | Global Scope |
| رجوع | Return |
| قيمة راجعة | Return Value |
| فعل خاوٍ | Void Function |
| قيمة عدمية | None |
| مفعول | Object |
| مذكور | Explicit |
| محذوف | Implicit |
| طلب التنفيذ | Function Call |
| تعريف الفعل | Function Definition |
