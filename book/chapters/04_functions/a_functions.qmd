# الإجراءات

**الإجراء** (أو **الدالة**) هو قطعة كود مخزَّنة لها اسم يمكن استدعاؤها بمتغيرات مغايرة.

عند **الاستدعاء**: يتم **تنفيذ نسخة معيَّنة** من قطعة الكود (ليس فيها متغيرات؛ وإنما هي قيَم تم تعيينها) فيما يسمى [**إطار التنفيذ**](https://docs.python.org/3/reference/executionmodel.html#structure-of-a-program) الذي يحتفظ بذاكرة محليَّة خاصة به إلى نهاية آخر جملة من القطعة. ثم تخلَّى الذاكرة المحليَّة وترجع ل**موضع الاستدعاء** المباشر لها.

## التعريف والاستدعاء

تأمل تعريف الإجراء التالي الذي يحسب العلامة بناءً على الدرجة:

- فإن جملة تعريف الإجراء تبتدئ بكلمة `def` مبتوعة باسم الإجراء (`calculate_grade`)
- بين الأقواس تحدد المتغيرات / العوامل (`score`) التي يُمكن تعيينها لاحقًا
- أما المُخرجات فإنَّها تخرُج بجملة الرجوع `return`.

```{python}
def calculate_grade(score):
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
```

يجوز الآن استدعاء الإجراء باسمه. و**جملة الاستدعاء** تتكون من اسم الإجراء متبوعًا بقوسين فيهما تعيين العوامل، ونتيجتها هي ما يرجع به الإجراء (عند جملة `return` بحسب حاله):

```{python}
print(calculate_grade(95))
print(calculate_grade(85))
```

ولا تقتصر على عاملٍ واحد. بل **تتعدد العوامل**:

```{python}
def weather_condition(temperature, humidity, wind_speed):
    if temperature >= 30 and humidity >= 60 and wind_speed >= 10:
        return "Rainy"
    elif temperature >= 20 and humidity >= 50 and wind_speed >= 5:
        return "Cloudy"
    elif temperature >= 10 and humidity >= 30 and wind_speed >= 0:
        return "Sunny"
    return "Normal"
```

ولتعيين العوامل طريقتان، وقد تستعملان معًا:

1. **تعيين بالموضع**: `weather_condition(30, 60, 10)`
2. **تعيين بالاسم** `weather_condition(temperature=30, humidity=60, wind_speed=10)` ولا يُشترط الترتيب فيه.

```{python}
cond = weather_condition(temperature=30, humidity=60, wind_speed=10)

if cond == "Rainy":
    print("Don't forget your umbrella!")
```

**ويجوز المزج بينهما بشرط تقدُّم التعيين بالموضع على التعيين بالاسم**. ولاحظ في هذا المثال جواز عدم التقيُّد بالترتيب عند التعيين بالاسم (إذ قدَّمنا `wind_speed` على `humidity` بينما هي في التعريف بعدها).

```{python}
print(weather_condition(20, wind_speed=5, humidity=50))
```

## التعيين الاختياري

نريد تعريف إجراء يتصرف بالشكل التالي:

```python
# assert convert_temperature(celsius=32) == 89.6
# assert convert_temperature(fahrenheit=89.6) == 32
```

فكيف نكتب هذا الإجراء؟

تذكر أن معادلة التحويل هي:

$$
F = \frac{9}{5} C + 32
$$

- لجعل العامل اختياريًّا تُعيَّنُ له **القيمة الافتراضية** `None` أو تعيَّنُ له أي قيمة افتراضيَّة أخرى فيأخذها حين لا يُعيَّن عند الاستدعاء.
- ولاحظ استعمال `is not None` للتحقق من عدم تعيين العامل وليس بالمقارنة المنطقية `== None` فهي **مقارنة هوية** وليست مقارنة قيمة.

```{python}
def convert_temperature(celsius = None, fahrenheit = None):
    if celsius is not None:
        fahrenheit = (9 / 5) * celsius + 32
        return fahrenheit
    elif fahrenheit is not None:
        celsius = (fahrenheit - 32) * (5 / 9)
        return celsius
    raise ValueError('Either celsius or fahrenheit must be provided')
```

لاحظ في السطر الأخير وجود: `raise ValueError` وهي جملة ترفع خطأ؛ وموضعها يجعلها ترفع في حال لم يتم تعيين أي من العوامل عند الاستدعاء. وسيأتي الكلام في [باب الخطِأ](05_errors.qmd) عنها بتفصيل إن شاء الله.

**الاختبارات**:

```{python}
assert convert_temperature(celsius=32) == 89.6
assert convert_temperature(fahrenheit=89.6) == 32
```

نجحنا! فجمل التوكيد لم تظهر أية مشاكل.

ولك أن تضفي على الإجراء تنويهًا بأنواع مدخلاته ومخرجاته لتقليل الخطأ وزيادة الوضوح على النحو التالي:

```python
def convert_temperature(celsius: float = None, fahrenheit: float = None) -> float:
    # ...
```

- فعبارة: `celsius: float = None` تتكون من ثلاثة أجزاء:
    - اسم العامل: `celsius`
    - نوعه: `float`
    - القيمة الافتراضية: `None` (أي: إذا لم يتم تعيينه فسيكون له القيمة `None`)
- وكذلك `fahrenheit: float = None` مثلها.
- ثم الجزء الأخير بعد الأقواس: `-> float` وهو يشير لنوع القيمة التي يرجعها الإجراء.

وقد تلاحظ أننا سابقًا لم نعرف لا أنواع المدخلات ولا أنواع المخرجات. فهي في بايثون اختيارية: تزيده وضوحًا وذلك يقلل من مساحة الخطأ عند استعماله.

## نطاق التسمية

ومن مميزات الإجراء المعرَّف أنَّ له نطاقًا خاصًّا؛ فما يُعرَّفُ داخله يبقى في نطاقه ولا يُعرَف خارجه. ويسمى هذا **نطاق التسمية**:

```{python}
def calculate_bmi(weight: float, height: float) -> float:
    bmi = weight / (height ** 2)
    return round(bmi, 2)
```

فنتوقع وقوع خطأ هنا لأن `bmi` غير معرفة إلا في نطاق الإجراء:

```{python}
#| error: true

print(bmi)
```

لكن نطاق التسمية الذي داخل الإجراء، هو نفسه داخل نطاقٍ أشمل منه. ففي هذا المثال نجد استعمال `len` الذي هو إجراء تم تعريفه في نطاق أشمل (ضمن الإجراءات الأساسية في اللغة)، وكذلك الأمر في المتغير `MAX_LEN` إلا أنه دونه في الشمول:

```{python}
MAX_LEN = 8

def check_password_strength(password: str) -> str:
    if len(password) > MAX_LEN:
        return "strong"
    elif len(password) > MAX_LEN // 2:
        return "medium"
    return "weak"
```

أما استعمالنا للأحرف الكبيرة، فهو عُرفٌ يقضي بأنَّنا سنلتزم بعدم تغييره. وكثيرًا ما يستعمل ذلك فيما هو من الإعدادات العامَّة التي تضبط سلوك البرنامج.

## استدعاء إجراء داخل إجراء

ومن قوَّة الإجراءات أنها **تتركب** من إجراءات أخرى. فهنا نركِّب من `sum` و `len` إجراء حساب المتوسط `mean`:


## الإجمال ثم التفصيل

ننصح بطريقة الإجمال ثم التفصيل في كتابة الكود، وهي:

- تصميم القطعة بتحديد ما تُنتج بناءً على ما تأخذ، بغض النظر عن كيفية وقوع ذلك على وجه التفصيل.
    - يتضمن ذلك كتابة العوامل وأنواعها، والنتائج وأنواعها
    - يتضمن ذلك كتابة وصف الإجراء باللغة الإنجليزية، لتوثيق ما لا يمكن تبيينه بمجرد أسماء العوامل والأنواع واسم الإجراء
- بعد ذلك نكتب الاختبارات التي تصف سلوك الإجراء (`مدخلات -> مخرجات`)
- وبعد ذلك نأتي لكتابة التفاصيل: التي هي قطعة الكود داخل الإجراء.
- وأثناء كتابة التفاصيل نشغل الاختبارات كي توجِّهنا لما هو غير مطابق للوصف.

في المثال التالي لاحظ هذه الأمور:

1. تعريف الإجراء باسم وعوامل وأنواعها.
2. الوصف المُجمَل باللغة الإنجليزية، ويسمى **docstring**؛ وهو النص الذي يترأس الإجراء (في سطره الأول). والقاعدة العامة فيه: ألا يصف إلا ما يفيد المستفيد من الإجراء. أما التفاصيل التي تفيد مطوِّر الإجراء فإنها تكون تعليقات بعلامة `#` في ثناياه.
3. كلمة `pass` التي تُستعمل لإرضاء مترجم اللغة. لأننا سنكتب الاختبارات قبل أن نكتب تفاصيله، ولا نريد لمترجم بايثون أن يظهر خطأ بسبب عدم وجود قطعة كود داخل الإجراء.

```{python}
def min_max(numbers: list[float]) -> tuple[float, float]:
    """Return the minimum and maximum values in the list."""
    pass
```

وهذا الذي يظهر حين تريد المساعدة عن طريق الإجراء المدمج `help`، هكذا:

```{python}
help(min_max)
```

ثم نكتب **اختبارات تصف السلوك** الذي نريده منه:

```python
# assert min_max([10, 20, 30, 40, 50]) == (10, 50)
# assert min_max([50, 40, 30, 20, 10]) == (10, 50)
# assert min_max([10, 10, -900, 10, 10]) == (-900, 10)
```

ثم الآن نعدل الإجراء الذي كتبناه في الأعلى، ولاحظ استعمال التعليقات `#` لتوضيح التسلسل التنفيذي:

```{python}
def min_max(numbers: list[float]) -> tuple[float, float]:
    """Return the minimum and maximum values in the list."""

    if len(numbers) == 0:
        return None, None
    
    # Assign the first element to minimum and maximum
    minimum = numbers[0]
    maximum = numbers[0]
    
    for num in numbers:
        if num < minimum:
            minimum = num
        # elif is used because maximum will never be less than minimum
        elif num > maximum:
            maximum = num
    return minimum, maximum
```

ونشغل الاختبارات:

```{python}
assert min_max([10, 20, 30, 40, 50]) == (10, 50)
assert min_max([50, 40, 30, 20, 10]) == (10, 50)
assert min_max([10, 10, -900, 10, 10]) == (-900, 10)
assert min_max([]) == (None, None)
```

## إطلاق عدد العوامل

قد تتساءل كيف تعمل `print` وهي تأخذ عددًا لا محدود من العوامل؟ الجواب باستعمال: `*args` على النحو التالي:

أولاً يجب أن نتعرف  على عملية فك الأقواس:

```{python}
t = (10, 20, 30)
print(t)
print(*t)
```

لاحظ الفرق بين الاستدعاء الأول والثاني:

1. الأوَّل يطبع المتغير `t` ككل، أي: كصف
2. يمرر العنار واحدًا تلوَ الآخر للإجراء `print` بعد فك الأقواس كأنك كتبت: `print(10, 20, 30)`

فعلامة النجمة `*` ما قبل المتغير هي في الحقيقة **عملية فك تسلسل** (unpacking).

ونستطيع أن نعرف متغيِّرًا يأخذ عددًا لا محدود من العوامل باستعمال `*args` (وكلمة: `args` هي اختصار لكلمة: `arguments` تم الاتفاق عليها لكنها ليست كلمة أصلية في لغة بايثون).

```{python}
def show(*args):
    print(type(args), args)
    print('print:', *args)

show(1, 2, 3, 4, 5)
```

أما إن كنت تريد عددًا لا محدود من العوامل المسماة فيمكنك استعمال `**kwargs` (وكلمة: `kwargs` هي اختصار لكلمة: `keyword arguments` تم الاتفاق عليها لكنها ليست كلمة أصلية في لغة بايثون).

```{python}
def show(**kwargs):
    print(type(kwargs), kwargs)
    print('print:', *kwargs)

show(a=1, b=2, c=3, d=4, e=5)
```

ويمكن استعمال `*args` و `**kwargs` معًا في الإجراءات:

```{python}
def show(x, y, *args, **kwargs):
    print(x, y)
    print(type(args), args)
    print(type(kwargs), kwargs)

show(1, 2, 3, 4, 5, a=1, b=2, c=3)
```

للمزيد راجع [العوامل الخاصة في التوثيق](https://docs.python.org/3/tutorial/controlflow.html#special-parameters).

## الإجراء النقي

حتى يستفاد من الإجراء، لا بد أن يكون له مخرجات؛ وتكون بأحد أمرين:

1. **الرجوع لموضع الاستدعاء بالنتيجة** (جملة الرجوع `return`) فينتقل أثر هذا الإجراء للعالم عن طريقها
2. **التأثير في العالم بغير الرجوع لموضع الاستدعاء بالنتيجة**

**الإجراء النقي** (pure) لا أثر على مخرجاته إلا بالنظر لمدخلاته فقط؛ ولا يؤثر هو إلا بإرجاع مخرجاته. أما **غير النقي** فهو الذي:

1. يؤثر في غير مخرجاته المباشرة (مثلاً يكتب في ملف أو على سطر الأوامر أو يعدِّل على مدخلاته) أو
2. يتأثر بغير مدخلاته المباشرة (مثلاً: يعتمد على متغيرات معرَّفة خارج الإجراء).

وهذا مثال لإجراء لا يُنتج في موضع الاستدعاء (لا يُرجع قيمة باستعمال جملة الرجوع `return`) لكنَّه يُنتج بطباعة حروف على سطر الأوامر. فنقول: هو يؤثر بطريقة غير مباشرة؛ لذا هو غير نقي.

```{python}
def print_decorated(message: str) -> None:
    print("*" * 50)
    print(message)
    print("*" * 50)

print_decorated("Hello, world!")
```

وكذلك يُقال أن مثل هذا الإجراء ذو **أعراض جانبية** (side effects)؛ وذلك إشارةً إلى التغيير الذي يحصل بسببه بطريقة غير مباشرة (ليس عن طريق الرجوع بنتيجة).

كذلك هو من جنس **الإجراء العقيم** (void) وهو الذي لا يرجع بقيمة لموضع الاستدعاء (فلا تجد جملة الرجوع `return` في ثناياه). وإنما تكون مخرجاته في غير موضع الاستدعاء. وأي إجراءٍ لا يجد فيه مترجم بايثون كلمة `return` فإنه يُدرجها في آخره بالرجوع بلا شيء: `return None`.

فكلما كان الإجراء نقيًّا كان عزله وضبطه وإتقانه واختباره أسهل. لكنّ الإجراءات النقية تعيش في عالم مثالي لا يتأثر بالواقع ولا يؤثر فيه (I/O)؛ بل بالمعالجات التي بينها فقط. ولنرى التأثير في الواقع يجب أن نخرج إلى ما هو مُنتجٌ فيه: وهو غير نقي.

والذي نميل إليه: تغليب النقاوة، واستعمال الأعراض الجانبية عند أطراف المعالجة ونهاياتها.

فتحصل لنا بذلك هذه الأنواع:

- إجراء نقي: لا يؤثر في العالم بغير الرجوع بالنتيجة. ونتيجته مرتبطة فقط بمدخلاته المباشرة.
- وغير النقي: يؤثر في العالم بغير الرجوع بالنتيجة. وفيه قسمان:
  - قد يرجع بنتيجة وكذلك له تأثير جانبي.
  - إجراء عقيم: لا يرجع بنتيجة.

## الإجراء المتسلسل

**الإجراء المتسلسل**: يحتوي على جملة يستدعي فيها نفسه. ويجب أن تؤول سلسلة الاستدعاءات هذه إلى جملة تنهي التسلسل.

فمثلا: تعرف الرياضيات **مضروب العدد**

$$ 
!n = n(n-1)(n-2)\cdots(1)
$$

فهي عملية ضرب لكل عدد مع الذي قبله حتى ينتهي للواحد. ومن أمثلته:

$$
!5 = (5)(4)(3)(2)(1)
$$

ولك أن تصف نفس العملية بالشكل التالي:

$$
!n = n !(n-1)
$$

أي أن مضروب العدد هو ضربُ هذا العدد في مضروب العدد الذي يقبله. وذلك يتسلسل على النحو التالي:

$$
!5 = (5)!(4) = (5)(4!(3)) = (5)(4(3!(2))) = (5)(4(3(2!(1)))) = (5)(4(3(2(1)))) = (5)(4)(3)(2)(1)
$$

إذا نخلص بالمعادلة التالية:

$$
!n = n(n-1)(n-2)\cdots(1) = n!(n-1)
$$

وهكذا يكون تعريفها في بايثون:

```{python}
def factorial(n: int) -> int:
    # Recursive case
    if n > 0:
        recursive_result = factorial(n - 1)
        return n * recursive_result
    # Terminal case
    return 1

factorial(5)
```

حيث لدينا حالتان:

- عندما تكون `n > 0` يتم الاستدعاء الذاتي : `recursive_result = factorial(n - 1)` إذْ هي جملة متسلسلة تكدِّس استدعاءات فوق استدعاءات؛ لكنها تؤول في النهاية إلى الجملة التي تُنهي التسلسل
- `return 1` هي الجملة التي تنهي التسلسل

وهنا قطعة كود نستعملها لتصور تسلسل الاستدعاءات:

```{python}
#| code-fold: true

def factorial(n: int, depth: int = 0) -> int:

    # Recursive case
    print(f"{'  ' * depth}Call factorial({n})")
    if n > 0:
        result = n * factorial(n - 1, depth + 1)
        print(f"{'  ' * depth}Return {result} from factorial({n})")
        return result
    
    # Terminal case
    print(f"{'  ' * depth}Return 1 from factorial({n})")
    return 1

factorial(5)
```

- فكل استدعاء يُنشأ له إطار تنفيذ جديد تكون بالنسبة له قيمة `n` هي المعيَّنة له وقت النداء.
- وهكذا يتم تكديس الاستدعاءات حتى ينتهي التسلسل عند الاستدعاء `factorial(0)` الذي يؤول لنتيجة مباشرة: `return 1` فيخلَّى هذا الإطار من الذاكرة وتعود نتيجته إلى الإطار المباشر الذي استدعاه وهو إطار `factorial(1)`.
- فتتعين القيمة `recursive_result = 1` وينتقل إلى الجملة التي بعدها وهي جملة الرجوع بنتيجة `return n * recursive_result` وهُما معيَّنان، أي تكون الجملة في واقع إطار التنفيذ: `return 1 * 1`.
- وهذه النتيجة تعود للإطار الذي استدعاه وهو `factorial(2)` ... إلخ.

استدعاء الإجراء المتسلسل يؤدي إلى إطارات تنفيذ متداخلة تؤول إلى إطار واحد في النهاية.

يستعمل الإجراء المتسلسل وكذلك هياكل البيانات المتسلسلة بشكل كبير في الخوارزميات الفعالة.

يسهل كتابة بعض الخوارزميات باستعمال الإجراء المتسلسل. لكن قد تكون (أحياًنا) أقل أداءً من استعمال الحلقات.
