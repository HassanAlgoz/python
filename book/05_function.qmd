---
title: الإجراء
jupyter: python3
---


استعملنا في دروس سابقة **إجراءات أساسية** مثل: `print()`, `input()`, و `int()`. وأيضًا من **المكتبة الأساسية** [`math`](https://docs.python.org/3/library/math.html) مثل: `math.sqrt()` و `math.pow()`. فإن نتيجة هذه الإجراءات يكون بحسب المدخلات. والآن جاء دورُنا لنضيف إجراءات نحن نعرفها. فـ**الإجراء المعرَّفة** هي قطعة كود لها اسم. مخرجاتها مبنية على مدخلاتها.

ولكن قد تتساءل: ما هي الفائدة من تعريف إجراءات إضافية؟ فنقول: قابلية العمليَّة للتعريف ثم الاستدعاء لاحقًا يعطيها خواص أساسية في البناء التراكمي للمنطق. منها ثلاثة عناصر:

**التفكيك**: وهو ضروري للتعامل مع المنطق المعقد، نفككه إلى أجزاء، ونربطها بعد برمجة كل جزء واختباره وإتقانه.

**التجريد**: يتم تركيب المكونات على نسق جديد. قد يكون بإخفاء تفاصيل كثيرة دقيقة تحت اسم بسيط يتطلب مدخلات ويعطيك مخرجات.

**تعدد الاستعمالات**: فإذا فككنا صار الأمر قابلاً للاستعمال في مواضع متعددة، ومن المتخصص وغير المتخصص. وهذا يختصر كثيرًا من التكرار، ويسهل التعامل مع الكود، ويقلل الأخطاء، ويسرع الإنتاج.

وتوجد في بايثون إلى جانب تعريف الإجراءات، تعريف الأشياء وهي: إجراءات مع بيانات. وهذا يعني أننا نستطيع تعريف أشياء جديدة تحتوي على بيانات وإجراءات تعمل على تلك البيانات. وهذا يعطينا قدرة أكبر على التجريد والتفكيك وتعدد الاستعمالات.

يكون تعريف الإجراء بكلمة `def` يتبعها اسم الإجراء، ثم بين الأقواس تكون المدخلات. أما المُخرجات فهي ما يتبع كلمة `return`. ولاحظ أن البرنامج بتنفيذ هذه العبارة سوف يخرج من نطاق العمليَّة.

وهذا مثال لإجراء تحكم على قوة كلمة المرور:

```{python}
def check_password_strength(password):
    if len(password) > 8:
        return "Strong"
    elif len(password) > 4:
        return "Medium"
    else:
        return "Weak"
```

بعد التعريف، نريد استعمالها فنضع اسمها ثم بين القوسين نمرر المدخلات التي نريد، ونحصل على النتيجة مباشرة، فنعينها للمُعرَّف `result` في هذه الحالة:

```{python}
result = check_password_strength("shorty")
print('password is:', result)

result = check_password_strength('verylongpassword')
print('password is:', result)
```

الإجراءات لديها نطاقها الخاص. أي أن المعرَّفات المضمَّنة فيها غير معروفة إلا في نطاقها. ونحن حين نستدعي الإجراء باسمها فإن التنفيذ يقفز من السطر الذي نحن فيه ليدخل في نطاق العمليَّة، وينفذ الأوامر التي فيه حتى تنتهي أو حتى يرى كلمة `return` فيخرج التنفيذ ومعه النتيجة إلى النطاق السابق الذي استدعاها.

مثلاً هنا مُعرَّف داخل العمليَّة، وإذا حاولنا طباعته خارج نطاقها فإننا سنحصل على خطأ:

```{python}
def check_password_strength(password):
    minimum_password_length = 8
```

```{python}
#| error: true
print(minimum_password_length)
```

وهذا أمرٌ جيِّد لأننا سنستخدم إجراءات كثيرة ويرد كثيرًا أننا نستخدم أسماء متشابهة ولا نريدها أن تختلط. فكل إجراء لها مهمة محددة ويجب أن تركز على تلك المهمة فقط.

الأمر الآخر فيما يخصُّ نطاق المُعرَّفات هو أن النطاق الأخص (داخل الإجراء) يجد المعرَّفات في النطاق الأعم معروفة لديه. وذلك يتيح لنا استعمال دوال في النطاق العام مثل: `len` و `int` و `type` ونحوها.

يمكننا تعيين قيَم افتراضية للعوامل هكذا:

```{python}
def greet(name, greeting='Hello'):
    return greeting.upper() + " " + name + "!"

print(greet('Adam'))
print(greet('Belal', 'good morning'))
```

لاحظ كيف أنه في الاستدعاء الأول للإجراء `greet()`، قمنا بتمرير عامل واحد فقط، لذلك تم استخدام القيمة الافتراضية لـ `greeting`. ولكن، في الاستدعاء الثاني، قمنا بتمرير كلا العاملين فنسخت القيمة الافتراضية.

## العوامل بين الترتيب والتسمية

نفهم من تعريف الإجراء [`pow(base, exp, mod=None)`](https://docs.python.org/3/library/functions.html#pow) أن لديها ثلاثة عوامل: `base`، `exp`، و `mod` بهذا الترتيب. لاحظ أن العامل `mod` اختياري (لوجود التعيين الافتراضي `mode=None`). هذا يعني أن الإجراء يمكن استعمالها بطرق مختلفة:

```{python}
print(pow(2, 4))
print(pow(2, exp=4))
print(pow(base=2, exp=4))
print(pow(exp=4, base=2))
```

فإن أردنا تعريف عوامل تستعمل بهذه الطريقة، فإننا نضعها في التعريف على النحو التالي: 

```{python}
def calculate_bmi(weight, height, unit='metric'):
    """ Calculate the Body Mass Index (BMI)
        
        weight and height must be of the same unit.

        unit is either 'metric' or 'imperial'.
    """
    if unit == 'imperial':
        weight *= 0.453592
        height *= 0.0254
    bmi = weight / (height ** 2)
    return round(bmi, 2)
```

الآن يمكننا استعمال الإجراء بطرق مختلفة. لاحظ أن استخدام `assert` هنا للتحقق من أن الإجراء تنتج نفس القيمة بغض النظر عن كيفية تمرير العوامل.

```{python}
w = 70   # kg
h = 1.75 # meters

print(calculate_bmi(w, h))

assert (
    calculate_bmi(w, h) ==
    calculate_bmi(w, height=h) ==
    calculate_bmi(weight=w, height=h) ==
    calculate_bmi(height=h, weight=w)
)
```

ونفس الأمر بالنسبة للعامل الذي عينت له قيمة افتراضية `units='imperial'`:

```{python}
w = 154 # pounds
h = 70  # inches

print(calculate_bmi(w, h, 'imperial'))

assert (
    calculate_bmi(w, h, 'imperial') ==
    calculate_bmi(w, h, unit='imperial')
)
```


## التعليق في مقدمة الإجراء

تحتوي بايثون على إجراء أساسية تسمى `help()` تظهر معلومات عن إجراء ما:

```{python}
help(pow)
```

كذلك يمكن استعمالها في أي إجراء مُعرَّفة، فهي تأخذ التعليق الذي يبدأ بثلاثة علامات تنصيص (`"""`) بداية الإجراء (انظر كيف استعملناها في الإجراء `calculate_bmi`):

```{python}
help(calculate_bmi)
```

