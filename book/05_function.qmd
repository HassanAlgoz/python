---
title: الإجراء
jupyter: python3
---

**الإجراء** هو قطعة كود مخزَّنة قابلة للتنفيذ بمعيَّنات لاحقة؛ وذلك عبر استدعائه بالاسم.

تأمل تعريف الإجراء التالي الذي يحسب العلامة بناءً على الدرجة. فإن جملة تعريف الإجراء تبتدئ بكلمة `def` مبتوعة باسم الإجراء (`calculate_grade`)، ثم بين الأقواس تكون المدخلات / العوامل (`score`) التي يُمكن تعيينها لاحقًا. أما المُخرجات فإنَّها تخرُج بجملة الرجوع `return`.

```{python}
def calculate_grade(score):
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
```

يجوز الآن استدعاء الإجراء باسمه. و**جملة الاستدعاء** تتكون من اسم الإجراء (من غير كلمة `def`) متبوعًا بقوسين فيهما تعيين العوامل، ونتيجتها هي ما يرجع به الإجراء:

```{python}
print(calculate_grade(95))
print(calculate_grade(85))
```

فجمل الاستدعاء هذه، تسمى كذلك لأن مؤشر التنفيذ ينتقل إلى الإجراء المخزَّن فينفذ الكود الذي فيه إلى أن يصل إلى جملة الرجوع `return` التي تخرج من الإجراء بالنتيجة إلى النطاق السابق حيث **موضع الاستدعاء**.

ولا تقتصر على عاملٍ واحد. بل **تتعدد العوامل**:

```{python}
def weather_condition(temperature, humidity, wind_speed):
    if temperature >= 30 and humidity >= 60 and wind_speed >= 10:
        return "Rainy"
    elif temperature >= 20 and humidity >= 50 and wind_speed >= 5:
        return "Cloudy"
    elif temperature >= 10 and humidity >= 30 and wind_speed >= 0:
        return "Sunny"
    return "Normal"
```

ولتعيين العوامل طريقتان، وقد تستعملان معًا:

1. **تعيين بالموضع**: `weather_condition(30, 60, 10)`
2. **تعيين بالاسم** `weather_condition(temperature=30, humidity=60, wind_speed=10)` ولا يُشترط الترتيب فيه.

```{python}
cond = weather_condition(temperature=30, humidity=60, wind_speed=10)

if cond == "Rainy":
    print("Don't forget your umbrella!")
```

**ويجوز المزج بينهما بشرط تقدُّم التعيين بالموضع على التعيين بالاسم**. ولاحظ في هذا المثال جواز عدم التقيُّد بالترتيب عند التعيين بالاسم (إذ قدَّمنا `wind_speed` على `humidity` بينما هي في التعريف بعدها).

```{python}
print(weather_condition(20, wind_speed=5, humidity=50))
```

ولجعل العامل اختياريًّا تُعيَّنُ له القيمة الافتراضية `None` أو تعيَّنُ له أي قيمة افتراضيَّة أخرى فيأخذها حين لا يُعيَّن.

ففي هذا المثال يكتب الإجراء النص في ملفّ (إن تم تعيينه) وإلا فإنه يرسله لأمر `print` الذي يعرضه على الشاشة. (يأتي الكلام عن الملفات والكتابة فيها والقراءة منها في بابه إن شاء الله):

```{python}
def log_message(message, filename=None):
    if filename is not None:
        file = open(filename, 'a')
        file.write(message + "\n")
        file.close()
    else:
        print(message)
```

ثم الآن نستدعي الإجراء بعامل واحد، ومرة بعاملين:

```{python}
log_message("Hello, screen!")
log_message("Hello, to the log file!", "log.txt")
```

لاحظ في الإجراء السابق `log_message` عدم وجود جملة رجوع (`return`). وهذا ما نسميه **الإجراء غير المنتج** (`void`)؛ أي: الإجراء الذي مخرجاته تكون في غير موضع الاستدعاء. إذ لا بُد للإجراء من نتيجة، إلا أنها غير مباشرة.

وأي إجراءٍ لا يجد فيه مترجم بايثون كلمة `return` فإنه يُدرجها في آخره بالرجوع بلا شيء: `return None`.

ومن مميزات الإجراء المعرَّف أنَّ له نطاقًا خاصًّا؛ فما يُعرَّفُ داخله يبقى في نطاقه ولا يُعرَف خارجه. ويسمى هذا **نطاق التسمية**:

```{python}
def calculate_bmi(weight, height):
    bmi = weight / (height ** 2)
    return round(bmi, 2)
```

فنتوقع وقوع خطأ هنا لأن `bmi` غير معرفة إلا في نطاق الإجراء:

```{python}
#| error: true

print(bmi)
```

لكن نطاق التسمية الذي داخل الإجراء، هو نفسه داخل نطاقٍ أشمل منه. ففي هذا المثال نجد استعمال `len` الذي هو إجراء تم تعريفه في نطاق أشمل (ضمن الإجراءات الأساسية في اللغة)، وكذلك الأمر في المتغير `MAX_LEN` إلا أنه دونه في الشمول:

```{python}
MAX_LEN = 8

def check_password_strength(password):
    if len(password) > MAX_LEN:
        return "Strong"
    return "Weak"
```

أما استعمالنا للأحرف الكبيرة، فهو عُرفٌ يقضي بأنَّنا سنلتزم بعدم تغييره. وكثيرًا ما يستعمل ذلك فيما هو من الإعدادات العامَّة التي تضبط سلوك البرنامج.

ومن قوَّة الإجراءات أنها **تتركب** من إجراءات أخرى. فهنا نركِّب من `sum` و `len` إجراء حساب المتوسط `mean`:

```{python}
def mean(numbers):
    return sum(numbers) / len(numbers)
```

ولأنَّ القطع هذه معزولة عن غيرها فإن **اختبارها** سهلٌ بالجمل التوكيدية.

```{python}
assert mean([10, 10, 20, 20]) == 15
assert mean([-10, 10, -10, 10]) == 0
```

ولدينا الآن ثقة بما تم اختباره فنعتمد عليه ونستعمله في كل موضع. بل إنَّ من الممارسات التي ننصح بها ألا تكتب الإجراء بنفسك إن كان فيه تعقيدٌ ويوجد من قد كتبه قبلك واختبره ووضعه في المكتبة البرمجية.

وأحيانًا نحتاج أن نعرِّف الإجراء، لكننا لا نريد كتابة تفاصيله الآن. لذلك نستعمل كلمة `pass` لإرضاء مترجم اللغة:

```{python}
def todo_later():
    pass
```

نكتفي بهذا القدر ونؤجل الحديث عن التجريد والتركيب إلى [باب الأصناف](14_classes.qmd).