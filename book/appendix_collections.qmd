---
title: المجموعة
jupyter: python3
---

```{mermaid}
%% | fig-cap: الأنواع المجردة حول المجموعة (Collection)
%% | label: fig-sequences-tree
classDiagram
    class Container {
        <<abstract>>
        +__contains__()
    }

    class Iterable {
        <<abstract>>
        +__iter__()
    }

    class Iterator {
        <<abstract>>
        +__next__()
        +__iter__()
    }

    class Reversible {
        <<abstract>>
        +__reversed__()
    }

    class Sized {
        <<abstract>>
        +__len__()
    }

    class Collection {
        <<abstract>>
        +__contains__()
        +__iter__()
        +__len__()
    }

    class Sequence {
        <<abstract>>
        +__getitem__()
        +__len__()
        +__contains__()
        +__iter__()
        +__reversed__()
        +index()
        +count()
    }

    class MutableSequence {
        <<abstract>>
        +__getitem__()
        +__setitem__()
        +__delitem__()
        +__len__()
        +insert()
        +append()
        +clear()
        +reverse()
        +extend()
        +pop()
        +remove()
        +__iadd__()
    }

    class Set {
        <<abstract>>
        +__contains__()
        +__iter__()
        +__len__()
        +__le__()
        +__lt__()
        +__eq__()
        +__ne__()
        +__gt__()
        +__ge__()
        +__and__()
        +__or__()
        +__sub__()
        +__xor__()
        +isdisjoint()
    }

    class MutableSet {
        <<abstract>>
        +__contains__()
        +__iter__()
        +__len__()
        +add()
        +discard()
        +clear()
        +pop()
        +remove()
        +__ior__()
        +__iand__()
        +__ixor__()
        +__isub__()
    }

    class Mapping {
        <<abstract>>
        +__getitem__()
        +__iter__()
        +__len__()
        +__contains__()
        +keys()
        +items()
        +values()
        +get()
        +__eq__()
        +__ne__()
    }

    class MutableMapping {
        <<abstract>>
        +__getitem__()
        +__setitem__()
        +__delitem__()
        +__iter__()
        +__len__()
        +pop()
        +popitem()
        +clear()
        +update()
        +setdefault()
    }

    Iterable <|-- Iterator
    Iterable <|-- Reversible
    Sized <|-- Collection
    Iterable <|-- Collection
    Container <|-- Collection
    Reversible <|-- Sequence
    Collection <|-- Sequence
    Sequence <|-- MutableSequence
    Collection <|-- Set
    Set <|-- MutableSet
    Collection <|-- Mapping
    Mapping <|-- MutableMapping
```


**ملاحظة**: في هذا الدرس سوف نرمز للمفرد بـ`x` ولما يدل على مجموعة بـ`xs`.

عرفت بايثون **المجموعة** (Collection) أنها حاوية محجَّمة قابلة للتكرار.

- **الحاوية** (`Container`) هي ما يقبل: `x in xs`
- **المحجَّمة** (`Sized`) هي ما يقبل: `len(xs)`
- **القابلة للتكرار** (`Iterable`) هي ما يقبل: `for x in xs`

ومن جنس المجموعة أربعة أنواع أساسية، متعددة لاختلافها في أربعة صفات:

- الترتيب أو عدمه
- التغير أو الثبات
- الوجود الفعلي أو المؤجَّل
- الوصول بالموضع أو بالرقم

درسنا اليوم عن شكل من أشكال مجموعة البيانات عندما تكون مرتبة. وهذا الشكل يسمى **بالتسلسل** (Sequence) ويشمل:

**القائمة** ([`list`](https://docs.python.org/3/library/stdtypes.html#list)) قابلة للتغيير ومرتبة ولها حد. ونظيرها الذي لا يقبل التغيير هو الصف ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple))

و**النص** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) صفٌّ مرتَّب.

و**المجال** ([`range`](https://docs.python.org/3/library/stdtypes.html#range)) ثابت مرتَّب إلا أن عناصره مؤجَّلة (فليس موجودة بالفعل إلا عند طلبها).

نعرض هنا لأربعة أنواع أساسية في بايثون كلها من صنف **مجموعة** (`Collection`):

- **القائمة** (`list`) وهي متتالية قابلة للتغيير (`Mutable Sequence`)
- **الصف** (`tuple`) وهو متتالية غير قابلة للتغيير (`Immutable Sequence`)
- **المجموعة الرياضية** (`set`) وهي مجموعة غير مرتبة (Unordered `Collection`)
- **القاموس** (`dict`) وهو دالة روابط فردية (`MutableMapping`)

عرفت بايثون **المجموعة** أنها حاوية محجَّمة قابلة للتكرار.

- **الحاوية** (`Container`): تقبل استعلام `in`
- **المحجَّمة** (`Sized`): تقبل `len()`
- **القابلة للتكرار** (`Iterable`): تقبل `for`

1. `Sized.__len__()`: get the length of the collection using the `len` function
2. `Iterable.__iter__()`: loop over the collection using a `for` loop
3. `Container.__contains__()`: use the `in` operator to check if an item is in the collection

The use of the two underscores (`__`) before and after the operation name is a Python convention that indicates that the operation is supported with language syntax: `+`, `in`, `for`, and so on.

See:

- [collections.abc](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)
- [`collections`](https://docs.python.org/3/library/collections.html#module-collections)

Let's see what this means in practice.

Let's say we have a list of objects which we want to calculate some statistics on. We can use the following list as an example:

```{python}
things = [10, 20, 30, 40, 'abb', 2.0, True]
```

We can get the length of the list using the `len` function. For example:

```{python}
length = len(things)
print(length)
```

We can loop over the list using a `for` loop. For example:

```{python}
for t in things:
    print(t)
```

We can check for the presence of an item in the list using the `in` operator. For example:

```{python}
check1 = 30 in things
check2 = 100 in things
print(check1)
print(check2)
```

These were just to illustrate what it means for an Object to implement the Collection Abstract Base Class (ABC). Let's turn our attention to a concrete built-in implementation of a widely used type of collection: the `list`.

## List

A `list` is a `Mutable Sequence`. Which is a `Reversible`, `Collection`. This means that it supports the following operations:

From being a `Collection`, it supports:

1. `__len__`: get the length of the list using the `len` function
2. `__iter__`: loop over the list using a `for` loop
3. `__contains__`: use the `in` operator to check if an item is in the list

From being a `Reversible`, it further supports:

1. `__reversed__`: reverse the list using the `reversed` function

From being a `Sequence`, it further supports:

1. `__getitem__`: get an item from the list using the `[]` operator
2. `index`: get the index of an item in the list
3. `count`: count the number of occurrences of an item in the list

From being a `MutableSequence`, it further supports:

1. `__setitem__`: set an item in the list using the `[]` operator
2. `insert`: insert an item into the list at a specific index
3. `append`: add an item to the end of the list
4. `extend`: add all items from another list to the end of the list
5. `__delitem__`: delete an item from the list using the `del` operator
6. `pop`: remove and return an item from the end of the list
7. `remove`: remove the first occurrence of an item from the list
8. `clear`: remove all items from the list

This is the full specification of the [`list`](https://docs.python.org/3/library/stdtypes.html#list) class as inferred from the [ABC](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes).

### Note on Mutability

A crucial distinction is made in programming on where objects are **mutable** or **immutable**. This is important when we have multiple references to the same object. If the object is mutable, we have to synchronize the reads/writes to the object. However, if such synchronization is error-prone, then we can fix this by changing the design of the program, to make the object immutable and avoid the need for synchronization. This is a fundamental concept in concurrent programming (when multiple threads are reading/writing to the same object). A topic for another day.

## Mapping

A [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) is a mutable collection of key-value pairs. The keys must be [hashable](https://docs.python.org/3/glossary.html#term-hashable) (like: `str`, `int` and `tuple`), and the values can be any object. It is a `MutableMapping`. It supports:

- `__len__`: get the number of key-value pairs
- `__iter__`: iterate over the keys
- `__contains__`: check if a key is in the dictionary
- `__getitem__`: get the value associated with a key
- `__setitem__`: set the value associated with a key
- `__delitem__`: delete a key-value pair
- `get`: get the value associated with a key, or a default value
- `pop`: remove a key-value pair and return the value
- `popitem`: remove and return an arbitrary key-value pair
- `clear`: remove all key-value pairs
- `update`: update the dictionary with another dictionary
- `setdefault`: get the value associated with a key, or set it to a default value
- `keys`: get a view of the keys
- `values`: get a view of the values
- `items`: get a view of the key-value pairs

Update (Python 3.7): Dictionaries are now ordered. In Python 3.6 and earlier, dictionaries are unordered.

يعرف القاموس على النحو التالي:

```{python}
data = {'key1': 'value1', 'key2': 'value2'}
```

لكن حين تكثر القيم نفردها على الأسطر لتكون أوضح للقراءة (وليس هذا بلازم):

```{python}
data = {
    'key1': 'value1',
    'key2': 'value2',
}
```

There are different ways to create a dictionary. Dictionaries compare equal if and only if they have the same (key, value) pairs (regardless of ordering).

```{python}
d = {
    'foo': 10,
    'two': 20,
    'three': 30,
}

d2 = {
    'three': 30,
    'two': 20,
    'foo': 10,
}

d3 = dict(foo=10, two=20, three=30)

assert d == d2 == d3
```

You can also construct a dictionary from two lists (iterables) with `zip`, like so:

```{python}
students = ['Ahmad', 'Belal', 'Careem', 'David']
marks = [90, 80, 75, 85]
data = dict(zip(students, marks, strict=True))
data
```

### Access

You can get the number of pairs using the `len()` function.

```{python}
len(data)
```

The index operator (`[]`) is used to access the value associated with a given `key`. Like so: `dict[key]`.

```{python}
d["foo"] == d.get('foo')
```

The `.get(key, default=None)` method returns `None` or a default value provided in the 2nd argument.

```{python}
assert 'five' not in d
d.get("five", 5000)
```

Three ways to iterate over a `dict`:

- Iterate over keys: `for key in d.keys()`
- Iterate over values: `for value in d.values()`
- Iterate over key-value pairs: `for key, value in d.items()`

```{python}
d = {
    "Saudi Arabia": "Riyadh",
    "Egypt": "Cairo",
    "Turkey": "Ankara",
    "Indonesia": "Jakarta",
    "Pakistan": "Islamabad",
}
```

```{python}
for key in d.keys():
    print(key)
```

```{python}
for value in d.values():
    print(value)
```

```{python}
for key, value in d.items():
    print(key, value)
```

### Mutation

You can update dictionary values by simply assigning a new value to a key.

```{python}
d["one"] = 1000
d
```

Or you may want to update using another dictionary.

```{python}
u = {
    'three': 3000,
    'four': 40,
}

d.update(u)
d
```

You may take out a value:

```{python}
d = {'one': 100, 'two': 200}
value = d.pop('two')
assert 'two' not in d
assert value == 200
```

You may want to just delete a pair.

```{python}
if 'two' in d:
    del d['two']
assert 'two' not in d
```
