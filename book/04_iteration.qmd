# التكرار

تقدم معنا أن  **حلقة التكرار**: هي الرجوع بالتنفيذ لجملة سابقة (غالبًا تكون سطرًا سابقًا) وذلك يحصل عددًا من المرات حتى تحقق أمرٍ معيَّن.

وللتكرار طريقتان:

- **التكرار بمتوالية** (`for`)؛ إذ يتوقف عدد مرات التكرار على عدد العناصر الناتجة من المتوالية التي يجري عليها التكرار.
- **التكرار بشرط** (`while`)؛ إذ يستمر التكرار مادام الشرط متحققًا.

## التكرار بشرط

نبدأ بالتكرار بالطريقة غير المحددة، وهي جُملة تبدأ بالكلمة `while` على النحو التالي.  كأنها `if` متكررة إلى حين تخلُّف الشرط (أن يصبح `False`). وإن لم يتحقق الشرط أصلاً فلا ينفذ الكود المضمَّن أصلا:

```python
while <boolean expression>:
    <code>
```

مثال:

```{python}
i = 0
while i < 5:
    print(i)
    i += 1
print('Done')
```

لنقم بتتبع الخطوات عندما تكون `i = 0`:

1. `0 < 5` تؤول `True`، فنطبع `0` ونزيد `i` لتصبح 1
2. `1 < 5` تؤول `True`، فنطبع `1` ونزيد `i` لتصبح 2
3. `2 < 5` تؤول `True`، فنطبع `2` ونزيد `i` لتصبح 3
4. `3 < 5` تؤول `True`، فنطبع `3` ونزيد `i` لتصبح 4
5. `4 < 5` تؤول `True`، فنطبع `4` ونزيد `i` لتصبح 5
6. `5 < 5` تؤول `False`،فنخرج من الحلقة
7. نطبع `Done`

وهذا تصوير لسير الأوامر لنفس الكود. ملاحظة: اضغط على الزر `Prev` أو `Next` للتنقل بين خطوات التنفيذ الفعلية:

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=i%20%3D%200%0Awhile%20i%20%3C%205%3A%0A%20%20%20%20print%28i%29%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28'Done'%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>

لاحظ أن نسيان جملة الزيادة (`i += 1`) يجعل الشرط دائمًا صحيحًا، فيدور البرنامج في **حقلة لا نهيائة** ولا يخرج أبدًا. ويعتبر هذا خطأ برمجيًّا يتعذر على الكود التعامل معه بنفسه؛ بل يجب على المبرمج أن يكتشفه.

### الاستمرار في أخذ المعطيات من المستخدم

توفر بايثون إجراءات للتعامل مع المدخلات والمخرجات بالنسبة للبرنامج. ومن ذلك إجراء `input` الذي يأخذ مدخلات مباشرةً من لوحة الأوامر. فهو يقطع سير البرنامج ليمنح المستخدم الوقت بإدخال حروف للوحة الأوامر ويتنظر حتى تأتيه إشارة الإتمام (وذلك عندما يضغط المفتاح `Enter`) فتخزَّن هذه الحروف في معرَّف نوعه: نص؛ يمكن استعماله فيما بعد.

نستطيع بناء لعبة تخمين بحيث نكرر الطلب من المستخدم إلى أن يُخمِّن الرقم الذي أضمره البرنامج له:

```python
num = "9"
guess = input("Guess the number (0-9): ")
while guess != num:
    guess = input("Try again: ")
print("You guessed it!")
```
1. السطر الأول تعريف لقيمة نصية مكوَّنة من حرف واحد هو الرقم `9`.
2. السطر الثاني هو الأمر الذي ينتظر فيه من المستخدم أن يُدخل أحرُفًا.
3. السطر الثالث والرابع هما جملة التكرار بشرط؛ فهي تتكرر إلى أن يطابق الحرف الذي أدخله المستخدم مع الحرف الذي في المعرَّف `num`. لاحظ أننا نعيد تعيين نفس المعرَّف `guess` إلى أن نخرج من هذه الحلقة.
4. السطر الأخير إذا وصلنا إليه علمنا أن الشرط انتفى (الحرف مطابق) وبالتالي نعرف أنه فعلاً قد خمَّنه.

قد يبدو الأمر تافهًا؛ لكن هكذا تعمل برامج الخوادم التي تستقبل الطلبات بشكل مستمر. فإنها تدخل حلقة لانهائية تأخذ فيها الطلبات من المستخدمين ليتم معالجتها والرد عليهم.

ملاحظة جانبية: إذا كنت تريد أن تكون المدخلات من المستخدم سريَّة عند الإدخال فاستعمل `getpass` بدلاً من `input` وستظهر الحروف على شكل نجوم `*` وليست نفسها التي تظهر:

```python
import getpass

x = getpass.getpass()
```

الآن المعرَّف `x` يحتوي على القيمة المدخلة. نجرب طباعته لنتحقق من ذلك.

```python
print(x)
```

### الخروج من الحلقة

- تستخدم كلمة [`break`](https://docs.python.org/3/reference/simple_stmts.html#break) لإيقاف عملية التكرار كلها.
- تستخدم كلمة [`continue`](https://docs.python.org/3/reference/simple_stmts.html#continue) للانتقال إلى الكرة التالية متخطيةً بقية الخطوات في الكرة الحالية.

أولاً نمثل لاستعمال جملة `break` على النحو التالي:

```{python}
i = 0
while i < 5:
    if i == 3:
        break
    print(i)
    i += 1
print('Done')
```

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=i%20%3D%200%0Awhile%20i%20%3C%205%3A%0A%20%20%20%20if%20i%20%3D%3D%203%3A%0A%20%20%20%20%20%20%20%20break%0A%20%20%20%20print%28i%29%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28'Done'%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>

وهذا مثال لاستخدام عبارة `continue` للتخطي:

```{python}
i = 0
while i < 5:
    if i == 3:
        i += 1
        continue
    print(i)
    i += 1
print('Done')
```

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=i%20%3D%200%0Awhile%20i%20%3C%205%3A%0A%20%20%20%20if%20i%20%3D%3D%203%3A%0A%20%20%20%20%20%20%20%20i%20%2B%3D%201%0A%20%20%20%20%20%20%20%20continue%0A%20%20%20%20print%28i%29%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28'Done'%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>

أما جملة `break` المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط، ولا يتوقف الخارجي. وهذا مثال:

```{python}
i = 0
while i < 3:
    j = 0
    while j < 3:
        if i == 1:
            break
        print(i, j)
        j += 1
    i += 1
print('Done')
```

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=i%20%3D%200%0Awhile%20i%20%3C%203%3A%0A%20%20%20%20j%20%3D%200%0A%20%20%20%20while%20j%20%3C%203%3A%0A%20%20%20%20%20%20%20%20if%20i%20%3D%3D%201%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20break%0A%20%20%20%20%20%20%20%20print%28i,%20j%29%0A%20%20%20%20%20%20%20%20j%20%2B%3D%201%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28'Done'%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>


## التكرار بمتوالية

تعرف بايثون **المتوالية** ([`Iterable`](https://docs.python.org/3/glossary.html#term-iterable)) بأنه الشيء الذي يُنتج عنصرًا في كل كرة، وذلك لأنه يطبق عملية `__iter__`. ويندرج تحته في لغة بايثون **المُكَرِّر** ([`Iterator`](https://docs.python.org/3/tutorial/classes.html#iterators)) وهو الشيء الذي يتحكم بعملية التكرار، وذلك لأنه يطبق عملية `__next__` .. وهذا يهمنا حين نريد أصناف تكون من جنس المتوالية أو المكرر. لكن الذي يهمنا الآن معرفة الأنواع الموجودة التي هي من جنسها.

فمن المتوالياتا في المكتبة الأساسية:

1. **المجموعة** ([Collection](https://docs.python.org/3/library/collections.html)) وهي مجموعة محدودة من العناصر.
2. **المولِّد** ([Generator](https://docs.python.org/3/tutorial/classes.html#generators)) وهو ما يُنتج عناصر (قد يكون محدودًا وقد لا يكون).

المهم أن نعرف أن الشيء الذي يُساق في جملة التكرار المبتدأة بكلمة `for` هو متوالية. وجملة التكرار بمتوالية لها هذا الشكل:

```python
for item in iterable:
    ...
```


وفي المثال التالي، لدينا مجموعة من الأرقام المرتبة، وضعناها للتكرار لتنتج لنا في كل كرة عنصرًا يتم تعيينه للمتغير `x` ليجري الكود في الداخل به:

```{python}
for x in (30, 10, 20, 40, 50, 60):
    print(x)
```

وكل ما تراه في قطعة الكود التالية هو من جنس ما يقبل التكرار (متوالية):

```python
# list of 3 elements
for element in [10, 20, 30]:
    print(element)

# tuple of 3 elements
for element in (10, 20, 30):
    print(element)

# dictionary of 2 elements
for key in {'one': 100, 'two': 200}:
    print(key)

# string of 3 characters
for char in "abc":
    print(char)

# file of lines
for line in open("myfile.txt"):
    print(line, end='')
```

لا تقلق فيما لم يتم تغطيته حتى الآن، فسيأتي الكلام عنه في وقته إن شاء الله.

وهذا مثال آخر:

- نعرف قائمة أرقام، ثم نعرف قائمتين خاويتين، ثم نستعمل التكرار لترشيح الأرقام الزوجية في القائمة الزوجية، والأرقام الفردية في القائمة الفردية.
- أما علامة `%` فتعني باقي القسمة؛ فإذا كان باقي القسمة من العدد اثنان صفرًا فهو عدد زوجي، وإلا فهو عدد فردي.


```{python}
numbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
evens = []
odds = []

for x in numbers:
    if x % 2 == 0:
        evens.append(x)
    else:
        odds.append(x)

print('list of evens:', evens)
print('list of odds:', odds)
```

## النطاق

يمثل **النطاق** ([`range`](https://docs.python.org/3/library/functions.html#func-range)) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فهي ثلاثة عوامل تحدده:

1. **البداية** (`start`): مشمول ، وقيمته الافتراضية `0`.
2. **النهاية** (`stop`): غير مشمول ، وتم تعريف النطاق بحيث لا يُمكن إهمال النهاية.
3. **الخطوة** (`step`): مقدار الزيادة أو النقص للعدد التالي ، وقيمته الافتراضية `1` (أي: الزيادة بواحد).

دعونا الآن نلقي نظرة على التعريف كما هو موجود في وثائق بايثون، وذلك لنتعلم كيف نقرؤ التعريف. [ادخل الرابط](https://docs.python.org/3/library/stdtypes.html#range) وتأمل معي ..

- `class range(stop)`
- `class range(start, stop[, step])`

أولاً: نلاحظ كلمة `class` في الابتداء وهذا يعني أنه صِنف وليس إجراءً.

ثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما تعمل به بايثون؟

نجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو `stop` وتأخذ البداية والخطوة فيمتهما الافتراضية: `start=0` و `step=1` حسب ما كُتب:

> If the step argument is omitted, it defaults to 1.
>
> If the start argument is omitted, it defaults to 0

```{python}
for i in range(5):
    print(i)
```

أما التعريف الثاني فيجب تفكيكه لنفهمه:  `class range(start, stop[, step])`.

وجود الأقواس المربعة `[ ]` يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو `start, stop`؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الافتراضية `step=1`.

```{python}
for i in range(5, 10):
    print(i)
```

أما إذا عينت الثلاثة جميعًا فسيكون الأول `start` والثاني `stop` والثالث `step`:

```{python}
for i in range(0, 10, 2):
    print(i)
```

ولك أن تعكس النطاق بتعيين `step` بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:

```{python}
for i in range(10, 0, -1):
    print(i)
```

ومن السياقات التي يستعمل فيها النطاق، أن تكرر على قائمة أرقام بخطوة معيَّنة، على النحو التالي:

```{python}
numbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
for i in range(1, len(numbers), 2):
    print(numbers[i])
```

- السطر الأول: تعيين قائمة الأرقام للمعرَّف `numbers`.
- السطر الثاني جملة مركَّبة من ثلاثة:
    - أولاً من الداخل: `len(numbers)` يعطينا عدد العناصر في القائمة.
    - ثانيًا نخرج قليلاً إلى إنشاء النطاق: `range(1, len(numbers), 2)` فيها:
        - البداية `1`
        - والنهاية `len(numbers)`
        - والخطوة `2`
- السطر الثالث: يأخذ من القائمة العنصر بالرقم الذي يتم تعيينه للمعرَّف `i` في كل كرة.


## خلاصة

تعرفنا في الدرس على شيء هو من أقوى البُنى البرمجية وهو التكرار. تعلمنا كيف نستعمل جملة التكرار بنوعيها: التكرار بشرط والتكرا بمتوالية. وتعرفنا على النطاق المحدد واستعمالاته المختلفة. وأيضًا عرفنا كيف نوقف التكرار عند الحاجة لذلك بجملة `break` أو جلمة `continue`.

يأتي في الدرس القادم الكلام عن [الإجراء](05_function.qmd): وهي مجموعة جمل برمجيَّة لها اسم.