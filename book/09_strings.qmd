---
title: النصوص
jupyter: python3
---

**النص** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) تسلسل من الأحرف. وإذا أردنا أن نكون أكثر دقَّة فنقول: هو تسلسل من أرقام يونيكود (Unicode) التي تمثل الأحرف، وهو ترميز عالمي يحوي جميع أحرف اللغات بالإضافة إلى علامات الترقيم ورموز الإموجي وغيرها.

النص يطول ويقصر من الحرف الواحد إلى الكلمة إلى الجملة إلى آخره:

- محادثات وسائل التواصل الاجتماعي
- رسائل البريد الإلكتروني
- مقالات
- كتب
- موسوعات

وكذلك يمكن أن تكون له بنية حُرَّة كما هو حال اللغات البشرية وقد يكون له قالب قابت يحدد بنيته مثل: `XML`, `HTML`, `JSON`, `CSV`، وغيرها. وتلك تستخدم .لتمثيل البيانات بصيغة نصية **مفهومة للبشر وللآلة**. سيأتي الحديث عنها إن شاء الله.

فتطبيقات العمل على النصوص كثيرة ومتنوعة كثيرة مثل: البحث، الاستبدال، العد، الفهرسة، القولبة، التصنيف، الترتيب، ...إلخ.

## تعريف النصوص

قيمة النص تحدد:

- بعلامة اقتباس مفردة: `'السلام عليكم!'`
- بعلامة اقتباس مزدوجة: `"السلام عليكم!"` وليس بينهما فرق تمامًا.
- بعلامة اقتاس مكررة ثلاثة مرات: `"""السلام عليكم!"""` وذلك للنصوص التي تمتد على أكثر من سطر.

مثلاً:

```{python}
name = 'Adam'
address = "Riyadh, Saudi Arabia"
```

ولاحظ هذا النص الذي يبتدئ في السطر الأول ويتمد لأربعة أسطر:

```{python}
message = """Salam everyone,
I hope you are enjoying the course,

Thank you.
"""
print(message)
```

ولكون النص تسلسلاً فإنه يدعم جميع عمليات التسلسل السابقة ذكرها (انظر [فصل التسلسل](06_sequences.qmd)). وهو فوق ذلك يدعم عمليات خاصلة بتسلسل الأحرف.

- الإشارة: `s[i]`
- معرفة موضع شيء (إن وجد): `s.index(x)`
- عد تكرارات شيء: `s.count(x)`
- معرفة الطول: `len(s)`
- التكرار: `for x in s`
- العضوية: `x not in s`

```{python}
s = 'Arabian'

first = s[0]
last = s[-1]
print(first + last)
```

```
 0   1   2   3   4   5   6   7
 +---+---+---+---+---+---+---+
 | A | r | a | b | i | a | n |
 +---+---+---+---+---+---+---+
-7  -6  -5  -4  -3  -2  -1
```

#### جرب

- `s[1:5]`
- `s[1:5:2]`
- `s[::2]`
- `s[::-1]`

لاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:

```{python}
s = ('A', 'r', 'a', 'b', 'i', 'a', 'n')
first = s[0]
last = s[-1]
print(first + last)
```

فالنص ، مثل الصف وبخلاف القائمة، **غير قابل للتغيير**. فلو حاولت تغيير حرف في النص. ستحصل على خطأ:

```{python}
#| error: true
s = 'Arabian'
s[0] = 'a'
```

لكن يمكنك تعديل النص بإنشاء نص جديد:

```{python}
s = 'Arabian'
s = 'a' + s[1:]
print(s)
```

لاحظ أننا أسندنا النص الجديد إلى المتغير `s`، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.

## العمليات الخاصة بالنصوص

لاستبدال جزء من النص، نستخدم إجراء `.replace()`:

```{python}
s = 'Arabian'
s = s.replace('ian', 'y')
print(s)
```

كما لدينا علميات `.strip()` لإزالة المسافات البيضاء من بداية ونهاية النص.

```{python}
assert '  Arabian  '.strip() == 'Arabian'
```

وكذلك لدينا عمليات **البحث**:

- التحقق من البدء والنهاية وما بينهما: `.startswith(prefix)` و `.endswith(suffix)` أو `sub in string` وهي أعم.
- لمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص `.find()`

```{python}
s = 'Arabian'
assert s.startswith('A')
assert not s.startswith('a')
assert s.endswith('n')
assert 'rabia' in s
assert s.find('a') == 2
```

انظر ملحق [أنماط السلاسل](zz_regex.qmd) للتعمق في علميات البحث والاستبدال بأنماط معقدة.

**الفصل والوصل**:

- فصل النص لقائمة: `list.split(seperator)`
- دمج القائمة إلى نص: `seperator.join(list)`

```{python}
csv = "Adam,25,Riyadh"
assert csv.split(',') == ['Adam', '25', 'Riyadh']
```

```{python}
csv = """name,age,city
Adam,25,Riyadh
Belal,30,Jeddah
Camal,35,Dammam
"""

csv = csv.strip()

data = []
for line in csv.split(sep='\n'):
    d = line.split(sep=',')
    data.append(d)
data
```

وهذا مثال للوصل:

```{python}
data = ['Adam', '25', 'Riyadh']
csv = ','.join(data)
assert csv == 'Adam,25,Riyadh'
```


**تفسير الأرقام** المكتوبة كسلسلة من الحروف، وهذا تكثر الحاجة إليه عندما نقرأ ملفات أو نتعامل مع بيانات مُدخلة من المستخدم، إذ دائمًا ما يكون الإدخال على شكل نصوص:

- `int(x)` لتحويل سلسلة نصية إلى عدد صحيح.
- `float(x)` لتحويل سلسلة نصية إلى عدد عشري.

لاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:

```{python}
x = '20'
y = '40'
print(x + y)
```

الواجب تحويلهما إلى أعداد أولاًً:

```{python}
x2 = float(x)
y2 = float(y)
print(x2 + y2)
```

وهنا عمليات **خاصة بالنصوص الإنجليزية**:

- `upper()` لتحويل النص إلى حروف كبيرة.
- `lower()` لتحويل النص إلى حروف صغيرة.
- `capitalize()` لتحويل الحرف الأول إلى كبير.
- `title()` لتحويل النص إلى حالة عنوان.

```{python}
name = 'Adam ibraheeM'
print(name.upper())
print(name.lower())
print(name.capitalize())
print(name.title())
```

وانظر [مستندات النصوص](https://docs.python.org/3/library/stdtypes.html#string-methods) لمعرفة كافة الإجراءات الممكنة على النصوص.

## تنسيق السلاسل النصية

نستعرض ثلاث طرق لدمج السلاسل النصية في بايثون:

1. الأولى: تحويل الشيء إلى نص قبل دمجه مع النص..
2. الثانية: استعمال فراغات `{}` مع الإجراء `.format()` لتمرير ما يحل فيها.
3. الثالثة: استعمال `f-string` بأن تضع الحرف `f`  قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل القواس المعكوفة `{}`. وهي الطريقة التي نفضلها.

```{python}
name = "John"
lvl = 300

x1 = "I am " + name + " and I want to reach level " + str(lvl) # + operator
x2 = "I am {} and I want to reach level {}".format(name, lvl)  # .format() method
x3 = f"I am {name} and I want to reach level {lvl}"            # f-strings
assert x1 == x2 == x3
print(x1)
```

#### جرب

اطبع الجملة `"Hello, my name is John Doe. and I am 30 years old"`. باستخدام المتغيرات `first_name`، `last_name`، و `age` عبر الطرق الثلاث المذكورة آنفًا:


## ترميز الحروف

**ترميز الحروف** هي عملية تعيين أرقام للأحرف الرسومية مما يسمح بتخزينها ونقلها وتحويلها باستخدام الحواسيب الرقمية.

**رموز ASCII** تحتوي على `128` حرف للغة الإنجليزية وبعض علامات الترقيم. منها `95` فقط هي أحرف قابلة للطباعة أما البقية فتسمى أحرف تحكُّم (مثل حرف السطر الجديد `\n` ، وحرف الرجوع لبداية السطر `\r`).

ثم امتدت عن طريق **رموز ANSII** لتغطي أحرف إضافية (من `128` إلى `255`) وهي الأحرف الاتينية للغات الأخرى.


لنستكشف السلاسل عن طريق حزمة من المكتبة الأساسية `string`. الآتي الأحرف اللاتينية الكبيرة والصغيرة، وعلامات الترقيم:

```{python}
import string

print(string.ascii_letters)
print(string.punctuation)
```


## ترميز Unicode

واليوم **رموز Unicode** تحتوي على أكثر من **مليون حرف** لتغطية لغات العالم كافة: اللاتينية، اليونانية، السيريلية، الأرمنية، العبرية، **العربية**، السريانية، الثانا، الديفاناغارية، البنغالية، الجورموخية، الأورية، التاميلية، التيلوغوية، الكانادية، المالايالامية، السنهالية، التايلاندية، اللاوية، التبتية، الميانمارية، الجورجية، الهانغول، الإثيوبية، الشيروكية، الرموز الكندية الأصلية، الخميرية، المنغولية، الهان (الأيدوغراف الياباني، الصيني، الكوري)، الهيراغانا، الكاتاكانا، واليي. [المصدر](https://www.unicode.org/faq/basic_q.html#:~:text=The%20simplest%20answer%20is%20that,%2C%20Myanmar%2C%20Georgian%2C%20Hangul%2C). وما يزال أول `128` حرف منها متطابق مع رموز ASCII.


### مثال

ماذا يحصل لو كتبنا حروف عربية ثم حاولنا حفظ الملف بترميز ASCII ولم نحفظه بترميز Unicode؟

![برنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات](assets/save_ascii_arabic.png)

الخطأ يقول: "This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?"


## كيف يتم تمثيل النصوص في بايثون؟

تمثيل النصوص في بايثون يكون عن طريق النوع `str`؛ يُعرَّف بكتابة سلسلة من الأحرف لكن في الواقع تتحول إلى سلسلة من رموز Unicode (أي: أرقام). هذا يعني أنها قد تكون سلسلة رموز لاتينية أو عربية أو صينية أو غير ذلك مما تحويه رموز Unicode.

الدالة المدمجة **ord()** تقوم بتحويل الحرف إلى رقم الرمز. بينما **chr()** تعكس ذلك (من الرمز إلى الحرف).

على النقيض من سي وجافا؛ لا يوجد نوع خاص بالحرف الواحد (`char`) في بايثون.


```{python}
print(ord("A"), ord("Z"))
print(chr(65), chr(90))
print(ord("a"), ord("z"))
print(ord("0"), ord("9"))
```

ماذا عن الحروف العربية؟ أين تقع في أرقام ترميز Unicode؟

```{python}
# Arabic Unicode points are between 1536 and 1791
print(ord("أ"), hex(ord("أ")))
print(ord("ب"), hex(ord("ب")))
print(ord("ي"), hex(ord("ي")))
print(ord('َ'), hex(ord('َ')))
print(ord('ُ'), hex(ord('ُ')))
```

إذا أردنا أن نعرف أرقام الحروف في نصٍّ ما، فيمكن أن نستعمل التكرار على النحو التالي:

```{python}
def get_unicode_points(s):
    codes = []
    for c in s:
        codes.append(ord(c))
    return codes

print(get_unicode_points('Arabian'))
print(get_unicode_points('السَّلَامُ عَلَيْكُمْ'))
```

فهذه هي الحروف في الواقع، إلا أننا نتعامل مع شيء مجرَّد في لغات البرمجة العالية غالبًا ما يسمى `str`.

راجع [ويكيبيديا: النص العربي في Unicode](https://en.wikipedia.org/wiki/Arabic_script_in_Unicode) لمزيد من التفاصيل.

### الأحرف البيضاء

الأحرف في الأجهزة الرقمية على نوعين:

1. **أحرف مطبوعة**: مثلاً: الأحرف اللاتينية والأرقام وعلامات الترقيم
2. **أحرف تحكُّم**: مخفيَّة؛ والغرض منها التحكم بمعالج هذا النص

لعرض الأحرف القابلة للطباعة في محارف آسكي (ASCII)، لدينا المعرَّف `printable` من مكتبة `string`:

```{python}
import string
string.printable
```

كانت أحرف التحكُّم تستخدم لرن جرس الآلة الطابعة ، والتحكم بها ، لكن اليوم الذي يُستخدم منها غالبًا هو [**الأحرف البيضاء**](https://docs.python.org/3/library/string.html#string.whitespace) (Whitespace Characters) ويشمل ذلك الأحرف التالية:

1. space: `\s` ويمثل المسافة التي بين الكلمات
2. tab: `\t` ويمثل المسافة التي بين أعمدة الجداول
3. linefeed: `\n` تعليمة سطر جديد
4. return: `\r` تعليمة العودة لبداية السطر الجديد
5. formfeed: `\f` تعليمة الصفحة الجديدة
6. vertical tab: `\v` تعليمة العمود الجديد
7. backspace: `\b` تعليمة عودة المؤشر بمقدار حرف واحد للكتابة فوق الحرف السابق

أما الثلاثة الأخيرة فقد كانت تستخدم فيما مضى، لكن اليوم المستخدم هو الأربعة الأولى فقط. ويجدر بالذكر أن ملفات نصوص نظام ويندوز تستعمل `\r\n` للانتقال لسطر جديد بينما تستعمل الأنظمة الأخرى `\n` فقط.

تذكر أن بايثون تعتمد على `space` و `tab` للمسافة البادئة للسطر (indentation)، لتحديد نطاقات الكود بحسب المحاذاة العمودية.

```{python}
import string
string.whitespace
```

يهمنا هنا الأحرف البيضاء لأنها تظهر في النصوص وقد تكون مزعجة عند معالجتها. لنلقي نظرة على ثلاثة من الأحرف البيضاء: المسافة (space)، التبويب (tab)، وتعليمة السطر الجديد (linefeed).

```{python}
# Tab character: "\t"
print('A\tB')
```

```{python}
# Space character: " "
print('   A            B   ')
```

```{python}
# Newline character: '\n'
print('A\nB')
```

لاحظ أن طول السلسلة النصية هو عدد الأحرف في السلسلة، سواء كانت **قابلة للطباعة** (printable) أو **أحرف بيضاء** (whitespace).

```{python}
assert len('A B') == 3
assert len('A\tB') == 3
assert len('A\nB') == 3
```

### `.strip()`

لاحظ أن هذه الدالة ستزيل الأحرف البيضاء من بداية ونهاية السلسلة النصية، ولكن ليس الأحرف البيضاء في منتصف السلسلة

قبل:

```{python}
text = '\t hello    world \n\n\n'
print(text)
```

بعد:

```{python}
print(text.strip())
```

### `.split()`

انظر: [Splitlines](https://docs.python.org/3/library/stdtypes.html#str.splitlines)

```{python}
text = '''
Hello
World

How are you?
'''
```

إذا تركنا الكود كما هو في السطر من غير `print` فإن ذلك يعرض السلسلة النصية كما هي (بما في ذلك أحرف المسافات البيضاء)

```{python}
text
```

أما إذا وضعنا `print` فإنه يطبع الأحرف المرئية ، وينسِّقُ المظهر بناءً على أحرف التحكُّم المخفية:

```{python}
print(text)
```

```{python}
text.splitlines()
```

إذا لم نحدد محدد الفاصل فإن الفاصل الافتراضي هو المسافة.

```{python}
print("Hello, world".split())
```

هنا نحدد الفاصل أنه الحرف `"l"`:

```{python}
print("Hello, world".split("l"))
```

لإزالة الأحرف البيضاء جميعها، يمكن أن نستعمل التكرار على النحو التالي:

```{python}
text = '\t hello    world \n\n\n'
sp = text.split()
print('split:', sp)
clean = ' '.join(sp)
print('clean:', clean)
```

الفصل في الداخل ينتج قائمة من النصوص، بعضها فارغ لوجود الأحرف البيضاء المتتالية، فلا تتضمن في القائمة الناتجة.

## الطباعة

### حروف التحكم بآلة الطباعة

يسمّى الحرف `\r` بالعودة للبداية لأنه يعني أمر يقوم بإرجاع المؤشر إلى بداية السطر.

كانت آلة الطباعة قديمًا يتحرك رأس الطباعة فيها بعد طباعة كل حرف. ثم عندما ينتهي السطر، يجب على الشخص أن يقوم بعمليتين:

1. الضغط على المفتاح الذي يرفع الورقة بمقدار سطر (ويرمز له بالحرف `\r`) 
2. الضغط على المفتاح الذي يرجع رأس الطباعة لبداية السطر (ويرمز له بالحرف `\n`)

وهما مستخدمان اليوم فيما يُعرض على الشاشة.

فإجراء `print` في الحقيقة يضع سطرًا جديدًا (حرف `\n`) في الوضع الافتراضي. فإن أردنا ألا يضعه، فنحدد العامل `end` الذي فيه على النحو التالي:

```{python}
print('Hello', end='')
print('World', end='')
```

لاحظ أننا جعلنا (`end=''`) أي: لا نريده أن يضع حرفًا بعد طباعة النص. ولذلك ظهرت الكلمتان في نفس السطر.

 ولو أردت أن تعيد الكتابة على نفس السطر، يمكنك أن تضع الحرف (`\r`) الذي يأمر رأس الطباعة بالرجوع لبداية السطر. على النحو التالي:
 
 
```{python}
print('123', end='\r')
print('45')
```

لاحظ أن النتيجة هي طباعة الحرفين `45` فوق الحرفين `12` مع بقاء الحرف الأخير `3` في الأخير. وذلك لرجوع رأس الطباعة.

تستعمل هذه اللطيفة في تحديث العداد حتى يظهر على الشاشة وكأنه يزيد شيئًا فشيئًا. وذلك على النحو التالي (لاحظ أننا نستعمل `time.sleep(t)` حتى نمثِّل وجود عمليَّة تأخذ وقتًا طويلاً فحسب):

```{python}
import time

for x in range(10 + 1):
    time.sleep(0.20)
    print(f'[{x}/10] ' + '===' * x + '>', end='\r')
```

