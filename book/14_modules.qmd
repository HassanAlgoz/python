# Modules

## The Main Module

Every program must start somewhere. In Python, all `.py` files are modules, and you can run a module in either of two ways:

1. Directly using the `python` command: `python my_module.py` in which case, it becomes the **main module** (entry file), and the built-in `__name__` variable is set to `"__main__"`.
2. Importing the module in another file: `import my_module` in which case, the built-in `__name__` variable points out the name of the module: `my_module`.

Also, if the program is installed using pip, you can run it using the `python -m` command. Example: `python -m my_package`.

Let's look at the snippet below to illustrate the above points:

```python
def main():
    print(f"Hello from {__name__}")

if __name__ == "__main__":
    main()
```

- First we have a function named `main()` which we could've named anything else.
- The body of the function prints the value of `__name__` (it is a built-in variable)
- Finally, the conditional statement `if __name__ == "__main__":` checks if the file is being run directly, and if so, it runs the `main()` function. Had it been imported, the `__name__` variable would have been set to the name of the module (`my_module`), and the `main()` function would not have been executed.

This pattern is used, for example, to run tests, but not when the module is imported (since tests are relevant in development only, not when the module is being used).


## Importing Modules

When you state `import <module_name>`, Python will first search for the module in the curret directory. If the name is not found, it will then search for installed and built-in modules. Hence, to avoid confusion, developers avoid naming their packages the same as built-in packages such as: `os`, `sys`, `math`, `random`. See: [`sys.builtin_module_names`](https://docs.python.org/3/library/sys.html#sys.builtin_module_names) and [6.1.2. The Module Search Path](https://docs.python.org/3/tutorial/modules.html#the-module-search-path) for more details.

Suppose we have the following package structure:

```
│   main1.py
│   main2.py
│
└───my_package
    │   __init__.py
    │
    ├───pkg1
    │   │   __init__.py
    │   │   module_a.py
    │   │   module_b.py
    │
    ├───pkg2
    │   │   __init__.py
    │   │   module_a.py
    │   │   module_b.py
    │   │   module_c.py
```

Here:

- The file `main.py` is where we will write our code to try various import statements and observe their effects.
- The folders `pkg1` and `pkg2` are said to be: sub-packages of `my_package`. Each one can have its own modules, and can be imported independently.
- The files `module_a.py`, `module_b.py`, `module_c.py` are modules inside the subpackages.
- The file `__init__.py` is used to mark a directory as a package. It can be empty, but often contains initialization code for the package.

The code inside of [`main.py`](../examples/packages/main1.py) imports the modules defined in `my_package` or any of its subpackages. Below we explain each of the imports and what does it do. Let's look at the imports one by one:

```python
import my_package
from my_package.pkg1 import module_a
from my_package.pkg2.module_a import func_a
from my_package.pkg2.module_b import *
```

Firstly, `import my_package` does not specify a module, rather, it specifies a package. Hence, it will execute `__init__.py` file, which contains assignment statements. These variables (like`__version__`, `DEFAULT_TIMEOUT`, etc.) are attatched to the `my_package` identifier, and would be accessible with a dot (`.`).

The second line is another import statement: `from my_package.pkg1 import module_a`. However, this statement specifies a module (`module_a`), and hence, all the code in `module_a.py` is executed and assigned the namespace `module_a`.

The third line imports only the `func_a` function from the `module_a` module in the `pkg2` subpackage. Thus, the identifier `func_a` is assigned the function defined in `module_a.py` directly.

The last import uses the `from ... import *` syntax, which imports all the names from the module (except those beginning with `__`) into the current namespace. Generally, this is frowned upon, possibly hiding some things you have already defined, but it is okay to use it to save typing in interactive sessions.

## Installing and importing packages

To install packages shared by others, you can use the `pip` command, which should've been installed when you installed Python:

```bash
pip install pandas
```

Now you can `import pandas` in your Python code, and use it.

```{python}
import pandas as pd

df = pd.read_csv('datasets/students.csv')
df
```

Note, **Python Package Index ([PyPI](https://pypi.org/))**  is the default Package Index for the Python community (it is not the only one though. There is also [Anaconda](https://anaconda.org/)). It is open to all Python developers to download and upload their packages.

## Packaging Python Projects

::: {.callout-info}
The [Packaging Python Projects Tutorial](https://packaging.python.org/en/latest/tutorials/packaging-projects/) walks you through how to package a simple Python project. It will show you how to add the necessary files and structure to create the package, how to build the package, and how to upload it to the Python Package Index (PyPI) so that it can be installed using `pip install your-package`.
:::

## Executing modules as scripts

You can pass arguments to a Python program by typing them after the program name, like so: `python my_program.py arg1 arg2 arg3`.

The arguments are then accessible in the `sys.argv` list, which is a list of strings, where the first string is the script name, and the subsequent strings are the arguments passed to the script.

Let's look at the [`main2.py`](../examples/packages/main2.py) file.

We have a function that adds two numbers, which we want to recieve from the user:

```python
def add_two(a, b):
    return a + b
```

When we run the script, we need to provide two arguments:

```bash
python main2.py 10 20
```

The arguments are then accessible in the `sys.argv` list, which is a list of strings, where the first string is the script name, and the subsequent strings are the arguments passed to the script. We want to convert them to integers, then pass them to the `add_two` function, and print the result.

```python
a = int(sys.argv[1])
b = int(sys.argv[2])
result = add_two(a, b)
print(result)
```

## Few things to keep in mind about imports

It is customary (but not required) to place all [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) statements at the beginning of a module.

It’s good practice if you import modules in the following order:

1. standard library modules – e.g. [`sys`](https://docs.python.org/3/library/sys.html#module-sys), [`os`](https://docs.python.org/3/library/os.html#module-os), [`argparse`](https://docs.python.org/3/library/argparse.html#module-argparse), [`re`](https://docs.python.org/3/library/re.html#module-re)
2. third-party library modules (anything installed in Python’s site-packages directory) – e.g. `dateutil`, `requests`, `PIL.Image`
3. locally developed modules
