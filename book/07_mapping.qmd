# الربط

## المجموعة الرياضية

**المجموعة الرياضية** ([`set`](https://docs.python.org/3/library/stdtypes.html#set)) تحوي أشياء فريدة بغير ترتيب. ونظيرها الثابت (الذي لا يقبل التغيير) هو المجموعة الرياضية الجامدة ([`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset)).

تقبل المجموعة الرياضة لكونها مجموعة ([Collection](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)) العمليات التالية:

- معرفة الطول: `len(s)`
- التكرار: `for x in s`
- العضوية: `x not in s`

باعتبارها مجموعة غير مرتبة، فإنها لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تقبل الإشارة (`xs[i]`) أو التقطيع (`xs[i:j]`) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:

```{python}
#| error: true
xs = {10, 20, 30}
xs[0]
```

مثال لاستعمال العضوية:

```python
languages = {"Arabic", "English"}
if 'Python' not in languages:
    print('you need to add Python to your languages!')
```

باعتبارها مجموعة قابلة للتغيير (Mutable Set)، فهي تدعم [الإجراءات](https://docs.python.org/3/library/stdtypes.html#frozenset.update) التالية:

- الإضافة: `add`
- الحذف: `discard`
- أخذ عنصر عشوائي: `pop`
- المحو: `clear`

سميناها رياضية لأنها تدعم عمليات:

- التقاطع والاتحاد والفرق، والفرق التماثلي
- وكذلك تحقق: (الجزئية والشمول والانفاصل) .. المعروفة في الرياضيات.

وهذا الكود مثال لجميع هذه العمليات:

```{python}
set1 = {1, 2, 3, 4, 5}
set2 =          {4, 5, 6, 7, 8}

union = set1 | set2
assert union == {1, 2, 3, 4, 5, 6, 7, 8}

intersection = set1 & set2
assert intersection == {4, 5}

diff1 = set1 - set2
assert diff1 == {1, 2, 3}

diff2 = set2 - set1
assert diff2 == {6, 7, 8}

symmetric_difference = set1 ^ set2
assert symmetric_difference == {1, 2, 3, 6, 7, 8}
```

نصيحة: من الأفضل استعمال اسم الإجراء بدلاً من العلامة التي تقابله حيث أنها تقبل أي نوع من المتكررات (Iterables) وليس المجموعات الرياضية فقط (`set`).

| العملية                        | العلامة        | الإجراء المكافئ                  |
|--------------------------------|----------------|----------------------------------|
| الاتحاد                        | `set1 | set2`  | `set1.union(set2)`               |
| التقاطع                       | `set1 & set2`  | `set1.intersection(set2)`        |
| الفرق                          | `set1 - set2`  | `set1.difference(set2)`          |
| الفرق التماثلي                | `set1 ^ set2`  | `set1.symmetric_difference(set2)`|

وكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:

| العملية                        | العلامة        | الإجراء المكافئ                  |
|--------------------------------|----------------|----------------------------------|
| تحقق الجزئية                   | `set1 <= set2` | `set1.issubset(set2)`            |
| تحقق الشمول                    | `set1 >= set2` | `set1.issuperset(set2)`          |
| تحقق الانفصال                  | `len(set1 & set2) == 0` | `set1.isdisjoint(set2)`          |


وهذا مثال لاستعمالها:

```{python}
set1 = {'A', 'B', 'C'}
set2 = {'A', 'B', 'C', 'D', 'E'}
set3 = {'سين', 'جيم', 'قاف'}

assert (set1 <= set2) == set1.issubset(set2)
assert (set2 >= set1) == set2.issuperset(set1)
assert (
    set3.isdisjoint(set1 | set2) ==
    (len(set3 & (set1 | set2)) == 0)
)
```

وتستعمل كذلك لإزالة العناصر المتكررة في أي مجموعة، نحو الكود التالي. فإننا نحول القائمة إلى مجموعة رياضية فتزول تلك العناصر تلقائيًّا، ثم نعيدها كما كانت:

```{python}
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = list(set(numbers))
print(unique_numbers)
```

وكذلك من الصف:

```{python}
t = (1, 2, 2, 3, 4, 4, 5)
unique_t = tuple(set(t))
print(unique_t)
```


## القاموس

**القاموس** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict)) هو مجموعة مرتبة من المؤشرات الفريدة الدالة على أشياء. يمكن أن تكون المؤشرات من نوع: سلسلة نصية، أو رقم، أو صف وما هو قابل للتجزئة (Hashable). أما القيَم فتكون من أي نوع.

يدعم القاموس العمليات التالية:

- معرفة عدد المؤشرات: `len(dict)`
- التكرار: `for key in dict`
- العضوية: `key not in dict`
- الإشارة: `dict[key]` أو `dict.get(key)`
- نزع قيمة: `dict.pop(key)`
- إضافة أو تعديل رابط: `dict[key] = value`
- إضافة أو تعديل مجموعة روابط: `dict.update(new_data)`
- الحذف: `del dict[key]`

يعرف القاموس على النحو التالي:

```{python}
data = {'key1': 'value1', 'key2': 'value2'}
```

لكن حين تكثر القيم نفردها على الأسطر لتكون أوضح للقراءة (وليس هذا بلازم):

```{python}
data = {
    'key1': 'value1',
    'key2': 'value2',
}
```

وهنا نمثل لبعض العمليات:

```{python}
assert data['key1'] == 'value1'
del data['key1']
assert 'key1' not in data
```

وهنا نستعرض مجموعة من الاستعمالات لشكل القاموس. أولاً كقاموس بالمعنى الذي يشير إليه اللفظ (الكلمة ومعناها).

### الكلمة ومعناها

نفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:

```{python}
english_to_arabic = {
    'apple': 'تفاحة',
    'banana': 'موزة',
    'orange': 'برتقالة',
}
```

أو الاختصارات إلى الكلمة التامة:

```{python}
abbreviations = {
    'SAR': 'Saudi Riyal',
    'KSA': 'Kingdom of Saudi Arabia',
    'ASAP': 'As Soon As Possible',
    'FYI': 'For Your Information',
}
```

### حفظ معلومات المستخدم

وهذا مثال على استعمال القاموس لتخزين معلومات شخص. لاحظ أن القيمة المقابلة لكل مؤشر قد تكون من أي نوع في بايثون، تمامًا مثل ما تُسنِد قيَم لمعرَّفات. فلدين النص والرقم والقاموس (داخل القاموس) والقيَم الثنائية (`True`, `False`) والقائمة `[ ]` (داخل القاموس).

```{python}
person = {
    'name': 'Adam',
    'language': 'Arabic',
    'phone': '966xxxxxxxxx',
    'last_updated': '2021-09-01',
    'age': 25,
    'notifications': {
        'email': True,
        'sms': False,
        'push': True
    },
    'emails': ['example1@domain.com', 'example2@domain.com']
}
```

### سلة المشتريات

نفترض أن لدينا سلة تحتوي على مشتريات العميل (`basket`)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس `prices` بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).

```{python}
prices = {
    'apple': 15,
    'banana': 10,
    'orange': 5,
    'cantaloupe': 40
}

basket = ['apple', 'apple', 'banana', 'orange', 'banana']
```

نحتاج أن نأتي على السلة عنصرًا عنصرًا، ونجمع قيمة كل فاكهة إلى المجموع الكلي:

```{python}
total = 0

for fruit in basket:
    total += prices[fruit]

print(total)
```

### الذاكرة القريبة (Cache)

وهي الذاكرة التي تحتفظ بنتائج العمليات المتكررة (خصوصًا إذا كانت خوارزميات معقَّدة) حتى لا نحتاج لحسابها كل مرة؛ فنقتصد في موارد المعالجة في مقابل توظيف موارد الذاكرة (والتخزين).

```{python}
factorial_table = {
    0: 1,
    1: 1,
    2: 2,
    3: 6,
}

def factorial(n):
    if n not in factorial_table:
        factorial_table[n] = n * factorial(n - 1)
    return factorial_table[n]
```

بل إن بايثون توفر هذه الخاصية للدوال عن طريق **المزيِّن** (decorator) [`@functools.lru_cache`](https://docs.python.org/3/library/functools.html#functools.cache)، هكذا:

```{python}
import functools

@functools.lru_cache
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
```

لاحظ عدم الحاجة لتعريف القاموس `factorial_table`، بل يقوم المزيِّن هو بذلك تلقائيًّا.