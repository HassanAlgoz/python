# المجموعة المرقومة

بعد أن رأينا التلسلسل الذي هو نوع مجموعة مرتبة. ننتقل في درسنا هذا للبحث في نوعين آخرين يندرجان تحت المجموعة المرقومة:

- مجموعة الفرائد: `set`
- مجموعة الروابط: `dict`

## مجموعة الفرائد

**مجموعة الفرائد** ([`set`](https://docs.python.org/3/reference/datamodel.html#set-types)) تحوي أشياء مرقومة فريدة بلا ترتيب.

تنشأ المجموعة الفريدة بالإجراء المنشئ [`set()`](https://docs.python.org/3/library/stdtypes.html#set). ويفضل استعمال القوسين المتعرجين `{ }` بدلاً منه:

```{python}
s1 = set([10, 20, 30])
s2 = {10, 20, 30}
assert s1 == s2
```

تقبل مجموعة الفرائد لكونها مجموعة ([Collection](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)) العمليات التالية:

- العد: `len(s)`
- التكرار: `for x in s`
- العضوية: `x not in s`

وباعتبارها مجموعة متغيرة (Mutable Set)، فإنها تقبل الأفعال التالية:

- الإضافة: `add`
- الحذف: `discard`
- نزع عنصر عشوائي: `pop`
- المحو: `clear`

ذكرنا أن شرط عضوية العنصر أن يكون مرقومًا؛ وهذا **يجعل عملية البحث فيها قفزة واحدة**؛ إذْ يتم حساب الرقم المقابل للعنصر فيعرف منه أين العنوان الذاكري مباشرة. ولكن ما هو المرقوم؟

**المرقوم** ([`Hashable`](https://docs.python.org/3/glossary.html#term-hashable)): هو ما يقبل الفعل `hash()` الذي يحول الشيء إلى رقم فريد. ومنه:

- النص (`str`) له خوارزمية معيَّنة لرقْمه
- الرقم (`int`) رقْمه هو نفسه
- الصف (`tuple`) رقْمه هو رقم عناصره (فيجب أن تكون جميع عناصره مرقومة)

ملاحظة: لأن المرقوم يشترط فيه ألا يتغيَّر رقْمه إلا بتغير محتواه؛ فإنه في الغالب يكون في الأنواع الثابتة (Immutable). لذا تجد الصف معدودًا ضمن المرقومات وليست القائمة كذلك:

```{python}
s = {10, 'AAA', True, (22, 'BB')}

assert len(s) == 4
assert 22 not in s
assert (22, 'BB') in s

for x in s:
    print(x)
```

باعتبارها مجموعة غير مرتبة، فإنها لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تقبل الإشارة (`xs[i]`) أو التقطيع (`xs[i:j]`) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:

```{python}
#| error: true
xs = {10, 20, 30}
xs[0]
```

وتقبل المجموعة الفريدة ما تقبله المجموعة في الرياضيات من عمليات:

- التقاطع والاتحاد والفرق، والفرق التماثلي
- وكذلك تحقق: (الجزئية والشمول والانفاصل).

وهذا الكود مثال لجميع هذه العمليات الرياضية:

```{python}
set1 = {1, 2, 3, 4, 5}
set2 =          {4, 5, 6, 7, 8}

union = set1 | set2
assert union == {1, 2, 3, 4, 5, 6, 7, 8}

intersection = set1 & set2
assert intersection == {4, 5}

diff1 = set1 - set2
assert diff1 == {1, 2, 3}

diff2 = set2 - set1
assert diff2 == {6, 7, 8}

symmetric_difference = set1 ^ set2
assert symmetric_difference == {1, 2, 3, 6, 7, 8}
```

نصيحة: من الأفضل استعمال اسم الإجراء بدلاً من العلامة التي تقابله حيث أنها تقبل أي نوع من المتكررات (Iterables) ولا تقتصر على مجموعة الفرائد فقط (`set`).

| العملية                        | العلامة        | الإجراء المكافئ                  |
|--------------------------------|----------------|----------------------------------|
| الاتحاد                        | `set1 | set2`  | `set1.union(set2)`               |
| التقاطع                       | `set1 & set2`  | `set1.intersection(set2)`        |
| الفرق                          | `set1 - set2`  | `set1.difference(set2)`          |
| الفرق التماثلي                | `set1 ^ set2`  | `set1.symmetric_difference(set2)`|

وكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:

| العملية                        | العلامة        | الإجراء المكافئ                  |
|--------------------------------|----------------|----------------------------------|
| تحقق الجزئية                   | `set1 <= set2` | `set1.issubset(set2)`            |
| تحقق الشمول                    | `set1 >= set2` | `set1.issuperset(set2)`          |
| تحقق الانفصال                  | `len(set1 & set2) == 0` | `set1.isdisjoint(set2)`          |


وهذا مثال لاستعمالها:

```{python}
set1 = {'A', 'B', 'C'}
set2 = {'A', 'B', 'C', 'D', 'E'}
set3 = {'سين', 'جيم', 'قاف'}

assert (set1 <= set2) == set1.issubset(set2)
assert (set2 >= set1) == set2.issuperset(set1)
assert (
    set3.isdisjoint(set1 | set2) ==
    (len(set3 & (set1 | set2)) == 0)
)
```

وهنا بحثٌ سريع جدًا باستعمال جملة التحقق من العضوية (بالتأكيد لا يظهر أثر السرعة في مجموعة صغيرة):

```{python}
languages = {"Arabic", "English"}
if 'Python' not in languages:
    print('you need to add Python to your languages!')
```

وتستعمل كذلك لإزالة العناصر المتكررة في أي مجموعة، نحو الكود التالي. فإننا نحول القائمة إلى مجموعة فرائد فتزول تلك العناصر تلقائيًّا، ثم نعيدها كما كانت:

```{python}
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = list(set(numbers))
print(unique_numbers)
```

وكذلك من الصف:

```{python}
t = (1, 2, 2, 3, 4, 4, 5)
unique_t = tuple(set(t))
print(unique_t)
```


## القاموس

**القاموس** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict)) هو مجموعة مرتبة من المرقومات الفريدة الدالة على قيم.

تنشأ المجموعة الرابطة بالإجراء المنشئ [`dict()`](https://docs.python.org/3/library/stdtypes.html#dict) ويفضل استعمال القوسين المتعرجين `{ }` بدلاً منه:

```{python}
d1 = dict(key1='value1', key2='value2')
d2 = {'key1': 'value1', 'key2': 'value2'}
assert d1 == d2
```

اصطلاحات: نسمي `key1` المرقوم ونسمي `value1` القيمة؛ وهما معًا نسميهما **رابطًا**.

ومن حيث كون القاموس **مجموعة** (`Collection`)، فإنه يقبل الأفعال ثلاثة:

- العضوية: `x not in d`
- العد: `len(d)`
- التكرار: `for x in d`

ويقبل القاموس لكونه **دالة** ([`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)) الأفعال التالية:

- معرفة عدد المؤشرات: `len(dict)`
- الإشارة بمرقوم: `dict[key]` أو `dict.get(key)`

ويجوز التكرار بثلاثة طرق:

- كر الروابط: `for key, value in d.items()`
- كر المرقومات: `for key in d.keys()`
- كر القيم: `for value in d.values()`

ولكونه **دالة متغيرة** (Mutable Mapping)، فإنه يقبل الأفعال التالية:

- التعديل بمرقوم: `dict[key] = value`
- الحذف بمرقوم: `del dict[key]`
- نزع بمرقوم وإرجاع القيمة: `x = dict.pop(key)`
- التحديث بدالَّة أو بمكرر روابط: `dict.update(mapping)`

ملاحظة: منذ بايثون 3.7 أصبح القاموس مرتبًا.

لاحظ أننا نستعمل مرقومات مختلفة وأيضًا نستعمل قيم مختلفة:

```{python}
data = {
    'key1': 100,
    20: 'value2',
    'c': [10, 20, 30, True],
    (1, 2): 'value3',
    ('a', 'b', 'c'): 'value4',
}

assert len(data) == 5
del data['key1']
assert 'key1' not in data
```

ونحصل عليها بالإشارة بمرقوم:

```{python}
print(data[20])
print(data['c'])
print(data[(1, 2)])
print(data[('a', 'b', 'c')])
```

#### إنشاء قاموس من سلسلتين

ويتحصل القاموس من سلسلتين باستعمال الإجراء [`zip()`](https://docs.python.org/3/library/functions.html#zip)، كما يلي:

```{python}
students = ['Ahmad', 'Belal', 'Careem', 'David']
marks = [90, 80, 75, 85]
data = dict(zip(students, marks, strict=True))
data
```

## استعمالات القاموس

نستعرض ثلاثة استعمالات للقاموس:

- الكلمة ومعناها
- حفظ معلومات المستخدم
- سلة المشتريات

### الكلمة ومعناها

وهنا نستعرض مجموعة من الاستعمالات لشكل القاموس. أولاً كقاموس بالمعنى الذي يشير إليه اللفظ (الكلمة ومعناها).

نفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:

```{python}
english_to_arabic = {
    'apple': 'تفاحة',
    'banana': 'موزة',
    'orange': 'برتقالة',
}
```

أو الاختصارات إلى الكلمة التامة:

```{python}
abbreviations = {
    'SAR': 'Saudi Riyal',
    'KSA': 'Kingdom of Saudi Arabia',
    'ASAP': 'As Soon As Possible',
    'FYI': 'For Your Information',
}
```

### حفظ معلومات المستخدم

وهذا مثال على استعمال القاموس لتخزين معلومات شخص. لاحظ أن القيمة المقابلة لكل مؤشر قد تكون من أي نوع في بايثون، تمامًا مثل ما تُسنِد قيَم لمعرَّفات. فلدين النص والرقم والقاموس (داخل القاموس) والقيَم الثنائية (`True`, `False`) والقائمة `[ ]` (داخل القاموس).

```{python}
person = {
    'name': 'Adam',
    'language': 'Arabic',
    'phone': '966xxxxxxxxx',
    'last_updated': '2021-09-01',
    'age': 25,
    'notifications': {
        'email': True,
        'sms': False,
        'push': True
    },
    'emails': ['example1@domain.com', 'example2@domain.com']
}
```

### سلة المشتريات

نفترض أن لدينا سلة تحتوي على مشتريات العميل (`basket`)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس `prices` بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).

```{python}
prices = {
    'apple': 15,
    'banana': 10,
    'orange': 5,
    'cantaloupe': 40
}
```

يجوز تحديث الأسعار هكذا:

```{python}
prices['banana'] = 12
```

أو بالمجموع هكذا:

```{python}
prices.update({'banana': 12, 'orange': 15})
```

والآن نفترض أن لدينا قائمة بالفواكه التي يريدها العميل:

```{python}
basket = ['apple', 'apple', 'banana', 'orange', 'banana']
```

ولأن القاموس **متوالية** ([`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)) فهو يقبل **جملة التكرار بمتوالية** (`for`) وذلك لجمع قيمة كل فاكهة إلى المجموع الكلي:

```{python}
total = 0

for fruit in basket:
    total += prices[fruit]

print(total)
```

### الذاكرة القريبة (Cache)

وهي الذاكرة التي تحتفظ بنتائج العمليات المتكررة (خصوصًا إذا كانت خوارزميات معقَّدة) حتى لا نحتاج لحسابها كل مرة؛ فنقتصد في موارد المعالجة في مقابل توظيف موارد الذاكرة (والتخزين).

```{python}
factorial_table = {
    0: 1,
    1: 1,
    2: 2,
    3: 6,
}

def factorial(n):
    if n not in factorial_table:
        factorial_table[n] = n * factorial(n - 1)
    return factorial_table[n]
```

بل إن بايثون توفر هذه الخاصية للدوال عن طريق **المزيِّن** (decorator) [`@functools.lru_cache`](https://docs.python.org/3/library/functools.html#functools.cache)، هكذا:

```{python}
import functools

@functools.lru_cache
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
```

لاحظ عدم الحاجة لتعريف القاموس `factorial_table`، بل يقوم المزيِّن هو بذلك تلقائيًّا.

## خلاصة

بنهاية هذا الباب والذي قبله أنهينا ما يتعلق بالمجموعة:

- التسلسل
- المجموعة الرياضية
- الدالة: متمثلة في القاموس

وننتقل إلى صف الأحرف في [باب النص](08_string.qmd).