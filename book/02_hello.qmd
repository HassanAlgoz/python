---
title: "أول سطر"
jupyter: python3
---

تحتوي Python على وضع تفاعلي (Interactive Mode) يسمح لك بكتابة الأوامر والحصول على نتائج فورية.

- اضغط `Ctrl + Enter` لتشغيل خلية التعليمات البرمجية أدناه
- اضغط `Shift + Enter` لتشغيل التعليمات البرمجية والانتقال إلى الخلية التالية.

```{python}
2 + 10
```

جرب عمليات حسابية مختلفة في الخلية أدناه:

- الجمع: `5 + 5`
- الطرح: `9 - 4`
- الضرب: `2 * 5`
- القسمة: `5 / 5`
- القوة: `2 ** 4`

```{python}
# try it
```

لاحظ أنه إذا وضعت أمرين في نفس الخلية، فسيتم طباعة الأمر الأخير فقط. لذا، إذا كتبت `5 + 5` ثم `9 - 4`، فسيتم طباعة `9 - 4` فقط. إذا كنت تريد طباعة الأمرين، فيجب عليك استخدام الدالة `print()`، على النحو التالي:

```{python}
print(5 + 5)
print(9 - 4)
```

تستخدم الدالة `print()` لطباعة الأشياء على الشاشة. ويمكن استخدامها لطباعة النصوص أو الأرقام أو نتائج العمليات الحسابية.

يمكنك أيضًا طباعة أشياء متعددة في وقت واحد عن طريق فصلها برمز الفاصلة `,` على النحو التالي:

```{python}
print("My age is:", 40)
```

```{python}
# try it
```

## أنواع البيانات

### القيم والأنواع

هنا:

- `10` يعتبر **قيمة (value)** من **نوع (type)** `int`
- `"Adam"` تعتبر **قيمة (value)** من **نوع (type)** `str`

```{python}
type(10)
```

```{python}
type("Adam")
```

نخزن القيم في **متغيرات (variables)**. المتغير هو اسم يشير إلى قيمة. يمكننا استخدام عامل `=` لتعيين قيمة لمتغير.

```{python}
x = 10
```

الآن، يعيد `type(x)` **نوع** القيمة التي تحتوي عليها `x`.

```{python}
type(x)
```

### التويع الديناميكي (Dynamic Typing)

على عكس لغات التنويع الثابت (Static Typing)، تسمح لك بايثون بتغيير نوع المتغير بعد تعيينه. يُسمى هذا بالتنويع الديناميكي (Dynamic Typing).

```{python}
x = 1         # int
x = 'hello'   # -> str
x = [1, 2, 3] # -> list
```

```{python}
type(x)
```

#### تمرين

- ما نوع `3.14`؟
- ما نوع `"5" + "5"`؟

```{python}
# try it
```

تذكر:

- **التعبيرات (Expressions)** تنتج **قيمة (value)**
- كل **قيمة (value)** لها **نوع (type)**

```{python}
type(4 + 2)
```

```{python}
type("Adam" + " " + "Basel")
```

```{python}
type(9 > 5)
```

#### تمرين

ما نوع التعبيرات التالية؟

- `10 + 5`
- `"Adam" + "Basel"`
- `True or False`

```{python}
# try it
```

## المتغيرات

يأخذ التعيين القيم (والتعبيرات المقيمة) ويعينها لمتغير:

```{python}
num = 10
name = "Adam" + " " + "Basel"
b = 9 > 5

print(type(num))   # int
print(type(name))  # str
print(type(b))     # bool
```

يُظهر الكود التالي تعيين متغير:

- `x` هو **متغير (variable)**
- `5` هو **قيمة (value)**
- `=` هو **عامل التعيين (assignment operator)**

```{python}
x = 5
```

القيمة `5` مخزنة في عنوان ذاكري (memory address) `x` حتى نتمكن من الوصول إليه لاحقًا.

```{python}
print(x)
```

لاحظ أن سلسلة الأرقام ليست هي نفسها الرقم:

- الرقم `20` هو قيمة من نوع (type) `int`
- السلسلة النصية `"20"` هي قيمة من نوع (type) `str`

**ملاحظة جانبية**: التنصيص المفرد (`'A'`) والتنصيص المزدوج (`"A"`) متكافئة في بايثون (Python).

```{python}
x = 20
y = '20'

print(x, type(x))
print(y, type(y))
```

```{python}
#| error: true
print(x + y)
```

نتوقع خطأ وراء هذا السطر لأننا نحاول إضافة سلسلة نصية (string) إلى رقم (number).

يجب علينا تحويل السلسلة النصية إلى رقم قبل أن نتمكن من إضافتها إلى رقم آخر.

```{python}
z = int(y)
print(z, type(z))
print(x + z)
```

## قواعد في تسمية المتغيرات

القاعدة الأولى: المتغيرات حساسة لحالة الأحرف (case-sensitive). مثال:

```python
my_variable = 5
My_Variable = 10
```

جرب تشغيل الخلية أعلاه وستحصل على قيمتين مختلفتين. لذلك، يجب أن تكون حذرًا عند تسمية المتغيرات.

القاعدة الثانية: لا يمكن أن تبدأ أسماء المتغيرات برقم. مثال:

```python
2my_variable = 5
```

جرب تشغيل الخلية أعلاه وستحصل على خطأ. لذلك، يجب أن تبدأ أسماء المتغيرات بحرف.

القاعدة الثالثة: لا يمكنك استخدام الكلمات المحجوزة (reserved keywords). مثال:


```python
class = 5
True = 1
break = True
```

جرب تشغيل الخلية أعلاه وستحصل على خطأ. لذلك، يجب تجنب استخدام الكلمات المحجوزة كأسماء للمتغيرات.

### الكلمات المحجوزة

| الفئة (Category) | الكلمة المحجوزة (Keyword) | الوصف (Description) |
|---|---|---|
| عوامل منطقية (Logical operators) | `and`, `or`, `not`, `is` | عوامل تستخدم لدمج التعبيرات البوليانية (Boolean expressions). |
| عبارات شرطية (Conditional statements) | `if`, `elif`, `else` | كلمات محجوزة تستخدم لإنشاء عبارات شرطية. |
| الحلقات (Loops) | `while`, `for`, `break`, `continue` | كلمات محجوزة تستخدم لإنشاء الحلقات. |
| معالجة الاستثناءات (Exception handling) | `try`, `except`, `finally` | كلمات محجوزة تستخدم لمعالجة الاستثناءات. |
| الدوال والفئات (Functions and classes) | `def`, `class`, `return`, `yield`, `lambda` | كلمات محجوزة تستخدم لتعريف الدوال والفئات. |
| أنواع البيانات (Data types) | `None`, `True`, `False` | كلمات محجوزة تستخدم لتمثيل أنواع بيانات خاصة. |
| أخرى (Other) | `import`, `from`, `as`, `assert`, `global`, `nonlocal`, `with`, `pass`  | كلمات محجوزة أخرى تستخدم لأغراض متنوعة. |


القاعدة الرابعة: يُكره استخدام أسماء الدوال المبنية في اللغة (built-in function names). مثال:

```python
sum = 5
max = 10
list = [10, 20, 30]
```

يسبب هذا ما يُعرف بـ **تعارض الأسماء (naming conflict)**، وهو يجعل الكود أقل فهمًا وأقل قابلية للصيانة. وهو سبب لنوع من أخطر أنواع الأخطاء وهي **الأخطاء الصامتة (silent errors)** ، إذ لا تظهر رسالة الخطأ وإن ظهرت فإنها غير دالة على السبب الحقيقي للخطأ.

الخلية التالية تحتوي على أسماء متغيرات لا معنى لها. نقدم بديلاً أفضل أدناه ونلاحظ الفرق.

```{python}
x2 = 35
y = 12.50
mne = x2* y
print(mne)
```


**يجب** استخدام أسماء ذات معنى، مثل:

```{python}
hours = 35
rate = 12.50
pay = hours * rate
print(pay)
```

الغرض من الكود أصبح واضحًا.

### نظرة عامة على أنواع البيانات

تمثل أنواع البيانات (Data types) نوع القيمة التي تخبرنا ما هي العمليات التي يمكن إجراؤها على بيانات معينة. على سبيل المثال:

- يمكن جمع الأرقام وطرحها وضربها
- أما السلاسل النصية (Strings)، فيمكننا دمجها وتكرارها

وهذا تشجير غير مستوفي لأنواع البيانات في بايثون:

```{mermaid}
graph LR
    A[Object]
    
    A --> A1[None]

    A --> A2[numbers.Number]
    A2 --> A21[numbers.Integral]
    A21 --> A211[Integers: int]
    A21 --> A212[Booleans: bool]
    A2 --> A22[numbers.Real: float]
    A2 --> A23[numbers.Complex: complex]
    
    A --> A3[Sequences]
    A3 --> A31[Immutable Sequences]
    A31 --> A311[Strings]
    A31 --> A312[Tuples]
    A31 --> A313[Bytes]
    A3 --> A32[Mutable Sequences]
    A32 --> A321[Lists]
    A32 --> A322[Byte Arrays]
    
    A --> A4[Set Types]
    A4 --> A41[Sets]
    A4 --> A42[Frozen Sets]

    A --> A5[Mappings]
    A5 --> A51[dict]

    A --> A6[Callable Types]
    A6 --> A61[Functions]
    A6 --> A62[Classes]
    A62 --> A7[Instances]
```

الكائنات (Objects) هي تجريدات بايثون (Python) للبيانات. جميع البيانات في برنامج بايثون يتم تمثيلها بواسطة كائنات وعلاقات بينها. (وفقًا لنموذج فون نيومان (Von Neumann) لـ "الكمبيوتر المخزن للبرنامج"، يتم تمثيل الكود أيضًا بواسطة كائنات.)


إليك جدول بأكثر أنواع البيانات شيوعًا في بايثون (Python):

| النوع | النوع في بايثون | مثال |
|---|---|---|
| **نص (Text)** | `str` | `message = "Hello, world!"` |
| **رقمي (Numeric)** | `int`, `float`, `complex` | `number = 10`, `pi = 3.14`, `complex_number = 1 + 2j` |
| **تسلسل (Sequence)** | `list`, `tuple`, `range` | `my_list = [1, 2, 3, 4, 5]`, `my_tuple = (1, 2, 3, 4, 5)`, `my_range = range(10)` |
| **ربط (Mapping)** | `dict` | `my_dict = {"name": "Adam", "age": 25}` |
| **مجموعة (Set)** | `set`, `frozenset` | `my_set = {1, 2, 3, 4, 5}`, `my_frozenset = frozenset({1, 2, 3, 4, 5})` |
| **بولي (Boolean)** | `bool` | `is_true = True`, `is_false = False` |
| **ثنائي (Binary)** | `bytes`, `bytearray`, `memoryview` | `my_bytes = b"Hello, world!"`, `my_bytearray = bytearray(b"Hello, world!")`, `my_memoryview = memoryview(b"Hello, world!")` |
| **لا شيء (None)** | `NoneType` | `none = None` |

انظر: [توثيق أنواع البيانات](https://docs.python.org/3/library/datatypes.html)