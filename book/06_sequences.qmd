# المجموعة المرتبة

كثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، ...إلخ من العمليات التي تعمل على جميع عناصر المجموعة.

**التسلسل** ([`Sequence`](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)) هو أي مجموعة مرتبة من الأشياء. وسوف نرمز للمفرد بـ`x` ولما يدل على التسلسل بـ`s`.

يندرج تحت نوع التسلسل أربعة أنواع أساسية كلها تقبل الأفعال التالية:

- الإشارة:
    - لموضع: `s[i]`
    - لقطعة: `s[i:j]`
    - لقطعة مع خطوة: `s[i:j:k]`
- معرفة موضع شيء (إن وجد): `s.index(x)`
- عد تكرارات شيء: `s.count(x)`
- البحث عن الأصغر والأكبر: `min(s)` و `max(s)`

وتقبل من أفعال الإنشاء:

- الدمج: `s1 + s2`
- التكرار: `s * n`

ومن حيث كونها **مجموعة** (`Collection`)، تقبل الأفعال ثلاثة:

- العضوية: `x not in s`
- العد: `len(s)`
- التكرار: `for x in s`

والأنواع الأربعة التي من جنس التسلسل هي:

1. **القائمة** ([`list`](https://docs.python.org/3/library/stdtypes.html#list)) وهي الأكثر شيوعًا.
2. **الصف** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)) وهو النوع الجامد الذي لا يقبل التغير.
3. **المجال** ([`range`](https://docs.python.org/3/library/stdtypes.html#range)) وهو سلسلة محددة البداية والنهاية والخطوة، لكنّ عناصرها لا يتحقق وجودها إلا عند استدعائها. وقد سبق الحديث عنه في [باب التكرار](04_iteration.qmd).
4. **النص** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) وهو صفٌّ من الأحرف.

## التسلسل

### الإنشاء

- ينشأ الصف بوضع العناصر بين القوسين المنحنيين `()` أو باستعمال الإجراء المنشئ [`tuple()`](https://docs.python.org/3/library/stdtypes.html#tuple)
- تنشأ القائمة بوضع العناصر بين القوسين المربعين `[]` أو باستعمال الإجراء المنشئ [`list()`](https://docs.python.org/3/library/stdtypes.html#list)

```{python}
s = (10, 20, 30) + (40, 50)
s = s * 2
print(s)
```

ويقبل إنشاء مجموعة من العناصر مختلفة النوع، بما في ذلك القائمة والصف كعنصر:

```{python}
s = (10, 'A', 2.0, True, ['B', 30])
print(s)
```

والتعبير المختصر لإنشاء القائمة يستعمل الجملة التكرارية `for` مع الشرط الاختياري `if`، كما في المثال التالي (يأتي تفصيله في [باب التعبير المختصر لإنشاء المجموعات](zz_comprehension.qmd)):

```{python}
s = [x * 10 for x in (10, 20, 30, 40, 50, 60) if x <= 30]

assert 100 in s
assert 400 not in s
assert len(s) == 3

for x in s:
    print(x)
```


### الإشارة

تستعمل الإشارة الموضعية لقراءة عنصر من التسلسل. ويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل على النحو التالي:

```{python}
s = [10, 20, 30, 40, 50]
assert s[0] == 10
assert s[-1] == 50
assert s[len(s) // 2] == 30
```

```
 0    1    2    3    4    5     
 +----+----+----+----+----+
 | 10 | 20 | 30 | 40 | 50 |
 +----+----+----+----+----+
-5   -4   -3   -2   -1
```

شكل الإشارة بالقطعة على نحو: `s[start : end : step]`. والقيم الافتراضية عند الإغفال هي: `s[0:len(s):1]`.

```{python}
s = [10, 20, 30, 40, 50]
assert s[1:3] == [20, 30]
assert s[::2] == [10, 30, 50]
assert s[::-1] == [50, 40, 30, 20, 10]
assert s[1:4:2] == [20, 40] == s[-4:-1:2]
assert s[1:4:2] == s[slice(1,4,2)] == [20, 40]
```

وجاز للعنصر أن يكون مجموعة؛ ومثاله المصفوفة:

```{python}
matrix = (
    (10, 20, 30),
    (40, 50, 60),
    (70, 80, 90)
)

assert matrix[0] == (10, 20, 30)
assert matrix[-1] == (70, 80, 90)
assert matrix[1][1] == 50
```

```
 0              1              2               
 +--------------+--------------+--------------+
 | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |
 +--------------+--------------+--------------+
-3             -2             -1
```

الإشارة لعناصر الصف الواحد:

```
 0    1    2            
 +----+----+----+
 | 10 | 20 | 30 |
 +----+----+----+
-3   -2   -1
```

```
 0    1    2            
 +----+----+----+
 | 40 | 50 | 60 |
 +----+----+----+
-3   -2   -1
```

```
 0    1    2            
 +----+----+----+
 | 70 | 80 | 90 |
 +----+----+----+
-3   -2   -1
```

عناصر نصوص:

```{python}
ss = ["Apple", "Banana", "Orange", "Lemon"]
assert ss[1] == "Banana"
assert ss[-1][0] == "L"
```

```
 0       1        2        3       4
 +-------+--------+--------+-------+
 | Apple | Banana | Orange | Lemon |
 +-------+--------+--------+-------+
-4      -3       -2       -1
```

الإشارة لصف الأحرف في النص الواحد:

```
 0   1   2   3   4
 +---+---+---+---+---+
 | L | e | m | o | n |
 +---+---+---+---+---+
-5  -4  -3  -2  -1
```

وسيأتي التفصيل في [باب النص](08_string.qmd).

### البحث

```{python}
s = ('A', 'B', 'A')
assert s.index('B') == 1
assert s.count('A') == 2
```

```{python}
s = (30, 20, 40, 10, 50)
assert min(s) == 10
assert max(s) == 50
```


## تسلسل النطاق

**النطاق** ([`range`](https://docs.python.org/3/library/stdtypes.html#range)) يمثل تسلسلًا ثابتًا من الأرقام؛ له ثلاثة حدود: بداية ونهاية وخطوة `range(start, stop, step)`. ولا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وقد تقدم الكلام عنه في [باب التكرار](04_iteration.qmd) لكننا ننظر له هنا على أنه نوع من التسلسل.

وهو كالصف لا يقبل التعديل.

نستعمل إجراء الإنشاء `range()` لإنشاء نطاق:

```{python}
r = range(0, 20, 2)
r
```

فحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:

```{python}
print(11 in r)
print(10 in r)
```

كذلك الأمر عند البحث عن موضع رقمٍ ما:

```{python}
print(r.index(10))
```

والإشارة لموضع ما أو قطعة كذلك:

```{python}
print(r[5])
print(r[:5])
print(r[-1])
```

### تحويل النطاق

بمجرد تحويل النطاق إلى نوعٍ متحقق (كالقائمة أو الصف) ؛ يتم توليد جميع الأرقام التي في النطاق حالًا.

```{python}
l = list(range(1000, 0, -100))
t = tuple(range(0, 1000, 200))
print(l)
print(t)
```

مثال آخر هو إنشاء قائمتين؛ واحدة للأرقام الزوجية والأخرى للأرقام الفردية، مرة أخرى، باستخدام تركيب `list(range())`.

```{python}
evens = list(range(0, 10, 2))
odds = list(range(1, 10, 2))
print(evens)
print(odds)
```

## القائمة

**القائمة** ([`list`](https://docs.python.org/3/library/stdtypes.html#list)) تسلسل متغير.

### التغير

[**التغير**](https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types) هي الخاصية التي تختلف فيها القائمة عن  قسيماتها التسلسلية. ومعناه قبولها الأفعال التالية (نستعمل في المثال حرف `l` للقائمة):

- الاستبدال:
    - لموضع: `l[i] = x`
    - لقطعة: `l[i:j] = t`
    - لقطعة بخطوة: `l[i:j:k] = t`
- الحذف:
    - لموضع: `del l[i]`
    - لقطعة: `del l[i:j]`
    - لقطعة بخطوة: `del l[i:j:k]`
- الإزالة: `l.remove(x)` لحذف أول ورود للعنصر
- النزع: `l.pop([i])` حذف العنصر من الموضع وإرجاعه
    - إن لم يحدد الموضع: نزع الأخير. إذ القوسان `[i]` (الموضع) `i` هنا في التعريف يعبران عن عامل اختياري
- الإدراج: `l.insert(i, x)` لإضافة عنصر في موضع محدد
- الإلحاق: `l.append(x)` لإضافة عنصر في النهاية
- الترتيب: `l.sort()` أو بالإجراء المدمج `sorted(l)`
- العكس: `l.reverse()` أو بالإجراء المدمج `reversed(l)`

لاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين المنحنيين `()`:

```{python}
#| error: true
t = (10, 20, 30, 40, 50)
t[0] = 100
print(t)
```

لكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين `[]`:

```{python}
l = [10, 20, 30, 40, 50]
l[0] = 100
print(l)
```

الاستبدال بالموضع والحذف منه:

```{python}
l = [10, 20, 30, 40, 50]
l[0] = 100
assert l == [100, 20, 30, 40, 50]

del l[0]
assert 100 not in l
```

الاستبدال بالقطعة والحذف منها

```{python}
l = [10, 20, 30, 40, 50]
l[1:3] = [200, 300]
assert l == [10, 200, 300, 40, 50]

del l[1:3]
assert l == [10, 40, 50]
```

الإدراج:

```{python}
l = [10, 20, 30, 40, 50]
l.insert(1, 100)
assert l == [10, 100, 20, 30, 40, 50]
```

الإزالة:

```{python}
l = [10, 20, 30, 40, 50]
l.remove(20)
assert l == [10, 30, 40, 50]
```

الإلحاق:

```{python}
l = [10, 20, 30, 40, 50]
l.append(60)
assert l == [10, 20, 30, 40, 50, 60]
```

الترتيب والعكس:

```{python}
l = [30, 40, 10, 20, 50]
l.sort()
assert l == [10, 20, 30, 40, 50]

l.reverse()
assert l == [50, 40, 30, 20, 10]
```

نزع العنصر الأخير وإرجاعه:

```{python}
l = [10, 20, 30, 40, 50]
x = l.pop()
assert x == 50
assert 50 not in l
```

### تجميع النتائج

ولأن التسلسل نوع من المتوالية، فيجوز التكرار عليه بالجملة: `for item in sequence`.

يكثر استعمال القائمة أنها حاوية لنتائج عملية تكرارية. فهذا البرنامج ينتج من القائمة اثنين: إحداها زوجية والأخرى فردية:

```{python}
numbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
evens = []
odds = []

for x in numbers:
    if x % 2 == 0:
        evens.append(x)
    else:
        odds.append(x)

print('list of evens:', evens)
print('list of odds:', odds)
```

## التسلسلات المرتبطة

هذان تسلسلان مرتبطان:

```{python}
students = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']
marks = [90, 80, 75, 85, 95]

assert len(students) == len(marks)
```

لو أردنا أن نمر على التسلسلين في نفس الوقت نستعمل الإجراء المدمج `zip()` الذي يظل يولد صفًا عناصره من كل تسلسل:

```{python}
for x, y in zip(students, marks):
    print(x, y)
```

## القائمة كمكدس

**المكدس** هو عبارة عن مجموعة مرتبة تتراكم عناصرها فوق بعض، بحيث ما يدخل أخيرا هو ما يخرج أولاً.

يتحصل المكدس بفعلين من القائمة:

- الإلحاق (إضافة العنصر في النهاية): `l.append(x)`
- النزع (إزالة الأخير وإرجاعه): `l.pop()`

ومن تطبيقات المكدس السهلة، استعماله في التحقق من توازن الأقواس:

```{python}
def is_balanced(s):
    l = []
    for c in s:
        if c == '(':
            l.append(c)
        elif c == ')':
            if len(l) == 0:
                return False
            l.pop()    
    return len(l) == 0

assert is_balanced('()')
assert is_balanced('(())')
assert not is_balanced('(()')
assert not is_balanced('((()')
assert not is_balanced('())))')
```

## القائمة كطابور

يمكن استعمال القائمة كطابور إلا أن الذي تنصح به صفحات توثيق بايثون هو استعمال النوع [`deque`](https://docs.python.org/3/library/collections.html#collections.deque) من المكتبة `collections` الأساسية؛ والتي تسمح بإضافة العناصر ونزعها من كلا الطرفين بكفاءة عالية:

```{python}
from collections import deque

q = deque([50])
q.append(20)
q.appendleft(10)
assert q == deque([10, 50, 20])
assert q.pop() == 20
assert q.popleft() == 10
```

## خلاصة

تعرفنا على التسلسل باستعراض نوعين منه: القائمة والصف؛ وذلك لتمييز خاصية التغير وأثرها على الأفعال التي يقبلها نوع القائمة ولا يقبلها الصف. كما رأينا أن التسلسل في أصله مجموعة؛ تقبل العضوية والعد والتكرار كغيرها من المجموعات.

سنتعرف فيما يلي على نوعين آخرين من المجموعات: [المجموعة الرياضية والقاموس](07_mapping.qmd).