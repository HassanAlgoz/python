---
title: التسلسل
jupyter: python3
---

كثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، ...إلخ من العمليات التي تعمل على جميع عناصر المجموعة.

درسنا اليوم عن شكل من أشكال مجموعة البيانات عندما تكون مرتبة. وهذا الشكل يسمى **تسلسل** (Sequence) ويشمل:

- **القائمة**: [`list`](https://docs.python.org/3/library/stdtypes.html#list)
- **النطاق**: [`range`](https://docs.python.org/3/library/stdtypes.html#range)
- **الصف**: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)
- **النص**: [`str`](https://docs.python.org/3/library/stdtypes.html#str) انظر [فصل النصوص](08_strings.qmd)

انظر ملحق [مجردات المجموعات](appendix_collections.qmd) للمزيد من التفاصيل

عندما نقول أن `s` تسلسل، فهذا يعني أنها تدعم:

- الإشارة: `s[i]`
- معرفة موضع شيء (إن وجد): `s.index(x)`
- عد تكرارات شيء: `s.count(x)`
- معرفة الطول: `len(s)`
- التكرار: `for x in s`
- العضوية: `x not in s`

يحدد هذا السلوك في بايثون باستخدام بنية [`class`](). سيأتي الحديث عنه إن شاء الله.

لكن قبل ذلك، نلقي نظرة على أمثلة لنرى قطرة من بحر استعمالات مفهوم التسلسل في بايثون.

## استعمالات التسلسل

لا تحزن إذا لم يكن الكود واضحًا بعد. فإن الغرض هنا استعراض حالات من الاستخدام. بعد ذلك سنبدأ بالفهم خطوة خطوة.

### سلسلة أعداد

```{python}
xs = [10, 20, 30, 40, 50]
```

إجراء لجمع الأعداد:

```{python}
def summation(numbers):
    total = 0
    for n in numbers:
        total += n
    return total

summation(xs)
```

حساب المتوسط عن طريق إجراء الجمع ثم القسمة على عدد العناصر:

```{python}
def average(numbers):
    return summation(numbers) / len(numbers)

average(xs)
```

نرشح الأعداد الموجبة فقط:

```{python}
def filter_positive(numbers):
    result = []
    for n in numbers:
        if n >= 0:
            result.append(n)
    return result
```

نرشح الأعداد الموجبة ثم نجمعها هي فقط:

```{python}
positives = filter_positive(xs)
summation(positives)
```

## تفكيك المركبات

هذا مثال لشيء مركب (وهو النص المكتوب) نمثل هنا لشيء يكثر استعماله وهو تحويل أي شيء مركب إلى مجموعة من الأجزاء ليتم التعامل معها بشكل منفصل.

مثلاً، نريد عد الكلمات في نص. لدينا الإجراء `split()` الذي يقوم بتقسيم النص إلى كلمات.

```{python}
s = "this is five woooords long"
words = s.split()
print(words)
```

البحث عن أطول كلمة:

```{python}
def longest_word(words):
    longest = ""
    for word in words:
        if len(word) > len(longest):
            longest = word
    return longest

longest_word(words)
```

ويمكن تحويل الكلمات إلى حروف كبيرة:

```{python}
def to_upper(words):
    result = []
    for word in words:
        result.append(word.upper())
    return result
    
to_upper(words)
```

يجدُر بالذكر أن النصوص نفسها هي تسلسلات من الحروف، لذا يمكن استعمال العمليات نفسها على النصوص. لكن لن استعجل الحديث عن ذلك، فلنتعمق أكثر في القوائم والصفوف أولاً.

## القائمة (List)

**القائمة** (`list`) سلسلة مرتبة من الأشياء، يمكن التعديل على هذه السلسلة بالحذف والإضافة في الأول أو الأخير أو الوسط. كما يمكن أن تحتوي على عناصر من أنواع مختلفة، بما في ذلك قائمة داخل قائمة.

```{python}
l1 = []        # empty list
l2 = [1]       # list with one item
l3 = [1, 2, 3] # list with three items
l4 = ['abb', 1, 2.0, True] # list with different types
```

يمكن أيضًا تركيب القوائم عن طريق:

- الدمج: باستخدام معامل `+`
- التكرار: باستخدام معامل `*`

```{python}
l5 = [1, 2, 3] + [4, 5]
l6 = l5 * 2
print(l5)
print(l6)
```

#### جرب

- `len(l3)` للحصول على طول القائمة `l3`
- `'abb' in l4` للتحقق مما إذا كانت `'abb'` عنصرًا في القائمة `l4`
    - بعد ذلك، جرب `'abb' not in l4`
- جرب `min(l3)`, `max(l3)`, `sum(l3)` وانظر ماذا يحدث

### الإشارة (Indexing)

للوصول إلى عنصر من القائمة، استخدم عملية الإشارة `[]`. يجب أن يكون المؤئر عددًا صحيحًا (`int`) في النطاق `0 <= index < len(s) - 1`.

```{python}
l1 = [10, 20, 30, 40, 50]
print(l1[0])
```

#### جرب

كذلك، جرب `l1[1]`, `l1[2]`, و `l1[3]`.

```{python}
l2 = ["Apple", "Banana", "Orange", "Lemon"]
```

في القائمة `l2`، الفهرس على النحو التالي:

```
0       1        2        3       4
+-------+--------+--------+-------+
| Apple | Banana | Orange | Lemon |
+-------+--------+--------+-------+
-4      -3       -2       -1
```

### جرب

- `l[1]`
- `l[2]`
- `l[3]`

وجرب أيضًا:

- `l[4]` (لماذا هذا خطأ؟)
- `l[-1]` و `l[len(l) - 1]`; هل هما نفس الشيء؟
- `l[-2]`

### التقطيع (Slicing)

- يأخذ التقطيع الشكل `s[start : end : step]`
- القيم الافتراضية عند الإغفال هي:
    - `start = 0`
    - `end = len(list)`
    - `step = 1`

```{python}
l1 = [10, 20, 30, 40, 50]
print(l1[1:3])
```

#### جرب

- `l1[1:4]`
- `l1[1:]`
- `l1[:3]`
- `l1[:]`
- `l1[::2]`
- `l1[::-1]`

### البحث `.index()`

طريق `.index()` تخرج موقع أول ظهور للقيمة المحددة.

```{python}
l1 = ['A', 'A', 'B', 'A', 'B']
idx = l1.index('B')
print(l1[idx], 'is at index', idx)
```

إذا لم يكن العنصر موجودًا في القائمة، فإنه يخرج خطأ.

```{python}
#| error: true
l1 = [10, 20, 30, 40, 50]
l1.index(4444)
```

رسالة الخطأ تخبرنا أن `4444` غير موجود في القائمة. دعنا نتعامل مع هذه الحالة في لبنة `else`، بدلاً من ترك البرنامج أن يتعطل.

```{python}
l1 = [10, 20, 30, 40, 50]
if 4444 in l1:
    idx = l1.index(4444)
    print(l1[idx], 'is at index', idx)
else:
    print('Item not found')
```


### التغيير (Mutation)

القوائم قابلة للتغيير، مما يعني أنه يمكن تعديلها بعد إنشائها. يشمل التغيير:

1. الإضافة: `l.append(x)` لإضافة عنصر إلى نهاية القائمة
2. الإزالة: `l.remove(x)`
3. الإدراج: `l.insert(i, x)` لإدراج عنصر في موضع محدد
4. الاستبدال: `l[i] = x`
5. الترتيب: `l.sort()`

ولأن القائمة متتالية قابلة للتغيير فهي تحقق جميع عمليات تسلسل. [راجع ملحق عمليات تسلسل](sequence_operations.qmd).

```{python}
l1 = [10, 20, 30, 40, 50]
l1[0] = 100 # replace the first element
print(l1)
```

#### جرب

- `l1.append(60)`
- `l1.remove(10)`
- `l1.insert(2, 300)`

### استبدال المقاطع

استبدال عنصرين بعنصرين:

```{python}
l1 = [10, 20, 30, 40, 50]
l1[1:3] = [200, 300]
print(l1)
```

#### جرب

- استبدال عنصرين بعنصرين: `l1[1:3] = [200, 300]`
- استبدال عنصرين بثلاثة عناصر: `l1[1:3] = [200, 300, 400]`
- استبدال عنصرين بعنصر واحد: `l1[1:3] = [200]`
- استبدال عنصرين بصفر عناصر: `l1[1:3] = []`

## عبور التسلسل

نستخدم الجملة: `for <item> in <sequence>` لقراءة التسلسل. على سبيل المثال، هذا البرنامج يعبر العناصر واحدًا تلو الآخر بالترتيب  ويطبعها:

```{python}
numbers = [10, 20, 30, 40, 50]
for x in numbers:
    print(x)
```

وهذا البرنامج ينتج من القائمة اثنين: إحداها زوجية والأخرى فدرية:

```{python}
numbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
evens = []
odds = []

for x in numbers:
    if x % 2 == 0:
        evens.append(x)
    else:
        odds.append(x)

print('list of evens:', evens)
print('list of odds:', odds)
```

## النطاق `range`

نوع [`range`](https://docs.python.org/3/library/stdtypes.html#range) يمثل تسلسلًا غير قابل للتغيير من الأرقام.

ويستخدم عادةً للتكرار عددًا محددًا من المرات في حلقات [`for`](https://docs.python.org/3/reference/compound_stmts.html#for).

وفقًا لوثائق بايثون فإن النطاق له شكلان:

- `class range(stop)`
- `class range(start, stop[, step])`

دعونا نفصل المحددات أولاً:

- `start`: موضع الابتداء، وهو مشمول في النطاق. (القيمة الافتراضية هي 0)
- `stop`: موضع الانتهاء، وهو غير مشمول في النطاق.
- `step`: مقدار الزياة أو النقص بعد كل كرة (القيمة الافتراضية هي 1)

فإذا قمت بتعيين محدد واحد فسيكون هو `stop`:

```{python}
for i in range(5):
    print(i)
```

وإذا قمت بتعيين محددين، فسيكون الأول `start` والثاني `stop`:

```{python}
for i in range(5, 10):
    print(i)
```

أما إذا حددتها ثلاثة، فسيكون الأول `start` والثاني `stop` والثالث `step`:

```{python}
for i in range(0, 10, 2):
    print(i)
```

ولك أن تعكس النطاق بتحديد `step` بقيمة سالبة، وتقلب البداية والنهاية:

```{python}
for i in range(10, 0, -1):
    print(i)
```

## الصف (Tuple)

**الصف** هو مثل القائمة (تسلسل)، لكن يفترق عنها في نقطة واحدة: أنه غير قابل للتغيير.

عدا ذلك، كل ما ينطبق على القائمة ينطبق أيضًا على الصف؛ إذ كلاهما يشتركان في خاصية كونهما **تسلسل**.

بدلاً من الأقواس الحادة `[]`، يستخدم الصف الأقواس المنحنية `()`:

```{python}
t1 = ()        # empty tuple
t2 = (1,)      # tuple with one item
t3 = (1, 2, 3) # tuple with three items
t4 = ('abb', 1, 2.0, True) # tuple with different types
```

يمكن أيضًا إنشاء الصف بوسائل:

- الدمج: باستخدام معامل `+`
- التكرار: باستخدام معامل `*`

```{python}
t5 = (1, 2, 3) + (4, 5)
t6 = t5 * 2
print(t5)
print(t6)
```

لو حاولت تغيير عنصر في الصف، ستحصل على خطأ

```{python}
#| error: true
t1 = (10, 20, 30, 40, 50)
t1[0] = 100
```

رسالة الخطأ تخبرنا أننا لا نستطيع تغيير قيمة عنصر في هذا الجمع.

كما ستلاحظ عدم وجود إجراءات الحذف والإضافة ونحوها.

### تحويل `list <-> tuple`

يمكن تحويل القوائم إلى جموع والعكس باستخدام الإجراءات `list()` و `tuple()`.

```{python}
l1 = [10, 20, 30, 40, 50]
t1 = tuple(l1)
l2 = list(t1)
print(t1)
print(l2)
```

من المهم ملاحظة أن الإجراءات `tuple()` و `list()` تُنشئ كائنًا جديدًا، ولا تقوم فعليًا بتحويل الكائن في مكانه. لذا، تبقى `l1` قائمة وتبقى `t1` صفًا.

القوائم أكثر قدرة، فأين نستخدم الصف؟ يستخدم المبرمجون الأنواع غير القابلة للتغيير عندما يريدون توصيل أن البيانات لا ينبغي تغييرها. هذا مفيد بشكل خاص عند تمرير البيانات في البرنامج، حيث يمكن تمريرها دون الخوف من تغييرها.

### إنتاج صف من نتيجة إجراء

كما أن الإجراءات تأخذ مجموعة مدخلات، يمكن أيضًا أن تنتج مجموعة مخرجات، وذلك باستخدام النوع `tuple` (صف):

على سبيل المثال، هذا الإجراء يقسم سلسلة إلى جزئين بناءً على نسبة معينة:

```{python}
def split_data(seq, ratio):
    idx = int(len(seq) * ratio)
    return seq[:idx], seq[idx:]
```

نختبر الإجراء ونلاحظ أن الناتج من نوع صف (`tuple`). فنستعمل التعيين المتعدد لاستخراج القيم من الصف:

```{python}
my_data = list(range(1, 10 + 1))
t = split_data(my_data, 0.80)

print(type(t))
a, b = t
print(a, b)

assert a == [1, 2, 3, 4, 5, 6, 7, 8]
assert b == [9, 10]
```
