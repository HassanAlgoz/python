---
title: المتتاليات
jupyter: python3
---

There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of [binary data](https://docs.python.org/3/library/stdtypes.html#binaryseq) and [text strings](https://docs.python.org/3/library/stdtypes.html#textseq) are described in dedicated sections.

```{mermaid}
graph TD
    A[Object]

    A --> A3[Sequence]
    A3 --> A321[Mutable Sequence]
    A3 --> A322[Immutable Sequence]
    
    A321 --> A3211[List]
    A321 --> A3212[Bytearray]
    
    A322 --> A3221[Tuple]
    A322 --> A3222[Range]
    A322 --> A3223[String]
    A322 --> A3224[Bytes]
```

## Lists

A list is a mutable sequence.

```{python}
l1 = []        # empty list
l2 = [1]       # list with one item
l3 = [1, 2, 3] # list with three items
l4 = ['abb', 1, 2.0, True] # list with different types
```

Lists can also be constructed by means of:

- concatenation: using the `+` operator
- repetition: using the `*` operator

```{python}
l5 = [1, 2, 3] + [4, 5]
l6 = l5 * 2
print(l5)
print(l6)
```

Try the following:
- `len(l3)` to get the length of the list `l3`
- `'abb' in l4` to check if `'abb'` is an item in the list `l4`
    - Next, try `'abb' not in l4`
- Try `min(l3)`, `max(l3)`, `sum(l3)` and see what happens

```{python}
# try it
```

### Indexing

- Items in a sequence can be accessed by an integer index.
- Remember that in Python indices start at 0 and ends at `len(sequence) - 1`.

```{python}
l1 = [10, 20, 30, 40, 50]
print(l1[0])
```

Like wise, try `l1[1]`, `l1[2]`, and `l1[3]`.

```{python}
# try it
```

```{python}
l2 = ["Apple", "Banana", "Orange", "Lemon"]
```

In the list `l2`, the indices are as follows:

```
0       1       2       3       4
+-------+-------+-------+-------+
| Apple | Banana| Orange| Lemon |
+-------+-------+-------+-------+
-4      -3      -2      -1    None
```

Try `l2[1]`, `l2[2]`, and `l2[3]`.

Also try indexing at:

- `l[4]` (why is this an error?)
- `l[-1]` and `l[len(l) - 1]`; are they the same?
- `l[-2]`

```{python}
# try it
```

#### `list.index()`

The `index()` method returns the index of the first occurrence of the specified value.

```{python}
l1 = [10, 20, 30, 40, 50]
idx = l1.index(30)
print(l1[idx], 'is at index', idx)
```

If the item is not in the list, it raises a `ValueError`.

```{python}
#| error: true
l1 = [10, 20, 30, 40, 50]
l1.index(4444)
```

The error message tells us that `4444` is not in the list. Let's handle the case in an `else` block, rather than letting the program crash due to an unhandled exception (error).

```{python}
l1 = [10, 20, 30, 40, 50]
if 4444 in l1:
    idx = l1.index(4444)
    print(l1[idx], 'is at index', idx)
else:
    print('Item not found')
```

### Slicing

- Slicing takes the form `seq[start:end:step]`
- Default values when omitted are:
    - `start=0`
    - `end=len(list)`
    - `step=1`

```{python}
l1 = [10, 20, 30, 40, 50]
print(l1[1:3])
```

Try the following:

- `l1[1:4]`
- `l1[1:]`
- `l1[:3]`
- `l1[:]`
- `l1[::2]`
- `l1[::-1]`

```{python}
# try it
```

### Mutation

- Lists are mutable, meaning they can be changed after they are created.
- You can change, add, and remove items in a list.

```{python}
l1 = [10, 20, 30, 40, 50]
l1[0] = 100
print(l1)
```

Try the following:

- two assigned to two: `l1[1:3] = [200, 300]`
- two assigned to three: `l1[1:3] = [200, 300, 400]`
- two assigned to one: `l1[1:3] = [200]`
- two assigend to zero: `l1[1:3] = []`

Two assigned to two:

```{python}
# SOLVED
l1 = [10, 20, 30, 40, 50]
l1[1:3] = [200, 300]
print(l1)
```

Other mutation operations include:

- `l1.append(60)` to add an item to the end of the list
- `l1.insert(2, 25)` to insert an item at a specific index
- `l1.remove(40)` to remove an item by value

Lists implement all of the common and mutable sequence operations. Checkout the appendix for more on [sequence operations](sequence_operations.qmd).

Lists provide the `.sort()` method which does the sorting in-place. If you want to create a new list, use the `sorted()` function instead. Example:

```{python}
l1 = [10, 20, 50, 40, 30]
l2 = sorted(l1)
print(l1)
print(l2)
```

Notice they are different.

Whereas:

```{python}
l1 = [10, 20, 50, 40, 30]
l1.sort()
print(l1)
```

Notice that `l1` is sorted in-place, and doesn't even return a new list to be assigned.

## Iterating over sequences

To do something to each item in sequences (such as: `list`, `tuple`, `range`, and `str`), you can use the syntax: `for <item> in <sequence>`.

The following program filters out a list of numbers into two lists: one for even numbers and the other for odd numbers.

```{python}
numbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
evens = []
odds = []

for x in numbers:
    if x % 2 == 0:
        evens.append(x)
    else:
        odds.append(x)

print('list of evens:', evens)
print('list of odds:', odds)
```

Line 5-8
Inside the loop, think of `x` as each item in the list `numbers`, one at a time.

Line 4
Think of this as `x = numbers[0]` in the first iteration, `x = numbers[1]` in the second iteration, and so on, until `x = numbers[-1]` (the last item).

## Ranges

The [`range`](https://docs.python.org/3/library/stdtypes.html#range) type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in [`for`](https://docs.python.org/3/reference/compound_stmts.html#for) loops.

Per Python docs, [`range`](https://docs.python.org/3/library/stdtypes.html#ranges) has two forms:
- `class range(stop)`
- `class range(start, stop[, step])`

Let's break down the parameters first:
- `start`: the starting number (inclusive)
- `stop`: the stopping number (exclusive)
- `step`: the increment (default is 1)

The two forms above means if you specify only one argument, it will be considered as:
- 1st argument = `stop`.

```{python}
for i in range(5):
    print(i)
```

If you specify two arguments, they will be considered as:
- 1st argument = `start` and
- 2nd argument = `stop`.

```{python}
for i in range(5, 10):
    print(i)
```

If you specify three arguments, they will be considered as 1st=`start`, 2nd=`stop`, and 3rd=`step`.

```{python}
for i in range(0, 10, 2):
    print(i)
```

We can also use a negative step:

```{python}
for i in range(0, 10, -1):
    print(i)
```

### Convert `range -> list`

The call to `range()` can be passed to a call to `list()` to convert it. Here we generate a list of numbers from 1,000 to 100 (in reverse order).

```{python}
numbers = list(range(1000, 0, -100))
print(numbers)
```

Another example is to generate two lists; of even and odd numbers, again, using the `list(range())` composition.

```{python}
evens = list(range(0, 10, 2))
odds = list(range(1, 10, 2))
print(evens)
print(odds)
```

## Tuples

Unlike lists, tuples are immutable; That is, once created, it cannot be changed.

Other than that, everything we said about lists applies to tuples as well; since both share the property of being **sequences**.

For example, we can construct tuples in the following ways:

```{python}
t1 = ()        # empty tuple
t2 = (1,)      # tuple with one item
t3 = (1, 2, 3) # tuple with three items
t4 = ('abb', 1, 2.0, True) # tuple with different types
```

Tuples can also be constructed by means of:

- concatenation: using the `+` operator
- repetition: using the `*` operator

```{python}
t5 = (1, 2, 3) + (4, 5)
t6 = t5 * 2
print(t5)
print(t6)
```

Tuples implement all of the common [sequence operations](sequence_operations.qmd).

### Mutation

However, when we come to mutation, we find that tuples are immutable:

```{python}
#| error: true
t1 = (10, 20, 30, 40, 50)
t1[0] = 100
```

The error message tells us that we can't change the value of an item in a tuple.

### Convert `list <-> tuple`

Lists can be converted to tuples and vice-versa using the `list()` and `tuple()` functions.

```{python}
l1 = [10, 20, 30, 40, 50]
t1 = tuple(l1)
l2 = list(t1)
print(t1)
print(l2)
```

It is important to note that the `tuple()` and the `list()` functions return a new object, and doesn't actually convert the object in-place. So, `l1` remains a list and `t1` remains a tuple.

### Why use tuples?

Lists are more capable, so why use tuples? Programmers use immutable types when they want to explicitly communicate that the data should not be changed. This is especially useful when passing data around in a program, as it can be passed around without fear of being changed.

## Text Sequence Type

Just like `list`s `str`ings are also immutable [sequences](https://docs.python.org/3/library/stdtypes.html#typesseq), but of Unicode code points, rather than arbitray objects.

Thus, `str` type implements all of the [common sequence operations](sequence_operations.qmd). Meaning you can do things like:

```{python}
s1 = 'Hello, World!'
print(s1[0])
print(s1 * 2)
```

Try the following:

- `s1[1:5]`
- `s1[1:5:2]`
- `s1[::2]`
- `s1 + ' How are you?'[::-1])`

```{python}
# try it
```


#### Exercise

Write a program that takes a string and prints the string in reverse.

```{python}
# try it
```

#### Exercise

Write a program that takes a string and prints every other character in the string. Example: `abcdef` -> `bdf`

```{python}
# try it
```

#### Exercise

Write a program that takes a string and prints the string in reverse order, but only every other character. It also must capitalize it. Example: `abcdef` -> `ECA`

```{python}
# try it
```

#### Exercise

Count the number of `o` in the string `hello world`. Hint: use the `.count()` method.

```{python}
# try it
```

## Binary Sequence Types

Python provides two built-in types for binary sequences: `bytes` and `bytearray`.

Discussion on binary sequences is beyond the scope of this book, but you can read more about them in the [Python documentation](https://docs.python.org/3/library/stdtypes.html#binaryseq).

Visit the appendix for more on [sequence tricks](sequence_operations.qmd).