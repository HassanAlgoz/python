---
title: الأصناف
jupyter: python3
---

سبق لدينا تعريف مُعرَّفات وإجراءات تأخذ عوامل وتعمل عليها. وكان ذلك عن طريق كتابة اسم المعرَّف ثم تعيين قيمة له، وكذلك بتعريف الإجراء بكتابة كلمة `def` ثم اسم الإجراء وما يعمل عليه من عوامل ثم تطبيق هذا الإجراء. واستعملنا أشياء من أصناف معرَّفة في المكتبة الأساسية مثل: `str`, `int`, `list` ونحوها. أما الآن فسنرى كيف نعرِّف نحن مثل هذه الأصناف.

الفكرة تدور حول إسناد معرَّفات وإجراءات إلى **صِنف** (Class) مجرَّد بحيث يكون لأي **شيء** (Object) مشتق منه الأمران:

1. خصائصه وهي المعرَّفات (Attributes)
2. سلوكياته وهي الإجراءات (Behaviors)

لاحظ التعريف التالي:

- وجود كلمة `class` الدالة على تعريف صنف جديد
- وجود إجراءات مضمَّنة تتبع كلمة `def` (وهما إجراءان)

```{python}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
```

لاحظ وجود طريقة التعيين على النحو `self.x = x` وكذلك `self.y = y` هما تعيينان لخاصيَّتيْن: `x,y` للشيء المعيَّن `self`. وجود العامل `self` في الابتداء في جميع الإجراءات المضمَّنة يشير لمعيَّن من هذا الصنف (نرى تعيينهما في المثال التالي).

والآن نستطيع إنشاء معيَّنات من هذا الصنف ونمرر القيم `x, y` بحسب ما هو موجود في [الإجراء الخاص بالإنشاء: `__init__`](https://docs.python.org/3/reference/datamodel.html#object.__init__) على النحو التالي:

```{python}
p1 = Point(3, 4)
p2 = Point(7, 1)
```

للوصول إلى خاصيَّة للشيء، فإننا نحددها بعد ذكر اسم المعيَّن على النحو التالي: `Object.Attribute`، وهذا مثال للوصول لخصائص كل من النقطتين وإجراء عملية على ذلك:

```{python}
x_diff = abs(p1.x - p2.x)
y_diff = abs(p1.y - p2.y)
print(f"The difference between the x-coordinates is {x_diff} and between the y-coordinates is {y_diff}.")
```

لاحظ أن السلوكيات إجراءات متعلِّقة بمعيَّن؛ فيمكن استدعاؤها بذكر اسمه متبوعًا باسم الإجراء بعد النقطة على النحو `()Object.Method`، وهذا مثال:

```{python}
p1.move(4, 4)
print(p1.x, p1.y)
```

إذا أردنا تخصيص طريقة عرض الصنف، بحيث لو ذكرناه في آخر السطر يظهر بشكل منسَّق، يمكن تخصيص الإجراءء ءالخاص `__repr__` ويعني: Representation أي: التمثيل .. وذلك على النحو التالي:

```{python}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
```

والآن إن عرفنا نقطة جديدة، ووضعناها على السطر لوحدها ، ستظهر لنا الإحداثيات، لا عنوانها الذاكري:

```{python}
p = Point(3, 4)
p.move(7, 6)
p
```

يمكن أن نعرف إجراءات تكون بين الأشياء من نفس النوع، فيمكن استعمال المزيِّن `@staticmethod` ليكون الإجراء متعلِّقًا بالصنف نفسه لا بالأعيان (لاحظ عدم وجود `self` في الإجراء الجديد `distance`):

```{python}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
				
    @staticmethod
    def distance(p1, p2):
        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5
```

الآن يمكن حساب المسافة بذكر اسم الصنف متبوعًا بنقطة ، متبوعةً باسم الإجراء، على النحو التالي:

```{python}
a = Point(0, 1)
b = Point(1, 0)

Point.distance(a, b)
```

كما أضفنا إجراءً عامًّا متعلقًا بالأصناف لا بالأعيان ، يمكن أيضًا إضافة معرَّف وإسناد قيمة له نحو `distance_type` كما في المثال (ولاحظ استعماله في الإجراء `distance` في جملة `if-else` من غير استعمال `self` لأننا لا نشير إلى معيَّن):

```{python}
class Point:
    distance_type = 'euclidean'

    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    @staticmethod
    def distance(p1, p2):
        if Point.distance_type == 'euclidean':
            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5
        elif Point.distance_type == 'manhattan':
            return abs(p1.x - p2.x) + abs(p1.y - p2.y)
```

ماذا عن العمليات التي تكون بين الأشياء من نفس النوع، وتكون مثل الجمع والطرح ونحوه؟ (انظر [توثيق بايثون لمحاكاة العمليات الرقمية](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types)):

```{python}
class Point:
    distance_type = 'euclidean'

    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    @staticmethod
    def distance(p1, p2):
        if Point.distance_type == 'euclidean':
            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5
        elif Point.distance_type == 'manhattan':
            return abs(p1.x - p2.x) + abs(p1.y - p2.y)
    
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Point(self.x - other.x, self.y - other.y)
```

تبحث بايثون عن `__add__` كلما وجدت علامة الجمع `+`، وكذلك تبحث عن `__sub__` كلما وجدت علامة الطرح `-`. فلنجرب الآن. لاحظ أن نتيجة الجمع نقطة جديدة، وكذلك نتيجة الطرح.

```{python}
p1 = Point(0, 1)
p2 = Point(1, 0)
print(p1 + p2)
print(p1 - p2)
```

والآن يمكنن تركيب شيء مكون من النقاط، وهو المضلَّع، على النحو التالي:

- يأخذ إجراء الإنشاء `__init__` سلسلة من النقاط ويعيِّنُها لمعرَّف اسمه `points`
- يعرض إجراء التمثيل `__repr__` كلمة `Polygon` وداخل أقواسها يضع تمثيل النقاط
- الإجراء الثالث هُنا هو خاصّ، تستعمله بايثون حين ترى استعمال إجراء `len(x)` 
- الإجراء الرابع هو لحساب قُطر المضلَّع، وذلك يعتمد على قياس المسافة بين سلسلة النقاط المتتابعة كما نرى


```{python}
class Polygon:
    def __init__(self, points):
        self.points = points

    def __repr__(self):
        return f"Polygon({self.points})"

    def __len__(self):
        return len(self.points)
    
    def perimeter(self):
        n = len(self.points)
        s = 0
        for i in range(n):
            s += Point.distance(self.points[i], self.points[(i+1)%n])
        return s
```

لاحظ أن إنشاء المضلَّع يتطلَّب إنشاء نقاط. ولاحظ أننا جعلنا كل نقطة في سيطر، لكنها في الحقيقة كلها عناصر لقائمة، وذلك بالنظر إلى القوسين المربعين `[ ]` على النحو التالي:


```{python}
poly = Polygon([
    Point(0, 0),
    Point(5, 0),
    Point(5, 5),
    Point(0, 5),
])
```

تمثيل المضلع:

```{python}
poly
```

عدد النقاط:

```{python}
len(poly)
```

المحيط:

```{python}
poly.perimeter()
```

انظر التوثيق الرسمي لبايثون حول [محاكاة أنواع الحاويات](https://docs.python.org/3/reference/datamodel.html#emulating-container-types) لمزيد من المعلومات. الآن سنحاكي مزيدًا من الإجراءات:

```{python}
class Polygon:
    def __init__(self, points):
        self.points = points

    def __repr__(self):
        return f"Polygon({self.points})"

    def __len__(self):
        return len(self.points)
    
    def __getitem__(self, i):
        return self.points[i]

    def __setitem__(self, i, p):
        self.points[i] = p

    def __delitem__(self, i):
        del self.points[i]
    
    def perimeter(self):
        n = len(self.points)
        s = 0
        for i in range(n):
            s += Point.distance(self.points[i], self.points[(i+1)%n])
        return s
```

```{python}
poly = Polygon([
    Point(0, 0),
    Point(5, 0),
    Point(5, 5),
    Point(0, 5),
])
poly
```

والآن سنستعمل الإجراءات الجديدة: الأخذ والتعيين والحذف:

الأخذ بالرقم أو بالشريحة:

```{python}
print(poly[0])
print(poly[-1])
print(poly[1:3])
print(poly[::-1])
```

الإسناد:

```{python}
poly[0] = Point(10, 10)
poly
```

الحذف:

```{python}
del poly[0]
poly
```

تبين بهذا محاكاة بعض إجراءات الحاويات الأساسية مثل `list` و`set` و`tuple` و`str` و`dict`.