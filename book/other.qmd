### Truth Value Testing

Any object can be tested for truth value in an `if` condition. Here are most of the built-in objects considered false:

1. constants defined to be false: `None` and `False`
2. zero of any numeric type: `0`, `0.0`, `0j`
3. empty sequences and collections: `''`, `()`, `[]`, `{}`

Example:

```{python}
if False or None or 0 or "":
    print("should never print")
```

Any other object value is considered `True`:

```{python}
if True or 1 or "abc":
    print("should always print")
```

#### Exercise

- Ask the user to enter their address
- If the address is not empty, print: `"Thank you for providing your address"`

```{python}
# try it
```

### Copy vs view

<img src="../assets/list-memory.png">

```{python}
my_list = [1, 2, 3, 4, 5]     # original list
my_list_copy = my_list.copy() # a new copy
my_list_copy2 = my_list[:]    # a new copy
my_list_shallow = my_list # view
```

```{python}
my_list_shallow[0] = 100
print(my_list)
```

```{python}
my_list_copy[1] = 200
print(my_list)
```

```{python}
my_list_copy2[2] = 300
print(my_list)
```



### Void functions

A **void function** is one that doesn't have a `return` statement, and thus will return `None` by default. Such functiosn usually make their output accessible through **side effects** (like printing to the console, writing to a file, etc.).

```{python}
def do_some_work(x):
    # ... some code that does something with x
    f = open('output.txt', 'w')
    f.write(str(x))
    # return None is implicitly added at the end of the function
```

### *Args and **Kwargs

```{python}
def my_function(a, b, *args):
    print(a, b)
    for arg in args:
        print(arg)

my_function(1, 2, 3, 4, 5, 6, 7, 8)
```

```{python}
def my_function(a, b, *args, **kwargs):
    print(a, b)
    for arg in args:
        print(arg)
    for key, value in kwargs.items():
        print(key, value)

my_function(1, 2, 3, 4, 5, six=6, seven=7)
```

### Special parameters

For readability and performance, Python gives control to restricts the way arguments can be passed so that a developer need only look at the function definition to determine if items are passed by position, by position or keyword, or by keyword.

Here we demonstrate the three types of parameters:

```
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only

```

- Parameters before the `/` marker are positional-only: `pos1` and `pos2`.
- Parameters after the `/` maker may be positional or keyword: `pos_or_kwd`.
- Parameters after the `*` marker are keyword-only: `kwd1` and `kwd2`.

Here is an example:

```{python}
def func(a, b, /, c, d, *, e, f):
    return a + b * c - d / e


func(1, 2, 3, d=4, e=5, f=6)
```


Here, `a` and `b` are positional-only. And since `c` and `d` are after `/` and before `*`, they can be passed by position or keyword. `e` and `f` are after `*`, so they can only be passed by keyword.

Notice that `c` is set by position while `d` is set by keyword. `e` and `f` are set by keyword only.

You may not write everyday functions in such a way. However, it's good to know that Python provides this level of control such that when you use libraries written by other developers, you can easily understand how to use them.

You can see more examples at the [official Python documentation](https://docs.python.org/3/tutorial/controlflow.html#function-examples).

### Advanced functions

Calling functions within functions is **composition**; a powerful concept that allows you to build complex programs from simple building blocks. **recursive functions** are functions that call themselves to solve a problem by breaking it down into smaller problems.

Functions can be passed as arguments to other functions (known as **higher-order functions**) to create more flexible and reusable code. Intrestingly, functions can also return other functions (**closures**). This is similar to instance construction from classes.

## Modules

### `dir()`

To find out what functions are available in the `math` module, you can use the `dir()` function:

```{python}
dir(math)
```

#### The `from import` syntax

We can also use the `from` syntax to import specific functions from a module:

```python
from math import sqrt, pow
```

```{python}
import math
from math import sqrt, pow

print(sqrt(64))
print(math.sqrt(64))
```




### 

- Textual data in Python is handled with [`str`](https://docs.python.org/3/library/stdtypes.html#str) objects, or *strings*.
- Strings are immutable [sequences](https://docs.python.org/3/library/stdtypes.html#typesseq) of Unicode code points.


### Truth Value Testing

Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below.

By default, an object is considered true unless its class defines either:

1. a `__bool__()` method that returns `False`
2. a `__len__()` method that returns zero

### Identity Comparison

The operators `is` and `is not` test for an object’s identity: `x is y` is true if and only if x and y are the same object. An [Object’s identity](https://docs.python.org/3/reference/expressions.html#is-not) is determined using the `id()` function. In other words:

- `==` is used to compare the values of two objects
- `is` is used to compare their memory addresses

```{python}
a = [1, 2, 3]
b = [1, 2, 3]

if a == b:
    print('they are equal')

if a is b:
    print('they are the same object')

# `is` is equivalent to
if id(a) == id(b):
    print('they are the same object')
```

```{python}
print(id(a))
print(id(b))
```

We expand later on this concept when we get to **immutability**.

## Printing

### Carriage Return `'\r'` Character

The "carriage return" character has that name because it refers to a command to return the (print) carriage to the beginning of the line.

<img src="assets/type-writer.png" width="300">

> You'd start a new paragraph by feeding in the paper and then - with your left hand - shoving the carriage (the part on top that has the paper) all the way to the right so the keys will be hitting the spot on the far left first. Then as you typed, the carriage would advance one space at a time. When it got all the way to the right (usually it went "ding!"), you'd have to push that carriage back again, and if you didn't also hit the line-feed lever, you'd start typing over the same line. So the line-feed lever is right there, mounted in the same spot you'd use to push the carriage back anyway, and you could combine both motions. -- [Answer by **nico** on english.stackexchange.com](https://english.stackexchange.com/a/36082)

```{python}
print('A', end='\r')
print('B')
```

```{python}
import time
# progress bar using the Carriage Return "\r" character
for x in range(10 + 1):
    time.sleep(0.20)
    print(f'[{x}/10] ' + '===' * x + '>', end='\r')
```



## Buffering Output

Buffering is a technique used to reduce the number of I/O operations by storing the output in a buffer before writing it to the output device. This is more efficient than writing each line to the output device immediately.

Let's make our function smarter by using a text buffer (`TextIO`) to store the output, and then can choose what to do with it, such as printing it to the console or writing it to a file. For clarity, we will add type annotaions to the function signature. But first, we `from typing import Sequence, TextIO` to import the necessary types.

```{python}
from typing import Sequence, TextIO

def write_boxes(buf: TextIO, seq: Sequence):
    """Writes a sequence of items in a box format, in a given text buffer."
    Example:
    >>> write_boxes([100, 200, 300])
    0       1       2       3       
    +-------+-------+-------+
    |  100  |  200  |  300  |
    +-------+-------+-------+
    -3      -2      -1      
    """
    
    # constants
    x = '+' # corner
    h = '-' # horizontal
    v = '|' # vertical
    padding = 2
    
    # find the maximum string width of the items
    width = max(len(str(item)) for item in seq)

    # print the positive indexes on top
    for i in range(len(seq) + 1):
        s = str(i)
        buf.write(s.ljust(width + padding * 2 + len(s)))
    buf.write('\n')

    # print the top border line
    for i, item in enumerate(seq):
        if i == 0:
            buf.write(f'{x}')
        buf.write(f'{h * (width + padding * 2)}')
        buf.write(f'{x}')
    buf.write('\n')

    # print the items
    for i, item in enumerate(seq):
        if i == 0:
            buf.write(f'{v}')
        buf.write(str(item).center(width + padding * 2))
        buf.write(f'{v}')
    buf.write('\n')

    # print the bottom border line
    for i, item in enumerate(seq):
        if i == 0:
            buf.write(f'{x}')
        buf.write(f'{h * (width + padding * 2)}')
        buf.write(f'{x}')
    buf.write('\n')

    # print the negative indexes below
    for i in range(len(seq), 0, -1):
        s = str(-i)
        buf.write(s.ljust(width + padding * 2 + len(str(i))))
    buf.write('\n')
```

To directly print the output to the console, we can use the [`sys.stdout`](https://docs.python.org/3/library/sys.html#sys.stdout) (standard output) file object.


```{python}
import sys

write_boxes(sys.stdout, [100, 200, 300])
```

We can also use an efficient in-memory buffer (`io.StringIO`) to stream the output to. Later we can read its contents as a string, and do something with it. Here, we are just printing it to the console:

```{python}
import io

contents = ''
with io.StringIO() as buffer:
    write_boxes(buffer, [100, 200, 300])
    contents = buffer.getvalue()
print(contents)
```

We can [`open()`](https://docs.python.org/3/library/functions.html#open) a file an write to it instead:

```{python}
with open('output.txt', 'w') as fdst:
    write_boxes(fdst, ['Apple', 'Banana', 'Cherry', 'very long string'])
```


## How to read input from command line arguments?
- `sys.argv`
- `argparse`


## What are environment variables and how to read input from environment variables?
- `os.environ`
- `python-dotenv`




أؤمن بالرجوع للمصادر الأساسية في المسائل الأصلية في اللغة البرمجية. ولا بأس أن نرجع للمصادر الثانوية في المسائل الفرعية. لا يركز الكتاب على حفظ الكود البرمجي وإنما على معرفة مظان الوصول إليه. ولذلك كثيرًا ما يعزوا الكتاب إلى [الصفحات المرجعية في موقع بايثون](https://docs.python.org/3/) فهي المصدر الأوَّلي الذي يجب أن يُحتكم إليه. هذا لا يعني اطراح المصادر الثانوية ولكن تقديم الأوليَّة أولاً عند البحث عما هو أصلي؛ أما ما يتفرع عنه فلا بأس.

::: {.callout-note}
ملاحظة جانبية: قِس على هذا المدخلات الأخرى وكذلك المُخرجات. فعند أي مُدخَل (سواءً ملفٌّ يُقرأ ، أو بيانات قادمة من الشَّبكة أو من قاعدة بيانات محليَّة) فإنه يقطَعُ تدفُّقَ البرنامج لحين يتم تسجيله في الذاكرة (RAM) ، ثم يُتِمُّ البرنامج سيرَه. وكذلك الأمر عند أي عملية إنتاج مُخرجات؛ فهي عمليَّة كتابة تحتاج من البرنامج أن يجعل التحكم في يدِ نظام التشغيل لأنه المخوَّل بعمليَّات كهذه. ثم قد يعود على البرنامج برسالة خطأ، أو بالتمام إن تم كل شيء على أحسن حال. وهذا تفصيله يكون في تعدد خيوط التنفيذ (Multi-processing).
:::

#### تمرين

اطلب من المستخدم إدخال الاسم والعمر ثم أخبره كم سيكون عمره بعد 10 سنوات مناديًا له باسمه.

ملاحظة: استخدم دالة `int()` لتحويل المدخل إلى عدد صحيح قبل أن تتمكن من إجراء العمليات الحسابية عليه.

تلميح: تحقق من أن `type()` لمتغير العمر هو من نوع `int` قبل إجراء العمليات الحسابية.

```{python}
# try it
```


## الخوارزميات

**الخوارزمية (Algorithm)** خطوات نحو غاية. و**البرنامج** هو مجموعة خوارزميات صالحة للترجمة إلى خطوات حاسوبية محددة.

عدد لغات البرمجة (التي تكتب بها البرامج) اليوم 265 لغة (@tiobeIndex) وذلك لأن كل صانع لغة يصوغها لتجريد مكونات نظام التشغيل (التي هي تجريد للمكونات الحاسوبية، أي: وحدات المعالجة) بطريقة تناسب توظيفًا معيَّنًا وإن كان الأغلب يزعمون أن لغاتهم غير مختصة (General Purpose) إلا أنك ترى واقع المجتمع الذي يستعمل اللغة يقودها للتخصص في مجالات معيَّنة يراها أنسب فيها. فاللغات تتمايز في **قدر تجرُّد اللغة** (بُعد الأوامر البرمجية) عن وحدات المعالجة الذي ستنفذ هذه الأوامر في الواقع:

- فالأمر الواحد في لغة عالية مثل بايثون قد يترجم إلى مئة أمر تنفيذي (تفصيلي) بالنسبة للمعالِج
- بينما يمكنك التعبير عنه بلغة سي (C) بخمسة أوامِر تُترجَم إلى عشرين أمرًا تنفيذيًّا فقط، والنتيجة واحدة

كما أن لغة بايثون عادة ما تكون بوابة للغة C++ التي تعمل خلف الكواليس.

لغات البرمجة مثل بايثون تحتاج لترجمة الأكواد بلغتها المجردة نسبيًّا إلى **لغة الآلة**. ف**المترجم** يحول الكود إلى عمليات أكثر تفصيلاً لتتواءم مع الهيكل الرقمي للحاسوب، ثم يتم ترجمة تلك العمليات للمنطق الرقمي الثنائي (أصفار وآحاد) الذي هو البرنامج التنفيذي، ليتم بعد ذلك تحميلها في وحدة المعالجة المركزية (CPU) حتى يبدأ بتنفيذها كما لو أنه ينفذ الكود سطرًا سطرًا.

هذا ما يحدث خلف الكواليس عند تشغيل الكود المكتوب.



دعونا نجعل دالتنا أكثر اكتمالاً بإضافة ميزة الترجمة. سنقوم بتعريف قاموس يربط قوة كلمة المرور بلغات مختلفة.

```{python}
LANGUAGE = 'AR'

translation = {
    'Weak': {
        'AR': 'ضعيفة',
        'CN': '弱'
    },
    'Strong': {
        'AR': 'قوية',
        'CN': '强'
    }
}

def check_password_strength(password):
    minimum_length = 8 #<1>
    if len(password) < minimum_length: # <2>
        return translation['Weak'][LANGUAGE] # <3>
    else:
        return translation['Strong'][LANGUAGE]
```
1. `minimum_length` هو متغير محلي للدالة: **متغير محلي**.
2. يمكن للدالة الوصول إلى `len()` لأنه مدمج. ويمكنها الوصول إلى `minimum_length` لأنه متغير محلي.
3. يمكن للدالة أيضًا الوصول إلى `LANGUAGE` و `translation` لأن كلاهما **متغيرات عالمية** (ليست داخل أي دالة).

إذا حاولنا الوصول إلى المتغير المحلي `minimum_length` خارج الدالة، سنحصل على خطأ:

```{python}
#| error: true
print(minimum_length)
```

إذا كنت تفضل التذكيرات، فإن **LEGB** (محلي، محيط، عالمي، مدمج) هو تذكير جيد لتحديد أي متغير يتم الوصول إليه عند مواجهة اسم. يبحث عن المتغيرات بالترتيب التالي:

1. النطاق المحلي: كتلة كود الدالة الحالية.
2. النطاقات المحيطة: أي دوال أو حلقات تحيط بالدالة الحالية.
3. النطاق العالمي: مساحة الأسماء العالمية للوحدة. أي الكود الذي ليس داخل أي من الدوال.
4. الأسماء المدمجة: الدوال والمتغيرات المعرفة مسبقًا في بايثون.

انظر [9.2.1. مثال على النطاقات ومساحات الأسماء | وثائق بايثون](https://docs.python.org/3/tutorial/classes.html#scopes-and-namespaces-example) لمزيد من التفاصيل حول كيفية الرجوع إلى النطاقات ومساحات الأسماء المختلفة، وكيف تؤثر [`global`](https://docs.python.org/3/reference/simple_stmts.html#global) و [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) على ربط المتغيرات.

انظر: https://docs.python.org/3.13/tutorial/classes.html#scopes-and-namespaces-example
> خاصية فريدة في بايثون هي أنه – إذا لم يكن هناك تصريح `global` أو `nonlocal` قيد التنفيذ – فإن التعيينات للأسماء دائمًا تذهب إلى النطاق الأعمق.
> يمكن استخدام تصريح `global` للإشارة إلى أن المتغيرات المعينة تعيش في النطاق العالمي ويجب إعادة ربطها هناك؛ يشير تصريح `nonlocal` إلى أن المتغيرات المعينة تعيش في نطاق محيط ويجب إعادة ربطها هناك.



## Why use functions?

Core ideas behind using functions are:

Firstly, **Abstraction**: hiding low-level details behind a simpler, higher-level idea with a name.

Secondly, **Modularity**: dividing a system into components, each of which can be designed, implemented, tested, reasoned about, and reused separately from the rest of the system.

Thirdly, **Composition**: combining these modular abstractions in various ways to create higher-level abstractions.

Python provides other constructs related to these ideas: functions (our topic today), classes and packages. We will cover these in later chapters.


## المكتبات

لاستخدام مكتبة [`math`](https://docs.python.org/3/library/math.html) يمكن استيرادها بعبارة `import`:

```{python}
import math

print(math.sqrt(16))
print(math.pow(2, 4))
```

قد قام آخرون بإنشاء عمليات وجعلوا حزمهم متاحة. على سبيل المثال، تُستخدم حزمة `numpy` لإجراء العمليات العددية على المصفوفات متعددة الأبعاد (N-dimensional arrays). لاستخدامها، نحتاج أولاً إلى تثبيتها باستخدام `pip`:

```bash
pip install numpy
```

مدير الحزم PIP هو أداة لتثبيت الحزم من فهرس حزم بايثون (Python Package Index - PyPI). هنا صفحة [حزمة numpy](https://pypi.org/project/numpy/).

بعد ذلك نستطيع استعمالها بعد استيرادها:

```{python}
import numpy as np

mat1 = np.array([
    [1, 2],
    [3, 4]
])

mat2 = np.array([
    [5, 6],
    [7, 8]
])

print(np.dot(mat1, mat2))
```



```{python}
!pip install geopy
```

```{python}
from geopy.distance import geodesic
from geopy.geocoders import Nominatim

geolocator = Nominatim(user_agent="exercise")

dammam_location = geolocator.geocode("Dammam, Saudi Arabia")
bahrain_location = geolocator.geocode("Bahrain")

dammam_coords = (dammam_location.latitude, dammam_location.longitude)
bahrain_coords = (bahrain_location.latitude, bahrain_location.longitude)

# Calculate the distance
distance = geodesic(dammam_coords, bahrain_coords).kilometers
print(f"The distance between Dammam and Bahrain is {distance:.2f} kilometers.")
```

وهي معظم هياكل البيانات في المكتبة الأساسية: كالمتسلسلة المتغيرة (list)، ومتسلسلة الحروف (str)، والمتسلسلة الثابتة (tuple)، وكذلك غير المتسلسلات كالقاموس (dict)، وكائنات الملفات، وأي كائن لديه عملية: `__iter__` أو عملية `__getitem__` على طريقة المتسلسلة.


#### Exercise

Create a dictionary of fruits and prices:

- Add a new item to the dictionary: `bananas` with a price of `3.5`.
- Using the `update` method, add a new item to the dictionary: `apples` with a price of `4.5`.
- Using the `update` method, change the price of `bananas` to `5.5` and also add `hazelnuts` with a price of `12.5`
- Using the `pop` method, remove the item `bananas` from the dictionary.

```{python}
#| tags: []
fruits_and_prices = {
  "apple": 1.00,
  "orange": 2.50,
  # Add your own fruits and prices here ...
}
```

#### Exercise

Print the value of key `"history"` from the below by traversing the nested dictionary one key at a time.

```{python}
my_dict = {
    "class": {
        "president": {
            "name": "Malik",
            "marks": {
                "physics": 70,
                "history": 80
            }
        }
    }
}
```


#### تمرين

اكتب برنامجًا يأخذ سلسلة نصية ويطبعها بترتيب عكسي.

```{python}
# try it
```

#### تمرين

اكتب برنامجًا يأخذ سلسلة نصية ويطبع كل حرف ثاني في السلسلة النصية. مثال: `abcdef` -> `bdf`

```{python}
# try it
```


#### تمرين

عد عدد الأحرف `a` في السلسلة النصية `Adam Ibraheem`. تلميح: استخدم طريقة `.count()`.

```{python}
# try it
```
