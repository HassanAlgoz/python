# الأخطاء

الخطأ أو [الاستثناء](https://docs.python.org/3.13/tutorial/errors.html) هو خروج البرنامج عن المسار المثالي.

- فمثلاً: يحدث خطأ إن طُلِب من المستخدم إدخال قيمة عددية فأدخل قيمة حرفية؛ فوجب التعامل مع ذلك.
- أو: تمت قراءة ملف بصيغة معيَّنة لكن تمّ اكتشاف وجود قيم حرفية في مكان قيم التواريخ.
- أو: تم طلب معلومات المستخدم من الخادم لكنه لم يُجب.

فكل هذه تعتبر مسارات غير مثالية واقعية وعادةً ما تحصل، بل ويجب اعتبارها من الأساس في صناعة البرنامج.

فمن الأخطاء ما يمكن التعامل معه، ومنها ما لا يمكن التعامل معه:

- إذا كانت المشكلة بامتلاء الذاكرة في الجهاز؛ فإن البرنامج ليس له إلا أن يخرج برسالة للمستخدم أو المسؤول عن الجهاز .. وليس للبرنامج الأحقية في مسح بيانات مثلاً.
- أما إذا كانت المشكلة في تأخر الإجابة من الخادم مثلاً، فقد نعيد المحاول مرة أخرى بعد ثوانٍ، ونعيدها لعددٍ محدد من المرات، أملاً في الحصول على إجابة. ثم نظهر رسالة خطأ إن نفدت جميع المحاولات.

نستطيع أن نصنف الأخطاء إلى ثلاثة، وهي مرتبة من الأسهل إلى الأصعب:

1. أخطاء نحوية (Syntax errors)
2. أخطاء وقت التشغيل (Runtime errors)
3. أخطاء منطقية (Logical errors)

في هذا الفصل، سنناقش كل نوع من الأخطاء وكيفية التعامل معها.

## الأخطاء النحوية

الأخطاء النحوي تتعلق بتركيب اللغة لا أكثر ولا أقل. إليك ثلاثة أمثلة.

### فقدان النقطتين `:`

```{python}
#|error: true
if (x > 5)
    print("x")
```

### علامات اقتباس غير متوازنة

```{python}
#|error: true
print("x
```

### اسم متغير غير صالح

```{python}
#| error: true
my-variable = 10
```

### أخطاء المحاذاة

من الأخطاء النحوية الشائعة في بايثون: أخطاء المحاذاة (Indentation Error).

وذلك أن بايثون تقبل نوعين من المسافات البادئة للسطر؛ إما بحرف المسافة التي بين الكلمات `\s` أو بحرف المسافة بين الأعمدة `\t`. وقد يستعمل بعض الناس هذه وبعضهم ذلك، ثم تأخذ كودًا من هنا وكودًا من هناك، فترى الكود عنك لا يعمل، والسبب هو الخلط بينهما في نفس الكود. وبايثون لا تقبل ذلك. فيجب توحيد النوع. إما هذه أو هذه. لذلك يضبط VS Code ومحررات الأكواد الأخرى تحويل البادئة تلقائيًا إلى مسافة أو العكس.

إليك بعض الأمثلة لما يحصل من أخطاء في المحاذاة:

عدم وجود مسافة بادئة، عندما تكون متوقعة:

```{python}
#| error: true
if True:
print("x")
```

عدم تطابق المحاذاة:

```{python}
#| error: true
if True:
    print("x")
     print('y')
```


## أخطاء وقت التشغيل

**خطأ وقت التشغيل** هو ما يكتشفه البرنامج عند تنفيذه. ويُعرف **بالاستثناء** (Exception).

عند إهمال هذه الأخطاء يحصل أمران عند تنفيذ سببها:

1. يتوقف البرنامج
2. تظهر رسالة خطأ عن طريق منفذ الخطأ (stderr)

تسمى الاستثناءات بهذا الاسم لأنها تقطع التدفق المثالي السعيد للبرنامج. والحقيقة أنها ليست استثناءات من حيث نُدرتها؛ بل هي شائعة جدًّا ويجب التنبه إليها مثل أي حالة أخرى من البرنامج. مثلاً: عند قراءة ملف، يجب أن نتعامل مع حالة ما لو كان الملف غير موجودًا.

هناك آليتان في لغات البرمجة للتعبير عن حدوث خطأ:

- **الاستثناء (Exceptions)**: لغات مثل C++ (1979)، Java (1998)، Python (1991) و JavaScript (1995) ترمي/ترفع الاستثناءات باستعمال عبارة مثلة `raise` أو عبارة `throw` على حسب اللغة.
- **الإرجاع (Return)**: اللغات الحديثة مثل Go (2009) و Rust (2015) ببساطة تعيد الخطأ كشيء (قيمة) عند حدوثه باستعمال جملة `return` التي في الإجراء.

لنأخذ مثالًا لنرى كيف يتم التعامل مع الاستثناءات في Python.

#### مثال

افترض في بداية البرنامج، نحتاج إلى قراءة ملف تكوين `config.json` لتهيئة حالة البرنامج:

```{python}
#| error: true

file = open('config.json')
```

الملف غير موجود لذا يعرف إجراء `open()` استثناءً من نوع  `FileNotFoundError`. فنعالج هذا الاستثناء باستخدام جملة `try-except`. دعونا نطبع رسالة تخبر المستخدم بإنشاء الملف. أو الأفضل من ذلك، دعونا نشير إلى ملف تكوين افتراضي: `default.json`:

```python
try:
    file = open('config.json')
    # code that does something ...
    # ...
except FileNotFoundError:
    file = open(DEFAULT_CONFIG_PATH)
except Exception as e:
    print("something unexpected happened:", e)
```

الفقرة الأخيرة `except Exception as e` هي عبارة عن استثناء شامل، وذلك في حال حصول استثناء آخر لم نتوقعه. والغرض من ذلك ألا يتوقف البرنامج.

#### مثال آخر

دعونا نلقي نظرة على مثال آخر، قد يحصل فيه حالة خطأ بسبب تنوع مدخلات المستخدم:

```{python}
choices = ['bus', 'train', 'plane', 'boat'] 
print("""Choose an option:
1. Go by bus
2. Go by train
3. Go by plane
4. Go by boat
""")
# choice = input("Choose a number from 1 to 4: ")
```

ما هي حالات الخطأ الممكنة؟:

- قد يدخل المستخدم رقمًا خارج النطاق: `0` أو `9`
- قد يدخل المستخدم قيمة غير صحيحة: `three`

نحتاج إلى التعامل مع هذه الاستثناءات. يمكننا استخدام كتلة `try-except` للتعامل مع الاستثناءات.

دعونا نرى ما هو الاستثناء الذي يتم رفعه في الحالة الأولى:

```{python}
#| error: true
choices[9]
```

الاستثناء هو `IndexError`.

ماذا عن الحالة الثانية؟ لنرى:

```{python}
#|error: true
choices['three']
```

الاستثناء هو `TypeError`.

الآن بعد أن عرفنا الحالات، دعونا نتعامل معها.

```{python}
c = '9'

retry_message = "Please enter a digit between 1 and 4"

try:
    c = int(c)
    print('User chooses to:', choices[c-1])
except IndexError:
    print(retry_message)
except ValueError:
    print(retry_message)
```

يمكن تجميع الاستثناءات على النحو التالي:

```{python}
try:
    c = int(c)
    print('User chooses to:', choices[c-1])
except (IndexError, ValueError):
    print(retry_message)
```

## رفع الاستثناءات

إذا كنت تريد رفع استثناء، يمكنك استخدام الكلمة `raise`.

- إذا كان نوع العامل خاطئًا، يجب رفع `TypeError`
- وإلا، فتحقق من القيمة؛ فإن كانت خارج نطاق الإدخال المقبول، يجب رفع `ValueError`

ملاحظة: كان علينا استيراد `numbers` للتحقق من نوع الإدخال `x` باستخدام الإجراء المضمَّن: `isinstance(x, numbers.Number)` على النحو التالي:

```{python}
import numbers

def square_root(x):
    # Validation
    if not isinstance(x, numbers.Number):
        raise TypeError("Argument must be a number")
    if x < 0:
        raise ValueError("Cannot calculate square root of a negative number")
    # Now that we have checked the input, we can calculate the square root
    result = x ** 0.5
    return result
```

لنختبر حالتي الخطأ:

```{python}
#| error: true
square_root('16')
```

```{python}
#| error: true
square_root(-99)
```

لنختبر الآن المسار السعيد:

```{python}
square_root(16)
```


## أنواع الأخطاء الشائعة وأسبابها وحلولها:

فيما يلي بعض أنواع الأخطاء الشائعة وكيفية إصلاحها:

<!-- | **Error Type**  | **Cause**                                                                                  | **Fix**                                                                                   |
|-----------------|---------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| `TypeError`     | Happens when an operation is performed on an object of an inappropriate type, or a function is called with the wrong number/type of arguments. | Use `type()` or `isinstance()` to check the data types used match the operation requirements (e.g., `int+int` is valid whereas `str+int` is not). |
| `ValueError`    | Raised when a function receives an argument of the correct type but with an inappropriate value (e.g., passing a negative number where only positive numbers are valid). | Ensure the values passed to functions are valid and match the expected range or domain.    |
| `IndexError`    | Triggered when trying to access an index that is outside the range of a list or sequence.     | Check the length of the sequence (e.g., using `len()`) before accessing indices. You can also use `try-except` blocks to handle potential IndexError exceptions safely. Consider iterating over the list or using bounds-safe methods like `enumerate()`. |
| `KeyError`      | Raised when trying to access a key that does not exist in a dictionary.                       | Check for the key’s existence using `in` before accessing it (e.g., `if key in dict`). Alternatively, use the `.get()` method, which returns `None` (or a default value) if the key is not found, instead of raising an error. |
| `AttributeError`| Happens when an invalid attribute or method is accessed for an object (e.g., calling a method that doesn’t exist for a certain object). | Verify that the object has the attribute or method you're trying to use. Check for typos or wrong types. |
| `ModuleNotFoundError` | Happens when Python cannot find the module you are trying to import.                        | Check the module name for typos. Ensure the module is installed in your Python environment. |
| `SyntaxError`   | Occurs when the Python parser encounters a syntax error.                                      | Check the code for missing or extra characters, incorrect indentation, or other syntax issues. |
| `NamedError`    | Happens when a variable is used before it is defined.                                        | Ensure the variable is defined before using it. Also, check for typos in the variable name. | -->

1. **`TypeError`**  
   - **السبب**: يحدث عندما يتم تنفيذ عملية على كائن من نوع غير مناسب، أو عند استدعاء إجراء بعدد أو نوع غير صحيح من العوامل.  
   - **الحل**: استخدم `type()` أو `isinstance()` للتحقق من تطابق أنواع البيانات المستخدمة مع متطلبات العملية (على سبيل المثال، `int+int` صحيحة بينما `str+int` غير صحيحة).  

2. **`ValueError`**  
   - **السبب**: يتم رفع هذا الخطأ عندما تستقبل عامل من النوع الصحيح ولكنه ذو قيمة غير مناسبة (مثل تمرير عدد سالب إلى مكان يُتوقع فيه أعداد موجبة فقط).  
   - **الحل**: تأكد من أن القيم الممررة إلى الإجراءات صحيحة وتتطابق مع النطاق أو المجال المتوقع.  

3. **`IndexError`**  
   - **السبب**: يتم رفع هذا الخطأ عند محاولة الوصول إلى عنصر في موقع خارج حدود قائمة أو سلسلة.  
   - **الحل**: تحقق من طول التسلسل (مثل استخدام `len()`) قبل الوصول إلى الفهارس. يمكنك أيضاً استخدام كتل `try-except` للتعامل مع استثناءات `IndexError` بأمان. فكّر في التكرار على القائمة أو استخدام طرق آمنة مثل `enumerate()`.  

4. **`KeyError`**  
   - **السبب**: يحدث عند محاولة الوصول إلى مفتاح غير موجود في القاموس.  
   - **الحل**: تحقق من وجود المفتاح باستخدام `in` قبل الوصول إليه (مثل `if key in dict`). بدلاً من ذلك، يمكنك استخدام الطريقة `.get()` التي تُرجع `None` (أو قيمة افتراضية) إذا لم يتم العثور على المفتاح بدلاً من رفع خطأ.  

5. **`AttributeError`**  
   - **السبب**: يحدث عند محاولة الوصول إلى خاصية أو إجراء غير صالحة لكائن معين (مثل استدعاء إجراء غير موجودة على الكائن).  
   - **الحل**: تحقق مما إذا كان الكائن يحتوي على الخاصية أو الإجراء التي تحاول استخدامها. تحقق من وجود أخطاء إملائية أو من كون نوع الكائن صحيحاً.  

6. **`ModuleNotFoundError`**  
   - **السبب**: يحدث عندما لا يستطيع Python العثور على الوحدة (module) التي تحاول استيرادها.  
   - **الحل**: تحقق من اسم الوحدة للتأكد من خلوه من الأخطاء الإملائية. تأكد من تثبيت الوحدة في بيئة Python الخاصة بك.  

7. **`SyntaxError`**  
   - **السبب**: يحدث عندما يعترض المفسّر (Python parser) على خطأ في بناء الجملة.  
   - **الحل**: تحقق من وجود أي أحرف مفقودة أو زائدة، أو مشاكل في التنسيق، أو أي أخطاء في بناء الجملة.  

8. **`NameError`**  
   - **السبب**: يحدث عندما يتم استخدام متغير قبل تعريفه.  
   - **الحل**: تأكد من تعريف المتغير قبل استخدامه. تحقق أيضاً من وجود أخطاء إملائية في اسم المتغير.  


### كيفية إصلاح الأخطاء الأكثر تعقيدًا؟

قد تتطلب الأخطاء الأكثر تعقيدًا المزيد من التصحيح وفهم الكود. لذا، من المهم تعلم كيفية قراءة رسالة الخطأ التي تنتجها Python. يتكون الخطأ من ثلاثة أجزاء: **نوع الخطأ**، **رسالة الخطأ**، و **سلسلة النداءات** (stack trace).

أولاً، اقرأ السطر الأخير. فذلك يخبرك بأمرين:

1. `ErrorType` الذي يمكنك استخدامه في كتلة `try-catch` إذا لزم الأمر
2. يتبعه رسالة خطأ بلغة إنجليزية بسيطة توضح ما حدث

تدرج سلسلة النداءات (stack trace) الاستدعاءات (الإجراءات التي تستدعي إجراءات أخرى). وبالتالي، فإن الكود الذي رفع الخطأ سيكون الأخير (في الأسفل)، في حين أن الإجراء التي بدأت ذلك ستكون الأولى (في الأعلى).

اعتبر سلسلة الاستدعاءات حيث تستدعي `func_app` الإجراء `func_library_1` التي تستدعي الإجراء `func_library_2`. يُفترض أن الدالتين الأخريين هما مكتبات مستوردة. مثال: نعرّف إجراءات في تطبيقنا تستدعي مكتبة `pandas` التي تستدعي مكتبة `numpy`.

قد يتم رفع استثناء في مكان ما، ونريد تطبيق ما تعلمناه أعلاه لقراءته وإصلاحه.

```{python}
#|error: true

def func_library_2(c):
    if len(c) == 0:
        raise ValueError("Empty input")
    z = c
    return z

def func_library_1(b, c):
    if not isinstance(c, str):
        raise TypeError("c must be a string")
    y = func_library_2(c)
    return b + y

def func_app(a, b, c):
    x = func_library_1(b, c)
    return a + x

func_app('a', 'b', '')
```

لنقرأ رسالة الخطأ. تقول: `"ValueError: Empty input"`. حسنًا، ما الذي تسبب في ذلك؟ دعونا نلقي نظرة على سلسلة النداءات (stack trace) من الأعلى (للعثور على إجراءاتنا الخاصة). نجد:

```
File c:\Users\thund\OneDrive\3-Teach\DS-AI\2. Py\book\11_errors.qmd:17
     14     x = func_library_1(b, c)
     15     return a + x
---> 17 func_app('a', 'b', '')
```
هي أول استدعاء في سلسلة السببية. لنقرأ ماذا يأتي بعدها:

```
File c:\Users\thund\OneDrive\3-Teach\DS-AI\2. Py\book\11_errors.qmd:14
     13 def func_app(a, b, c):
---> 14     x = func_library_1(b, c)
     15     return a + x
```

الآن هذه هي الاستدعاء الثاني، والأخير في تطبيقنا. بعد هذه النقطة، يكون خارج نطاق سيطرتنا. بما أننا نحافظ على كودنا الخاص `func_app`، فمن الأرجح أننا ارتكبنا الخطأ. يمكننا إصلاحه عن طريق التحقق من الإدخال قبل أن يغادر كودنا إلى `func_library_1`.

```{python}
func_app('a', 'b', 'c')
```

تم الإصلاح. انتهى.

إذا كان الخطأ في الواقع في `func_library_1`، فعلينا التواصل مع القائمين على صيانة المكتبة لإصلاحه. ربما يمكننا إصلاحه بأنفسنا وتقديم طلب سحب (pull request) على GitHub. هكذا تتحسن البرمجيات مفتوحة المصدر.


## الأخطاء المنطقية

الأخطاء المنطقية صامتة. لا يتم اكتشافها بواسطة المترجم، ومع ذلك تتسبب في تصرف البرنامج بشكل غير صحيح. الأخطاء المنطقية هي الأصعب في العثور عليها وإصلاحها لأنها ليست واضحة دائمًا. يمكن أن تكون ناجمة عن:

- افتراضات غير صحيحة
- تطبيق غير صحيح للخوارزمية أو
- تحضير غير صحيح للبيانات

### استخدام الإجراء الخاطئ

```{python}
import math

square = math.sqrt(4) # should use math.pow(4, 2) instead
```

### استعمال العامل الخاطئ

```{python}
x = 16
if (x == "16"):
    print('equal')
```

### مستوى محاذاة خاطئ

هنا كانت النية تقتضي أن تكون `print(j)` داخل الحلقة الداخلية:

```{python}
for i in range(2):
    for j in range(3):
        print(i)  
    print(j)
```

### خطأ الحافَّة (Off-by-one error)

يكاد يكون أشهر الأخطاء في البرمجة: خطأ الحافَّة.

نشرحه بمثال: النية هنا هي طباعة الأرقام من 5 إلى 0 بما في ذلك 0، ولكن الحلقة تتوقف عند 1.

```{python}
for i in range(5, 0, -1):
    print(i)
```

## كيفية حل الأخطاء المنطقية؟

قد تستعين بعبارة `assert` هنا وهناك للتحقق من منطق الكود، أو تنتقل **لكتابة مجموعة اختبارات** أكبر. سيأتيي الكلام عن [كتابة الاختبارات](zz_testing.qmd).

**التتبع**. أفضل طريقة لحل الأخطاء المنطقية هي تنفيذ الكود والنظر في الناتج، وتتبع المنطق مرة أخرى إلى الكود سطرًا بسطر. يمكنك استخدام عبارات الطباعة `print` لتصحيح الأخطاء وفهم تدفق البرنامج.

**مراجعة الأقران**: بحيث يطلع على الكود شخص آخر، فإنه قد يرى منه ما لم تر.
