# مقدمة

تمثل بايثون المسميات البرمجية بنموذج يُعرف بمصطلح البرمجة الشيئية / الكائنية (Object-oriented Programming). فكل **شيء** مكوَّن من عنصرين: **بيانات وعمليات**. وباعتبار الصفات والعمليات المشتركة بين الأشياء المعيَّنة تتكون لدينا مُجرَّدات نسميها **الأصناف**.

نستعرض في هذه المقدمة كيف نكتب بلغة بايثون ما نعبر به عن تسمية هذه الأشياء، ونرى كيف تعمل العمليات فيها. لهذا سنعرض سريعًا لأصناف يكثر استعمالها ، وقد أفردنا لكل واحدٍ منها باباً: 

1. **الشيء المفرد** ونمثل له بصنف **الأرقام**
2. **الشيء المجموع**، ونمثل له بصنف **المتسلسلة المتغيرة**
3. وأخيرًا نستعرض صنفًا مستمدًّا من صنف **المتسلسلة** وهو صنف **متسلسلة الحروف**

## الشيء المفرد

ويندرج تحت صنف الأرقام مجموعة أصناف وإن شئت قل: أنواع، وهي: (العدد الصحيح، والعدد العشري، والعدد التخيلي) وكذلك يندرج تحتها في نموذج بايثون (العدد الثنائي) الذي يكون إما صفرًا أو واحدًا (0 أو 1).

فاشتراكها في صفة الرقمية (الذي جعلها تحت صنف الأرقام) أتى من حيث أنها تقبل عمليات الجمع والطرح والقسمة ، وكذلك عمليات المقارنة (أكبر من ، وأصغر من ، والمساواة) ونحو ذلك مما تقبله الأرقام. وسيأتي الحديث عنها بالتفصيل في [باب الأرقام](03_numbers.qmd).

مثال بلغة البرمجة نقول:

```{python}
x = 123
foo = 123.45
ok = True
not_ok = False
```
فالسطر الأول يعين قيمة `123` (وهي من جنس الأعداد الصحيحة) للاسم `x` وذلك عن طريق عملية التعيين (`=`). والثاني  مثله لكن عدد عشري (لاحظ أنه يمكن للمسمى أن يكون كلمة ولا يشترط أن يكون حرفًا كما في الرياضيات). والثالث مثله لكن قيمة ثنائي تساوي 1 ("نعم"). والخامس مثله لكن تساوي  0 ("لا"). فكل هذه أرقام.
 
ونستعرض الآن كيف نجري عمليات على الأرقام:
```{python}
x = 5
y = 10
z = x + y
print(z)
```

1. في السطر الأول: قمنا بتعيين **القيمة** `5` **لمعرف** `x`
2. في السطر الثاني: مثل الأول لمعرف `y`
3. في السطر الثالث: تعيين ناتج **عملية الجمع** (`+`) بين عددين
4. في السطر الرابع: `print` هي عملية تقدَّم تعريفها ضمن المكتبة الأساسية في حزمة البايثون، تعمل هنا على الكائن الرقمي `z` ليكون حاصلها: كتابة قيمة الرقم على الشاشة.

لاحظ أن علامة الـ(`=`) ليست تعني مساواة الطرفين كما في المعدالات الرياضية. وإنما هي **عمليَّة تعيين** (مثلها مثل عملية الجمع `+`) تقوم بإسناد قيمة لمسمى (وهو `x` هنا)؛ كأنما تُخزِّن القيمة في صندوقٍ معنوَن بالاسم `x`. وقل مثل ذلك في `y` وكذلك في `z`.

وتستطيع أن تقول إن ما قبل علامة التعيين (`=`) أصبح اسمًا مُعرَّفًا يُشير إلى شيء. وما بعد العلامة هو الشيء: وله صفتان أساسيتان: البيانات (`5`) والعمليات التي تُعرَف ضِمنيًّا بحسب النوع (`int`) وتعني صِنف الأعداد الصحيحة (Integers)، الذي يندرج تحت صنف الأرقام (numbers).

لو أردنا معرفة نوع الشيء، فلدينا عملية `type(x)` نستخدمها هكذا:
```{python}
print(type(10))
```

```{python}
print(type(100 + 200))
```

## الشيء المجموع

تعلمنا كيف نخزن قيمة عدد في `x` وقيمة عدد آخر في `y`. لكن لو أردنا التعامل مع مجموعة أعداد معًا لنحسب جمعها أو متوسطها أو غير ذلك من العمليات سواءً البسيطة منها والمعقدة، فإن لغة بايثون تستطيع التعبير عن ذلك. بل إن الشيء المعبر عن ذلك هو **المتسلسلة**: مجموعة مرتَّبة من الأشياء. 

ففي المثال التالي تعيين شيئين من نوع **متسلسلة متغيرة** (وكونها متغيرة يعني أنها تقبل الزيادة والنقص)، تحوي أشياء؛ وهذه الأشياء هي أعدادًا صحيحة في هذه الحالة. ثم نرى كيفية إجراء عملية محددة بعلامة `+` بين المتسلسلتين.


```{python}
one = [10, 20, 30]
two = [40, 50, 60]
combined = one + two
print(combined)
```

لاحظ أن النتيجة هي **إضافة** المتسلسلة الثانية للمتسلسلة الأولى لتصبح متسلسلة جديدة فيها العناصر الأولى تتبعها الثانية عناصر الثانية. وقد تتساءل لماذا لم تكن النتيجة جمع الأعداد المتقابلة؟ والإجابة هي: أنها عُرِّفَت هكذا هذه العملية للأشياء التي من نوع متسلسلة.

كما يوجد لنوع المتسلسلة (سواءً المتغيرة والثابتة) عمليات خاصة مثل `len` التي ناتجها عدد عناصرها؛ وتستعمل على النحو التالي:

```{python}
x = len(one)
print(x)
```

نقرأ القطعة السابقة فنقول: إن عمليَّة `len` تأخذ قيمة المعرف `one` (أو نقول: إننا نُمرِّر قيمة المعرف)؛ لتعطينا عدد العناصر (الذي هو عدد صحيح)؛ فنُعيِّن تلك القيمة بعلامة (`=`) للمعرف `x`. ثم نطبع ذلك باستخدام عملية `print`.

ولسنا بحاجة للمعرف `x` إذ يُمكن كتابة العملية على ناتج العملية السابقة مباشرة بحيث تكون التي في الأقواس أوَّل تنفيذًا ثم التي الأقواس الأشمل، وهكذا على النحو التالي:

```{python}
print(len(one))
```

ونأتي الآن لنوع آخر يكثر استخدامه وهو **متسلسلة الأحرف** وهي في الحقيقة صنف **مركَّب** من المتسلسلة (سنتعلم كيفية التركيب في [باب: الأصناف](14_classes.qmd)). فهي تستمد منها خصائصها (مثل أنها تقبل الدمج بعلامة `+`) وتضيف فوق ذلك عمليات إضافية خاصة للتعامل مع الأحرف.

ولكثرة استخدامها جُعل لها في اللغة علامة التنصيص (`"`) لتحدد عناصرها بدلا من الأقواس المربعة (`[ ]`) التي تحدد عناصر السلسلة المتغيرة.

انظر هذا المثال الذي نعرف فيه `message` ليشير إلى متسلسلة أحرف. ثم نستخدم نفس العملية التي استخدمناها مع المتسلسلة التي كانت تحتوي على أرقام لمعرفة عدد العناصر (`len`) ونخزن ذلك في مُعرَّف `length` ثم نقوم بطباعته عن طريق عملية `print`.

```{python}
message = "Adam"
length = len(message)
print(length)
```

## عملية مُسندة لشيء

وللعمليات شكلٌ آخر تستخدمه لغات البرمجة الشيئية، وهو أن توضَع علامة نقطة `.` بعد الشيء ثم كتابة اسم العمليَّة على النحو التالي:

```{python}
message = "hello adam"
up = message.upper()
print(up)
```

وقد تتساءل عن الأقواس الفارغة فتقول: ما هي مدخلات هذه العملية؟ فنقول: في البرمجة الشيئية: هذه العبارة تجعل العامل الأوَّل (المُدخل الأوَّل) لها هو ذات الشيء المذكور. ثم ما تضعه في الأقواء (إن وُجِد) يكون مُدخلاً ثانيًا وثالثًا وهكذا.

## علامة `+` بين الأشياء

وننبه هنا على أمرٍ يختلط على المبتدئ في البرمجة، وهو التفريق بين صنف الرقم وصن متسلسلة الأحرف، كما في المثال الآتي. فنقول: علامة `+` بين عددين تشير لعملية الجمع بينهما:


```{python}
x = 20 + 20
print(x)
```

بينما تعريف علامة `+` بين متسلسلتين من الحروف (وذلك لوجود علامة التنصيص `"`)، تكون عملية دمج:

```{python}
y = '20' + "20"
print(y)
```

ملاحظة: لغة بايثون لا تفرق بين علامة التنصيص المفرد (`'A'`) والتنصيص المزدوج (`"A"`) كما تفرق بينهما لغات أخرى مثل C أو Java.

أما إن حاولت وضع علامة (`+`) بين شيئين لم تُعرَّف العملية هذه بينهما فإن البرنامج سيقف برسالة خطأ، تفيد بأن العلامة غير مُسندة لعملية مُعرَّفة بين هذين الشيئين (هو لم يجد أنها جمع ولا دمج). لاحظ هنا أن العملية بين عدد ومتسلسلة نصية:


```{python}
#| error: true
print(x + y) 
```

فيمثل الشيء `x` قيمة عدد صحيح يُمكن جمعه وطرحه وقسمته ونحو ذلك، أما `y` فيشير لمتسلسلة حروف؛ لا تتيح الحساب الرياضي ، وإنما يمكن دمجها وفصلها وتكرارها ونحو ذلك؛ لأنها في الحقيقة حرفان وليست عددًا.

وإن أردت التحويل من نوع إلى نوع، فيمكنك ذلك عادة باستعمال عملية لها نفس اسم ذلك النوع. تأمثل المثال التالي:

```{python}
x = 40
y = "2020"
z =  int(y)
print(type(x))
print(type(y))
print(type(z))
print(x + z)
```

## النسخ

تنفيذ العملية يتسلسل بحسب ورودها، ولذلك فإن التعيين اللاحق ينسَخ (يمحو) التعيين السابق له. فمثلاً:

```{python}
x = 5
x = 10
print(x)
```

لاحظ أن القيمة المطبوعة على الشاشة هي: `10` وليست `5`.

## التراكم المنطقي

تتضمن بايثون **مركبات لغوية** تسمح بتعريف الأشياء (مثل `=`) وتسمح بالعبارات الشرطية (`if` و `else`) وحلقات التكرار (`for`) ونحو ذلك كثير مما سنراه في الدروس القادمة إن شاء الله. وفوق ذلك نجد في حزمة بايثون **المكتبة الأساسية** (المكتبة: حزمة عمليات وأشياء) تعتبر هي والمركبات اللغوية حجر أساس في بناء البرمجيات فوقها. وهي التي تحدد الحدود التي يمكن أن تصل إليها أيها المبرمج بهذه اللغة.

ونستعرض هنا قطرة من بحر **العمليات الأساسية** (مثل: `sum`, `len`, `max`, `min`)، وذلك باستعمال المفردات المُعرَّفة علنًا: 

```python
xs = [1, 2, 3, 4, 5]

# length
l = len(xs)

# sum
result = sum(xs)

# max and min
a = max(xs)
b = min(xs)

if a > 100:
    print('do this')

if b < 0:
    print('do that')
```

وسيأتي بالتفصيل الكلام عن هذا.

ثم نستعرض هنا **الحزم الأساسية** كحزمة `math` وهي ضمن المكتبة الأساسية:

```{python}
import math

sq = math.sqrt(16)
print(sq)
```

فهذه عملية الجذر التربيعي أتينا بها بطلب **الحزمة** (`math`) ثم أشرنا إلى المُعرَّف `sqrt` المندرج تحتها عن طريق علامة النقطة `.` مع القوسين لتعمل هذه العملية على مدخلات معيَّنة (`16`) فتنتج لنا شيئًا نعيِّنُه عن طريق عملية (`=`) للمُعرَّف `sq`.

بهذا تبيَّن أن لغة بايثون قابلة للتطوُّر بشكل قوي جدًّا، بحيث يبني كل شخص على:

1. العبارات البرمجية (عبارة تعيين ، عبارة شرط ، عبارة تكرار، ...إلخ) التي تستعمل كلمات أصلية في اللغة
2. المكتبة الأساسية التي تتضمن عمليات أساسية وحِزَمًا تتضمن أشياء وعمليات إضافية

فيستطيع كل شخص تركيب حزمة جديدة مكونة من أشياء مركبة وعمليات مركبة يستفيد هو في ذلك من حزم أشخاص آخرين ، ثم يوفرها هو لأشخاص آخرين. وهكذا ينمو النتاج البرمجي ، حزمةً تِلو الأخرى بحسب اهتمامات كل مجتمع برمجي.

فالمجتمعات البرمجية التي تدور حوْل حزم تطوِّرها بالتشارك العلني في بايثون متعددة جدًا باهتمامات مختلفة، منها على سبيل المثال لا على سبيل الحصر:

- تطوير مواقع شبكة الانترنت: `Django` و `FastAPI`
- بناء نماذج البيانات: `statsmodels`, `scikit-learn`, `TensorFlow`, `PyTorch`
- تصوير البيانات: `seaborn`, `matplotlib`
- التحليل الرياضي والهندسة: `sympy`, `PySR`, `SciPy`
- أتمتة عمليات نظم المعلومات: `ansible`, `salt`

وتصل عدد المشاريع (تقريبًا عدد الحزم) في قاعدة بيانات [(PyPI)  ](https://pypi.org/) اليوم ما يزيد على 580,000 مشروع. وتجد الكود مشاعًا على أكبر منصة لإدارة الأكواد البرمجية: [GitHub](https://github.com/).

بعد أن أخذنا نظرة عامة على لغة بايثون، سنأتي على المفاهيم الأساسية على وجه التفصيل في الدروس القادمة.

