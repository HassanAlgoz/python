[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "مقدمة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-نبرمج",
    "href": "index.html#لماذا-نبرمج",
    "title": "البايثونية",
    "section": "لماذا نبرمج؟",
    "text": "لماذا نبرمج؟\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nثم أدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة التخزين.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة ويشغِّل هذه الإلكترونيات المجهرية لتحقيق مقصوده منها.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لمن-هذا-الكتاب",
    "href": "index.html#لمن-هذا-الكتاب",
    "title": "البايثونية",
    "section": "لمن هذا الكتاب؟",
    "text": "لمن هذا الكتاب؟\nوُلِد الكتاب أثناء تدريسي لمادة البايثون لخريجي التخصصات التقنية تمهيدًا للدخول في علوم البيانات والذكاء الاصطناعي. فأردت أن أضع مادة جامعة لأهم مفاهيم البرمجة بلغة بايثون. فهي مادة شاملة للفصول المؤسسة التي يحتاجها المبرمج في مشواره ذلك.\nثم راجعته فراعيتُ أصحاب التخصصات والميول الأخرى؛ فلم أجعل فيه ما يختصُّ بفهمه أصحابُ التخصص. وحاولت أن يرى المتعلم اتصال النظرية بالتطبيق بأسلوب مباشر ليس فيه تطويل الكلام. فهو مناسب للمبتدئ، وكذلك لمن أراد سد فجوات وجدها بعد ممارسة؛ ليعود بأساس قوي متين -بحول الله-.\nوهو كذلك معينٌ لمن أراد تدريس البرمجة منطلقًا من لغة بايثون؛ فقد جمعتُ فيه ما تفرَّق ونظمتُه بعد نظرٍ في عدة مؤلفات مماثلة، وعلى ما رأيتُ أنه أنفع للمتعلم بأخصر طريق. ولستُ استغني عن إسهاماتكم. فبرمجية الكتاب مفتوحة ومتاحة على منصة GitHub للمساهمة بالإشكالات، خصوصًا فيما يتعلق بالتطبيقات والمسائل. ومرحبًا بمن أراد البناء.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#أهداف-الكتاب",
    "href": "index.html#أهداف-الكتاب",
    "title": "البايثونية",
    "section": "أهداف الكتاب",
    "text": "أهداف الكتاب\n\nتمكين المتدرب من مهارة قراءة وكتابة قطع بايثون وتشغيلها والاستفادة من نتائجها.\nتمكين المتدرب من البنى الأساسية في لغة بايثون وهي: الأعداد، الشرط والتكرار، الإجراءات، الجموع (المرتبة والمرقومة)، النص، الوقت والتاريخ، صياغة البيانات وحفظها واسترجاعها، والتعامل مع الأخطاء.\nتمكين المتدرب من قراءة توثيق البرمجيات الأخرى والاستفادة منها بكتابة برمجية تكامل بلغة بايثون؛ سواء كانت مكتبات أو خدمات برمجية عبر الشبكة العالمة.\n\nبتحقق الهدف الثالث، تفتح لك أبواب البرمجة -بإذن الله-. انظر مكتبة البرمجيات.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-وقع-الاختيار-على-لغة-بايثون",
    "href": "index.html#لماذا-وقع-الاختيار-على-لغة-بايثون",
    "title": "البايثونية",
    "section": "لماذا وقع الاختيار على لغة بايثون؟",
    "text": "لماذا وقع الاختيار على لغة بايثون؟\nيقع الاختيار على لغة بايثون كثيرًا لأمور:\n\nالسهولة: ففي البداية يحس المتعلم أنه يتعلم لغة إنجليزية بقواعد معيَّنة\nالعموم: فهي ليست مختصة مثلاً ببرمجيات المواقع فقط؛ بل مجالات تطبيقاتها متنوعة\nالقبول فالجهود متظافرة على خدمة مكتباتها من المجتمعات التي تتمحور حول نوع ما من التطبيقات. وهذا يسهِّل على الجميع البناء على الجهود المتراكمة.\n\n\nمجالات لغة بايثون\nإذا نظرنا في إحصاء JetBrains 2023 نجد مجالات استعمال لغة بايثون:\n\n\n\nبم تستعمل لغة بايثون؟\n\n\n\n47% تحليل البيانات\n42% تعلم الآلة (الذكاء الاصطناعي)\n39% تطوير المواقع\n31% برمجة كاسحات المواقع (التي تجمع البيانات)\n30% أتمتة إدارة الأنظمة والبنية التحتية التقنية\n26% أتمتة اختبار البرمجيات\n23% أغراض تعليمية\n22% صناعة برمجيات أوليَّة (أي لسهولتها)\n\nوانظر إحصاء JetBrains 2024 لمقارنة بايثون مع غيرها من اللغات، حيث يظهر في الجدول التالي توزيع استعمال المبرمجين للغات في مختلف المجالات. ويظهر لنا أن بايثون هي أكثر اللغات انتشارًا بين المجالات التقنية؛ فتعلمها يعطيك أوسع فرصة في المجالات:\n\n\n\nتوزيع استعمال اللغات بحسب المجالات التقنية في 2024\n\n\nوإليك بعض الشركات التقنية التي قامت على بايثون: Instagram، Spotify, Reddit, Netflix, Dropbox, Quora, Pintrest.\n\n\nبايثون وحدها لا تكفي\nالواقع أن ليسَ ثمة لغة واحدة تحقق كل متطلبات بناء التطبيق؛ بل يغلب على المشاريع البرمجية تعدد اللغات فيها، وإن كانت مشاريع فردية صغيرة. وليست بايثون مقصودة لذاتها. فإن من منافع التعلم بطريقة تأصيلية صحيحة؛ أن تعلُّمَك للغة الثانية يصبح أسهل؛ وقد تختلف أساليب التعبير بين لغة وأخرى، إلا أن المفاهيم متشابهة.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#منهجية-الكتاب",
    "href": "index.html#منهجية-الكتاب",
    "title": "البايثونية",
    "section": "منهجية الكتاب",
    "text": "منهجية الكتاب\nتم تقسيم الكتاب ليكون في الباب أربعة جوانب:\n\nالمفاهيم حيث التعريفات والأقسام والقواعد (وليست فيه أمثلة وتطبيق).\nالتطبيقات: نرى فيه كيف نضع ما تعلمنا في سياقات مختلفة\nالتمارين: يأتي دورك لممارسة ما تعلمت\nالحلول: لترى طريقة أخرى لحل التمرين",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#موضوعات-الكتاب",
    "href": "index.html#موضوعات-الكتاب",
    "title": "البايثونية",
    "section": "موضوعات الكتاب",
    "text": "موضوعات الكتاب\nنبدأ بمقدمتين:\nالمقدمة الأولى عن لغة البرمجة: مفرداتها وجملها وقواعدها ونموها بالمكتبات الأساسية والخارجية.\nالمقدمة الثانية عن معمارية فون نويمان: الإحساس والاستيعاب والمعالجة والتخزين.\nوبهتين المقدمتين يتكون لدينا تصوُّر عن ماهية لغة البرمجة وأجزاء الحاسب الأساسية التي تعمل فيها اللغة.\nالباب الثاني عن الأعداد: ندخل في كيفية التعبير عن الحِساب البسيط كعملية الجمع. ففيه الحساب والمقارنة، وترتيب العمليات، والتعيين النسبي، ووحدة الرياضيات، ومجموعة الأعداد، وأنواع الأعداد (الصحيح والمنطقي والعشري)، والفرق بين النوع العددي والنصي، وكتابة القيم العددية.\nالباب الثالث عن الشروط والتكرار: فنتعلم كيفية تعليق تنفيذ جملة على شرط، وكذلك كيف نختار أن نكرر مجموعة من العمليات عددًا من المرات (أيًّا كانت هذه العلميات). ففيه الجملة الشرطية والتعبيرات المنطقية وتركيب الشروط وتضمين الجمل الشرطية، وجمل التكرار وما يتعلق بها من جمل التحكم في التكرار.\nالباب الرابع عن الإجراءات: فنتعلم كيفية تعريف الإجراءات لنعطيها أسماءً من عندنا ونستدعيها أينما نريد. ففيه تعريف الإجراء وعوامله المؤثرة والمتأثرة، وطريقتان لتعيين العوامل: بالموضع وبالاسم، وتعريف إجراءات جديدة بتفاصيلها وتنفيذها، والعوامل الجائزة والواجبة، والتصريح بالنوع، ومفهوم نطاق التسمية، وثمرة الإجراء.\nثم الجمع المرتب: إذ ننتقل من التعامل مع أفراد البيانات إلى مجموعات البيانات. ففيه المجموعة المرتبة والصف والقائمة، وعمليات الإشارة والتقطيع والتكرار، وعمليات التعديل والإضافة والحذف، والفرز والترتيب.\nثم الجمع المرقوم: إذ نتعامل مع المجموعات التي تكون عناصرها ذات رقم / رمز وليسَ لها موضِع في المجموعة. وفيه المجموعة الرياضية والقاموس، وعمليات الإضافة والحذف والتعديل، والبحث والتكرار، والتقاطع والاتحاد والفرق.\nثم النص: وهو سلسلة الرموز (سواءُ كانت حروفًا أو بيانات أو أي سلسلة منسقة أو غير منسقة من البيانات). ففيه النص الطبيعي والمقولب، وإنشاء النص وقراءته، والإشارة والتقطيع، والعمليات الخاصة بالنصوص من استبدال وبحث وفصل ووصل، وتفسير الأرقام وإخراج النص وتنسيقه. وكذلك ترميز يونيكود وتشفير النصوص وتحويلها.\nثم التعامل مع الأخطاء؛ وفيه الخطأ النحوي والخطأ المنطقي والخطأ الواقعي؛ وكيفية التعامل مع الخطأ المتوقع (الاستثناء).\nثم البرمجة الإجرائية: نتعلم كيفية بناء برامج مبنية على الإجراءات.\nثم صياغة البيانات وانتقالها وتخزينها وقراءتها وكتابتها، وكذلك التعامل مع المجلدات والملفات.\nثم البرمجة الشيئية؛ إذ ندخل في صناعة الأشياء (مثل الأرقام والنصوص والقوائم وأي مجردات) بأنفسنا. ففيه تعريف الأنواع وصفاتها وإجراءاتها، ثم التقسيم الاسمي والتقسيم العملي؛ ثم التجريد والتعميم والتركيب والتخصيص والتسلسل.\nثم الوقت والتاريخ؛ وفيه طريقة التعامل مع الوقت الحاسوبي والمناطق الزمنية والحساب بين الأزمنة والتكرار الزمني.\nثم تكامل البرمجيات؛ حيث نتعلم كيفية الاستفادة من البرمجيات التي كتبها الآخرون، سواءٌ كانت مكتبة أو خدمة متصلة بالشبكة العالمية.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#ترجمة-المصطلحات",
    "href": "index.html#ترجمة-المصطلحات",
    "title": "البايثونية",
    "section": "ترجمة المصطلحات",
    "text": "ترجمة المصطلحات\n\nهل ترى الشاشة تعمل بلا كهرباء؟ وهل تعلم أن حركة المغناطيس سبب هذه الطاقة؟ فلولاه ما وجد المكيف ولا التلفاز ولا الجوال.\n\nلماذا لا نستغرب هذه المصطلحات؟ بل نحن متصالحون معها في لغتنا العربية، مع أنها أسماء لمخترعات حديثة لم يعرفها العرب. هو السبب ذاته الذي أريدك أن تكون به واسع الصدر عند رؤوية مصطلحات جديدة لم تطرق سمعك.\nولو نظرت في اللغة نفسها لرأيت في المصطلح الواحد اختلافًا كثيرًا، وهذا أمر طبعي لاختلاف الأنظار والأذواق والألسن. على سبيل المثال:\n\nمصطلح Procedure من مرادفاته المستعملة: Routine, Subroutine, Subprogram, Function, Method.\nكذلك القيمة التي تدل على العدم: Null, Nil, None\nوكذلك المرادفات: import, include, use, require, using, load, link\n\nوأعظم من ذلك؛ عدد لغات البرمجة (250+) التي تعبر كل واحدة منها بأسلوبها الخاص؛ وكلها حروف إنجليزية. فلا مشاحة في الإصطلاح.\nلعل وصف المفاهيم باللغة الأم أقرب للطبع، وأمكن في الذهن وأوعى، وأسهل في التقليب والانتقاد، وأوسع في الاختراع والإبداع. فالمفاهيم لا تتعلق باللغة التي كتبت بحروفها. فالمفهوم شيء، واللغة شيء. بل علامة تمكن المرء من المفهوم أن يعبِّر عنه بأي لغة شاء. فليس بينه وبين المفهوم حاجز اللغة، ولا هالة المصطلح.\nواجتهدت في بيان المقصود مع ذكر المصطلح الإنجليزي لزامًا. لأنه لا بد من معرفته، ولا بد للمتعلم من إتقان اللغة الإنجليزية ليستقل ويتبحر.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "إعداد بيئة التطوير",
    "section": "",
    "text": "نبدأ بالتعرف على بيئة التطوير ، وتثبيتها في جهازك؛ وذلك أنني أؤمن بضرورة إكساب الفرد أعلى قدر من التحكم في أدواته حتى يتمكن منها ومن تطويعها لعمل ما يريد بالشكل الأمثل.\nبيئة التطوير هي الأدوات البرمجية الأساسية والمساعدة لعمليات كتابة النص البرمجي وتنفيذه واختباره ونحو ذلك.\n\nمحرر النصوص البرمجية\nأما محرر النص البرمجي فسنختار محرر (Visual Studio Code) التابع لشركة مايكروسوفت.\n\nوهو مفتوح المصدر (أي: يمكن الاطلاع على نصه البرمجي).\nويستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024 وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن.\nوتُعنى الشركة بدعمه وصيانته باستمرار وتطويره، كما يساهم فيه آخرون من خارج الشركة لكوْنه مفتوح المصدر.\nوتم تصميمه كي يقبل الزيادات واللواحق البرمجية ليختار كل مبرمج ما يناسبه من الأدوات حسب احتياجاته.\n\nموقع المحرر: https://code.visualstudio.com/\nولتشغيل القطع البرمجية راجع هذا الرابط: https://code.visualstudio.com/docs/python/run.\n\n\nإدارة حزمة البرمجيات\nوأما تنظيم المشروعات والمكتبات فسنختار uv من Astral إذْ يجمع بين الترتيب (فصل كل مشروع عن الآخر)، والسرعة (فهو أسرع بكثير من pip)، وكذلك السهولة.\nموقع مدير الحزم: https://docs.astral.sh/uv/\nتابع المقطع الذي فيه تفصيل ذلك كله:\n\n\nبعد ذلك تكون جاهزًا للبدء في البرمجة.",
    "crumbs": [
      "إعداد بيئة التطوير"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html",
    "href": "chapters/01_intro/a1_intro.html",
    "title": "1  المقدمة الأولى: لغة البرمجة",
    "section": "",
    "text": "القطعة البرمجية\nيتألف البرنامج المكتوب بلغة البرمجة من قِطَع هي عبارة عن سلسلة من الجُمَل البسيطة والمركبة المكونة من مُفْرَدات للتعبير عن الأوامِر بطريقة يَسْهُلة على المبرمج كتابتها ، وفي نفس الوقت تَتَّبِعُ قَواعِدَ نَحْوِيَّة صارمة حتى لا تشتبه على المترجم عند تحويلها لتعليمات مفصَّلة على لغة المنطق الرقمي لآلة التي تنفذها.\nوفي هذا المثال عرضٌ لقطع برمجية في بايثون وشرحٌ لعملها، وليس المطلوب أي شيء منها أو تأمُّلَه ومحاولة فهمه بل هذه نظرة عامَّة لتكوين تصوُّر مُجْمَل عمّا سيأتي إن شاء الله.\nتُنَفَّذُ القطعة (Code Snippet) بحسب ترتيب جُمَلِها نزولاً من الأعلى.\npages = 900\nspeed =  50\nfinish_time = pages / speed\n\nif finish_time &lt; 14:\n    print('الوقت كافٍ')\nelse:\n    print('داهمنا الوقت')\n\nداهمنا الوقت\nفي هذه القطعة مجموعة جُمل، نشرحها سطرًا سطرًا:\nفهذه أربعة أنواع من الجُمل في قطعة واحدة. والجملة في بايثون لها أنواعُ كثيرة، وتنقسم إلى قسمين: بسيطة ومركبة:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>المقدمة الأولى: لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#القطعة-البرمجية",
    "href": "chapters/01_intro/a1_intro.html#القطعة-البرمجية",
    "title": "1  المقدمة الأولى: لغة البرمجة",
    "section": "",
    "text": "السطرين الأولين: جملة تعيين حرفّيْ (900 و 50) لمتغير (pages و speed).\nالسطر الثالث: جملة تعيين ناتج عبارة القسمة. ولاحظ أن اسم المتغير finish_time يستعمل الشرطة السفلية بدلاً من المسافة (وهذا ضروري)\nجملة شرطية: if (بمعنى إن كان)\n\nالجزء الأول (الشرط): finish_time &lt; 14\nثم ما بعده مباشرة: جملة معلَّقة بالشرط\nالجزء الثاني else (بمعنى فإن لم يكن) جملة معلَّقة بانتفاء الشرط\n\n\n\n\n\nجملة بسيطة وهي 14 جملة:\n\nالتعبير: x + y\nالتعيين: x = y\nالتأكيد: assert condition\nالمرور: pass\nالحذف: del x\nالإرجاع: return y\nالإنتاج: yield y\nرفع الاستثناء: raise Exception\nالكسر: break\nالاستمرار: continue\nالاستيراد: import module\nالعالمية: global x\nغير المحلية: nonlocal x\nالنوع: type(x)\n\n\nجملة مركبة وهي 10 جمل:\n\nالشرط: if ...\nالتكرار: while ...\nالحلقة: for ...\nالمحاولة: try ...\nالسياق: with ...\nالمطابقة: match ...\nتعريف الإجراء: def ...\nتعريف النوع: class ...\nتعريف الإجراء غير المتزامن: async def ...\nقائمة الأنواع المتغيرة: [T1[, T2, ...]]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>المقدمة الأولى: لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#الكلمات",
    "href": "chapters/01_intro/a1_intro.html#الكلمات",
    "title": "1  المقدمة الأولى: لغة البرمجة",
    "section": "الكلمات",
    "text": "الكلمات\nأول أنواع الكلمة هو المفردات الأصلية (Keywords) التي لها معنىً خاصّ مفهوم لدى بايثون وتستعمل في جُمَل محددة. وهي 35 كلمة:\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\nومنها كذلك 4 كلمات: match, case, type و _ (الشرطة السفلية).\nوما عدا ذلك\nفقد تبني الحروف كلمةً تكونُ متغيِّرًا (Variable)، نحو: x أو price أو body_weight فكلها أسماء مقبولة للمتغيرات؛ لا كما في الرياضيات التي عادةً ما تستعمل الحرف الواحد.\nوقت تبني الحروف كلمة تكون حرفيٍّا (Literal)، نحو: 44 أو 3.14 أو \"كيف حالك؟\" ويُسمَّى قيمة (Value).\nومن الحروف علامات الابتداء والوَقف، نحو: ( ) و [ ] و { } والفصل، نحو: , (الفاصلة اللاتينية) و : (النقطتان الرأسِيَّتان) و = (علامة التعيين) ، وتُسمى جميعًا المحددات (Delimiters).\n\nفالأقواس () في العبارة: (y + z) * (a + b) لتحديد ترتيب العمليات\nوالأقواس () في العبارة: print(x, y, z) لتحديد عوامل الإجراء: أي: المتغيرات التي نمررها له\nوالأقواس () في العبارة: (10, 20, 30) لتحديد صف من الأرقام\n\nومن الحروف المعاملات (Operators)، نحو: + و * و / و ** و ==\nفمثلاً: معامل الجمع + يفسَّر بحسب السياق: x + y\n\nفإن كان x = 5 و y = 10 فهما من نوع الرقم (Number) فهي للجمع\nفإن كان x = \"Ahmad\" و y = \"Belal\" فهما من نوع النص (String) فهي للدمج بينهما\nفإن كان x = 5 و y = \"Belal\" فهما من نوع الرقم و النص فليسَ بمعرَّف",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>المقدمة الأولى: لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#الأنواع-والإجراءات-المبنية",
    "href": "chapters/01_intro/a1_intro.html#الأنواع-والإجراءات-المبنية",
    "title": "1  المقدمة الأولى: لغة البرمجة",
    "section": "الأنواع والإجراءات المبنية",
    "text": "الأنواع والإجراءات المبنية\nومن الأنواع والإجراءات ما هو مبنيُّ (Built-in) في لغة بايثون:\nالأنواع المبنية مثل:\n\nالرقم: int, float, complex للحساب\nالنص: str للتعامل مع الكلام المكتوب\nالجمع: list, tuple, range, set, dict لغير المفرد\n\n\n\n\n\n\ngraph TD\n    A[&lt;b&gt;شيء&lt;/b&gt; &lt;br&gt; &lt;code&gt;Object&lt;/code&gt;] --&gt; B[&lt;b&gt;رقم&lt;/b&gt; &lt;br&gt; &lt;code&gt;Number&lt;/code&gt;]\n    B --&gt; E[&lt;b&gt;صحيح&lt;/b&gt; &lt;br&gt; &lt;code&gt;int&lt;/code&gt;]\n    B --&gt; F[&lt;b&gt;عشري&lt;/b&gt; &lt;br&gt; &lt;code&gt;float&lt;/code&gt;]\n    B --&gt; G[&lt;b&gt;مركب&lt;/b&gt; &lt;br&gt; &lt;code&gt;Complex&lt;/code&gt;]\n    A --&gt; D[&lt;b&gt;جمع&lt;/b&gt; &lt;br&gt; &lt;code&gt;Collection&lt;/code&gt;]\n    D --&gt; M[&lt;b&gt;تسلسل&lt;/b&gt; &lt;br&gt; &lt;code&gt;Sequence&lt;/code&gt;]\n    M --&gt; C[&lt;b&gt;نص&lt;/b&gt; &lt;br&gt; &lt;code&gt;str&lt;/code&gt;]\n    M --&gt; H[&lt;b&gt;قائمة&lt;/b&gt; &lt;br&gt; &lt;code&gt;list&lt;/code&gt;]\n    M --&gt; I[&lt;b&gt;صف&lt;/b&gt; &lt;br&gt; &lt;code&gt;tuple&lt;/code&gt;]\n    M --&gt; J[&lt;b&gt;نطاق&lt;/b&gt; &lt;br&gt; &lt;code&gt;range&lt;/code&gt;]\n    D --&gt; K[&lt;b&gt;مجموعة&lt;/b&gt; &lt;br&gt; &lt;code&gt;set&lt;/code&gt;]\n    D --&gt; L[&lt;b&gt;قاموس&lt;/b&gt; &lt;br&gt; &lt;code&gt;dict&lt;/code&gt;]\n\n\n\n\n\n\nوسيأتي تفصيلها في أبوابها إن شاء الله.\nالإجراءات المبنية مثل: print, sum, max, min, len\n\n\n\nالإجراء\nFunction\n\n\n\n\nالطباعة\nprint\n\n\nالجمع\nsum\n\n\nالأكبر\nmax\n\n\nالأصغر\nmin\n\n\nالطول\nlen\n\n\nإدخال\ninput\n\n\nنوع\ntype\n\n\nأي\nany\n\n\nكل\nall\n\n\nالتالي\nnext\n\n\nتطبيق\nmap\n\n\nتجميع\nzip\n\n\nتقريب\nround\n\n\n\nوغيرها كثير لا يفيد حصره هنا. ولا تزال اللغة تتطوَّر ويُزادُ فيها من هذه الأنواع والإجراءات.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>المقدمة الأولى: لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#نمو-اللغة",
    "href": "chapters/01_intro/a1_intro.html#نمو-اللغة",
    "title": "1  المقدمة الأولى: لغة البرمجة",
    "section": "نمو اللغة",
    "text": "نمو اللغة\nومن خواص لغة البرمجة: إنشاء مركبات لغوية جديدة، وذلك بشيئين:\n\nتعريف أنواع جديدة؛ بجملة class\nتعريف إجراءات جديدة؛ بجملة def\n\nفأضاف مطوروا بايثون أنفسهم إلى اللغة ما يسمى بالمكتبة الأساسية (Standard Library)، ومن أقسامها:\n\nوحدة math التي تضم مجموعة إجراءات تعنى بالعمليات الرياضية على الأعداد\nوحدة statistics التي تضم مجموعة إجراءات تعنى بالإحصاء\nوحدة datetime التي تضم مجموعة أنواع وإجراءات تعنى بالوقت والتاريخ\n\n\nالمكتبة الأساسية\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nالقطعة:\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\nتفصيل هذه القطعة كالتالي:\n\nجملة استيراد المكتبة الرياضية: import math\nتعيين النقطتين: x1, y1 = 0, 0 و x2, y2 = 3, 4\nحساب المسافة: distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) وفيه:\n\nx2 - x1 هو الفرق بين الإحداثيات السينية\ny2 - y1 هو الفرق بين الإحداثيات الصادية\n** هي عملية تربيع العدد\nmath.sqrt هي فعل حساب الجذر التربيعي\n\nطباعة النتيجة: print(distance)\n\n\n\nالمكتبات المساهمة\nوتسمى المكتبات الخارجية (External Libraries) وهي مكتبات يساهم بها الناس، ويضيفونها إلى اللغة، نجدها في موقع قاعدة بيانات PyPI الذي يضم أكثر من 580 ألف مشروع، أو غيرها من المواقع. وهذه يتم تنزيلها وتثبيتها للاستفادة من لغتها المزيدة.\nعلى سبيل المثال، تختص حزمة pandas المتخصصة في تفكيك وتركيب الجداول والتحليلات الإحصائية عليها؛ فهي أقوى من أي نسخة من إكسل (Excel) أو غيره.\nلتثبيتها نستعمل uv هكذا في سطر الأوامر (النافذة السوداء):\nuv add pandas\nثم نستطيع استعمال المكتبة لقراءة بيانات الطلاب -مثلاً- من ملف CSV:\n\n\nimport pandas as pd\n\ndf = pd.read_csv('../../datasets/students.csv')\ndf\n\n\n\n\n\n\n\n\nName\nAge\nGrade\nDone\n\n\n\n\n0\nAdam\n12\n90\nF\n\n\n1\nBelal\n13\n92\nF\n\n\n2\nCamal\n14\n91\nT\n\n\n3\nDalal\n8\n99\nF\n\n\n4\nEman\n9\n98\nF\n\n\n\n\n\n\n\n\nثم لعرض ملخصات إحصائية:\n\n\ndf.describe(include=['number'])\n\n\n\n\n\n\n\n\nAge\nGrade\n\n\n\n\ncount\n5.000000\n5.0000\n\n\nmean\n11.200000\n94.0000\n\n\nstd\n2.588436\n4.1833\n\n\nmin\n8.000000\n90.0000\n\n\n25%\n9.000000\n91.0000\n\n\n50%\n12.000000\n92.0000\n\n\n75%\n13.000000\n98.0000\n\n\nmax\n14.000000\n99.0000\n\n\n\n\n\n\n\n\nأو تصوير البيانات:\n\n\ndf['Done'].value_counts().plot(kind='bar', color='skyblue', figsize=(4, 3), rot=0)\n\n\n\n\n\n\n\n\n\nهكذا بكل بساطة.\nفإذًا .. هنا دور المجتمع (Community) ليبني باللغة: بمفرداتها وجملها ومكتبتها الأساسية والخارجية، ليبني فوق ذلك ما يخدم أغراضه. فلكل فئة من الناس تركيب حزمة جديدة مكونة من أنواع وإجراءات مركبة مبنية على غيرها ، ثم يوفرونها لغيرهم. وهكذا تنمو اللغة ، حزمةً تِلو الأخرى بحسب إسهامات كل مجتمع برمجي بما يهتم به.\nومن مكامن القوة في لغة بايثون: أنها متوافقة مع لغتي C/C++ إذْ يُمكن كتابة برمجيات عالية الأداء والكفاءة بهما مستفيدين من الحزم الموجودة فيهما، ثم توفيق ذلك ليكون كمكتبة في لغة بايثون.\nفالمجتمعات البرمجية في بايثون كثيرة ومتعددة في اهتماماتها. منها على سبيل المثال:\n\nتطوير مواقع الشبكة:\n\nDjango - لبناء مواقع متصلة بقواعد بيانات\nFastAPI - حديث وسريع لبناء واجهات برمجية على الشبكة\n\nتحليل البيانات وتصويرها:\n\npandas - لتحليل البيانات المرصوصة\nseaborn - لتصوير البيانات الإحصائية على أساس Matplotlib.\nmatplotlib - مكتبة شاملة لإنشاء تصورات ثابتة ومتحركة وتفاعلية.\n\nالذكاء الاصطناعي وتعلم الآلة:\n\nstatsmodels - للنماذج الإحصائية\nscikit-learn - لاكتشاف الأنماط والتنبؤ (تعلم الآلة)\nPyTorch - لبناء نماذج التعلم العميق\n\nالتحليل الرياضي والهندسة:\n\nsympy - للرياضيات الرمزية.\nPySR - الانحدار الرمزي.\nSciPy - للرياضيات والعلوم والهندسة.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>المقدمة الأولى: لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html",
    "href": "chapters/01_intro/a2_intro.html",
    "title": "2  المقدمة الثانية: جهاز الحاسب",
    "section": "",
    "text": "وحدة المعالجة المركزية\nرغم تعقيد الحواسيب اليوم، فهي ترجع إلى معمارية فون نويمان (بالإنجليزية: Von Neumann architecture) وهي مجموعة من القواعد الأساسية وضعها العالم الرياضي جون فون نويمان ومعاونوه عام 1945م وتُستعمل حتى الأن في تصميم الحاسبات.\nوحدة المعالجة المركزية (Central Processing Unit - CPU) وهي التي يُعبأ فيها البرنامج المترجَم ليتم تنفيذه. وتتكون من شيئين:\nالأول: وحدة التحكم وهي التي تتحكم في سيْر العمليات:\nالثاني: وحدة الحساب والمنطق تنفذ تعليمات المنطق الرقمي كالجمع والطرح والمقارنة والرجوع ونحو ذلك.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المقدمة الثانية: جهاز الحاسب</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#وحدة-المعالجة-المركزية",
    "href": "chapters/01_intro/a2_intro.html#وحدة-المعالجة-المركزية",
    "title": "2  المقدمة الثانية: جهاز الحاسب",
    "section": "",
    "text": "بقلم براين وونغ - https://www.flickr.com/photos/57993471@N06/37962336546/\n\n\n\n\n\nحين نريد أن نكرر عمليَّةً ما عدة مرات، أو نريد أن نعلق تنفيذ عمليَّة ما بشرط\nحين نريد القراءة أو الكتابة من وإلى خارج وحدة المعالجة المركزيَّة",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المقدمة الثانية: جهاز الحاسب</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#أجهزة-الإدخال-والإخراج",
    "href": "chapters/01_intro/a2_intro.html#أجهزة-الإدخال-والإخراج",
    "title": "2  المقدمة الثانية: جهاز الحاسب",
    "section": "أجهزة الإدخال والإخراج",
    "text": "أجهزة الإدخال والإخراج\nوحتى يكون للبرنامج فائدة؛ فلا بُدَّ له من منفَذٍ تدخل منه المعطيات من الواقع، ومنفذٍ آخر تخرجُ منه نتائج معالجته. وقد اصطلح الناس على الاختصار I / O إشارة إلى الإنجليزية Input / Output لهذين الأمرين. فمن ذلك:\n\nجهاز إدخال: لوحة المفاتيح (Keyboard)، والمؤشر (Mouse)، والكاميرا، ولاقط الصوت\nجهاز إخراج: الطابعة، والسماعات، والشاشة\nجهاز إدخال وإخراج: جهاز التخزين الدائم الذي تُحفظ فيه الملفات، ومِقبَس الشبكة الذي يتصل بالإنترنت (وبالتالي يتصل بالحواسيب الآخرى)\n\n\nويصوِّرُها نظام التشغيل للغة البرمجة على أنها ملفات (Files) مثل سائر الملفات.\n\nفالإدخال يكون بالقراءة منها بالأمر: read\nوالإخراج يكون بالكتابة عليها بالأمر: write\n\nوقد رأينا عملية: print() حيث هي أمر بالكتابة في الملف الذي يمثِّل النافذة المتصل بها البرنامج.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المقدمة الثانية: جهاز الحاسب</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#الذاكرة",
    "href": "chapters/01_intro/a2_intro.html#الذاكرة",
    "title": "2  المقدمة الثانية: جهاز الحاسب",
    "section": "الذاكرة",
    "text": "الذاكرة\nأما الذاكرة فتحمل البرنامج المترجَم ليتمَّ إدخاله لوحدة المعالجة، وكذلك تحمل البيانات التي نريد معالجتها، والنتائج الجزئية بين عمليَّة والتي بعدها، والنتائج النهائيَّة؛ ربما إلى حين كتابتها في الخارج.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المقدمة الثانية: جهاز الحاسب</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#نظام-التشغيل",
    "href": "chapters/01_intro/a2_intro.html#نظام-التشغيل",
    "title": "2  المقدمة الثانية: جهاز الحاسب",
    "section": "نظام التشغيل",
    "text": "نظام التشغيل\nويتولى نظام التشغيل إدارة الموارد من ملفات، وأجهزة إدخال وإخراج، وذاكرة ومعالجة؛ بين الجهاز (المعدن) والبرمجيات (المنطق).\n\nفالجهاز له ذاكرة مشتركة يتولى نظام التشغيل توزيعها بين البرامج بحيث لا يتعدَّى برنامجٌ حدوده إلى آخر؛ لأن ذلك يسبب إشكاليات لا يمكن حلها. وإذا انتهى منها برنامجٌ أعادها لنظام التشغيل ليتصرف بها.\nوله معالج مركزي؛ يتولى تشغيل البرامج عليه جدولٌ يضعه نظام التشغيل ويسيِّر البرامج عليه.\nوهكذا في بقية الموارد من أجهزة إخراج وإدخال.\n\n\n\n\n\n\ngraph TD\n    A[التطبيقات البرمجية &lt;br&gt; Application Programs]\n    A --&gt; B[نظام التشغيل &lt;br&gt; Operating System]\n    B --&gt; C[المعدن &lt;br&gt; Hardware]\n    C --&gt; D[وحدة المعالجة المركزية &lt;br&gt; CPU]\n    C --&gt; E[أجهزة الإدخال والإخراج &lt;br&gt; I/O Devices]\n    C --&gt; F[الذاكرة &lt;br&gt; Memory]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#ddf,stroke:#333,stroke-width:2px\n    style D fill:#fdd,stroke:#333,stroke-width:2px\n    style E fill:#fdd,stroke:#333,stroke-width:2px\n    style F fill:#fdd,stroke:#333,stroke-width:2px",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المقدمة الثانية: جهاز الحاسب</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#خلاصة",
    "href": "chapters/01_intro/a2_intro.html#خلاصة",
    "title": "2  المقدمة الثانية: جهاز الحاسب",
    "section": "خلاصة",
    "text": "خلاصة\nتبيَّن لنا أن الجهاز لا يكون مفيدًا إلا باتصاله بالعالَم المحيط به. وذلك يكون بأجهزة الإدخال للنظر في معطياته، وبأجهزة الإخراج للتأثير فيه. والمعالجةُ هي محوَر ذلك كله.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المقدمة الثانية: جهاز الحاسب</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html",
    "href": "chapters/02_numbers/a_numbers.html",
    "title": "3  الأعداد",
    "section": "",
    "text": "الحساب والمقارنة\nx = 5\ny = 10\n\nprint(x + y) # الجمع\nprint(x - y) # الطرح\nprint(x * y) # الضرب\nprint(x / y) # القسمة\nprint(x % y) # باقي القسمة\nprint(x ** y) # الأس\n\n15\n-5\n50\n0.5\n5\n9765625\nالمقارنة بين الأعداد:\nx = 5\ny = 10\n\nprint(x == y) # التطابق\nprint(x != y) # الاختلاف\nprint(x &gt; y) # أكبر\nprint(x &lt; y) # أصغر\nprint(x &lt;= y) # أصغر أو يساوي\nprint(x &gt;= y) # أكبر أو يساوي\n\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "href": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "title": "3  الأعداد",
    "section": "ترتيب العمليات",
    "text": "ترتيب العمليات\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\nإليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه. ولاحظ أننا نستعمل جملة التوكيد (assert) التي تسكُت إن كان الشيء الذي أمامها جملة منطقية صحيحة؛ وإلا فهي تظهر رسالة خطأ. وسترى أننا نستعملها بكثرة لتقرير لوازم ما نبينه في الدرس:\n\nassert 3 + 2 * 5 == 13\nassert (3 + 2) * 5 == 25\n\n\nassert 8 - 4 / 2 == 6\nassert (8 - 4) / 2 == 2\n\n\nassert 2 ** 3 * 4 == 32\nassert (2 ** 3) * 4 == 32",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "href": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "title": "3  الأعداد",
    "section": "التعيين النسبي",
    "text": "التعيين النسبي\nيراجع: التعيين النسبي.\nلأن التعيين النسبي يستعمل بكثرة، فوجب علينا التعرف عليه، وأحيانًا نحتاج لاستعماله. فجمل التعيين التالية متكافئة:\n\ni = i + 1 تعادل i += 1\ni = i - 1 تعادل i -= 1\ni = i * 2 تعادل i *= 2\ni = i / 2 تعادل i /= 2\n\nجرب النص البرمجي أدناه لترى النتيجة:\n\ni = 0\ni = i + 1\ni += 1\nprint(i)\n\n2\n\n\nوإن أتيت من لغات أخرى مثل سي أو جافا فإنك تعلم أن تعبير i++ يعني زيادة المتغير i بواحد. لكن في بايثون لا يوجد هذا التعبير. فالنص التالي سيؤدي إلى خطأ:\n\ni++\nprint(i)\n\n\n  Cell In[41], line 1\n    i++\n       ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات-math",
    "href": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات-math",
    "title": "3  الأعداد",
    "section": "وحدة الرياضيات (math)",
    "text": "وحدة الرياضيات (math)\n\nimport math\n\nx = 5.4\n\nكل هذه الطرق الثلاث يتم فيها حساب الأس:\n\nالأولى pow فعل مبني\nالثانية math.pow فعل من وحدة الرياضيات\nالثالثة x ** 2 عن طريق المعامل **\n\n\\[\nx^2 = x \\times x\n\\]\n\nassert(\n    pow(x, 2) ==\n    math.pow(x, 2) ==\n    x ** 2 ==\n    x * x\n)\n\nوكذلك الجذر التربيعي:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\n\nالأولى math.sqrt فعل من وحدة الرياضيات\nالثانية x ** 0.5 عن طريق المعامل **\n\n\nassert (\n    math.sqrt(x) ==\n    x ** 0.5\n)\n\nتقريب لأقرب عدد صحيح أصغر:\n\\[\n\\text{floor}(x) = \\lfloor x \\rfloor\n\\]\n\nmath.floor(5.4)\n\n5\n\n\nتقريب لأقرب عدد صحيح أكبر:\n\\[\n\\text{ceil}(x) = \\lceil x \\rceil\n\\]\n\nmath.ceil(5.4)\n\n6\n\n\nحذف ما بعد الفاصلة:\n\nmath.trunc(5.4)\n\n5\n\n\nتقريب إلى رقمين بعد الفاصلة:\n\nround(5.436, 2)\n\n5.44\n\n\nملاحظة: الإجراء الأخير round ليس مستوردًا من math وإنما هو مُضمَّن في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "href": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "title": "3  الأعداد",
    "section": "مجموعة الأعداد",
    "text": "مجموعة الأعداد\nأما التعامل مع المجموعات (كمجموعة الأعداد) فسيأتي في باب المجموعات المرتبة. لكننا نعرض لمثال بسيط للتعامل مع المجموعات العددية:\n\nxs = [10, 20, 30, 40, 50]\n\nتوفر بايثون الدوال التالية للمجموعة العددية:\n\nالطول (عدد العناصر): len (من كلمة length)\nمجموع العناصر: sum\nالعنصر الأكبر: max\nالعنصر الأصغر: min\n\n\nprint('length:', len(xs))\nprint('total:', sum(xs))\nprint('average:', sum(xs) / len(xs))\nprint('maximum:', max(xs))\nprint('minimum:', min(xs))\n\nlength: 5\ntotal: 150\naverage: 30.0\nmaximum: 50\nminimum: 10\n\n\n\nالإحصاء\nونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:\n\nالمتوسط الحسابي: statistics.mean\nالوسيط: statistics.median\nالمنوال: statistics.mode\nالانحراف المعياري: statistics.stdev\n\n\nimport statistics\n\nxs = [\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20,\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20\n]\n\nprint('mean:', statistics.mean(xs))\nprint('median:', statistics.median(xs))\nprint('mode:', statistics.mode(xs))\nprint('standard deviation:', statistics.stdev(xs))\n\nmean: 20.785714285714285\nmedian: 20.5\nmode: 20\nstandard deviation: 1.8126539343499315",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "href": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "title": "3  الأعداد",
    "section": "أنواع العدد في بايثون",
    "text": "أنواع العدد في بايثون\n\nالعدد الصحيح (int)\nالقيمة المنطقية (bool)\nالعدد العشري (float)\nالعدد المركب (complex)\n\nصفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالإجراء فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.\nفالتمثيل الداخلي للأعداد له أثر:\n\nفي مساحة التخزين\nدقة العدد؛ وبالتالي صحة الحساب\nسرعة الحساب\n\nلكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.\n\nالعدد الصحيح (int)\nالوظيفة: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك\n\nage = 20\nlevel = 3\nindex = -2\nstart, end = -5, 10\nleft, middle, right = 3, 5, 7\n\nيؤتى بالإجراء type لمعرفة نوع المتغير:\n\nassert int == type(age) \nassert int == type(level) \nassert int == type(index) \nassert int == type(start) == type(end)\nassert int == type(left) == type(middle) == type(right)\n\nالمجال: نقصد بالمجال هو أعلى قيمة ممكنة وأقل قيمة ممكنة للنوع. فنوع العدد الصحيح (int ويرمز له بالرياضي \\(\\mathbb{Z}\\)) هو في واقع الحواسيب محكوم بعدد الخانات (Bits) التي يتم استعمالها في تمثيله. ورغم أن بايثون تخفي عنا عدد الخانات؛ إلا أنها تتعامل مع هذا الواقع، ولذلك وجب معرفته:\n\n8-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^7 \\leq x &lt; 2^7\\} = \\{-128, \\ldots, 127\\}\\) أي أن أقل عدد ممكن في 8 خانات: \\(-128\\) وأعلى عدد ممكن: \\(127\\). وهلم جرا.\n16-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{15} \\leq x &lt; 2^{15}\\}\\)\n32-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{31} \\leq x &lt; 2^{31}\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{63} \\leq x &lt; 2^{63}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{127} \\leq x &lt; 2^{127}\\}\\)\n\n\n\n\n\n\n\nملاحظة\n\n\n\n\n\nلاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)\n\n\n\n\n\nالقيمة المنطقية (bool)\nوهي مجموعة العددين: \\(\\{0, 1\\}\\) الذين يمثل لهما بالكلمتين: True و False وذلك لتبيين وظيفتهما المنطقية.\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nالوظيفة: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.\nنلجئ الكلام عنها إلى باب الشرط والتكرار.\n\n\nالعدد العشري (float)\nالوظيفة: تمثيل الكميات مثل المال، المسافة، والوقت\n\ndistance = 100.0\nprice = 10.5\ntime = 1.5\ntemperature = 36.6\ndifference = 0.001\n\nنفحص أنواعها:\n\nassert float == type(distance)\nassert float == type(price)\nassert float == type(time)\nassert float == type(temperature)\nassert float == type(difference)\n\nالمجال: يعبر الرمز \\(\\mathbb{R}\\) عن مجموعة الأعداد العشرية (float). وهي تتبع نظام التمثيل IEEE 754.\n\n32-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{31} \\leq x &lt; 2^{31}\\} = \\{-3.4 \\times 10^9, \\ldots, 3.4 \\times 10^9\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{63} \\leq x &lt; 2^{63}\\} = \\{-1.8 \\times 10^{19}, \\ldots, 1.8 \\times 10^{19}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{127} \\leq x &lt; 2^{127}\\} = \\{-1.2 \\times 10^{38}, \\ldots, 1.2 \\times 10^{38}\\}\\)",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "href": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "title": "3  الأعداد",
    "section": "اختلاف نوع العدد",
    "text": "اختلاف نوع العدد\nإذا اختلف النوع تُقدَّرُ الترقيةُ للأشمل، وذلك بحسب ناتج العملية:\n\nجمع صحيح وعشري = عشري: int + float = float\nقسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): int / int = float\nالقسمة الصحيحة بين صحيح وصحيح = صحيح: int // int = int\n\nالمثال الأول: جمع عدد صحيح وعدد عشري:\n\na = 1 + 1.0\nprint(a)\nassert type(a) == float\n\n2.0\n\n\nالمثال الثاني: قسمة عدد صحيح على عدد عشري:\n\nc = 1 / 2\nprint(c)\nassert type(c) == float\n\n0.5\n\n\nالمثال الثالث: استعمال القسمة الصحيحة //:\n\nb = 9 // 2\nprint(b)\nassert type(b) == int\n\n4\n\n\nس: لماذا النتيجة 4؟\nج: لأن قسمة 9 على 2 تُنتِج 4.5 ولكن بايثون تقربها لأقرب عدد صحيح أصغر وهو 4؛ وذلك لأننا اخترنا القسمة الصحيحة بالعلامة // وليس القسمة العشرية بالعلامة /.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "3  الأعداد",
    "section": "الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "الفرق بين النوع العددي والنوع النصي للعدد\nتأمل المتغيرين\n\na = 50\nb = '50'\n\n\nالأول: عدد صحيح (int)\nالثاني: حرفان (str)\n\nنستعمل جمل التوكيد لبيان ذلك:\n\nassert type(a) == int\nassert type(b) == str\nassert type(a) != type(b)\n\nومقتضى ذلك: امتناع عملية الجمع: a + b\n\n'5' + 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[62], line 1\n----&gt; 1 '5' + 5\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nبل يجب التحويل أولاً باستعمال الإجراء int الذي يفسر الأحرف كعدد صحيح:\n\na = 5\nb = '5'\n\nb = int(b)\n\nassert a + b == 10",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "href": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "title": "3  الأعداد",
    "section": "كتابة القيَم العددية",
    "text": "كتابة القيَم العددية\nالحروفيَّة (Literals) هي رموز للقيم لبعض الأنواع المدمجة. مثال: 42 هو حرفيُّ عدد صحيح و 3.14 هو حرفيُّ عدد عشري.\nوتخصيص الحرفيّ True للعدد 1 و False للعدد 0 ليس من قبيل الضرورة في اللغة وإنما من قبيل التسهيل (وفوق ذلك فإن بايثون تجعل له نوعًا خاصًّا وعمليات مصاحبة).\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nكذلك خصصت بايثون e أو E للترميز العلمي (وجاء الحرف e من كلمة: Exponent) المخصص للأعداد العشرية الكبيرة والصغيرة.\n\nassert 1e2 == 100\nassert 1e9 == 1E9\nassert 1e-4 == 0.0001\n\nويجوز استعمال الشرطة السفلية _ لفاصلة الألوف:\n\nassert 1_000_000 == 1000000\n\nوأما إن كنت تهتم بالتمثيل الثنائي أو الثماني أو الست عشري فذلك أيضًا له تعبيرات مخصصة:\n\n0b أو 0B للأرقام الثنائية\n0o أو 0O للأرقام الثمانية\n0x أو 0X للأرقام الست عشرية\n\nوإليك تطبيق ذلك:\n\nassert 0b1010 == 10\nassert 0o10 == 8\nassert 0x10 == 16\n\nوأخيرًا يمكن استعمال j أو J للأعداد المركبة:\n\nassert 1 + 2j == 2j + 1",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#خلاصة",
    "href": "chapters/02_numbers/a_numbers.html#خلاصة",
    "title": "3  الأعداد",
    "section": "خلاصة",
    "text": "خلاصة\nعرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.\nننتقل الآن لباب الشرط والتكرار حيث الجمل الشرطية والتعيين المشروط.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#المصطلحات",
    "href": "chapters/02_numbers/a_numbers.html#المصطلحات",
    "title": "3  الأعداد",
    "section": "المصطلحات",
    "text": "المصطلحات\n\n\n\nالعربية\nالإنجليزية\n\n\n\n\nعدد\nNumber\n\n\nعدد صحيح\nInteger\n\n\nعدد عشري\nFloat\n\n\nعملية حسابية\nOperation\n\n\nجمع\nAddition\n\n\nطرح\nSubtraction\n\n\nضرب\nMultiplication\n\n\nقسمة\nDivision\n\n\nباقي القسمة\nModulo\n\n\nالقسمة الصحيحة\nFloor Division\n\n\nالأس\nPower\n\n\nالجذر\nRoot\n\n\nمعادلة\nEquation\n\n\nمتغير\nVariable\n\n\nقيمة\nValue\n\n\nتعيين\nAssignment\n\n\nنسبة مئوية\nPercentage\n\n\nنسبة التغير\nRate of Change\n\n\nالتغير النسبي\nRelative Change",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html",
    "href": "chapters/02_numbers/apps.html",
    "title": "التطبيقات",
    "section": "",
    "text": "معادلة مساحة المكعب\nلا يلزمنا اشتقاق هذه المعادلات؛ لكن نستعمل النتائج التي خرج بها أهل الرياضيات فنعوض هذه المتغيرات بالقيم التي نريد لنتحصل على الناتج.\nاكتب برنامجًا يحسب مساحة المكعب وفق المعادلة:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\nwidth = 3\nlength = 4\nheight = 5\n\narea = width * length * height\nprint(area)\n\n60",
    "crumbs": [
      "باب الأعداد",
      "التطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "href": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "title": "التطبيقات",
    "section": "معادلة تحويل وحدة إلى وحدة أخرى",
    "text": "معادلة تحويل وحدة إلى وحدة أخرى\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n\nc = 32\nf = (9 / 5) * c + 32\n\nprint('Celsius:', c)\nprint('Fahrenheit:', f)\n\nCelsius: 32\nFahrenheit: 89.6",
    "crumbs": [
      "باب الأعداد",
      "التطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "href": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "title": "التطبيقات",
    "section": "معادلة مساحة الدائرة",
    "text": "معادلة مساحة الدائرة\nاكتب برنامجًا لحساب مساحة الدائرة وفق المعادلة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nimport math\n\nradius = 5\narea = math.pi * radius**2\nprint(area)\n\n78.53981633974483\n\n\nملاحظة:\n\nتم استعمال radius ** 2 بدلاً من الإجراء math.pow(radius, 2) لتربيع العدد.\nكذلك يجوز استعمال x ** 0.5 بدلاً من الإجراء math.sqrt(x) لحساب الجذر التربيعي.",
    "crumbs": [
      "باب الأعداد",
      "التطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "href": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "title": "التطبيقات",
    "section": "معادلة طول الخط المستقيم بين نقطتين",
    "text": "معادلة طول الخط المستقيم بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0",
    "crumbs": [
      "باب الأعداد",
      "التطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#الزيادة",
    "href": "chapters/02_numbers/apps.html#الزيادة",
    "title": "التطبيقات",
    "section": "الزيادة",
    "text": "الزيادة\nإذا كنت تقضي في القراءة 15 دقيقة في اليوم. ثم أحببت أن تزيد في كل أسبوع 5 دقائق. فكم ستكون الزيادة في 10 أسابيع؟\n\ntoday = 15\nincrease = 5\nweeks = 9\n\ntotal = today + (increase * weeks)\nprint(total)\n\n60\n\n\nأو لحساب كل أسبوع:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60",
    "crumbs": [
      "باب الأعداد",
      "التطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#النمو",
    "href": "chapters/02_numbers/apps.html#النمو",
    "title": "التطبيقات",
    "section": "النمو",
    "text": "النمو\nإذا كان عدد الأرانب في السنة الأولى 100. وكان عدد الأرانب يزيد بنسبة 11.7% في اليوم. فكم سيكون عدد الأرانب في اليوم السابع؟\n\nrabbits = 100\ngrowth_rate = 0.117\ndays = 7\n\ntotal = rabbits * (1 + growth_rate) ** days\nprint(total)\n\n216.9562730596121\n\n\nأو لحساب كل يوم:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "باب الأعداد",
      "التطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#نسبة-التغير",
    "href": "chapters/02_numbers/apps.html#نسبة-التغير",
    "title": "التطبيقات",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كان معدل قراءتك في الأسبوع الثاني 15 دقيقة، وكان معدل قراءتك في الأسبوع الأول 10 دقائق، فكم نسبة الزيادة في معدل قراءتك؟\n\nweek1 = 10\nweek2 = 15\n\nincrease_ratio = (week2 - week1) / week1\nprint(increase_ratio * 100, '%')\n\n50.0 %",
    "crumbs": [
      "باب الأعداد",
      "التطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html",
    "href": "chapters/02_numbers/problems.html",
    "title": "التمارين",
    "section": "",
    "text": "كم سيكون عمرك حين كذا؟",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-حين-كذا",
    "href": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-حين-كذا",
    "title": "التمارين",
    "section": "",
    "text": "عرف تاريخ الحدث المستقبلي بالسنوات: future_date\nعرف تاريخ اليوم: today\nعرف المتغير: age\nاحسب عمرك عند حصول الحدث: age_then\nاطبع النتيجة: print(age_then)",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الأجر",
    "href": "chapters/02_numbers/problems.html#حساب-الأجر",
    "title": "التمارين",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nعدد ساعات العمل: hours\nمعدل الأجر لكل ساعة: per_hour_rate\nاحسب الأجر الذي تستحقه بناءً على عدد الساعات ومعدل الأجر: gross_pay\nاطبع النتيجة: print(gross_pay)",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "التمارين",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nسرعة السيارة: speed\nالمسافة: distance\nاحسب الزمن المستغرق للوصول إلى المكان المعيَّن بناءً على السرعة والمسافة: time\nاطبع النتيجة: print(time)",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "التمارين",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\n\n\nمثلث\n\n\nباستخدام معادلة هيرون:\n\\[\n\\text{area} = \\sqrt{s (s - a) (s - b) (s - c)}  \n\\]\nحيث:\n\n\\(a\\), \\(b\\), \\(c\\) هي أطوال أضلاع المثلث\nنصف المحيط:\n\n\\[\ns = \\frac{a + b + c}{2}\n\\]\n\na = 3\nb = 4\nc = 5",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#نسبة-التغير",
    "href": "chapters/02_numbers/problems.html#نسبة-التغير",
    "title": "التمارين",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#التغير-النسبي",
    "href": "chapters/02_numbers/problems.html#التغير-النسبي",
    "title": "التمارين",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\nمساعدة: فكك العبارة واجعلها في متغيرات، وضع لكل أسبوعٍ متغيِّرًا يعتمد على الأسبوع الذي قبله.",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/problems.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "التمارين",
    "section": "الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "الفرق بين النوع العددي والنوع النصي للعدد\nإذا كان عندك هذه المتغيرات الثلاثة، فكيف تقيم عملية الجمع بالشكل الصحيح؟ (أولاً: استعمل type لمعرفة نوع كل متغير)\n\na = 4\nb = 3.14\nc = \"10\"",
    "crumbs": [
      "باب الأعداد",
      "التمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html",
    "href": "chapters/02_numbers/solutions.html",
    "title": "الحلول",
    "section": "",
    "text": "كم سيكون عمرك حين كذا؟\nfuture_date = 2050\ntoday = 2024\nage = 20\nage_then = age + (future_date - today)\nprint('you will be', age_then, 'years old in', future_date)\n\nyou will be 46 years old in 2050",
    "crumbs": [
      "باب الأعداد",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "href": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "title": "الحلول",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nhours = 40\nper_hour_rate = 10\ngross_pay = hours * per_hour_rate\nprint('you deserve:', gross_pay, 'SAR')\n\nyou deserve: 400 SAR",
    "crumbs": [
      "باب الأعداد",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "الحلول",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nspeed = 100\ndistance = 200\ntime = distance / speed\nprint('it will take you', time, 'hours to reach the destination')\n\nit will take you 2.0 hours to reach the destination",
    "crumbs": [
      "باب الأعداد",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "الحلول",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\nimport math\n\na = 3\nb = 4\nc = 5\n\ns = (a + b + c) / 2\narea = math.sqrt(s * (s - a) * (s - b) * (s - c))\nh = 2 * area / c\nprint('the height of the triangle is', h)\n\nthe height of the triangle is 2.4",
    "crumbs": [
      "باب الأعداد",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "href": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "title": "الحلول",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟\n\nold_expense = 1000\nnew_expense = 650\n\npercentage = (new_expense - old_expense) / old_expense\nprint(percentage * 100, '%')\n\n-35.0 %",
    "crumbs": [
      "باب الأعداد",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "href": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "title": "الحلول",
    "section": "الزيادة النسبية",
    "text": "الزيادة النسبية\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\n\nincrement = 1.10\n\nw1 = 20\nw2 = w1 * increment\nw3 = w2 * increment\nw4 = w3 * increment\n\nprint(round(w4, 1))\n\n26.6",
    "crumbs": [
      "باب الأعداد",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html",
    "href": "chapters/03_control_flow/a_control_flow.html",
    "title": "4  الجملة الشرطية",
    "section": "",
    "text": "الجملة الشرطية\nإن بايثون من اللغات الأمرية (Imperative). أي أن الجمل البرمجية خطوات متتالية تنفذ من الأعلى للأسفل.\nفإن جملة التعيين التالية تكتُب قيمة 2 في نفس المحلّ الذي كتبت عليه جملة التعيين الأولى 1. لذا ظهرت النتيجة: 2.\nكثيرًا ما نحتاج للتحكم فيما يُنفَّذ وما يُهمل أو ما يتكرر من الجمل البرمجية. فمن الحالات التي يتغير فيها الترتيب:\nالجملة الشرطية هي جملة مركَّبة من كلمة if وتعبير منطقي ثم الجمل التي يتعلق تنفيذها بناءً على هذا الشرط. ويجب أن تكون حذوها:",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "title": "4  الجملة الشرطية",
    "section": "",
    "text": "flowchart TD\n    IF{{if cond}} -- False --&gt; X[\"Outside\"]\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n\n  style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ncond = True\nif cond:\n    print('Inside')\nprint('Outside')\n\nInside\nOutside\n\n\n\n\n\nتنبيه: المحاذاة العمودية\nلاحظ أن المحاذاة العمودية (Indentation) (المسافات البيضاء أسفل كلمة if) في القطعة البرمجية أعلاه ليست لمجرد تسهيل القراءة، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال النص البرمجي.\nلاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في النص البرمجي:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    Y[\"Inside\"] --&gt; X[\"Outside\"]\n    style IF fill:#fc0000, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[3], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل النص البرمجي بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n    \n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\n\n\nيؤدي النص البرمجي السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في بايثون!",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التعبير-المنطقي",
    "href": "chapters/03_control_flow/a_control_flow.html#التعبير-المنطقي",
    "title": "4  الجملة الشرطية",
    "section": "التعبير المنطقي",
    "text": "التعبير المنطقي\nأما الشروط فتستند إلى الجبر الثنائي (Boolean Logic) الذي نجد له في بايثون كلمتين من أصل اللغة هما:\n\nكلمة True ويعبَّر عنها بالرقم: 1\nكلمة False ويعبَّر عنها بالرقم: 0\n\nوكلاهُما يندرج تحت نوع خاصّ من نوع الأرقام وهو النوع البولي (bool) نسبةً لعالم الرياضيات جورج بول الذي وضع أسسه.\nأما الجملة الشرطية أو التعيين الشرطي ونحوه، فيتعلَّق بتحقق عبارة منطقية. فمن العبارات المنطقية: عبارة المقارنة:\n\n\n\nالعلامة\nالوصف\n\n\n\n\na == b\nيساوي\n\n\na != b\nلا يساوي\n\n\na &gt; b\nأكبر من\n\n\na &lt; b\nأصغر من\n\n\na &gt;= b\nأكبر من أو يساوي\n\n\na &lt;= b\nأصغر من أو يساوي\n\n\n\nهنا نستكشف عبارات تؤول إلى قيَم منطقية. العبارة الأولى: خمسة أكبر من تسعة؟\n\nb1 = 5 &gt; 9\nprint(type(b1))\nprint(b1)\n\n&lt;class 'bool'&gt;\nFalse\n\n\nالعبارة الثانية: هل طول كذا أكبر من طول كذا؟\n\nb2 = len('12345') &gt; len('123456789')\nprint(b2)\n\nFalse\n\n\n\nتركيب الشروط\nيجوز دمج عدة شروط بعمليات الجمع والتخيير والحصر والعكس، فناتجها المنطقي ملخص في الجدول التالي:\n\n\n\nA\nB\nAND\nOR\nXOR\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n\n\nالجمع: AND (و): تخرج 1 فقط إذا كان كلا المدخلين 1.\nالتخيير: OR (أو): تخرج 1 إذا كان أحد المدخلين على الأقل 1.\nالحصر: XOR (أو الحصرية): تخرج 1 إذا كان أحد المدخلين 1 والآخر 0.\nالعكس: NOT (ليس): تخرج عكس المدخل (1 يصبح 0، و0 يصبح 1).\n\nعلى سبيل المثال:\n\nage = 20\nweight = 50\n\nif age &gt; 18 and weight &gt; 45:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nيؤول طرفي المعامل and لقيمة منطقية هكذا:\n\nage &gt; 18 تؤول إلى True لأن age=20 وهو أكبر من 18\nweight &gt; 45 تؤول إلى True لأن weight=50 وهو أكبر من 45\nفتكون الجملة إذًا: True and True وهي تؤول إلى True\n\nوهذا تمثيل الشجرة الثنائية للعبارة الشرطية:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{and} -- True --&gt; RESULT\n  middle_left{\"&gt;\"} -- True --&gt; ROOT\n  middle_right{\"&gt;\"} -- True --&gt; ROOT\n  left_left[age] -- \"20\" --&gt; middle_left\n  left_right[18] -- \"18\" --&gt; middle_left\n  right_left[weight] -- \"50\" --&gt; middle_right\n  right_right[45] -- \"45\" --&gt; middle_right\n\n\n\n\n\n\n\n\nتستعمل الأقواس لتجميع الشروط لإيقاع الترتيب المنطقي المراد:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\nage &lt; 16 تؤول إلى False لأن age=16 ليست أصغر من 16\ntemperature &lt; 20 تؤول إلى True لأن temperature=15 أصغر من 20 فعلاً\nnot is_wearing_coat تؤول إلى False لأن is_wearing_coat=True وهي عكسها\nإذًا الجملة بين القوسين (temperature &lt; 20 and not is_wearing_coat) تؤول إلى True and False وهي تؤول إلى False\nإذًا الجملة age &lt; 16 or (False) تؤول إلى False or False وهي تؤول إلى False\n\nوهذا تمثيل الشجرة الثنائية للعبارة الشرطية:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{or} -- False --&gt; RESULT\n  middle_left{\"&lt;\"} -- False --&gt; ROOT\n  middle_right{and} -- False --&gt; ROOT\n  left_left[age] -- \"16\" --&gt; middle_left\n  left_right[16] -- \"16\" --&gt; middle_left\n  right_middle{\"&lt;\"} -- True --&gt; middle_right\n  right_not{not} -- False --&gt; middle_right\n  right_temp[temperature] -- \"15\" --&gt; right_middle\n  right_val[20] -- \"20\" --&gt; right_middle\n  right_coat[is_wearing_coat] -- True --&gt; right_not\n\n\n\n\n\n\n\nيُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون True أو False ولا بأس بتجزئته حينما يسهل بذلك الفهم:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\n\nif is_minor or (is_cold and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\n\nتسلسل المقارنات\nتفهم بايثون المقارنات المتسلسلة. فعبارة x &lt; y &lt;= z تكافئ x &lt; y and y &lt;= z:\n\nlow = 10\nhigh = 20\nx = 15\n\nassert (low &lt; x &lt; high) == (low &lt; x and x &lt; high)\n\nكذلك تراها تستعمل في المساواة:\n\nassert 3 == len('123') == len([10, 20, 30]) == len('abc')",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "title": "4  الجملة الشرطية",
    "section": "الجملة الشرطية المتكاملة",
    "text": "الجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if condition_1}}\n    IF -- False --&gt; ELIF{{elif condition_2}}\n    IF -- True --&gt; code_1\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; code_2\n    ELSE --&gt; code_3\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\n\nكلمة if (إذا) تبدأ الجملة المركبة الشرطية\nقد توجد else (وإلا) مرة. وهي تعمل عند تخلُّف العبارة المنطقية السابقة لها سواءً كانت السابقة لها if أو elif.\nوقد توجد elif بينهما مرة أو أكثر (وهي اختصار لكلمة else if وتعني: وإلا فإن)، فتعمل مثل else معلَّقة بعبارة منطقية مثل if.\n\n\nجرب\nاستكشف المنطق التالي بتغيير قيمة x كل مرة للتبع ما يحصل في كل مرة:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSet to zero\nAlways: 0\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if x &lt; 0}}\n    IF -- False --&gt; ELIF{{elif x == 0}}\n    IF -- True --&gt; S1[x = 0] --&gt; S2[\"Set to zero\"]\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; S3[x = 1] --&gt; S4[\"Single\"]\n    ELSE --&gt; S5[\"More\"]\n\n    Always[Always: x]\n    S2 --&gt; Always\n    S4 --&gt; Always\n    S5 --&gt; Always\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,3 color:red;\n\n\n\n\n\n\nوهذا تصوير لسير الإجراءات لنفس النص البرمجي. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الإجراءية:\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "title": "4  الجملة الشرطية",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nتستطيع في بايثون أن تجعل جملة التعيين تأخذ قيمتها بحسب شرطٍ معين. مثلاً:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if age &gt; 14}}\n    IF -- False --&gt; S2[\"status = 'child'\"]\n    IF -- True --&gt; S1[\"status = 'adult'\"]\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0 color:red;\n\n\n\n\n\n\n\n\nage = 18\nstatus = 'adult' if age &gt; 14 else 'child'\n\nprint(status)\n\nadult\n\n\n\n\nوهي مكافئة للنص البرمجي التالي:\n\nage = 18\n\nif age &gt; 14:\n  status = 'adult'\nelse:\n  status = 'child'\n\nprint(status)\n\nadult\n\n\nويحصل تسلسل التعيين المشروط بالصيغة التالية:\n\nscore = 75\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\"\nprint(grade)\n\nC\n\n\n\n\n\n\n\nflowchart TD\n  S1[\"score = 75\"] --&gt; IF1\n  IF1{{if score &gt;= 90}} -- True --&gt; A[\"grade = 'A'\"]\n  IF1 -- False --&gt; IF2{{if score &gt;= 80}} -- True --&gt; B[\"grade = 'B'\"]\n  IF2 -- False --&gt; C[\"grade = 'C'\"]\n  \n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 2,4 color:red;",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "title": "4  الجملة الشرطية",
    "section": "تضمين الجمل الشرطية",
    "text": "تضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\n\n\n\n\n\n\n\nflowchart TD\n  IF1{{if condition_1}}\n  IF1 -- False --&gt; ELSE1\n  IF1 -- True --&gt; IF2{{if condition_2}}\n  IF2 -- False --&gt; code_2\n  IF2 -- True --&gt; code_1\n  ELSE1[code_3]\n\n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\nننبه مرة أخرى أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\nمثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+\n\n\nوهذا تصوير له:",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "href": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "title": "4  الجملة الشرطية",
    "section": "التكرار",
    "text": "التكرار\nحلقة التكرار: هي الرجوع بالتنفيذ لجملة سابقة (غالبًا تكون سطرًا سابقًا) وذلك يحصل عددًا من المرات أو معلَّقًا بشرط.\nفللتكرار طريقتان:\n\nسرد مكرر (for): حيث يعيَّن متغير التكرار لكل عنصر في المكرر، واحدًا تلوَ الآخر. (وسيأتي ذكره في باب الجمع المرتب)\nالتكرار بشرط (while): حيث يستمر التكرار مادام الشرط متحققًا. (وهو موضوع هذا القسم)\n\n\nالتكرار بشرط\nنبدأ بالتكرار بالطريقة غير المحددة، وهي جُملة تبدأ بالكلمة while على النحو التالي. كأنها if متكررة إلى حين تخلُّف الشرط (أن يصبح False). وإن لم يتحقق الشرط أصلاً فلا ينفذ القطعة المضمَّنة أصلا:\n\n\n\n\n\n\n\nflowchart TD\n  WHILE{{while condition}}\n  WHILE -- False --&gt; END\n  WHILE -- True --&gt; S1[code] --&gt; WHILE\n  \n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\nwhile &lt;boolean expression&gt;:\n    &lt;code&gt;\n\n\nمثال:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; S3[\"Done\"]\n  WHILE -- True --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n3\n4\nDone\n\n\n\n\nلنقم بتتبع الخطوات عندما تكون i = 0:\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\nوهذا تصوير لسير الإجراءات لنفس النص البرمجي. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الإجراءية:\n\n\nلاحظ أن نسيان جملة الزيادة (i += 1) يجعل الشرط دائمًا صحيحًا، فيدور البرنامج في حلقة لا نهيائة ولا يخرج أبدًا. ويعتبر هذا خطأ برمجيًّا يتعذر على البرنامج التعامل معه بنفسه؛ بل يجب على المبرمج أن يكتشفه. وسيأتي الكلام عن أنواع الأخطاء في البرمجة في باب الأخطاء.\n\n\nالخروج من الحلقة\n\nتستخدم كلمة break لإيقاف عملية التكرار كلها.\nتستخدم كلمة continue للانتقال إلى الكرة التالية متخطيةً بقية الخطوات في الكرة الحالية.\n\nأولاً نمثل لاستعمال جملة break على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- break --&gt; Done\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,4 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\n\n\n\n\nوهذا مثال لاستخدام عبارة continue للتخطي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- True --&gt; S3[\"i += 1\"]\n  S3 -- continue --&gt;  WHILE\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,5 color:red;\n  linkStyle 4 color:blue;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\n\n\n\n\nأما جملة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط، ولا يتوقف الخارجي. وهذا مثال:\n\n\n\n\n\n\n\nflowchart TD\n  INIT1[\"i = 0\"] --&gt; WHILE1\n  WHILE1{{\"while i &lt; 3\"}}\n    S3[\"i += 1\"] --&gt; WHILE1\n    WHILE1 -- True --&gt; INIT2[\"j = 0\"] --&gt; WHILE2\n    WHILE2{{\"while j &lt; 3\"}}\n      WHILE2 -- True --&gt; IF1{{\"if i == 1\"}} -- break --&gt; WHILE1\n      IF1 -- False --&gt; S1[\"print(i, j)\"] --&gt; S2[\"j += 1\"] --&gt; WHILE2\n    WHILE2 -- False --&gt; S3\n\n  style WHILE1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style WHILE2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 5,8 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone\n\n\n\n\n\n\n\n\nالملحق بعدم الوقوع\nإذا قلنا أن الوقوع (True) عدمه (False) ؛فإن بايثون تلحق بعض القيم بعدم الوقوع:\n\nFalse\nNone\n0\n0.0\n''\n[]\n()\n{}\nset()\n\nوما عدا ذلك فملحق بالوقوع (True).\n\nif False or None or 0 or 0.0 or '' or [] or () or {} or set():\n    print('True')\nelse:\n    print('False')\n\nFalse",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#المصطلحات",
    "href": "chapters/03_control_flow/a_control_flow.html#المصطلحات",
    "title": "4  الجملة الشرطية",
    "section": "المصطلحات",
    "text": "المصطلحات\n\n\n\nالعربية\nالإنجليزية\n\n\n\n\nجملة شرطية\nConditional Statement\n\n\nجملة تكرارية\nLoop Statement\n\n\nشرط\nCondition\n\n\nتكرار\nLoop\n\n\nتكرار محدد\nFor Loop\n\n\nتكرار غير محدد\nWhile Loop\n\n\nاستمرار\nContinue\n\n\nتوقف\nBreak\n\n\nتعيين مشروط\nConditional Assignment\n\n\nتعبير شرطي\nConditional Expression\n\n\nتداخل\nNesting\n\n\nتسلسل\nSequence\n\n\nتفرع\nBranching\n\n\nمقارنة\nComparison\n\n\nعملية منطقية\nLogical Operation",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html",
    "href": "chapters/03_control_flow/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "تسجيل الدخول\nلاحظ:",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "href": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "title": "تطبيقات",
    "section": "",
    "text": "استخدم الإجراء input() لطلب اسم المستخدم (username) و كلمة المرور (password) من المستخدم وخزن كل منهما في متغير مناسب\nإذا كان اسم المستخدم هو \"admin\" وكلمة المرور هي \"abc123\"، اطبع: \"Welcome admin\"\nأو إذا كان اسم المستخدم هو \"backdoor\" وكلمة المرور هي \"let me in\"، اطبع: \"Nobody knows!\"\nخلاف ذلك، اطبع: \"Access denied!\"\n\nimport getpass\n\nusername = input(\"Enter your username: \")\npassword = getpass.getpass(\"Enter your password: \")\n\nmax_tries = 3\ntries = 0\n\nwhile tries &lt; max_tries:\n  if username == \"admin\" and password == \"abc123\":\n    print(\"Welcome admin\")\n    break\n  elif username == \"backdoor\" and password == \"let me in\":\n    print(\"Nobody knows!\")\n    break\n  else:\n    print(\"Access denied!\")\n    tries += 1\n\n\nوجود حلقة while لإعادة المحاولة ثلاث مرات فقط\nوجود جملة break لإنهاء الحلقة إذا تم التسجيل بنجاح\n\nلا توجد break في جزئية else الأخيرة وذلك لأن عدد المحاولات يزيد في كل مرة ليؤول الإجراء إلى انتفاء شرط الدوران",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "href": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "title": "تطبيقات",
    "section": "حساب مجموع الأعداد المدخلة",
    "text": "حساب مجموع الأعداد المدخلة\nهذا البرنامج الصغير يأخذ مجموعة أعداد، واحدًا تلوَ الآخر، ويجمعها جميعًا.\ntotal = 0\n\nwhile True:\n  user_input = input(\"Enter a number: \")\n  if user_input == \"quit\":\n    break\n  x = int(user_input)\n  total += x\nprint(total)\nإليك شرحه بالتفصيل:\nتذكر: أن لكل متغير قيمة. وأن لكل قيمة نوعًا. وأن النوع يحدد ما يقبله المتغير من عمليات.\n\nنعين المتغير total = 0 لتجميع النتائج\nنستعمل حلقة لا نهائية: while True لأننا نريد أن يستمر البرنامج إلى أن يكتب المستخدم quit\nنطلب من المستخدم أن يدخل عددًا، ونضع ما أدخَل في متغير: user_input\nهذا المتغير نوعه: str (نصي) لأن الإجراء input() يعطينا قيمة نصية\nإن كان المدخل كلمة quit، نكسر الحلقة بـ: break\nوإلا:\n\nننشئ قيمة عددية من المتغير user_input باستخدام int(user_input) أو float(user_input) ونعيِّنُ النتيجة في متغير جديد: x\nنجمع العدد إلى الحاصل: total\nعندها نكسر الحلقة بكلمة: break",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#المكيف",
    "href": "chapters/03_control_flow/apps.html#المكيف",
    "title": "تطبيقات",
    "section": "المكيف",
    "text": "المكيف\nتشغييل المكيف إن كانت درجة الحرارة أعلى من المرغوب، بشرط أن يكون المكيف يعمل:\n\nroom_temp = 30\ndesired_temp = 24\nac_functional = False\n\nif room_temp &gt; desired_temp:\n    if ac_functional:\n        print(\"Turning on AC.\")\n    else:\n        print(\"AC malfunction! Please repair.\")\n\nAC malfunction! Please repair.",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "href": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "title": "تطبيقات",
    "section": "برنامج تفاعلي",
    "text": "برنامج تفاعلي\nجرب انسخ هذا البرنامج واختبره بنفسك حتى تفهمه.\ninventory = 100\n\nwhile True:\n    print(\"Store Menu:\")\n    print(\"1. Buy Apples\")\n    print(\"2. Restock Apples\")\n    print(\"3. Exit\")\n\n    choice = input(\"Enter your choice: \")\n\n    if choice == \"1\":\n        quantity = int(input(\"Enter the quantity of fish to buy: \"))\n\n        if quantity &lt;= inventory:\n            inventory -= quantity\n            print(\"You bought\", quantity, \"fish. Remaining inventory:\", inventory)\n        else:\n            print(\"Insufficient stock. Please try again later.\")\n\n    elif choice == \"2\":\n        quantity = int(input(\"Enter the quantity of fish to restock: \"))\n        inventory += quantity\n        print(\"Restocked\", quantity, \"fish. New inventory:\", inventory)\n\n    elif choice == \"3\":\n        print(\"Exiting the store...\")\n        break\n\n    else:\n        print(\"Invalid choice. Please try again.\")",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "href": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "title": "تطبيقات",
    "section": "حساب مضروب العدد",
    "text": "حساب مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots 1\n\\]\n\ni = 5\nj = i\nwhile j &gt; 1:\n  j -= 1\n  i *= j\nprint(i)\n\n120\n\n\nشرح للخطوات التنفيذية التفصيلية:\n\nأولاً، قم بتعيين المتغير i إلى العدد 5\nثانياً، قم بتعيين المتغير j إلى العدد 5\nثالثاً، استمر في الدوران إلى أن يصل j إلى القيمة 1\n\nفي كل دوران، قم بطرح 1 من j\nثم قم بضرب i بالقيمة الجديدة لـ j: المتحصل هو أن `i = i * (i - 1)\n\nأخيراً، قم بطباعة القيمة النهائية لـ i",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html",
    "href": "chapters/03_control_flow/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "المحاذاة\nما هي المشكلة في هذه القطعة البرمجية؟ وكيف تحلها؟\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[1], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#تركيب-الشروط",
    "href": "chapters/03_control_flow/problems.html#تركيب-الشروط",
    "title": "مسائل",
    "section": "تركيب الشروط",
    "text": "تركيب الشروط\nاعكس هذه العبارة الشرطة المرسومة بكتابة القطعة البرمجية التي تمثلها:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{and} -- True --&gt; RESULT\n  middle_left{\"&gt;\"} -- True --&gt; ROOT\n  middle_right{\"&gt;\"} -- True --&gt; ROOT\n  left_left[age] -- \"20\" --&gt; middle_left\n  left_right[18] -- \"18\" --&gt; middle_left\n  right_left[weight] -- \"50\" --&gt; middle_right\n  right_right[45] -- \"45\" --&gt; middle_right",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#ارسم-الشجرة-الثائية",
    "href": "chapters/03_control_flow/problems.html#ارسم-الشجرة-الثائية",
    "title": "مسائل",
    "section": "ارسم الشجرة الثائية",
    "text": "ارسم الشجرة الثائية\nارسم الشجرة الثنائية للعبارة الشرطية في القطعة البرمجية التالية:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/03_control_flow/problems.html#الجملة-الشرطية-المتكاملة",
    "title": "مسائل",
    "section": "الجملة الشرطية المتكاملة",
    "text": "الجملة الشرطية المتكاملة\nما هو حاصل تنفيذ هذه القطعة (فقط بالنظر إليها يجب أن تعرف):\n\nx = 1\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSingle\nAlways: 1",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط",
    "title": "مسائل",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nكيف تكتب هذه الجملة بطريقة مختصرة؟\n\nspeed = 45\n\nif speed &gt; 50:\n  message = 'Too fast!'\nelse:\n  message = 'Okay'\n\nprint(message)\n\nOkay",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط-1",
    "href": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط-1",
    "title": "مسائل",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nوماذا عن هذه الجملة، كيف تكتبها مختصرة؟\n\ntemperature = 25\n\nif temperature &gt; 30:\n  comfort = 'Hot'\nelif temperature &gt; 15:\n  comfort = 'Comfortable'\nelse:\n  comfort = 'Cold'\n\nprint(comfort)\n\nComfortable",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "title": "مسائل",
    "section": "الوزن الطبيعي",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\n\n\n\nالتصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\nالمطلوب:\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية مضمنة تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة\n\nملاحظة: يجب أن تكون الجمل الشرطية تستعمل التضمين على النحو التالي:\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "title": "مسائل",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار",
    "href": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار",
    "title": "مسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة البرمجية التالية بحلقة تكرار:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار-1",
    "href": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار-1",
    "title": "مسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nوكذلك اكتب القطعة التالية بحلقة تكرار:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "href": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "title": "مسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "href": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "title": "مسائل",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بمفتاح الدولة، مثلاً بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html",
    "href": "chapters/03_control_flow/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\nالمطلوب:\nheight = 1.70\nweight = 95\nbmi = weight / height**2\n\nword = ''\ncategory = ''\n\nif bmi &lt; 18.5:\n    word = 'thin'\n    if bmi &lt; 16:\n        category = 'severe'\n    elif bmi &lt; 17:\n        category = 'moderate'\n    else:\n        category = 'mild'\nelif bmi &lt; 25:\n    word = 'normal'\nelse:\n    word = 'overweight'\n    if bmi &lt; 30:\n        category = 'class 1'\n    elif bmi &lt; 35:\n        category = 'class 2'\n    elif bmi &lt; 40:\n        category = 'class 3'\n    else:\n        category = 'class 4'\n\nprint(word, category)\n\noverweight class 2",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "title": "حل المسائل",
    "section": "",
    "text": "التصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\n\n\n\n\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\n\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "title": "حل المسائل",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة\n\nuser_input = input(\"Enter a number: \")\nn = int(user_input)\n\ntotal = 0\ni = 1\nwhile i &lt;= n:\n    total += i\n    i += 1\n\nprint('sum is:', total)",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار",
    "href": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار",
    "title": "حل المسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة البرمجية التالية بحلقة تكرار:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60\n\n\nالجواب:\n\nvalue = 15\nincrease = 5\nweeks = 10\n\ni = 0\nwhile i &lt; weeks:\n    value += increase\n    print(value, end=' ')\n    i += 1\n\n20 25 30 35 40 45 50 55 60 65 \n\n\nملاحظة: استعمال print(value, end=' ') يجعل الناتج يظهر في سطر واحد. وذلك لأن end='\\n' في الأصل وتعني سطرًا جديدًا.",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار-1",
    "href": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار-1",
    "title": "حل المسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة التالية بحلقة تكرار:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194\n\n\nالجواب:\n\nimport math\n\nday = 100\ngrowth_rate = 0.117\n\ni = 0\nwhile i &lt; 6:\n    day *= (1 + growth_rate)\n    print(math.floor(day))\n    i += 1\n\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "href": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "title": "حل المسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)\nقد مرت علينا هذه المسألة، لكن الآن المطلوب حلها بالتكرار.\n\nweight = 20\nfor week in range(12):\n    weight += weight * 0.1\nprint(weight)\n\n62.768567534419994",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "href": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "title": "حل المسائل",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”\n\nprint(\"\"\"مرحبا بك في خدمة التبرع\nفضلا أريد منك تزويدي ببعض المعلومات ..\n\"\"\")\n\nprint('أتشرف باسمك، مثلا: محمد أحمد')\nname = input()\n\nprint('زودنا برقم جوالك، يبدأ بـ966')\nphone = input()\n\nprint('ممكن تحدد مدينتك؟')\ncity = input()\n\nprint('الرجاء قم بكتابة اسم الحي')\nneighborhood = input()\n\nprint('name:', name)\nprint('phone:', phone)\nprint('city:', city)\nprint('neighborhood:', neighborhood)\n\nwhile True:\n    print('هل تود تأكيد طلب التبرع؟')\n    print('1. تأكيد الطلب')\n    print('2. تعديل الطلب')\n    print('3. إلغاء الطلب')\n    user_confirmation = input()\n\n    if user_confirmation == '1':\n        print('تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً')\n        break\n    elif user_confirmation == '2':\n        print('ما الشيء الذي تريد تعديله؟')\n        print('1. الاسم')\n        print('2. رقم الهاتف')\n        print('3. المدينة')\n        print('4. اسم الحي')\n        user_modification = input()\n        match user_modification:\n            case '1':\n                print('اسم الزبون')\n                name = input()\n            case '2':\n                print('رقم الهاتف')\n                phone = input()\n            case '3':\n                print('المدينة')\n                city = input()\n            case '4':\n                print('اسم الحي')\n                neighborhood = input()\n            case _:\n                print('إختيار غير موجود')\n\n    elif user_confirmation == '3':\n        print('تم إلغاء طلب التبرع')\n        break",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/04_functions/a1_function_calling.html",
    "href": "chapters/04_functions/a1_function_calling.html",
    "title": "5  استدعاء الإجراءات",
    "section": "",
    "text": "الإجراء (Procedure) هو جزء محفوظ من البرنامج يتم استدعاؤه مع تمرير عوامل مختلفة.\nويمكن استدعاؤه (Call) بعامل واحد:\n\nنحو: int(x) لإنشاء العدد الصحيح من النص. مثل: int(\"12\") ينتج: 12.\nأو نحو: abs(x) للقيمة المطلقة مثل: abs(-10) ينتج: 10.\n\nوقد يأخذ عاملين:\n\nنحو: round(x, n) مثل: round(10.259, 2) ينتج: 10.26.\nأو نحو: pow(x, y) لرفع العدد x إلى القوة y. مثل: pow(2, 3) ينتج: 8.\n\nوقد يأخذ عاملاً واحدًا لكنَّهُ قائمة:\n\nنحو: sum(numbers) مثل: sum([1, 2, 3, 4, 5]) ينتج: 15.\nأو نحو: max(numbers) لأكبر عدد في القائمة. مثل: max([1, 2, 30, 4, 5]) ينتج: 30.\n\nوقد يكون عدد عوامله لا محدودًا:\n\nنحو: print(*values). فعلامة النجمة (*) تشير لقبول عدد مطلق من العوامل. مثل:\n\n\nname = \"Adam\"\nage = 25\nprint(\"My name is\", name, \"and I'm\", age, \"years old\")\n\nMy name is Adam and I'm 25 years old\n\n\nفإن print قبلت خمسة عوامل:\n\nالنص: \"My name is\"\nقيمة المتغير: name\nالنص: \"and I'm\"\nقيمة المتغير: age\nالنص: \"years old\"\n\nولدينا الإجراء help(func) يطلب مساعدة الإجراء المعيَّن، بلا أقواس، هكذا:\n\nhelp(sum)\n\nHelp on built-in function sum in module builtins:\n\nsum(iterable, /, start=0)\n    Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\n    When the iterable is empty, return the start value.\n    This function is intended specifically for use with numeric values and may\n    reject non-numeric types.\n\n\n\nوقد عرفت أن طلب التنفيذ يكون بالقوسين بعد اسمه ()، وتوضَع العوامل فيهما وهي ضربان:\n\nعامل مؤثر\nعامل متأثر\n\nوفي كل ما سبق كانت العوامل من النوع المؤثر؛ لأنها كانت تؤثر في النتيجة ولا تتأثر بها.\nأما المتأثر فنحو فعل الترتيب من مكتبة القائمة: list.sort(xs) فإن المتأثر به القائمة نفسها، مثل:\n\nxs = [40, 20, 10, 30]\nlist.sort(xs)\n\nفأما جملة list.sort فإننا حددنا اسم النوع list وأردنا منه الإجراء sort، وأتينا بالقوسين لطلب تنفيذه، ووضعنا المتأثر xs فيه.\nومع أننا لم نعيِّن النتيجة (بجملة التعيين =)، فقد تغيَّرت (تأثرت) القائمة بالإجراء:\n\nprint(xs)\n\n[10, 20, 30, 40]\n\n\nبعكس الترتيب بالإجراء الذي ليس من النطاق العام: sorted(xs) فإنَّ القائمة فيه ليست متأثرًا؛ إذْ يُنتِجُ الإجراءُ قائمةً جديدةً ولا يغير القائمة المُدخلة:\n\nxs = [40, 20, 10, 30]\nys = sorted(xs)\nprint(xs, \"لم يعمل الإجراء في القائمة نفسها\")\nprint(ys, \"هي قائمة جديدة\")\n\n[40, 20, 10, 30] لم يعمل الإجراء في القائمة نفسها\n[10, 20, 30, 40] هي قائمة جديدة\n\n\nوقد تتساءل ما الفائدة من وجود طريقتين وكلاهما يعمل نفس العمل؟\n\nالطريقة الأولى: list.sort(xs) لا ترجع بشيء بل تعدل نفس القائمة\nالطريقة الثانية: sorted(xs) ترجع قائمة جديدة\n\nفأما الطريقة الأولى فأصغر في الذاكرة لأنها لا تُنشئ نُسخة كما تفعل الطريقة الثانية. لكن الطريقة الثانية مفيدة إن أردت أن تُبقي القائمة الأصلية كما هي.\nوالأمر كذلك في الإجراءين:\n\nlist.reverse(xs)\nreversed(xs)\n\nويجتمع المؤثر والمتأثر في نحو:\n\nlist.append(xs, 50)\n\nفالإجراء list.append يأخذ القائمة، ويضيف إليها القيمة 50. ولذلك نقول الأوَّل متأثر والثاني مؤثر.\n\nprint(xs)\n\n[40, 20, 10, 30, 50]\n\n\nوقد وضعت اللغات الشيئية (Object-Oriented) مثل بايثون صياغة خاصَّةً: للإجراء المسند إلى الشيء. وبذلك يتحصل لدينا طريقتان كلتاهما تؤديان نفس المعنى:\n\nإسناد الإجراء للنوع: list.append(xs, 25)\nإسناد الإجراء للشيء: xs.append(25)\n\nومثاله أيضًا في الإجراء list.sort للترتيب وكذلك في list.append للإضافة:\n\nxs = [20, 10, 30, 40]\nys = [20, 10, 30, 40]\n\nlist.sort(xs)\nys.sort()\nassert xs == ys\n\nlist.append(xs, 50)\nys.append(50)\nassert xs == ys\n\nوسنفرد للبرمجة الشيئية باباً.\nوقد تُعَيَّنُ العوامل بأحد طريقتين:\n\nتعيين بالموضع: نحو: round(3.14159, 2)\nتعيين بالاسم: نحو: round(number=3.14159, ndigits=2) فلا يشترط فيه ترتيب العوامل.\n\nويجوز استعمال الطريقتين معًا في نحو: list.sort(numbers, reverse=True) ويشترط فيه تقدم التعيين بالموضع ليكون في مكانه، ثم يتبعه التعيين بالاسم حيث لا يشترط الترتيب فيه.",
    "crumbs": [
      "باب الإجراء",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>استدعاء الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html",
    "href": "chapters/05_sequences/a_sequences.html",
    "title": "6  الجمع المرتب",
    "section": "",
    "text": "الجمع (Collection)\nكثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، …إلخ من العمليات التي تعمل على جميع عناصر المجموعة.\nالجمع (Collection) ضد المفرد (Atomic). وهو ما يقبل الإجراءات التالية:\nانظر خريطة الجموع شكل 1 حيث يتبين أنه مكون من ثلاثة:\nويتفرع منه ثلاثة:\nفالأول موضوع هذا الباب، والآخران في الباب التالي إن شاء الله.",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الجمع-collection",
    "href": "chapters/05_sequences/a_sequences.html#الجمع-collection",
    "title": "6  الجمع المرتب",
    "section": "",
    "text": "ملاحظة\n\n\n\nنرمز للمفرد بـx ولما يدل على الجمع بـc.\n\n\n\nالعضوية: x not in c\nالعد: len(c)\nالتكرار: for x in c\n\n\n\nالحاوي: Container (لقبوله العضوية)\nذو الحجم: Sized (لقبوله العد)\nالمكرر: Iterable (لقبوله التكرار)\n\n\n\nالتسلسل: Sequence\nالمجموعة: Set\nالدالة: Mapping",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#التسلسل-sequence",
    "href": "chapters/05_sequences/a_sequences.html#التسلسل-sequence",
    "title": "6  الجمع المرتب",
    "section": "التسلسل (Sequence)",
    "text": "التسلسل (Sequence)\nالتسلسل (Sequence) جمع مرتب من الأشياء.\n\nجمع: يعني قبوله الإجراءات الثلاثة السابق ذكرها (العضوية والعد والتكرار).\nمرتب: يعني أن لكل عنصرٍ موضعًا بالنسبة لبدايته.\n\nويبدأ ترقيم المواضع بالنسبة لبداية التسلسل لذلك نجعل للعنصر الأوَّل الموضِع 0، إذ نسبةُ ذلك لبداية التسلسل. ويكون موضع الثاني 1 بالنسبة لبداية التسلسل، وللثالث 2، وهكذا إلخ.\nومن أمثلة المجموعات المرتبة:\n\nقائمة الرسائل، إذ هي مرتبة بالوقت واحدة تتلو الأخرى\nمجموعة الحروف في اللغة العربية، إذ تبدأ بالألف وتنتهي بالياء وما بينهما كلٌّ له ما قبله وما بعده\nقائمة الانتظار التي تعطي الأولويَّة لمن يأتي أوَّلاً للدخول على الطبيب\n\nوالمشترك في هذه الأمثلة الثلاثة: أن العناصر لها موضِعٌ بالنسبة لبعضها (مرتَّبة).\nوالأنواع الأربعة التي من جنس التسلسل هي:\n\nالقائمة (list) ويُعبَّرُ عنه بالقوسين المربعين [].\nالصف (tuple) ويُعبَّرُ عنه بالقوسين المنحنيين ().\nالمجال (range) ويُعبَّرُ عنه بالإجراء المنشئ range().\nالنص (str) ويُعبَّرُ عنه بالتنصيص المفرد '' أو المزدوج \"\"\n\n\n\n\n\n\n\n\nflowchart TD\n    Collection[&lt;b&gt;الجمع&lt;/b&gt; &lt;br&gt; &lt;code&gt;Collection&lt;/code&gt;]\n    Collection --&gt; Sequence[&lt;b&gt;التسلسل&lt;/b&gt; &lt;br&gt; &lt;code&gt;Sequence&lt;/code&gt;]\n    Sequence --&gt; MutableSequence[&lt;b&gt;التسلسل المتغير&lt;/b&gt; &lt;br&gt; &lt;code&gt;MutableSequence&lt;/code&gt;]\n    MutableSequence --&gt; list[&lt;b&gt;القائمة&lt;/b&gt; &lt;br&gt; &lt;code&gt;list&lt;/code&gt;]\n    Sequence --&gt; tuple[&lt;b&gt;الصف&lt;/b&gt; &lt;br&gt; &lt;code&gt;tuple&lt;/code&gt;]\n    Sequence --&gt; range[&lt;b&gt;المجال&lt;/b&gt; &lt;br&gt; &lt;code&gt;range&lt;/code&gt;]\n    Sequence --&gt; str[&lt;b&gt;النص&lt;/b&gt; &lt;br&gt; &lt;code&gt;str&lt;/code&gt;]\n\n\n\n\nشكل 6.1: شجرة أنواع التسلسل\n\n\n\n\n\n\nوراجع خريطة المجموعات: شكل 1\nفهذه الأربعة تقبل الإجراءات التالية (المتغير s هو التسلسل هنا):\n\nالإشارة:\n\nبالموضع: s[i]\nبالقطعة: s[i:j]\nبالقطعة مع خطوة: s[i:j:k]\n\nمعرفة موضع شيء (إن وجد): s.index(x)\nعد تكرارات شيء: s.count(x)\nالبحث عن الأصغر والأكبر: min(s) و max(s)\n\nوتقبل من إجراءات الإنشاء:\n\nالدمج: s1 + s2\nالتكرار: s * n\n\nأما تخصيص حرف + للدمج (لا للجمع) ، وحرف * للتكرار (لا للضرب)؛ فسيأتي معنا -إن شاء الله- في فصل تعريف الإجراءات المخصوصة في باب الأنواع.",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الصف-tuple",
    "href": "chapters/05_sequences/a_sequences.html#الصف-tuple",
    "title": "6  الجمع المرتب",
    "section": "الصف (tuple)",
    "text": "الصف (tuple)\nالصف تسلسل جامد.\nفالجامد هو ما لا يقبل التغيير بعد إنشائه.\n\nالإنشاء\nيكون إنشاء الصف بالقوسين المنحنيين () على النحو التالي:\n\nالفرد: (x,) وهو صف بعنصر واحد\nالزوج: (x, y) وهو صف بعنصرين\nالثلاثي: (x, y, z) وهو صف بثلاثة عناصر\n…إلخ.\n\nولا يشترط تجانس العناصر؛ بل يجوز أن تكون أنواعها مختلفة:\n\ns = (10, 20, 'hello', True, (300, 400))\nprint(s)\n\n(10, 20, 'hello', True, (300, 400))\n\n\nوقد يتألف الإنشاء بالتكرار بعلامة *:\n\ns = (10, 20) * 3\nprint(s)\n\n(10, 20, 10, 20, 10, 20)\n\n\nأو الدمج، بعلامة +:\n\ns = (10, 20) + (30, 40)\nprint(s)\n\n(10, 20, 30, 40)\n\n\nنستعرض هنا العضوية والعد والتكرار:\n\ns = (100, 200, 300)\n\nassert 100 in s\nassert 400 not in s\nassert len(s) == 3\n\nfor x in s:\n    print(x)\n\n100\n200\n300\n\n\n\n\nالإشارة\nتستعمل الإشارة الموضعية لقراءة عنصر من التسلسل.\n\ns = (10, 20, 30, 40, 50)\nassert s[0] == 10\nassert s[-1] == 50\nassert s[len(s) // 2] == 30\n\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\nويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل.\nفهذا يفشل لأن المؤشر ليس رقمًا صحيحًا:\n\ns = (10, 20, 30, 40, 50)\ns['3']\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[149], line 2\n      1 s = (10, 20, 30, 40, 50)\n----&gt; 2 s['3']\n\nTypeError: tuple indices must be integers or slices, not str\n\n\n\nوكذلك هذا لأنه يتجاوز نطاق التسلسل (0 - 4):\n\ns = (10, 20, 30, 40, 50)\ns[5]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[150], line 2\n      1 s = (10, 20, 30, 40, 50)\n----&gt; 2 s[5]\n\nIndexError: tuple index out of range\n\n\n\nشكل الإشارة بالقطعة (slice) على نحو: s[start : end : step]. والقيم الابتدائية عند الإغفال هي: s[0:len(s):1].\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\n\ns = (10, 20, 30, 40, 50)\nassert s[1:3] == (20, 30)\nassert s[::2] == (10, 30, 50)\nassert s[::-1] == (50, 40, 30, 20, 10)\nassert s[1:4:2] == (20, 40) == s[-4:-1:2]\nassert s[1:4:2] == s[slice(1,4,2)] == (20, 40)\n\nلاحظ استعمال الإجراء المنشئ slice() في الإشارة بالقطعة، وقد جعلت بايثون علامة : بديلاً عنه.\nوإذا جعلته صفًّا من صفوف؛ صار مصفوفة:\n\nmatrix = (\n    (10, 20, 30),\n    (40, 50, 60),\n    (70, 80, 90)\n)\n\nassert matrix[0] == (10, 20, 30)\nassert matrix[-1] == (70, 80, 90)\n\nوتستعمل الإشارة مرتين للإشارة إلى العدد، مثلاً للإشارة إلى العنصر الثاني في الصف الثاني:\n\nassert matrix[1][1] == 50\n\n 0              1              2              3\n +--------------+--------------+--------------+\n | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |\n +--------------+--------------+--------------+\n-3             -2             -1\nالإشارة لعناصر الصف الواحد:\n 0    1    2    3\n +----+----+----+\n | 10 | 20 | 30 |\n +----+----+----+\n-3   -2   -1\n 0    1    2    3 \n +----+----+----+\n | 40 | 50 | 60 |\n +----+----+----+\n-3   -2   -1\n 0    1    2    3\n +----+----+----+\n | 70 | 80 | 90 |\n +----+----+----+\n-3   -2   -1\nعناصر نصوص:\n\nss = (\"Apple\", \"Banana\", \"Orange\", \"Lemon\")\nassert ss[1] == \"Banana\"\nassert ss[-1][0] == \"L\"\n\n 0       1        2        3       4\n +-------+--------+--------+-------+\n | Apple | Banana | Orange | Lemon |\n +-------+--------+--------+-------+\n-4      -3       -2       -1\nالإشارة لصف الأحرف في النص الواحد:\n 0   1   2   3   4   5\n +---+---+---+---+---+\n | L | e | m | o | n |\n +---+---+---+---+---+\n-5  -4  -3  -2  -1\nوسيأتي التفصيل في باب النص.\n\n\nالبحث\nالبحث عن موضع العنصر (s.index(x)) وعد تكراره (s.count(x)):\n\ns = ('Python', 'Python', 'Go')\nassert s.index('Go') == 2\nassert s.count('Python') == 2\n\nالبحث عن الأصغر والأكبر:\n\ns = (30, 20, 40, 10, 50)\nassert s.index(min(s)) == 3\nassert s.index(max(s)) == 4",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#القائمة-list",
    "href": "chapters/05_sequences/a_sequences.html#القائمة-list",
    "title": "6  الجمع المرتب",
    "section": "القائمة (list)",
    "text": "القائمة (list)\nالقائمة (list) تسلسل متغير.\nانظر MutableSequence في خريطة المجموعات: شكل 1.\n\nالتغير\nفالأنواع على قسمين من حيث قبول التغير بعد الإنشاء:\n\nمتغير (Mutable: قابل للتغيير): يعني قبوله الإضافة والحذف والتعديل على عناصرها بعد الإنشاء.\nجامد (Immutable: غير قابل للتغيير): لا يقبل التغير. ومن جهة كونها عوامل للإجراء؛ فإن الجامد لا يقبل أن يكون محل عمل الإجراء.\n\n\n\n\n\n\n\nملاحظة\n\n\n\nالتغير والجمود مفهومان يتكرران كثيرًا في البرمجة. للمزيد راجع: بناء البرمجيات: الفصل التاسع، الجمود (MIT-6.005)\n\n\nالتغير هي الخاصية التي تختلف فيها القائمة عن قسيماتها التسلسلية (الصف والمجال والنص). ومعناه قبولها الإجراءات التالية (نستعمل في المثال حرف l للقائمة):\n\nالاستبدال:\n\nلموضع: l[i] = x\nلقطعة: l[i:j] = t\nلقطعة بخطوة: l[i:j:k] = t\n\nالحذف:\n\nلموضع: del l[i]\nلقطعة: del l[i:j]\nلقطعة بخطوة: del l[i:j:k]\n\nالإزالة: l.remove(x) لحذف أول ورود للعنصر\nالنزع: l.pop([i]) أخذ العنصر من الموضع (مع حذفه من ذلك الموضع)\n\nإن لم يحدد الموضع: نزع الأخير. إذ القوسان [i] هنا في التعريف يعبران عن عامل اختياري وهو الموضع i\n\nالإدراج: l.insert(i, x) لإضافة عنصر في موضع محدد\nالإلحاق: l.append(x) لإضافة عنصر في النهاية\nالترتيب: l.sort() أو بالإجراء المبني sorted(l)\nالعكس: l.reverse() أو بالإجراء المبني reversed(l)\n\nلاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين المنحنيين ()، إذْ هو جامد لا يقبل التغير:\n\nt = (10, 20, 30, 40, 50)\nt[0] = 100\nprint(t)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[157], line 2\n      1 t = (10, 20, 30, 40, 50)\n----&gt; 2 t[0] = 100\n      3 print(t)\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nلكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين []، لأنها متغيرة:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nprint(l)\n\n[100, 20, 30, 40, 50]\n\n\nالاستبدال بالموضع والحذف منه:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nassert l == [100, 20, 30, 40, 50]\n\ndel l[0]\nassert 100 not in l\n\nالاستبدال بالقطعة والحذف منها\n\nl = [10, 20, 30, 40, 50]\nl[1:3] = [200, 300]\nassert l == [10, 200, 300, 40, 50]\n\ndel l[1:3]\nassert l == [10, 40, 50]\n\nالإدراج:\n\nl = [10, 20, 30, 40, 50]\nl.insert(1, 100)\nassert l == [10, 100, 20, 30, 40, 50]\n\nالإزالة:\n\nl = [10, 20, 30, 40, 50]\nl.remove(20)\nassert l == [10, 30, 40, 50]\n\nالإلحاق:\n\nl = [10, 20, 30, 40, 50]\nl.append(60)\nassert l == [10, 20, 30, 40, 50, 60]\n\nالترتيب والعكس:\n\nl = [30, 40, 10, 20, 50]\nl.sort()\nassert l == [10, 20, 30, 40, 50]\n\nl.reverse()\nassert l == [50, 40, 30, 20, 10]\n\nنزع العنصر الأخير:\n\nl = [10, 20, 30, 40, 50]\nx = l.pop()\nassert x == 50\nassert 50 not in l",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#النطاق-range",
    "href": "chapters/05_sequences/a_sequences.html#النطاق-range",
    "title": "6  الجمع المرتب",
    "section": "النطاق (range)",
    "text": "النطاق (range)\nيمثل النطاق (range) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فثلاثة عوامل تحدده:\n\nالبداية (start=0):\n\nمشمولة\nقيمتها الابتدائية 0 (إذا أهملت)\n\nالنهاية (stop):\n\nغير مشمولة\nوهي واجبة (إهمالها ممتنع)\n\nالخطوة (step=1):\n\nمقدار الزيادة أو النقص للعدد في كل كرة\nقيمتها الابتدائية 1 (إذا أهملت)\n\n\nدعونا الآن نلقي نظرة على التعريف كما هو موجود في وثائق بايثون، وذلك لنتعلم كيف نقرؤ التعريف. ادخل الرابط وتأمل معي ..\n\nclass range(stop)\nclass range(start, stop[, step])\n\nأولا: تدل كلمة class على أنها معرَّفة كنوع، فيكون طلب الإجراء بنفس الاسم range للإنشاء.\nثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما يكون؟\nنجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو stop وتأخذ البداية والخطوة قيمتهما الابتدائية: start=0 و step=1 حسب ما كُتب:\n\nIf the step argument is omitted, it defaults to 1.\nIf the start argument is omitted, it defaults to 0\n\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nأما التعريف الثاني فيجب تفكيكه لنفهمه: class range(start, stop[, step]).\nوجود الأقواس المربعة [ ] يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو start, stop؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الابتدائية step=1.\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\nالتكرار والإشارة\n\nxs = [10, 20, 30, 40, 50, 60]\n\nويُسرَد التسلسل بكلمة for، على النحو التالي:\n\nfor x in xs:\n    print(x)\n\n10\n20\n30\n40\n50\n60\n\n\nأو بسرد النطاق (حيث النهاية تكون: len(xs) أي: طول التسلسل) واستعمال الإشارة بالموضع (xs[i])، نحو:\n\nfor i in range(len(xs)):\n    print(xs[i])\n\n10\n20\n30\n40\n50\n60\n\n\nفهذا يفيد في التحكم في السرد، فلو أردنا كل عنصرٍ ثانٍ، نجعل الخطوة 2 ابتداء من العنصر الثاني 1، فنكتبها هكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i])\n\n20\n40\n60\n\n\nأو أردنا قراءة الموضع والذي قبله، فهكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i-1], xs[i])\n\n10 20\n30 40\n50 60\n\n\nفإن جوَّزنا التداخل، جعلنا الخطوة 1، هكذا:\n\nfor i in range(1, len(xs), 1):\n    print(xs[i-1], xs[i])\n\n10 20\n20 30\n30 40\n40 50\n50 60\n\n\nوهلم جرا..\n\n\nتأجيل النتيجة\nويجدر بالذكر أن النطاق لا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وهو كالصف لا يقبل التعديل.\nنستعمل فعل الإنشاء range() لإنشاء نطاق:\n\nr = range(0, 20, 2)\nr\n\nrange(0, 20, 2)\n\n\nفحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:\n\nprint(11 in r)\nprint(10 in r)\n\nFalse\nTrue\n\n\nكذلك الإجراء عند البحث عن موضع رقمٍ ما:\n\nprint(r.index(10))\n\n5\n\n\nوالإشارة لموضع ما أو قطعة كذلك:\n\nprint(r[5])\nprint(r[:5])\nprint(r[-1])\n\n10\nrange(0, 10, 2)\n18\n\n\n\n\nتحقيق النطاق\nالمولِّد لا تتحقق عناصره إلا عند الحاجة إليها؛ أي: عند قراءتها. فإذا جعلناه عاملاً في جملة الإنشاء list؛ تولَّدَت جميع عناصره ووُضِعَت في قائمة:\n\nevens = list(range(0, 10, 2))\nodds = list(range(1, 10, 2))\nprint(evens)\nprint(odds)\n\n[0, 2, 4, 6, 8]\n[1, 3, 5, 7, 9]",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#ضم-التسلسلات-المرتبطة-zip",
    "href": "chapters/05_sequences/a_sequences.html#ضم-التسلسلات-المرتبطة-zip",
    "title": "6  الجمع المرتب",
    "section": "ضم التسلسلات المرتبطة (zip)",
    "text": "ضم التسلسلات المرتبطة (zip)\nهذان تسلسلان مرتبطان:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = [90, 80, 75, 85, 95]\n\nassert len(students) == len(marks)\n\nويُمكن ضمُّ السلسلتين بحيث ينتج في التكرار عُنصران في كل مرة؛ وذلك بفعل الضم zip() الذي يُنتج مُكَرَّرًا -بفتح الراء- (Iterable). فإذا ضممنا سلسلتين، خرج لنا في كل كرَّة زوج (x, y):\n\nfor x, y in zip(students, marks):\n    print(x, y)\n\nAhmad 90\nBelal 80\nCamal 75\nDawud 85\nEmad 95\n\n\n\n\n\n\n\nflowchart LR\n    students --&gt; zip\n    marks --&gt; zip\n    zip --&gt; for\n    for --&gt; x\n    for --&gt; y\n\n\n\n\n\n\n\nضم المكررات\nولاحظ فيما يلي أن:\n\nنوع students قائمة (list)\nونوع marks نطاق (range)\nونوع classes صف (tuple)\n\nومع ذلك فإنه يجوز ضمُّها لأن الإجراء يقبلُ كُل ما هو مُكَرَّر:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = range(75, 95+1, 5)\nclasses = ('A-1', 'A-1', 'A-2', 'A-1', 'A-2')\n\nassert list == type(students)\nassert tuple == type(classes)\nassert range == type(marks)\n\nfor x, y, z in zip(students, marks, classes):\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2\n\n\n\n\nالقراءة بالموضع المشترك\nويكون قراءة التسلسلات المرتبطة أيضًا بسرد مُكَرَّر النطاق، والإشارة إلى كل عنصر بالموضع:\n\nfor i in range(len(students)):\n    x, y, z = students[i], marks[i], classes[i]\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "href": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "title": "6  الجمع المرتب",
    "section": "الإنشاء المختصر: الجملة الثلاثية",
    "text": "الإنشاء المختصر: الجملة الثلاثية\nمما تميزت به لغة بايثون عن غيرها: مختصرة الإنشاء (Comprehension)؛ وهي جملة تُنشئ مجموعة مستمَدَّة من مكرر في ثلاث جُمَل في سطرٍ واحدٍ -غالبًا- ووظيفتها: إنشاء مجموعة مستمَدَّة من مكرر.\nوليسَت زيادتها في اللغة من باب الضرورة وإنما من باب التحسين. إذْ فيها قوة في التعبير عن جمل كثيرة في مساحة صغيرة. فهذا المثال يعبر عن إنشاء قائمة كل عنصرٍ فيها مربَّعٌ من المكرر range(10) في سطرٍ واحد:\n\nsquares = [x ** 2 for x in range(10)]\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nفهي جملة إنشاء مركَّبة من ثلاث جمل:\n\nتعبير (x ** 2) ، الذي يشتمل غالبًا على متغير التكرار (x)\nتكرار: (for x in range(10))\nوشرط: والشرطُ ليسَ بشرط؛ لذا جاز إهماله في هذا المثال\n\nفهي مكافئة للقطعة التالية:\n\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nولو أردنا ترشيح الأعداد الزوجية من قائمة، نستطيع استعمال جملة الشرط في الاختصار على النحو التالي:\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nevens = [x for x in numbers if x % 2 == 0]\nevens\n\n[0, 2, 4, 6, 8]\n\n\n\nالتعبير: (x) فقط\nالتكرار: (for x in numbers)، وتذكر أن القائمة مُكرَّر\nالشرط: (if x % 2 == 0)\n\nوهي مكافئة للقطعة التالية:\n\nevens = []\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\nevens\n\n[0, 2, 4, 6, 8]\n\n\nوأما القوسان المربعان [ ] -في كلا المثالين- فلإنشاء قائمة. وبحسب ما يُراد إنشاؤه تختلف الأقواس:\n\n[expression for item in iterable if condition] للقائمة (list)\n(expression for item in iterable if condition) للمولِّد (Generator)\n{expression for item in iterable if condition} لمجموعة الفرائد (set) وسيأتي الكلام عنها في الباب القادم\n{expression: expression for item in iterable if condition} للقاموس (dict) وسيأتي الكلام عنه في الباب القادم",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الجمع المرتب</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html",
    "href": "chapters/05_sequences/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "ترتيب قائمة الأسماء\nإن تطبيقات البيانات المتسلسلة كثيرة جدًا وواقعية إلى حد كبير. ولن نتطرق الآن إلى كيفية وصول هذه البيانات إلى بايثون (فذلك موضوع له تفاصيله)، لكننا سنتعامل مع البيانات باعتبار أنها وصلت إلينا.\nلو كان لدينا قائمة من الأسماء ونريد ترتيبها أبجديًّا؛ فإننا نستعمل الإجراء sort() الذي يأخذ القائمة كمفعول به ويرتبها في مكانها:\nnames = [\n    \"Yousef\",\n    \"Ali\",\n    \"Belal\",\n]\nlist.sort(names)\nnames\n\n['Ali', 'Belal', 'Yousef']",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#ضم-القوائم",
    "href": "chapters/05_sequences/apps.html#ضم-القوائم",
    "title": "تطبيقات",
    "section": "ضم القوائم",
    "text": "ضم القوائم\nتأتي البيانات عادة من مصادر متعددة. فلو كان لدينا قائمتان لدرجات الطلاب، بحيث تحتوي القائمة أزواجًا تحوي اسم الطالب ودرجته، فإننا نريد ضمها جميعًا في قائمة واحدة. وهذا يتحقق بعملية الجمع + بين القوائم:\n\nclass1_marks = [\n    (\"Yousef\", 80),\n    (\"Ali\", 70),\n    (\"Belal\", 90),\n]\nclass2_marks = [\n    (\"Dawood\", 85),\n    (\"Muhammad\", 75),\n    (\"Yaser\", 95),\n]\nstudent_marks = class1_marks + class2_marks\nstudent_marks\n\n[('Yousef', 80),\n ('Ali', 70),\n ('Belal', 90),\n ('Dawood', 85),\n ('Muhammad', 75),\n ('Yaser', 95)]\n\n\nنتأكد من عدد الطلاب:\n\nassert len(student_marks) == len(class1_marks) + len(class2_marks)",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#ترتيب-قائمة-صفوف",
    "href": "chapters/05_sequences/apps.html#ترتيب-قائمة-صفوف",
    "title": "تطبيقات",
    "section": "ترتيب قائمة صفوف",
    "text": "ترتيب قائمة صفوف\nوالآن نريد أن نرتب هذه القائمة تصاعديًّا بحسب الدرجات.\n\n# أولاً سنفصل قائمة الدرجات لوحدها\nmarks = [mark for name, mark in student_marks]\n\nresult = []\n# نأتي على قائمة الدرجات بشكل تصاعدي\nfor mark in sorted(marks, reverse=True):\n    # نبحث عن الطلاب الذين حصلوا على هذه الدرجة\n    for row in student_marks:\n        # إذا كانت الدرجة متطابقة\n        if row[1] == mark:\n            # نضيفهم إلى النتيجة\n            result.append(row)\nresult\n\n[('Yaser', 95),\n ('Belal', 90),\n ('Dawood', 85),\n ('Yousef', 80),\n ('Muhammad', 75),\n ('Ali', 70)]\n\n\nولو أردنا أسماء الثلاثة الأوَل:\n\nhigh = [x[0] for x in result[:3]]\nhigh\n\n['Yaser', 'Belal', 'Dawood']\n\n\nونستطيع أن نأخذ أسماء الطلبة الأضعف في الدرجات حتى نفهم الأسباب ونحاول أن نرفع من مستواهم الدراسي. ولاحظ هنا نستعمل فك الأقواس بدل تحديد الموضع بالرقم:\n\nlow = [name for name, mark in result[-3:]]\nlow\n\n['Yousef', 'Muhammad', 'Ali']",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#توزيع-نماذج-الاختبار",
    "href": "chapters/05_sequences/apps.html#توزيع-نماذج-الاختبار",
    "title": "تطبيقات",
    "section": "توزيع نماذج الاختبار",
    "text": "توزيع نماذج الاختبار\nتصور أن لدينا نموذجين من الاختبار، ونريد أن نوزعها بحيث يأخذ نصفهم النموذج الأول والنصف الثاني يأخي النموذج الثاني، لكن نريد أن يكون التوزيع بحسب الصف الذي يجلس فيه الطلاب.\nنفترض أن كل صف يجلس فيه ثلاثة طلاب، ونريد أن نجعل لكل صف نموذجًا.\n\nstudents = [\n    'Ahmad',\n    'Belal',\n    'Camal',\n    'Dawood',\n    'Emad',\n    'Faris',\n    'Ghaith',\n    'Hussain',\n]\n\nنمر على قائمة الأسماء بخطوة مقدارها 3 (عدد الطلاب في كل صف):\n\nfor i in range(0, len(students), 3):\n    print(students[i:i+3])\n\n['Ahmad', 'Belal', 'Camal']\n['Dawood', 'Emad', 'Faris']\n['Ghaith', 'Hussain']\n\n\nوالآن نريد أن نحدد لكل صف نموذجًا. نحقق ذلك بعملية باقي القسمة لمعرفة ما إذا كان العدد يقبل القسمة على 2؛ إذ به يعرف الزوجي، والآخر هو الفردي:\n\nfor i in range(0, len(students), 3):\n    if i % 2 == 0:\n        print(students[i:i+3], 'test1')\n    else:\n        print(students[i:i+3], 'test2')\n\n['Ahmad', 'Belal', 'Camal'] test1\n['Dawood', 'Emad', 'Faris'] test2\n['Ghaith', 'Hussain'] test1",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#فرز-البيانات",
    "href": "chapters/05_sequences/apps.html#فرز-البيانات",
    "title": "تطبيقات",
    "section": "فرز البيانات",
    "text": "فرز البيانات\nتصور أن لدينا قائمة من الأرقام الموجبة والسالبة في مجموعة واحدة، ونريد فصلها لمجموعتين:\n\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = []\nnegatives = []\n\nfor x in numbers:\n    if x &gt; 0:\n        positives.append(x)\n    else:\n        negatives.append(x)\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]\n\n\nأو باستعمال الإنشاء المختصر:\n\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = [x for x in numbers if x &gt; 0]\nnegatives = [x for x in numbers if x &lt; 0]\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#المحاسبة-المالية",
    "href": "chapters/05_sequences/apps.html#المحاسبة-المالية",
    "title": "تطبيقات",
    "section": "المحاسبة المالية",
    "text": "المحاسبة المالية\nافترض أن لديك قائمة بالمصروفات والإيرادات لكل رُبع من السنة، وتريد حساب صافي الربح لكل ربع على حدة، ثم جمعها لتحصل على الربح الإجمالي للسنة.\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet     = [    0,     0,     0,     0]\nfor i in range(len(income)):\n    net[i] = income[i] - expense[i]\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100\n\n\nأو باستعمال zip للتكرار على مضموم القائمتين:\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet = []\nfor inc, exp in zip(income, expense):\n    net.append(inc - exp)\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100\n\n\nأو باستعمال الإنشاء المختصر:\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet = [inc - exp for inc, exp in zip(income, expense)]\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#أسعار-السلة",
    "href": "chapters/05_sequences/apps.html#أسعار-السلة",
    "title": "تطبيقات",
    "section": "أسعار السلة",
    "text": "أسعار السلة\nلديك قائمة بالأسعار:\n\nprices = [\n    ('apple', 10),\n    ('banana', 20),\n    ('orange', 30),\n    ('mango', 40),\n    ('pineapple', 50),\n]\n\nوتريد حساب مجمل سلة مشتريات لأحد الزبائن:\n\nbasket1 = [\n    ('apple', 2),\n    ('mango', 1)\n]\nbasket2 = [\n    ('banana', 1),\n    ('orange', 2),\n    ('pineapple', 1),\n]\n\nنكرر على العناصر\n\ntotal_basket1 = 0\nfor fruit, count in basket1:\n    for label, price in prices:\n        if fruit == label:\n            total_basket1 += price * count\nprint(total_basket1)\n\n60\n\n\nوكذلك للسلة الثانية:\n\ntotal_basket2 = 0\nfor fruit, count in basket2:\n    for label, price in prices:\n        if fruit == label:\n            total_basket2 += price * count\nprint(total_basket2)\n\n130",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#إدارة-الطلبات",
    "href": "chapters/05_sequences/apps.html#إدارة-الطلبات",
    "title": "تطبيقات",
    "section": "إدارة الطلبات",
    "text": "إدارة الطلبات\n\norders = []\n\nوتدخل الطلبات بإجراء الإلحاق append للقائمة:\n\nx = (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\norders.append(x)\n\nوهكذا الطلبات اللاحقة:\n\norders.append((('falafel', 'hummus', 'tea'), '8:48 PM'))\norders.append((('kabab', 'tabbouleh', 'water'), '8:52 PM'))\n\nوإننا حين ننجز الطلبات أو نعرضها، يكون بالترتيب التي دخلت به من الأول:\n\nfor order in orders:\n    print(order)\n\n(('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n(('kabab', 'tabbouleh', 'water'), '8:52 PM')\n\n\nوإذا أنجزنا الطلب (بالترتيب)، نزيله من القائمة:\n\nfinished = orders.pop(0)\nprint('done:', finished)\n\nprint('remaining:')\nfor order in orders:\n    print(order)\n\ndone: (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\nremaining:\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n(('kabab', 'tabbouleh', 'water'), '8:52 PM')\n\n\nأو هب أن الزبون الأخير ألغى الطلب، فإننا نزيله هكذا:\n\ncancelled = orders.pop(-1)\nprint('cancelled:', cancelled)\n\nprint('remaining:')\nfor order in orders:\n    print(order)\n\ncancelled: (('kabab', 'tabbouleh', 'water'), '8:52 PM')\nremaining:\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n\n\nملاحظة: pop(-1) تساوي pop() إذ القيمة الابتدائية هي -1.",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#إزالة-العناصر-المتكررة",
    "href": "chapters/05_sequences/apps.html#إزالة-العناصر-المتكررة",
    "title": "تطبيقات",
    "section": "إزالة العناصر المتكررة",
    "text": "إزالة العناصر المتكررة\nهب أننا وجدنا الطلب أدخل بالخطأ مرتين، ونريد إزالة التكرارات الموجودة في قائمة الطلبات كلها:\n\norders = [\n    (('falafel', 'hummus', 'tea'), '8:42 PM'),\n    (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n    (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n    (('falafel', 'hummus', 'tea'), '8:50 PM'),\n]\n\nلاحظ أن الطلب الأول والأخير ليسا مكررين، وذلك لأنهما في وقتين مختلفين، أم الطلبان في الوسط فهما في نفس الوقت بالضبط، ونريد إزالة مثل هذا التكرار:\n\nresult = []\nfor order in orders:\n    if order not in result:\n        result.append(order)\nresult\n\n[(('falafel', 'hummus', 'tea'), '8:42 PM'),\n (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n (('falafel', 'hummus', 'tea'), '8:50 PM')]",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#تعديل-الطلب",
    "href": "chapters/05_sequences/apps.html#تعديل-الطلب",
    "title": "تطبيقات",
    "section": "تعديل الطلب",
    "text": "تعديل الطلب\nنريد أن نتابع حالة الطلب، ونعدلها إذا أنهينا الطلب. لن نستطيع ذلك إذا حاولنا تعديل الصف ()، بل يجب أولًا أن نجعل قائمة الطلبات مكونة من قوائم [] وليس من صفوف:\n\norders = [\n    [('falafel', 'hummus', 'tea'), '8:42 PM', 'PENDING'],\n    [('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM', 'PENDING'],\n    [('falafel', 'hummus', 'tea'), '8:50 PM', 'PENDING'],\n]\n\n\norders[0][2] = 'DONE'\n\nوالآن نستطيع فرز الطلبات بحسب حالة الطلب:\n\norders_done = [order for order in orders if order[2] == 'DONE']\norders_pending = [order for order in orders if order[2] == 'PENDING']\n\nprint('done:')\nfor order in orders_done:\n    print(order)\n\nprint('pending:')\nfor order in orders_pending:\n    print(order)\n\ndone:\n[('falafel', 'hummus', 'tea'), '8:42 PM', 'DONE']\npending:\n[('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM', 'PENDING']\n[('falafel', 'hummus', 'tea'), '8:50 PM', 'PENDING']",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "href": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "title": "تطبيقات",
    "section": "معرفة النقاط المجاورة",
    "text": "معرفة النقاط المجاورة\nتقول الرياضيات أن المسافة الإقليدية (على سطح مستوي لا متعرج) بين نقطتين تحكمها المعادلة:\n\\[\nd = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nنريد استعماله لقائمة من النقاط لمعرفة النقاط المجاورة.\n\npoints = [(1, 2), (5, 6), (7, 8), (3, 4)]\nx1, y1 = (2, 4)\n\ndistances = []\n\nfor x2, y2 in points:\n  d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n  distances.append(d)\n  print(f'distance from {x1, y1} to {x2, y2} is {d}')\n\nmin_distance = min(distances)\nmin_distance_index = distances.index(min_distance)\n\nprint('min distance index:', min_distance_index, 'with distance:', min_distance)\n\nnearest_point = points[min_distance_index]\n\nprint(f'nearest point to {x1, y1} is {nearest_point}')\n\ndistance from (2, 4) to (1, 2) is 2.23606797749979\ndistance from (2, 4) to (5, 6) is 3.605551275463989\ndistance from (2, 4) to (7, 8) is 6.4031242374328485\ndistance from (2, 4) to (3, 4) is 1.0\nmin distance index: 3 with distance: 1.0\nnearest point to (2, 4) is (3, 4)",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "href": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "أمثلة إضافية على الإنشاء المختصر",
    "text": "أمثلة إضافية على الإنشاء المختصر\nيمكن استعمال اختصار من اختصار على النحو التالي. في هذا المثال نفرد قائمة مكونة من قوائم عددية، فنحوِّلها لتكون قائمة واحدة مكوَّنة من جميع هذه الأرقام:\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nإذا كتبناها من غير اختصار فشكلها كالتالي (لاحظ استعملنا متغير flat لتجميع القيَم المفردة):\n\nflat = []\nfor elem in vec:\n    for num in elem:\n        flat.append(num)\nflat\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nوهذا مثال لحاصل الضرب الديكارتي بين مجموعتين رياضيتين:\n\ncolors = ['red', 'green']\nshapes = ['circle', 'square']\ncartesian_product = [(color, shape) for color in colors for shape in shapes]\ncartesian_product\n\n[('red', 'circle'),\n ('red', 'square'),\n ('green', 'circle'),\n ('green', 'square')]\n\n\nراجع التوثيق لمزيد من الأمثلة.",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html",
    "href": "chapters/05_sequences/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "إنشاء قائمة\nلديك مجموعة طلاب في الفصل وتريد تجميع أسمائهم في مجموعة. وهم:",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#إنشاء-قائمة",
    "href": "chapters/05_sequences/problems.html#إنشاء-قائمة",
    "title": "مسائل",
    "section": "",
    "text": "\"عمرو\"\n\"لؤي\"\n\"محمد\"\n\"علي\"\n\"فصيل\"",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#قائمة-الطلاب",
    "href": "chapters/05_sequences/problems.html#قائمة-الطلاب",
    "title": "مسائل",
    "section": "قائمة الطلاب",
    "text": "قائمة الطلاب\nمن القائمة السابقة تريد تحصيل التالي:\n\nهل الطالب “لؤي” في القائمة؟\nكم عدد الطلاب؟\nاسرد الفائمة",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#أضف-طالبا-جديدا",
    "href": "chapters/05_sequences/problems.html#أضف-طالبا-جديدا",
    "title": "مسائل",
    "section": "أضف طالبًا جديدًا",
    "text": "أضف طالبًا جديدًا\nأضف طالبًا جديدًا إلى القائمة، وهو: \"زياد\".",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#بالإشارة",
    "href": "chapters/05_sequences/problems.html#بالإشارة",
    "title": "مسائل",
    "section": "بالإشارة",
    "text": "بالإشارة\n\nمن هو أول طالب؟\nمن هو آخر طالب؟\nمن هو الطالب الذي في المنتصف؟",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#بالقطعة",
    "href": "chapters/05_sequences/problems.html#بالقطعة",
    "title": "مسائل",
    "section": "بالقطعة",
    "text": "بالقطعة\n\nمن هم الطلاب باستثناء الأول والأخير؟\nمن هم الطلاب الثلاثة الأُخَر\nمن هم الطلاب الذين في موضع فردي؟\nمن هم الطلاب الذين في موضع زوجي؟",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "title": "مسائل",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\n\nلديك قائمة بالمبيعات اليومية.\n\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\nوتريد أن تحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الإجراء len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الإجراء sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الإجراء statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "href": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "title": "مسائل",
    "section": "سلة مشتريات",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها:\nfruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\nاحسب حاصل مشتريات كل سلة وفق قائمة الأسعار:\nbasket1 = [\"apple\", \"apple\", \"apple\"]\nbasket2 = [\"banana\", \"apple\"]",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "href": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "title": "مسائل",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\nيوصف ضرب المتجهين بالصيغة:\n\\[\n\\vec{u} \\cdot \\vec{v} = \\sum_{i=1}^{n} u_i v_i\n\\]\nأي أن كل عنصر من المتجه الأول يضرب في العنصر المناظر له في المتجه الثاني، ويُجْمَعُ ناتج ذلك كله.\nu = (1, 2, 3)\nv = (4, 5, 6)\nفهذا التوكيد الأول بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{v} &= [4, 5, 6] \\\\\n\\vec{u} \\cdot \\vec{v} &= (1)(4) + (2)(5) + (3)(6) \\\\\n                     &= 4 + 10 + 18 \\\\\n                     &= 32\n\\end{align*}\n\\]\nوهذا التوكيد الثاني بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{u} \\cdot \\vec{u} &= (1)(1) + (2)(2) + (3)(3) \\\\\n                     &= 1 + 4 + 9 \\\\\n                     &= 14\n\\end{align*}\n\\]",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html",
    "href": "chapters/05_sequences/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "إنشاء قائمة\nلديك مجموعة طلاب في الفصل وتريد تجميع أسمائهم في مجموعة. وهم:\nstudents = [\"عمرو\", \"لؤي\", \"محمد\", \"علي\", \"فصيل\"]",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#إنشاء-قائمة",
    "href": "chapters/05_sequences/solutions.html#إنشاء-قائمة",
    "title": "حل المسائل",
    "section": "",
    "text": "\"عمرو\"\n\"لؤي\"\n\"محمد\"\n\"علي\"\n\"فصيل\"",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#قائمة-الطلاب",
    "href": "chapters/05_sequences/solutions.html#قائمة-الطلاب",
    "title": "حل المسائل",
    "section": "قائمة الطلاب",
    "text": "قائمة الطلاب\nمن القائمة السابقة تريد تحصيل التالي:\n\nهل الطالب “لؤي” في القائمة؟\nكم عدد الطلاب؟\nاسرد الفائمة\n\n\nprint(\"لؤي\" in students)\nprint(len(students))\nfor s in students:\n    print(\"Student:\", s)\n\nTrue\n5\nStudent: عمرو\nStudent: لؤي\nStudent: محمد\nStudent: علي\nStudent: فصيل",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#أضف-طالبا-جديدا",
    "href": "chapters/05_sequences/solutions.html#أضف-طالبا-جديدا",
    "title": "حل المسائل",
    "section": "أضف طالبًا جديدًا",
    "text": "أضف طالبًا جديدًا\nأضف طالبًا جديدًا إلى القائمة، وهو: \"زياد\".\n\nstudents.append(\"زياد\")\n\nأو\nstudents = students + [\"زياد\"]",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#بالإشارة",
    "href": "chapters/05_sequences/solutions.html#بالإشارة",
    "title": "حل المسائل",
    "section": "بالإشارة",
    "text": "بالإشارة\n\nمن هو أول طالب؟\nمن هو آخر طالب؟\nمن هو الطالب الذي في المنتصف؟\n\n\nprint(students[0])\nprint(students[-1])\nprint(students[len(students) // 2])\n\nعمرو\nزياد\nعلي",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#بالقطعة",
    "href": "chapters/05_sequences/solutions.html#بالقطعة",
    "title": "حل المسائل",
    "section": "بالقطعة",
    "text": "بالقطعة\n\nمن هم الطلاب باستثناء الأول والأخير؟\nمن هم الطلاب الثلاثة من النهاية\nمن هم الطلاب الذين في موضع فردي؟\nمن هم الطلاب الذين في موضع زوجي؟\n\n\nprint(students[1:-1])\nprint(students[:-3])\nprint(students[::2])\nprint(students[1::2])\n\n['لؤي', 'محمد', 'علي', 'فصيل']\n['عمرو', 'لؤي', 'محمد']\n['عمرو', 'محمد', 'فصيل']\n['لؤي', 'علي', 'زياد']",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/solutions.html#متوسط-المبيعات-اليومية",
    "title": "حل المسائل",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\n\nلديك قائمة بالمبيعات اليومية.\n\n\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\n\nوتريد أن تحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الإجراء len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الإجراء sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الإجراء statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري\n\n\nimport statistics\n\nprint(len(daily_sales))\nfor i in range(0, len(daily_sales), 7):\n    print(\"Week\", i//7+1)\n    print(\"Sales:\", sum(daily_sales[i:i+7]))\n    print(\"Mean:\", round(statistics.mean(daily_sales[i:i+7]), 2))\n    print(\"Std:\",  round(statistics.stdev(daily_sales[i:i+7]), 2))\n    print()\n\n28\nWeek 1\nSales: 84\nMean: 12\nStd: 2.08\n\nWeek 2\nSales: 86\nMean: 12.29\nStd: 3.5\n\nWeek 3\nSales: 85\nMean: 12.14\nStd: 3.53\n\nWeek 4\nSales: 101\nMean: 14.43\nStd: 4.12",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#سلة-مشتريات",
    "href": "chapters/05_sequences/solutions.html#سلة-مشتريات",
    "title": "حل المسائل",
    "section": "سلة مشتريات",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها:\n\nfruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\n\nاحسب حاصل مشتريات كل سلة وفق قائمة الأسعار:\n\nbasket1 = [\"apple\", \"apple\", \"apple\"]\nbasket2 = [\"banana\", \"apple\"]\n\nللسلة الواحدة نكتب هكذا\n\ntotal = 0\nfor item in basket1:\n    total += prices[fruits.index(item)]\nprint(total)\n\n4.5\n\n\nلجميع السلال يمكن أن نضيف حلقة أخرى:\n\ntotals = []\nfor basket in [basket1, basket2]:\n    total = 0\n    for item in basket:\n        total += prices[fruits.index(item)]\n    totals.append(total)\nprint(totals)\n\n[4.5, 3.5]\n\n\nونستطيع أن نجمع المجموعات كلها:\n\nprint(sum(totals))\n\n8.0\n\n\nأو نكتبها التعبير المختصر:\n\nprint(sum([sum(prices[fruits.index(item)] for item in basket) for basket in [basket1, basket2]]))\n\n8.0",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#ضرب-متجهين",
    "href": "chapters/05_sequences/solutions.html#ضرب-متجهين",
    "title": "حل المسائل",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\nيوصف ضرب المتجهين بالصيغة:\n\\[\n\\vec{u} \\cdot \\vec{v} = \\sum_{i=1}^{n} u_i v_i\n\\]\nأي أن كل عنصر من المتجه الأول يضرب في العنصر المناظر له في المتجه الثاني، ويُجْمَعُ ناتج ذلك كله.\n\nu = (1, 2, 3)\nv = (4, 5, 6)\n\nفهذا التوكيد الأول بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{v} &= [4, 5, 6] \\\\\n\\vec{u} \\cdot \\vec{v} &= (1)(4) + (2)(5) + (3)(6) \\\\\n                     &= 4 + 10 + 18 \\\\\n                     &= 32\n\\end{align*}\n\\]\nوهذا التوكيد الثاني بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{u} \\cdot \\vec{u} &= (1)(1) + (2)(2) + (3)(3) \\\\\n                     &= 1 + 4 + 9 \\\\\n                     &= 14\n\\end{align*}\n\\]\nنضم العناصر المتقابلة من المتجهين ونجمع حاصل ضربهما:\n\nresult = 0\nfor a, b in zip(u, v):\n    result += a * b\nprint(result)\n\n32\n\n\n\nresult = 0\nfor a, b in zip(u, u):\n    result += a * b\nprint(result)\n\n14",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html",
    "href": "chapters/06_mapping/a1_set.html",
    "title": "7  المجموعة",
    "section": "",
    "text": "التحقق السريع\nوراجع خريطة المجموعات: شكل 1\nالمجموعة (set) هي جمع متغير من عناصر مرقومة فريدة بلا ترتيب.\nأو بالقوسين المتعرجين {} أو بالإجراء المُنشئ set() على النحو التالي:\nتقبل المجموعة -لكونها من نوع الجمع (Collection)- العمليات التالية:\nوباعتبارها مجموعة متغيرة (MutableSet)، فإنها تقبل الإجراءات التالية:\nولا يشترط تجانس العناصر؛ بل يجوز أن تكون أنواعها مختلفة:\nونرى عمليات المجموعة عليها: العد، والعضوية والتكرار:\nوكون المجموعة غير مرتبة، فإنها لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تقبل الإشارة (xs[i]) أو التقطيع (xs[i:j]) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:\nعرفنا أن المجموعة تقبل إجراء العضوية x in s، ولكن ثمة خصوصية لهذا الإجراء في المجموعة. وهذه الخصوصية تكمن في سرعة هذا الإجراء في المجموعة مقارنة بعملة في التسلسل مثلاً:\nblack_set = {\"192.168.1.1\", \"10.0.0.5\", \"172.16.0.2\"}\nip = \"10.0.0.5\"\nif ip in black_set:\n    print(\"Access Denied\")\n\nAccess Denied\nومثله في التسلسل:\nblack_list = [\"192.168.1.1\", \"10.0.0.5\", \"172.16.0.2\"]\nip = \"10.0.0.5\"\nif ip in black_list:\n    print(\"Access Denied\")\n\nAccess Denied\nلكن الفرق هو تفاصيل هذه العملية، إذ تختلف الكيفية خلف الكواليس. ولن يكون الفرق في السرعة واضحًا إلا حين تكون المجموعة كبيرة جدًّا.\nإن أردت مزيدًا من التفاصيل فإليك هذا الرابط: https://www.w3schools.com/dsa/dsa_data_hashsets.php.",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#التحقق-السريع",
    "href": "chapters/06_mapping/a1_set.html#التحقق-السريع",
    "title": "7  المجموعة",
    "section": "",
    "text": "وذلك أننا في القائمة نحتاج أن نمر على العناصر واحدًا تلو الآخر، حتى نجد العنصر أو لا نجده\nأما في المجموعة، فإن القيمة يتم رقمها (hash) حتى يُعرف موقع العنصر في المجموعة مباشرة من غير المرور على عناصرها. فعملية الرقم تعطينا العنوان بشكل ذكي.",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#منطق-المجموعة-الرياضية",
    "href": "chapters/06_mapping/a1_set.html#منطق-المجموعة-الرياضية",
    "title": "7  المجموعة",
    "section": "منطق المجموعة الرياضية",
    "text": "منطق المجموعة الرياضية\nمما تتميز به المجموعة عن بقية أنواع الجمع: قبولها المنطق الرياضي على النحو التالي:\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل).\n\nوهذه القطعة مثال لجميع هذه العمليات الرياضية:\n\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#العمليات-على-المجموعات",
    "href": "chapters/06_mapping/a1_set.html#العمليات-على-المجموعات",
    "title": "7  المجموعة",
    "section": "العمليات على المجموعات",
    "text": "العمليات على المجموعات\n\nالاتحاد\n\n\n\nاتحاد مجموعتين\n\n\n\nset.union(set1, set2)\n\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n\n\n\nالتقاطع\n\n\n\nتقاطع مجموعتين\n\n\n\nset.intersection(set1, set2)\n\n{4, 5}\n\n\n\n\nالفرق\n\n\n\nالفرق\n\n\n\nset.difference(set1, set2)\n\n{1, 2, 3}\n\n\n\nset.difference(set2, set1)\n\n{6, 7, 8}\n\n\n\n\nالفرق التماثلي\n\n\n\nالفرق التماثلي\n\n\n\nset.symmetric_difference(set1, set2)\n\n{1, 2, 3, 6, 7, 8}\n\n\nملاحظة: لكل من الإجراءات السابقة علامة تمثله كما هو موضَّح في الجدول. إلا أن استعمال اسم الإجراء يقبل أي نوع من المتكررات (Iterables) ولا تقتصر على نوع المجموعة فقط (set):\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nالاتحاد\nset1 | set2\nset1.union(set2)\n\n\nالتقاطع\nset1 & set2\nset1.intersection(set2)\n\n\nالفرق\nset1 - set2\nset1.difference(set2)\n\n\nالفرق التماثلي\nset1 ^ set2\nset1.symmetric_difference(set2)",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#العلاقات-بين-المجموعات",
    "href": "chapters/06_mapping/a1_set.html#العلاقات-بين-المجموعات",
    "title": "7  المجموعة",
    "section": "العلاقات بين المجموعات",
    "text": "العلاقات بين المجموعات\n\nالجزئية والشمول\nوكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nتحقق الجزئية\nset1 &lt;= set2\nset1.issubset(set2)\n\n\nتحقق الشمول\nset1 &gt;= set2\nset1.issuperset(set2)\n\n\nتحقق الانفصال\nlen(set1 & set2) == 0\nset1.isdisjoint(set2)\n\n\n\n\n\n\nالجزئية والشمول\n\n\n\nA = {1, 2, 3}\nB = {1, 2, 3, 4, 5, 6}\n\nوهذا مثال لاستعمالها كما في الجدول:\n\nassert A.issubset(B)\nassert B.issuperset(A)\n\n\n\nالانفصال\nوأما الانفصال، فهو عدم وجود أدنى تقاطع بين المجموعتين:\n\nC = {'Apple', 'Banana'}\nassert C.isdisjoint(A)\nassert C.isdisjoint(B)",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html",
    "href": "chapters/06_mapping/a2_dict.html",
    "title": "8  القاموس",
    "section": "",
    "text": "استعمالات القاموس\nوراجع خريطة المجموعات: شكل 1\nالقاموس (dict) جمع متغير مرتب، العنصر فيه مرقوم فريد مقابل لقيمة.\nتنشأ المجموعة الرابطة بالإجراء المنشئ dict() أو بالقوسين المتعرجين {} وذلك على النحو التالي:\nوفي كل اقتران نضيفه إلى قائمة الاقتران (القاموس):\nيستعمل القاموس في كثير من السياقات في البرمجة، وهو من أهم هياكل البيانات.",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#استعمالات-القاموس",
    "href": "chapters/06_mapping/a2_dict.html#استعمالات-القاموس",
    "title": "8  القاموس",
    "section": "",
    "text": "الكلمة ومعناها\nالقاموس بالمعنى الذي يشير إليه اللفظ. نفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:\n\nenglish_to_arabic = {\n    'apple': 'تفاحة',\n    'banana': 'موزة',\n    'orange': 'برتقالة',\n}\n\n\n\nربط الأسماء بالأرقام\nمثلاً: دليل أرقام الهواتف هو قاموس:\n\nname_to_phone = {\n    'Adam': '966xxxxxxxxx',\n    'Mohammed': '966xxxxxxxxx',\n}\n\n\n\nدليل أسماء النطاقات\nوكذلك دليل أسماء النطاقات (DNS: Domain Name System) على شبكة الانرتنت هو قاموس:\n\ndomain_to_ip = {\n    'google.com': '172.217.14.206',\n    'wikipedia.org': '103.86.96.10',\n}\n\n\n\nاختصار الروابط الطويلة\nمن استعمالات القاموس: اختصار الروابط الطويلة في روابط قصيرة.\n\nshort_to_full = {\n    'google': 'https://www.google.com',\n    'python': 'https://www.python.org',\n    'wiki': 'https://www.wikipedia.org',\n}\n\n\n\nالكلمات المختصرة\nأو الاختصارات إلى الكلمة التامة:\n\nabb_to_full = {\n    'ASAP': 'As Soon As Possible',\n    'BRB': 'Be Right Back',\n    'DIY': 'Do It Yourself',\n    'EDA': 'Exploratory Data Analysis',\n    'FYI': 'For Your Information',\n    'SAR': 'Saudi Riyal',\n}",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#القاموس-dict",
    "href": "chapters/06_mapping/a2_dict.html#القاموس-dict",
    "title": "8  القاموس",
    "section": "القاموس (dict)",
    "text": "القاموس (dict)\nومن حيث كون القاموس من نوع الجمع (Collection)، فإنه يقبل الإجراءات ثلاثة:\n\nالعضوية: x not in d\nالعد: len(d)\nالتكرار: for x in d\n\nويقبل القاموس لكونه اقترانًا (Mapping) الإجراءات التالية:\n\nالإشارة مفتاح: dict[key]\nالإشارة بمفتاح مع الرجوع بقيمة ابتدائية إن لم يُعثَر عليه: dict.get(key[, default])\n\nولكونه اقترانًا متغيرًا (MutableMapping)، فإنه يقبل الإجراءات التالية:\n\nالتعديل بمفتاح: dict[key] = value\nالحذف بمفتاح: del dict[key]\nنزع بمفتاح وإرجاع القيمة: x = dict.pop(key)\nالتحديث: dict.update(mapping)\n\nراجع خريطة الجموع: شكل 1.\nوهذه كذلك، كلها مرقومات، ولا يشترط أن تكون متجانسة (من نفس النوع)، كما يلي:\n\ndata = {\n    'key1': 100,\n    20: 'value2',\n    'c': [10, 20, 30, True],\n    (1, 2): 'value3',\n    ('a', 'b', 'c'): 'value4',\n}\n\nassert len(data) == 5\ndel data['key1']\nassert 'key1' not in data\n\nونحصل عليها بالإشارة بمرقوم:\n\nprint(data[20])\nprint(data['c'])\nprint(data[(1, 2)])\nprint(data[('a', 'b', 'c')])\n\nvalue2\n[10, 20, 30, True]\nvalue3\nvalue4",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#التضمين",
    "href": "chapters/06_mapping/a2_dict.html#التضمين",
    "title": "8  القاموس",
    "section": "التضمين",
    "text": "التضمين\nيجوز جعل القيمة نفسها قاموسًا. ومثال ذلك حفظ اختيارات المستخدم هكذا:\n\nuser = {\n    'name': 'Adam',\n    'language': 'Arabic',\n    'phone': '966xxxxxxxxx',\n    'last_updated': '2021-09-01',\n    'age': 25,\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\nوللوصول إلى قيمة مضمَّنة، نستعمل الإشارة بالمفتاح مرتين، هكذا:\n\nuser['notifications']['push']\n\nTrue",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#التكرار",
    "href": "chapters/06_mapping/a2_dict.html#التكرار",
    "title": "8  القاموس",
    "section": "التكرار",
    "text": "التكرار\nويجوز التكرار بثلاثة طرق:\n\nكر العناصر: for key, value in d.items()\nكر المفاتيح: for key in d.keys()\nكر القيم: for value in d.values()\n\nمثال:\n\nd = {\n    'A': 'Salam',\n    'B': 'Hello',\n    'C': 'Hi',\n}\nfor value in d.values():\n    print(value)\n\nSalam\nHello\nHi",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#عكس-القاموس",
    "href": "chapters/06_mapping/a2_dict.html#عكس-القاموس",
    "title": "8  القاموس",
    "section": "عكس القاموس",
    "text": "عكس القاموس\nإذا أردت عكس القاموس بحيث يصير المفتاح مكان القيمة والقيمة مكان المفتاح، فبهذه الطريقة:\n\nd = {\n    'ASAP': 'As soon as possible',\n    'TBD': 'To be determined',\n    'IDK': 'I don\\'t know',\n}\ninverse = dict()\nfor k, v in d.items():\n    inverse[v] = k\ninverse\n\n{'As soon as possible': 'ASAP',\n 'To be determined': 'TBD',\n \"I don't know\": 'IDK'}\n\n\nأو بالجملة المختصرة:\n\ninverse = {v: k for k, v in d.items()}\ninverse\n\n{'As soon as possible': 'ASAP',\n 'To be determined': 'TBD',\n \"I don't know\": 'IDK'}",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#إنشاء-قاموس-من-سلسلتين",
    "href": "chapters/06_mapping/a2_dict.html#إنشاء-قاموس-من-سلسلتين",
    "title": "8  القاموس",
    "section": "إنشاء قاموس من سلسلتين",
    "text": "إنشاء قاموس من سلسلتين\nويتحصل القاموس من سلسلتين باستعمال الإجراء zip()، كما يلي:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawood']\nmarks    = [     90,      80,      75,       85]\ndata = dict(zip(students, marks))\ndata\n\n{'Ahmad': 90, 'Belal': 80, 'Camal': 75, 'Dawood': 85}",
    "crumbs": [
      "باب الجمع المرقوم",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html",
    "href": "chapters/06_mapping/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "الأجزاء المنتمية إلى الكل\nأو الاختصارات إلى الكلمة التامة:\nanimal_class = {\n    \"Dog\": \"Mammalia\",\n    \"Cat\": \"Mammalia\",\n    \"Elephant\": \"Mammalia\",\n    \"Snake\": \"Reptilia\",\n    \"Lizard\": \"Reptilia\",\n    \"Frog\": \"Amphibia\",\n}\nنريد عكس هذه القائمة أيضًا بحيث نستطيع أن نعرف من الصنف كل الحيوانات المتنمية إليه.\nنأتي على جميع المفاتيح في القاموس الأول ونضيفها بحسب القيمة التي تقابلها:\nclass_animal = {}\nfor animal, clazz in animal_class.items():\n    if clazz not in class_animal:\n        class_animal[clazz] = []\n    class_animal[clazz].append(animal)\nclass_animal\n\n{'Mammalia': ['Dog', 'Cat', 'Elephant'],\n 'Reptilia': ['Snake', 'Lizard'],\n 'Amphibia': ['Frog']}\nلاحظ استعمال اسم clazz بدل class لأن كلمة class أصلية في لغة بايثون فلا يجوز استعمالها كمتغير.",
    "crumbs": [
      "باب الجمع المرقوم",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#سلة-المشتريات",
    "href": "chapters/06_mapping/b_context.html#سلة-المشتريات",
    "title": "تطبيقات",
    "section": "سلة المشتريات",
    "text": "سلة المشتريات\nنفترض أن لدينا سلة تحتوي على مشتريات العميل (basket)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس prices بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).\n\nprices = {\n    'apple': 15.25,\n    'banana': 10.50,\n    'orange': 5.75,\n    'cantaloupe': 40.00\n}\n\nيجوز تحديث الأسعار هكذا:\n\nprices['banana'] = 12\nprices['orange'] = 15\n\nأو تحديثها بالإجراء update():\n\nprices.update({'banana': 12, 'orange': 15})\nprices\n\n{'apple': 15.25, 'banana': 12, 'orange': 15, 'cantaloupe': 40.0}\n\n\nوالآن نفترض أن لدينا قائمة بالفواكه التي يريدها العميل:\n\nbasket = ['apple', 'apple', 'banana', 'orange', 'banana']\n\nنحسب سعر كل فاكهة في السلة بناءً على الأسعار الموجودة في القاموس:\n\ntotal = 0\n\nfor fruit in basket:\n    total += prices[fruit]\n\nprint(total)\n\n69.5\n\n\nأو تستطيع أن تعدها أولاً ثم تضربها بالسعر:\n\ncounts = dict()\nfor fruit in set(basket):\n    counts[fruit] = basket.count(fruit)\ncounts\n\n{'banana': 2, 'apple': 2, 'orange': 1}\n\n\nثم تضربها بالسعر:\n\ntotal = sum(counts[fruit] * prices[fruit] for fruit in counts)\ntotal\n\n69.5",
    "crumbs": [
      "باب الجمع المرقوم",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#استعمال-الإنشاء-المختصر",
    "href": "chapters/06_mapping/b_context.html#استعمال-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "استعمال الإنشاء المختصر",
    "text": "استعمال الإنشاء المختصر\nتقدم معنا الكلام عن الإنشاء المختصر. وسنستعرضه الآن مع القاموس.\nهنا مثال لقاموس من الفواكه، نريد ترشيح ما قيمته أقل من 20:\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nfiltered_menu = {k: v for k, v in menu.items() if v &lt; 20}\nfiltered_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5}\n\n\nوهذا مثال أكثر تعقيدًا. نطبق خصم 20% فقط على العناصر التي يكون سعرها أعلى من المتوسط، مع الحفاظ على بقية الأسعار كما هي. لاحظ أن التعبير هنا هو تعيين شرطي: value * (1 - discount) if value &gt; avg_price else value وليس هو قطعة الترشيح (if)؛ إذ تلك تأتي في نهاية الجملة، بعد قطعة التكرار (for).\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\navg_price = sum(menu.values()) / len(menu)\ndiscount = 0.20\n\ndiscounted_menu = {\n    k: v * (1 - discount) if v &gt; avg_price else v\n    for k, v in menu.items()\n}\ndiscounted_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5, 'cantaloupe': 32.0}",
    "crumbs": [
      "باب الجمع المرقوم",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html",
    "href": "chapters/06_mapping/c_problems.html",
    "title": "مسائل",
    "section": "",
    "text": "قاموس داخل قاموس\nإذا كان لديك قاموس متداخل كالتالي:\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\nالمطلوب أن تسحب من تفضيلات المستخدم المتغيرات التالية:",
    "crumbs": [
      "باب الجمع المرقوم",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#قاموس-داخل-قاموس",
    "href": "chapters/06_mapping/c_problems.html#قاموس-داخل-قاموس",
    "title": "مسائل",
    "section": "",
    "text": "theme\nsms\nآخر عنصر في: emails",
    "crumbs": [
      "باب الجمع المرقوم",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html",
    "href": "chapters/07_strings/a1_strings.html",
    "title": "9  النص",
    "section": "",
    "text": "النص الطبيعي\nالنص (str) صف من الأحرف. وهو تسلسل ثابت من أرقام الترميز العالمي (Unicode) التي هي رموز تتبع ترميزًا عالميًا يحوي جميع أحرف اللغات بالإضافة إلى علامات الترقيم والرسوم (مثل: 💡🔍📐) ونحوها.\nالنص الطبيعي (الحر أو البشري) هو ما لا يتبع هيكلاً أو قالبًا يحكم طريقة كتابته؛ وهو يطول ويقصر من الحرف الواحد إلى مجموعة الأحرف إلى الكلمة إلى الجملة وإلى أكبر من ذلك نحو:\nوأوجه معالجة النصوص الحرة كثيرة منها: الفهرسة والبحث والاستبدال والعد والتصنيف والترتيب والقولبة …إلخ.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "href": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "title": "9  النص",
    "section": "",
    "text": "محادثات وسائل التواصل الاجتماعي\nرسائل البريد الإلكتروني\nمقالات\nكتب\nموسوعات\nصفحات الشبكة\nمواقع الشبكة",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "href": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "title": "9  النص",
    "section": "النص المُقَوْلَب",
    "text": "النص المُقَوْلَب\nالنص المقولَب الذي يأخذ شكلاً محددًا؛ وله صيغ متعددة يُنشئ الناس منها قوالب للنص لتمثل مجموعات أو ارتباطات من البيانات، كالجداول ونحوها.\nوصيغ القولبة كثيرة من أشهرها: XML, YAML, JSON, CSV\n\n\nمثال لقالب بصيغة YAML:\n---\nName: Adam\nAge: 25\nCity: Riyadh\n\nمثال لقالب بصيغة JSON:\n{\n  \"Name\": \"Adam\",\n  \"Age\": 25,\n  \"City\": \"Riyadh\"\n}\n\n\nوهذا مثال لقالب بصيغة XML:\n&lt;person&gt;\n  &lt;name&gt;Adam&lt;/name&gt;\n  &lt;age&gt;25&lt;/age&gt;\n  &lt;city&gt;Riyadh&lt;/city&gt;\n&lt;/person&gt;\nوالصيغة التي تستعمل كثيرًا لتمثيل الجداول (صفوف) هي صيغة CSV. فكل سطرٍ هو صفٌّ في الجدول، وأوَّلُ سطرٍ هو رأس الجدول عادةً. وذلك على النحو التالي:\nName,Age,City\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\nجرب أن تُنشئ ملفًّا نصيًّا وتكتب فيه ذلك وتحفظه بصيغة csv ثم سترى أنه يمكنك فتحه بمحرر جداول (:مثل إكسل - Excel).",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "href": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "title": "9  النص",
    "section": "إنشاء النص",
    "text": "إنشاء النص\nجملة إنشاء النص في بايثون تكون كالتالي:\n\nبعلامة اقتباس مفردة: 'السلام عليكم!'\nأو بعلامة اقتباس مزدوجة: \"السلام عليكم!\" وليس بينهما فرق.\nأو بعلامة اقتاس مكررة ثلاثة مرات: \"\"\"السلام عليكم!\"\"\" للنص الجاري على أكثر من سطر.\n\nعلى سبيل المثال:\n\nname = 'Adam'\naddress = \"Makkah, Saudi Arabia\"\n\nتأمل إنشاء هذا النص الذي يبتدئ في السطر الأول ويمتد لأربعة أسطر:\n\nmessage = \"\"\"السلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\"\"\"\nprint(message)\n\nالسلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\n\n\n\nقراءة الملفات النصية\nوكثيرًا ما يكون وجود النص في البرنامج ناتجًا عن قراءة ملف نصي بالإجراء open() وذلك بإضافة الحرف r ميشرًا إلى أن غرض الفتح للقراءة (ويجب أن يكون الملف موجودًا إلى جانب البرنامج - أي: في نفس المجلد الذي يوجد فيه البرنامج):\nfile = open('my_file.txt', 'r')\nmessage = file.read()\nfile.close()\nprint(message)\nوسيأتي تفصيل كيفية التعامل مع الملفات في باب الملفات.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "href": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "title": "9  النص",
    "section": "الإشارة لجزء من النص",
    "text": "الإشارة لجزء من النص\nولكون النص تسلسلاً ثابتًا فإنه يقبل جميع عمليات التسلسل السابق ذكرها (انظر باب المجموعة المرتبة).\n\ns = 'Arabian'\n\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\n 0   1   2   3   4   5   6   7\n +---+---+---+---+---+---+---+\n | A | r | a | b | i | a | n |\n +---+---+---+---+---+---+---+\n-7  -6  -5  -4  -3  -2  -1\n\nجرب\n\ns[1:5]\ns[1:5:2]\ns[::2]\ns[::-1]\n\nلاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:\n\ns = ('A', 'r', 'a', 'b', 'i', 'a', 'n')\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\nلكن الفرق أن النص نوعٌ له إجراءات / عمليات خاصة تتعلق بالنصوص.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "href": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "title": "9  النص",
    "section": "النص ثابت لا يقبل التغير",
    "text": "النص ثابت لا يقبل التغير\nفالنص تسلسل يشبه الصف في كوْنه ثابتًا (أي لا يقبل تعديل عنصر أو إضافته أو حذفه). فلو حاولت تغيير موضعٍ s[i] في النص أو قطعة s[i:j] فإنك ستواجه خطأ:\n\ns = 'Arabian'\ns[0] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 s = 'Arabian'\n----&gt; 2 s[0] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nلكننا لتعديل النص في الواقع نعيِّنُ إلى نفس المتغير نصًّا جديدًا منه:\n\ns = 'Arabian'\ns = 'a' + s[1:]\nprint(s)\n\narabian\n\n\nلاحظ أننا أسندنا النص الجديد إلى المتغير s، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "href": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "title": "9  النص",
    "section": "العمليات الخاصة بالنصوص",
    "text": "العمليات الخاصة بالنصوص\n\nالاستبدال\nلاستبدال جزء من النص، نستخدم فعل .replace():\n\ns = 'Arabian'\ns = s.replace('ian', 'y')\nprint(s)\n\nAraby\n\n\n\n\nإزالة المسافات\nكما لدينا علميات .strip() لإزالة المسافات البيضاء من بداية ونهاية النص.\n\nassert '  Arabian  '.strip() == 'Arabian'\n\n\n\nالبحث والمطابقة\nوكذلك لدينا عمليات البحث:\n\nالتحقق من البدء والنهاية وما بينهما: .startswith(prefix) و .endswith(suffix) أو sub in string وهي أعم.\nلمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص .find()\n\n\ns = 'Arabian'\nassert s.startswith('A')\nassert not s.startswith('a')\nassert s.endswith('n')\nassert 'rabia' in s\nassert s.find('a') == 2\n\n\n\nالفصل والوصل\n\nفصل النص لقائمة بناءً على جزء فاصل: list.split(seperator)\nوصل عناصر القائمة في نص مفصول بجزء فاصل: seperator.join(list)\n\nأولاً: الفصل: مثاله قراءة سطر في ملف csv إذْ القيم مفصولة بعلامة الفاصلة ,:\n\ncsv = \"Adam,25,Riyadh\"\nassert csv.split(',') == ['Adam', '25', 'Riyadh']\n\nولقراءة الملف كاملاً نكرر:\n\nالقيم في السطر الواحد مفصولة بعلامة الفاصلة ,\nوالصفوف مفصولة بعلامة السطر الجديد \\n\n\nلذلك سنستعمل الاثنين هنا:\n\ncsv = \"\"\"name,age,city\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\"\"\"\n\ndata = []\nfor line in csv.split(sep='\\n'):\n  row = line.split(sep=',')\n  data.append(row)\nprint(data)\n\n[['name', 'age', 'city'], ['Adam', '25', 'Riyadh'], ['Belal', '30', 'Jeddah'], ['Camal', '35', 'Dammam']]\n\n\nثانيًا: الوَصل: مثاله أننا نحول القائمة إلى نص مفصول بعلامة الفاصلة , وذلك ليكون سطرًا في ملف csv:\n\ndata = ['Adam', '25', 'Riyadh']\nseperator = ','\ncsv = seperator.join(data)\nassert csv == 'Adam,25,Riyadh'\n\n\n\nعمليات إنجليزية\nوهنا عمليات خاصة بالنصوص الإنجليزية:\n\nupper() نسخة ذات حروف كبيرة.\nlower() نسخة ذات حروف صغيرة.\ncapitalize() نسخة ذات حرف أول كبير من كل كلمة.\ntitle() نسخة ذات حالة عنوان.\n\n\nname = 'Adam ibraheeM'\nprint(name.upper())\nprint(name.lower())\nprint(name.capitalize())\nprint(name.title())\n\nADAM IBRAHEEM\nadam ibraheem\nAdam ibraheem\nAdam Ibraheem\n\n\nوانظر مستندات النصوص لمعرفة كافة الإجراءات الممكنة على النصوص.\n\n\nتفسير الأرقام\nتفسير الأرقام المكتوبة نصًّا تكثر الحاجة إليه خصوصًا عند قراءة ملفات أو التعامل مع بيانات من المستخدم، إذ يكون الإدخال نصيًّا:\n\nint(x) لتحويل نص إلى عدد صحيح.\nfloat(x) لتحويل نص إلى عدد عشري.\n\nلاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:\n\nx = '20'\ny = '40'\nprint(x + y)\n\n2040\n\n\nالواجب تحويلهما إلى أعداد أولاًً:\n\nx2 = float(x)\ny2 = float(y)\nprint(x2 + y2)\n\n60.0",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "href": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "title": "9  النص",
    "section": "إخراج النص",
    "text": "إخراج النص\nنستعرض ثلاث طرق لدمج النصوص في بايثون:\n\nالأولى: تحويل الشيء إلى نص قبل دمجه مع النص، باستعمال str(x)\nالثانية: استعمال فراغات بالقوسين المعكوفين {} مع الإجراء .format() لاستبدالها.\nالثالثة: استعمال f-string بأن تضع الحرف f قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل الأقواس المعكوفة {}. وهي الطريقة التي نفضلها.\n\n\nname = \"John\"\nlvl = 300\n\ns1 = \"I am \" + name + \" and I want to reach level \" + str(lvl) # + operator\ns2 = \"I am {} and I want to reach level {}\".format(name, lvl)  # .format() method\ns3 = f\"I am {name} and I want to reach level {lvl}\"            # f-strings\nassert s1 == s2 == s3\nprint(s1)\n\nI am John and I want to reach level 300\n\n\nيقبل النص التكرار بعلامة *:\n\nprint('-' * 10)\nprint('*' * 10)\nprint('=' * 10)\n\n----------\n**********\n==========",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "href": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "title": "9  النص",
    "section": "المحاذاة والحشو",
    "text": "المحاذاة والحشو\n\nname = 'Adam'\nprint(name.ljust(15)) \nprint(name.center(15))\n\nAdam           \n      Adam     \n\n\nطريقة ممتعة لتزيين سلسلة نصية باستخدام الإجراء center:\n\nprint('*' * 20)\nprint('Adam'.center(20, \"*\"))\nprint('*' * 20)\n\n********************\n********Adam********\n********************",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "href": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "title": "9  النص",
    "section": "تنسيق الأرقام",
    "text": "تنسيق الأرقام\n\nمحاذاة الأرقام\n\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\n       100\n      1000\n     10000\n\n\nيمكننا أيضًا جعل كل من العدد n والتعبئة p متغيرات:\n\nn = 100\np = 5\nprint(f'{n:{p}}')\n\n  100\n\n\nبشكل افتراضي، يتم محاذاة الرقم إلى اليمين. يمكننا محاذاته إلى اليسار بإضافة &lt;. لاحظ الفرق بين التعبيرين أدناه:\n\nprint(f'{n:&gt;{p}}')\nprint(f'{n:&lt;{p}}')\n\n  100\n100  \n\n\n\n\nفاصل الآلاف\n\nbig_num = 10000\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n10000\n10,000\n\n\n\n\nالترميز العلمي\n\nsmall_num = 0.00001\nprint(f\"{small_num:.2e}\")\n\n1.00e-05\n\n\n\n\nالأعداد العشرية\n\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\nمثال: تنسيق الكم المالي\n\nprice_dollars = 2978.95\nprice_riyals = price_dollars * 3.75\nprint(f\"${price_dollars:,.2f} = {price_riyals:,.2f} SAR\")\n\n$2,978.95 = 11,171.06 SAR",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html",
    "href": "chapters/07_strings/a2_unicode.html",
    "title": "10  ترميز الحروف",
    "section": "",
    "text": "ترميز (Unicode)\nترميز الحروف هي عملية تعيين أرقام للأحرف الرسومية مما يسمح بتخزينها ونقلها وتحويلها باستخدام الحواسيب الرقمية.\nرموز ASCII تحتوي على 128 حرف للغة الإنجليزية وبعض علامات الترقيم. منها 95 فقط هي أحرف قابلة للطباعة أما البقية فتسمى أحرف تحكُّم (مثل حرف السطر الجديد \\n ، وحرف الرجوع لبداية السطر \\r).\nثم امتدت عن طريق رموز ANSII لتغطي أحرف إضافية (من 128 إلى 255) وهي الأحرف الاتينية للغات الأخرى.\nلنستكشف السلاسل عن طريق حزمة من المكتبة الأساسية string. الآتي الأحرف اللاتينية الكبيرة والصغيرة، وعلامات الترقيم:\nواليوم رموز Unicode تحتوي على أكثر من مليون حرف لتغطية لغات العالم كافة: اللاتينية، اليونانية، السيريلية، الأرمنية، العبرية، العربية، السريانية، الثانا، الديفاناغارية، البنغالية، الجورموخية، الأورية، التاميلية، التيلوغوية، الكانادية، المالايالامية، السنهالية، التايلاندية، اللاوية، التبتية، الميانمارية، الجورجية، الهانغول، الإثيوبية، الشيروكية، الرموز الكندية الأصلية، الخميرية، المنغولية، الهان (الأيدوغراف الياباني، الصيني، الكوري)، الهيراغانا، الكاتاكانا، واليي. المصدر. وما يزال أول 128 حرف منها متطابق مع رموز ASCII.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "href": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "title": "10  ترميز الحروف",
    "section": "",
    "text": "مثال\nماذا يحصل لو كتبنا حروف عربية ثم حاولنا حفظ الملف بترميز ASCII ولم نحفظه بترميز Unicode؟\n\n\n\nبرنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات\n\n\nالخطأ يقول: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "href": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "title": "10  ترميز الحروف",
    "section": "كيف يتم تمثيل النصوص في بايثون؟",
    "text": "كيف يتم تمثيل النصوص في بايثون؟\nتمثيل النصوص في بايثون يكون عن طريق النوع str؛ يُعرَّف بكتابة سلسلة من الأحرف لكن في الواقع تتحول إلى سلسلة من رموز Unicode (أي: أرقام). هذا يعني أنها قد تكون سلسلة رموز لاتينية أو عربية أو صينية أو غير ذلك مما تحويه رموز Unicode.\nالإجراء المبني ord() تقوم بتحويل الحرف إلى رقم الرمز. بينما chr() تعكس ذلك (من الرمز إلى الحرف).\nعلى النقيض من سي وجافا؛ لا يوجد نوع خاص بالحرف الواحد (char) في بايثون.\n\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nماذا عن الحروف العربية؟ أين تقع في أرقام ترميز Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nلمعرفة أرقام الحروف في نصٍّ ما؛ نستعمل التكرار هكذا:\n\ns = \"'Arabian'\"\ncodes = []\nfor c in s:\n    codes.append(ord(c))\nprint(codes)\n\n[39, 65, 114, 97, 98, 105, 97, 110, 39]\n\n\n\ns = 'السَّلَامُ عَلَيْكُمْ'\ncodes = []\nfor c in s:\n    codes.append(ord(c))\nprint(codes)\n\n[1575, 1604, 1587, 1614, 1617, 1604, 1614, 1575, 1605, 1615, 32, 1593, 1614, 1604, 1614, 1610, 1618, 1603, 1615, 1605, 1618]\n\n\nفهذه هي الحروف في الواقع، إلا أننا نتعامل مع شيء مجرَّد في لغات البرمجة العالية غالبًا ما يسمى str.\nراجع ويكيبيديا: النص العربي في Unicode لمزيد من التفاصيل.\n\nالأحرف البيضاء\nالأحرف في الأجهزة الرقمية على نوعين:\n\nأحرف طباعة: مثلاً: الأحرف اللاتينية والأرقام وعلامات الترقيم\nأحرف تحكم: مخفيَّة؛ والغرض منها التحكم بمعالج هذا النص\n\nلعرض الأحرف القابلة للطباعة في محارف آسكي (ASCII)، لدينا المتغير printable من مكتبة string:\n\nimport string\nstring.printable\n\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n\n\nكانت أحرف التحكُّم تستخدم لرن جرس الآلة الطابعة ، والتحكم بها ، لكن اليوم الذي يُستخدم منها غالبًا هو الأحرف البيضاء (Whitespace Characters) ويشمل ذلك الأحرف التالية:\n\nspace: \\s ويمثل المسافة التي بين الكلمات\ntab: \\t ويمثل المسافة التي بين أعمدة الجداول\nlinefeed: \\n تعليمة سطر جديد\nreturn: \\r تعليمة العودة لبداية السطر الجديد\nformfeed: \\f تعليمة الصفحة الجديدة\nvertical tab: \\v تعليمة العمود الجديد\nbackspace: \\b تعليمة عودة المؤشر بمقدار حرف واحد للكتابة فوق الحرف السابق\n\nأما الثلاثة الأخيرة فقد كانت تستخدم فيما مضى، لكن اليوم المستخدم هو الأربعة الأولى فقط. ويجدر بالذكر أن ملفات نصوص نظام ويندوز تستعمل \\r\\n للانتقال لسطر جديد بينما تستعمل الأنظمة الأخرى \\n فقط.\nتذكر أن بايثون تعتمد على space و tab للمسافة البادئة للسطر (indentation)، لتحديد نطاقات القطع البرمجية بحسب المحاذاة العمودية.\n\nimport string\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\nيهمنا هنا الأحرف البيضاء لأنها تظهر في النصوص وقد تكون مزعجة عند معالجتها. لنلقي نظرة على ثلاثة من الأحرف البيضاء: المسافة (space)، التبويب (tab)، وتعليمة السطر الجديد (linefeed).\n\n# Tab character: \"\\t\"\nprint('A\\tB')\n\nA   B\n\n\n\n# Space character: \" \"\nprint('   A            B   ')\n\n   A            B   \n\n\n\n# Newline character: '\\n'\nprint('A\\nB')\n\nA\nB\n\n\nلاحظ أن طول السلسلة النصية هو عدد الأحرف في السلسلة، سواء كانت قابلة للطباعة (printable) أو أحرف بيضاء (whitespace).\n\nassert len('A B') == 3\nassert len('A\\tB') == 3\nassert len('A\\nB') == 3\n\n\n\nالأطراف الزائدة\nلاحظ أن هذا الإجراء سيزيل الأحرف البيضاء من بداية ونهاية السلسلة النصية، ولكن ليس الأحرف البيضاء في منتصف السلسلة\nقبل:\n\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\nبعد:\n\nprint(text.strip())\n\nhello    world\n\n\n\n\nتجزئة النص\nانظر: Splitlines\n\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\nإذا تركنا القطعة البرمجية كما هي في السطر من غير print فإن ذلك يعرض السلسلة النصية كما هي (بما في ذلك أحرف المسافات البيضاء)\n\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\nأما إذا وضعنا print فإنه يطبع الأحرف المرئية ، وينسِّقُ المظهر بناءً على أحرف التحكُّم المخفية:\n\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\nإذا لم نحدد محدد الفاصل فإن الفاصل الافتراضي هو المسافة.\n\nprint(\"Hello, world\".split())\n\n['Hello,', 'world']\n\n\nهنا نحدد الفاصل أنه الحرف \"l\":\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\nلإزالة الأحرف البيضاء جميعها؛ نستعمل التكرار هكذا:\n\ntext = '\\t hello    world \\n\\n\\n'\nsp = text.split()\nprint('split:', sp)\nclean = ' '.join(sp)\nprint('clean:', clean)\n\nsplit: ['hello', 'world']\nclean: hello world\n\n\nالفصل في الداخل ينتج قائمة من النصوص، بعضها فارغ لوجود الأحرف البيضاء المتتالية، فلا تتضمن في القائمة الناتجة.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#الطباعة",
    "href": "chapters/07_strings/a2_unicode.html#الطباعة",
    "title": "10  ترميز الحروف",
    "section": "الطباعة",
    "text": "الطباعة\n\nحروف التحكم بآلة الطباعة\nيسمّى الحرف \\r بالعودة للبداية لأنه يعني فعل يقوم بإرجاع المؤشر إلى بداية السطر.\nكانت آلة الطباعة قديمًا يتحرك رأس الطباعة فيها بعد طباعة كل حرف. ثم عندما ينتهي السطر، يجب على الشخص أن يقوم بعمليتين:\n\nالضغط على المفتاح الذي يرفع الورقة بمقدار سطر (ويرمز له بالحرف \\r)\nالضغط على المفتاح الذي يرجع رأس الطباعة لبداية السطر (ويرمز له بالحرف \\n)\n\nوهما مستخدمان اليوم فيما يُعرض على الشاشة.\nففعل print في الحقيقة يضع سطرًا جديدًا (حرف \\n) في الوضع الافتراضي. فإن أردنا ألا يضعه، فنحدد العامل end الذي فيه على النحو التالي:\n\nprint('Hello', end='')\nprint('World', end='')\n\nHelloWorld\n\n\nلاحظ أننا جعلنا (end='') أي: لا نريده أن يضع حرفًا بعد طباعة النص. ولذلك ظهرت الكلمتان في نفس السطر.\nولو أردت أن تعيد الكتابة على نفس السطر، يمكنك أن تضع الحرف (\\r) الذي يفعل رأس الطباعة بالرجوع لبداية السطر:\n\nprint('123', end='\\r')\nprint('45')\n\n12345\n\n\nلاحظ أن النتيجة هي طباعة الحرفين 45 فوق الحرفين 12 مع بقاء الحرف الأخير 3 في الأخير. وذلك لرجوع رأس الطباعة.\nتستعمل هذه اللطيفة في تحديث العداد حتى يظهر على الشاشة وكأنه يزيد شيئًا فشيئًا. وذلك على النحو التالي (لاحظ أننا نستعمل time.sleep(t) حتى نمثِّل وجود عمليَّة تأخذ وقتًا طويلاً فحسب):\nimport time\n\nfor x in range(10 + 1):\n    time.sleep(0.20)\n    print(f'[{x}/10] ' + '===' * x + '&gt;', end='\\r')",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a1_errors.html",
    "href": "chapters/13_errors/a1_errors.html",
    "title": "11  الخطأ",
    "section": "",
    "text": "الخطأ النحوي\nينقسم الخطأ لثلاثة أنواع:\nنتحدث في هذا الفصل عن الخطأ النحوي والمنطقي، ونستكمل الحديث عن الخطأ العملي (الاستثناء) في الفصل التالي.\nالأخطاء النحوية تتعلق بتركيب اللغة لا أكثر ولا أقل. إليك ثلاثة أمثلة.",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a1_errors.html#الخطأ-النحوي",
    "href": "chapters/13_errors/a1_errors.html#الخطأ-النحوي",
    "title": "11  الخطأ",
    "section": "",
    "text": "1. فقدان النقطتين :\nلاحظ عدم النقطيتن بعد الشرط (if x &gt; 5).\n\nif x &gt; 5\n    print(\"x\")\n\n\n  Cell In[1], line 1\n    if x &gt; 5\n            ^\nSyntaxError: expected ':'\n\n\n\n\n\n\n2. علامات اقتباس غير متوازنة\nلاحظ عدم علامة الاقتباس (\") للنص.\n\nprint(\"x\n\n\n  Cell In[2], line 1\n    print(\"x\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\n3. اسم غير صالح\nلاحظ أن بايثون تسمح بالشرطة السفلية (_) لكن هنا ستعملنا الشرطة (-) التي يظنها علامة طرح.\n\nmy-variable = 10\n\n\n  Cell In[3], line 1\n    my-variable = 10\n    ^\nSyntaxError: cannot assign to expression here. Maybe you meant '==' instead of '='?\n\n\n\n\n\n\nأخطاء المحاذاة\nمن الأخطاء النحوية الشائعة في بايثون: خطأ المحاذاة (Indentation Error).\nوذلك أن بايثون تقبل نوعين من المسافات البادئة للسطر:\n\nإما بحرف المسافة التي بين الكلمات \\s\nأو بحرف المسافة بين الأعمدة \\t\n\nويحصل الخلط بينهما من غير قصد عند النسخ واللصق من هنا وهناك. وهذا مما لا تقبله بايثون. لذلك تضبط محررات النصوص عملية النسخ واللصق فتوحِّد المسافة البادئة بأحدهما، حتى لا نهتم لذلك نحن. فهي حروف خفيَّة.\nوإليك بعض الأمثلة لما يحصل من أخطاء في المحاذاة:\n\nعدم وجود مسافة بادئة، عندما تكون متوقعة:\n\n\nif True:\nprint(\"x\")\n\n\n  Cell In[4], line 2\n    print(\"x\")\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\n\nعدم تطابق المحاذاة:\n\n\nif True:\n    print(\"x\")\n     print('y')\n\n\n  Cell In[5], line 3\n    print('y')\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\nتجويد العبارة\nمن تجويد العبارة تسمية المتغيرات بما يدل على وظيفتها، مثل:\n\nrate = 50\nhours_per_day = 6\ndays = 5\npay = rate * hours_per_day * days\nprint(pay)\n\n1500\n\n\nوإن كان ليس من الخطأ النحوي كتابتها بطريقة مختلفة وبأسماء غير معبِّرة، إلا أنه فعلٌ غير مستحسن:\n\nr, hpd, d = 50, 6, 5\np = r * hpd * d\nprint(p)\n\n1500\n\n\nوفي هذا نصائح كثيرة، يراجع فيها دليل أسلوب الكتابة في بايثون.",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a1_errors.html#الخطأ-المنطقي",
    "href": "chapters/13_errors/a1_errors.html#الخطأ-المنطقي",
    "title": "11  الخطأ",
    "section": "الخطأ المنطقي",
    "text": "الخطأ المنطقي\nوهي التي نقصدها حين نقول: بَق (Bug) بمعنى: مشكلة في البرنامج. ويسمى البرنامج الذي يساعد في إصلاح المشاكل البرمجية: المدقق (Debugger). وتسمى وعملية البحث عنها وإصلاحها: التدقيق (Debugging).\nالأخطاء المنطقية صامتة. إذ لا يكتشفها المترجم، وتتسبب في تصرف البرنامج بشكل غير صحيح. الأخطاء المنطقية هي الأصعب في التتبع والإصلاح لأنها ليست واضحة. يمكن أن تكون ناجمة عن:\n\nافتراضات غير صحيحة\nخطوات غير مؤديَّة للمقصود\n\nوإليك بعض الأمثلة ..\n\n1. استعمال الإجراء الخاطئ\nهنا يريد المبرمج استعمال دالَّة التربيع (Square) فظنَّها math.sqrt لكن هذه (Square Root) أي: الجذر التربيعي. والصحيح أن يختار: math.pow(4, 2) لرفع 4 للقوة 2.\n\nimport math\n\nsquare = math.sqrt(4)\n\n\n\n2. استعمال العامل الخاطئ\nهنا تمَّت المقارنة بين نوعين مختلفين أصلاً: int و str لكنَّ المبرمج لم يستوعِب ذلك، فحصل الخطأ وهو لا يدري لماذا x لا تساوي y عندما يكون كلاهما 16؟ وهذا قد يبدو لك واضحًا وذلك لأننا عزلنا المثال عن غيره من التفاصيل فظهر جليًّا.\n\nx = 16\ny = \"16\"\nif (x == y):\n    print('equal')\n\n\n\n3. مستوى محاذاة خاطئ\nهنا كانت النية تقتضي أن تكون print(j) داخل الحلقة الداخلية. لكن إن كانت النيَّة كما كُتب فليس بخطأ طبعًا.\n\nfor i in range(2):\n    for j in range(3):\n        print(i)  \n    print(j)\n\n0\n0\n0\n2\n1\n1\n1\n2\n\n\n\n\n4. خطأ الحافَّة\nخطأ الحافَّة (Off-by-one error)، يكاد يكون أشهر الأخطاء في البرمجة.\nنشرحه بمثال: النية هنا هي طباعة الأرقام بالعكس من الرقم الأعلى (5) إلى (0) بما في ذلك (0)، ولكن الحلقة تتوقف عند (1). وذلك أن آلية عمل النطاق (range) عدم شمول النهاية.\n\nfor i in range(5, 0, -1):\n    print(i)\n\n5\n4\n3\n2\n1",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a1_errors.html#كشف-الأخطاء-المنطقية",
    "href": "chapters/13_errors/a1_errors.html#كشف-الأخطاء-المنطقية",
    "title": "11  الخطأ",
    "section": "كشف الأخطاء المنطقية",
    "text": "كشف الأخطاء المنطقية\nلكونها جملاً صحيحة في ذاتها؛ لا يستطيع البرنامج كشف هذه الأخطاء لوحده. بل يجب على من يُدركُ حقيقة المطلوب من البرنامج أن يتكفل بذلك. وهنا تكون الحاجة ماسَّة لجمل التوكيد: assert وقد رأيناها كثيرًا.\nوالتدقيق؛ إذْ أفضل طريقة لحل الأخطاء المنطقية هي تنفيذ القطعة البرمجية والنظر في الناتج، وتتبع المنطق مرة أخرى إلى النص البرمجي سطرًا بسطر. يمكنك استخدام عبارات الطباعة print لتصحيح الأخطاء وفهم تدفق البرنامج. وقد يكون الأفضل من ذلك استعمال المدقق (Debugger).\nومراجعة الأقران: بحيث يطلع على النص البرمجي شخص آخر، فإنه قد يرى منه ما تعذر عليك رؤيته. وقد يتم تنظيمه بين أعضاء الفريق الواحد بأحد برمجيات التعاون مثل: GitHub وGitLab وBitbucket وغيرها. لكن ليس شرطًا أن يكون بطريقة منظَّمة حتى تستفيد منه.",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a1_errors.html#المصطلحات",
    "href": "chapters/13_errors/a1_errors.html#المصطلحات",
    "title": "11  الخطأ",
    "section": "المصطلحات",
    "text": "المصطلحات\n\n\n\nالعربية\nالإنجليزية\n\n\n\n\nالخطأ النحوي\nSyntactic Error\n\n\nالخطأ المنطقي\nLogical Error\n\n\nالخطأ العملي\nRuntime Error\n\n\nالاستثناء\nException\n\n\nأخطاء المحاذاة\nIndentation Error\n\n\nأسلوب الكتابة\nCode Style\n\n\nخطأ الحافَّة\nOff-by-one Error\n\n\nالمدقق\nDebugger\n\n\nالتدقيق\nDebugging\n\n\nجمل التوكيد\nAssert Statements\n\n\nمراجعة الأقران\nPeer Review\n\n\nبرمجيات التعاون\nCollaboration Tools",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a2_exceptions.html",
    "href": "chapters/13_errors/a2_exceptions.html",
    "title": "12  الاستثناء",
    "section": "",
    "text": "تغير سير الأوامر عند الخطأ\nالاستثناء (Exception) هو خروج البرنامج عن المسار المثالي. ويسمى أيضًا الخطأ العملي (Runtime Error). مثل:\nفكل هذه تعتبر مسارات غير مثالية لكنها تحصل في ظروف واقعيَّة. فيجب كتابة قطع في البرنامج تتعامل معها. ولذا فإن بعض الممارسين لا يفضلون استعمال كلمة استثناء لأنَّ مثل ذلك يحصل كثيرًا فهو ليس خارجًا عن العادة؛ بل من الطبيعي أن يحصل ذلك في الواقع!\nتنفذ التعليمات في لغة البرمجة الأمرية (Imperative) كبايثون بحسب ترتيبها (من الأعلى إلى الأسفل). لكن عند حدوث خطأ، يتغيَّر سيْر الأوامر باستعمال جملة try-except. وشكل جملة التعامل مع الخطأ على هذا النحو:",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a2_exceptions.html#تغير-سير-الأوامر-عند-الخطأ",
    "href": "chapters/13_errors/a2_exceptions.html#تغير-سير-الأوامر-عند-الخطأ",
    "title": "12  الاستثناء",
    "section": "",
    "text": "المحاولة: try تتضمن الجملة التي نتوقع حدوث خطأٍ فيها\nالمطابقة: except Exception هي مثل if تنفذ ما تتضمنه إن كان الخطأ من نوع Excpetion\nعدم المطابقة: else تعمل عند عدم الخطأ\nالمتابعة: finally وهي جُملة تعمل سواء وقع الخطأ أم لم يقع؛ لكنَّ بايثون تضمن عملها إن حصل خطأ أثناء التعامل مع الخطأ\n\nprint('enter')\ntry:\n    # حاول تشغيل هذه القطعة\nexcept Exception as e:\n    # شغل هذه القطعة عند الخطأ\nelse:\n    # وإن لم يحصل فهذه القعطة\nfinally:\n    # وهذه تشتغل سواء حصل الخطأ أم لا\n    # وفائدتها أنها تعمل قبل رجوع الخطأ لموضع النداء\nprint('exit')",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a2_exceptions.html#أنواع-الاستثناء",
    "href": "chapters/13_errors/a2_exceptions.html#أنواع-الاستثناء",
    "title": "12  الاستثناء",
    "section": "أنواع الاستثناء",
    "text": "أنواع الاستثناء\nتم تعريف أنواع من الخطأ في بايثون متبوعة بكلمة Error، وذلك باعتبار حالات خطأ نمطية ومتكررة:\n\nSyntaxError\nالسبب: خطأ نحوي في صياغة اللغة:\n\nكلمة غير صحيحة: خطأ في الإملاء\nفي وضع كلمة صحيحة في غير سياقها\nمحاذاة غير متسقة (IndentationError)\n\nالحل: اقرأ رسالة الخطأ وستدلُّك على السبب والموضع الذي حصل فيه الخطأ.\n\n\nTypeError\nالسبب:\n\nطلب فعل بعدد أكثر أو أقل من العوامل الواجبة (مثل: len(1, 2))\nطلب فعل بعوامل لا تطابق النوع المحدد في تعريفه (مثل: math.sqrt('nine') أو 5 + '5')\n\nالحل: الوقاية بـ type() أو isinstance() أو بالتأكد من تحويل النوع مسبقًا.\na = 5\nb = input('Enter a number: ')\nresult = a + int(b)\n\n\nValueError\nالسبب: أن يكون النوع صحيحًا (فلا يحصُل TypeError) لكن القيمة غير مقبولة.\n\nمثلاً: طلب فعل بقيمة نوعها عددي لكنَّها سالبة وهو لا يقبل إلا الموجبة. نحو: math.sqrt(-16) فالجذر التربيعي لا يقبل السالب.\n\nالحل: الوقاية بفحص مدى القيمة ، نحو: if x &gt;=0: math.sqrt(x)\n\n\nIndexError & KeyError\nالسبب: الرقم الذي استعمل في عملية الإشارة [index]list (قائمة) أو dict[key] (قاموس) يشير لما هو خارج المجموعة.\nنحو:\n\nmy_list = [10, 20, 30]\nidx = 3\nvalue = my_list[idx]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[1], line 3\n      1 my_list = [10, 20, 30]\n      2 idx = 3\n----&gt; 3 value = my_list[idx]\n\nIndexError: list index out of range\n\n\n\nالحل بالوقاية:\nif idx &lt; len(my_list):\n    value = my_list[idx]\nelse:\n    # do something else\nأو بالعلاج:\ntry:\n    value = my_list[idx]\nexcept IndexError:\n    # do something else\nوكذلك في القاموس، نحو:\n\nmy_dict = {'A': 10, 'B': 20, 'C': 30}\nkey = 'Z'\nvalue = my_dict[key]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[2], line 3\n      1 my_dict = {'A': 10, 'B': 20, 'C': 30}\n      2 key = 'Z'\n----&gt; 3 value = my_dict[key]\n\nKeyError: 'Z'\n\n\n\nالحل بالوقاية\nif key in my_dict:\n    value = my_dict[key]\nelse:\n    # do something else\nأو هكذا (تعيين قيمة ابتدائية):\nvalue = my_dict.get(key, 0)\nأو بالعلاج:\ntry:\n    value = my_dict[key]\nexcept KeyError:\n    # do something else\n\n\nAttributeError & NameError\nالسبب: استعمال متغير أو فعل قبل تعريفه.\n\nفإن أسنِد إلى كائن؛ وقع AttributeError\nوإلا وقع NameError\n\n\na = 10\na + X\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 2\n      1 a = 10\n----&gt; 2 a + X\n\nNameError: name 'X' is not defined\n\n\n\n\nsome_function(55)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 some_function(55)\n\nNameError: name 'some_function' is not defined\n\n\n\n\nclass A:\n    pass\n\na = A()\na.x\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 5\n      2     pass\n      4 a = A()\n----&gt; 5 a.x\n\nAttributeError: 'A' object has no attribute 'x'\n\n\n\n\na.do_something()\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 a.do_something()\n\nAttributeError: 'A' object has no attribute 'do_something'\n\n\n\n\n\nModuleNotFoundError\nالسبب: فشل جُملة الاستيراد import numpy\nالحل:\n\nتأكد من صحة الإملاء\nتأكد من تثبيت الوحدة في البيئة التي يعمل فيها البرنامج: pip install numpy",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a2_exceptions.html#تعريف-أخطاء-جديدة",
    "href": "chapters/13_errors/a2_exceptions.html#تعريف-أخطاء-جديدة",
    "title": "12  الاستثناء",
    "section": "تعريف أخطاء جديدة",
    "text": "تعريف أخطاء جديدة\nتعريف الخطأ يكون بتعريف نوع جديد يرث من النوع Exception، وهذا ما يحققه السطر الأول بين القوسين. وتستطيع أن ترث ممن يرث، فتتكون لديك فروع من هذا الخطأ:\n\nclass ParentError(Exception):\n    pass\n\nclass XError(ParentError):\n    pass\n\nclass YError(ParentError):\n    pass\n\n\n\n\n\n\nflowchart TD\n    A[ParentError] --&gt; B[XError]\n    A --&gt; C[YError]\n\n\n\n\n\n\nوهذا الإجراء يحصل فيه الخطأ بطريقة مصطنعة لكنها توضح ما نريد، وهو الخطأ الفرعي XError الذي يرث من الخطأ الأصلي ParentError:\n\ndef do_something():\n    raise XError('Something went wrong')\n\nثم حين نفحص، تسطيع أن نطابق بالأصل أو الفرع:\n\ntry:\n    do_something()\nexcept ParentError as e:\n    print(\"caught you:\", e)\n\ncaught you: Something went wrong",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/13_errors/a2_exceptions.html#المصطلحات",
    "href": "chapters/13_errors/a2_exceptions.html#المصطلحات",
    "title": "12  الاستثناء",
    "section": "المصطلحات",
    "text": "المصطلحات\n\n\n\nالعربية\nالإنجليزية\n\n\n\n\nالاستثناء\nException\n\n\nخطأ\nError\n\n\nظرف التنفيذ\nExecution Frame\n\n\nالوقاية\nIf-else\n\n\nالعلاج\nTry-except\n\n\nخطأ نحوي\nSyntax Error\n\n\nخطأ في المحاذاة\nIndentation Error\n\n\nخطأ في النوع\nType Error\n\n\nخطأ في القيمة\nValue Error\n\n\nخطأ في المؤشر الرقمي\nIndex Error\n\n\nخطأ في المؤشر المرقوم\nKey Error\n\n\nخطأ في الخاصية\nAttribute Error\n\n\nخطأ في الاسم\nName Error\n\n\nخطأ في استيراد الوحدة\nModule Not Found Error\n\n\nخطأ القسمة على صفر\nZero Division Error\n\n\nرفع الخطأ\nRaise Exception\n\n\nإلتقاط الخطأ\nCatch Exception\n\n\nتدفق الخطأ\nError Flow",
    "crumbs": [
      "باب الخطأ والاستثناء",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html",
    "href": "chapters/08_procedural/a1_procedural.html",
    "title": "13  البرمجة الإجرائية",
    "section": "",
    "text": "تعريف الإجراء\nرأينا في جميع ما سبق كيف أن بايثون لغة أمريَّة (Imperative)؛ أي أنها مجموعة متسلسلة من التعليمات البرمجية التي يتبعها المفسِّر حَسَبَ ورودها (من الأعلى إلى الأسفل).\nوفي هذا الفصل نعرف أن بايثون لغة إجرائية (Procedural)؛ وهذا يعني تركيب البرنامج من إجراءات يستدعي كل واحد منها مجموعة أخرى من الإجراءات. فقد يستدعي الإجراء الأول إجرائين، وقد يستدعي كل منهما إجرائين كذلك، …إلخ. حتى تعود النتيجة إلى الإجراء الأوَّل الذي يمثِّل مدخل البرنامج: main. ويتشكل لدينا التسلسل الهرمي كما هو موضح:\nفأما الإجراء (Procedure) فهو: قطعة نص برمجي مخزَّنة تُستدعى باسمها بعوامل متغيرة. ويسمى الدالة (Function) أو الروتين (Routine) أو البرنامج الفرعي (Sub-Program). ونقول استدعي الإجراء (Call) أو نفذه (Execute). وتسمى مكان القطعة التي قامت بالاستدعاء: موقع الاستدعاء (Call-site).\nأما القطعة الأخيرة: if __name__ == \"__main__\" فإن المتغير __name__ هو متغير مخصوص في لغة بايثون تعطيه القيمة __main__ إذا تم تشغيل البرنامج عن طريق هذا الملف، بخلاف ما لو تم استيراد هذا الملف. وسيأتي بيان ذلك في الفصل التالي، عندما نشرح الحزم والوحدات.\nفأي إجراء يتم تعريفه؛ كالمتغير الذي يتم تعريفه: هو نص برمجي محفوظ ينتظر الاستدعاء حتى يحضر في ذاكرة البرنامج في ظرف تنفيذي ويتم تشغيله بعوامل معيَّنة. لذا فإننا إن لم نشتغل الإجراء الأوَّل main فإن البرنامج وإن كان يحفظ هذه الإجراءات إلا أنها تحتاج إلى الاستدعاء لتعمل.\nيعرَّف الإجراء بـ def ويتكون من قسمين:\nالأول: الحد (Function Signature). وهو ثلاثة أجزاء:\nالثاني: الجسد (Body). وهو القطعة البرمجية التي جُعِلَ اسمه عنوانًا لها. وقد يتضمن الجسد جملة رجوع (Return Statement) للخروج بنتيجة\nتأمل المثال التالي:\ndef add(x, y):\n    result = x + y\n    return result",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#تعريف-الإجراء",
    "href": "chapters/08_procedural/a1_procedural.html#تعريف-الإجراء",
    "title": "13  البرمجة الإجرائية",
    "section": "",
    "text": "الاسم (Name): الذي يُطلَبُ به\nالعوامل (Parameters): وهي متغيرات تؤثر (تعمل) في النتيجة\nنوع العائد (Return Type): نوع القيمة التي يرجع بها الإجراء نتيجة عمله\n\n\n\n\n\nالحد: def add(x, y)\n\nالاسم: add\nالعوامل: x, y ونفترض أنهما من النوع العددي Number\nالعائد: Number (نوع النتيجة)\n\nالجسد:\n\nresult = x + y هنا نرى كيف أن العوامل أُعمِلَت في الإجراء\nreturn result تسمى جملة الرجوع وهي التي؛ ترجع بالنتيجة إلى الموضع الذي طلب الإجراء.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#التصريح-بالأنواع",
    "href": "chapters/08_procedural/a1_procedural.html#التصريح-بالأنواع",
    "title": "13  البرمجة الإجرائية",
    "section": "التصريح بالأنواع",
    "text": "التصريح بالأنواع\nتسمح بايثون بعدم التصريح بأنواع المتغيرات إلا أنه يجوز، وذلك على النحو التالي:\n\nfrom numbers import Number\n\ndef add(x: Number, y: Number) -&gt; Number:\n    result = x + y\n    return result\n\n\nوبهذا نعرف أن التصريح بنوع المتغيِّر يكون بإضافة نقطتين رأسيتين (:) ثم النوع Number بعد كل عامل.\nوبعد السهم لنوع الناتج من الإجراء (-&gt;)\n\nومن الأنواع المبنيَّة (Built-in Types) في بايثون:\n\nNumber وهو النوع الذي ترجع إليه جميع أنواع الأعداد\nint الأعداد الصحيحة، نحو: 10\nfloat الأعداد العشرية، نحو: 10.5\nstr وهي نوع النص، نحو: \"Salam\"\nlist قائمة وإن شئت تحديد نوع العنصر الواحد فيها؛ فإنك تضعه بين القوسين المربعين، نحو:\n\nlist[int]\nlist[float]\nlist[str]",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#ظرف-التنفيذ",
    "href": "chapters/08_procedural/a1_procedural.html#ظرف-التنفيذ",
    "title": "13  البرمجة الإجرائية",
    "section": "ظرف التنفيذ",
    "text": "ظرف التنفيذ\nتأمل الإجراء التالي:\n\ndef calculate_grade(score):\n    if score &gt;= 90:\n        return \"A\"\n    elif score &gt;= 80:\n        return \"B\"\n    elif score &gt;= 70:\n        return \"C\"\n    elif score &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\n\nوعند طلب التنفيذ نعين العوامل. فينتج لنا بطلب calculate_grade(95) نسخة معيَّنة من تفاصيل الإجراء، نسمّيها ظرف التنفيذ (Execution Frame) ؛ يكون فيه المتغير score=95 تكون هذه النسخة حاضرة في ذاكرة البرنامج وقت تنفيذ الإجراء:\nif 95 &gt;= 90:\n    return \"A\"\nelif 95 &gt;= 80:\n    return \"B\"\nelif 95 &gt;= 70:\n    return \"C\"\nelif 95 &gt;= 60:\n    return \"D\"\nelse:\n    return \"F\"\nوبطلب تنفيذ calculate_grade(80) يكون الظرف هكذ:\nif 80 &gt;= 90:\n    return \"A\"\nelif 80 &gt;= 80:\n    return \"B\"\nelif 80 &gt;= 70:\n    return \"C\"\nelif 80 &gt;= 60:\n    return \"D\"\nelse:\n    return \"F\"\nلاحظ أن نتيجة السطرين بحسب الظرفين المختلفين:\n\nprint(calculate_grade(95))\nprint(calculate_grade(80))\n\nA\nB",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#تمرير-العوامل-بالاسم",
    "href": "chapters/08_procedural/a1_procedural.html#تمرير-العوامل-بالاسم",
    "title": "13  البرمجة الإجرائية",
    "section": "تمرير العوامل بالاسم",
    "text": "تمرير العوامل بالاسم\nقد تكون العوامل كثيرة في الإجراء على النحو التالي:\n\ndef weather_condition(temperature, humidity, wind_speed):\n    if temperature &gt;= 30 and humidity &gt;= 60 and wind_speed &gt;= 10:\n        return \"Rainy\"\n    elif temperature &gt;= 20 and humidity &gt;= 50 and wind_speed &gt;= 5:\n        return \"Cloudy\"\n    elif temperature &gt;= 10 and humidity &gt;= 30 and wind_speed &gt;= 0:\n        return \"Sunny\"\n    return \"Normal\"\n\nويكون طلبها بالطريقتين كما تقدَّم، بالموضع أو بالاسم. ولاحظ أن التمرير بالاسم يجوز فيه تبديل الترتيب، وأما القيمة التي تمرر بالموضع فلا بد أن تكون في الموضع.\n\ncond = weather_condition(30, wind_speed=10, humidity=60)\n\nif cond == \"Rainy\":\n    print(\"Don't forget your umbrella!\")\n\nDon't forget your umbrella!",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#العوامل-الجائزة",
    "href": "chapters/08_procedural/a1_procedural.html#العوامل-الجائزة",
    "title": "13  البرمجة الإجرائية",
    "section": "العوامل الجائزة",
    "text": "العوامل الجائزة\nالأصل في العوامل المعرَّفة الوجوب؛. فلو أهملت أحدها فإنك ستواجه بالخطأ:\n\ndef weather_condition(temperature, humidity, wind_speed):\n    pass\n\nweather_condition(30)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[8], line 4\n      1 def weather_condition(temperature, humidity, wind_speed):\n      2     pass\n----&gt; 4 weather_condition(30)\n\nTypeError: weather_condition() missing 2 required positional arguments: 'humidity' and 'wind_speed'\n\n\n\nتقول رسالة الخطأ (السطر الأخير) أن الإجراء يفتقد عاملين موضعيين إلزاميين، وهما: humidity و wind_speed.\nفلو أردنا أن يكون عمل الإجراء بحسب أحد العوامل بالتعيين، على نحو:\n\nلو عينت السلزيوس فالتحويل لفهرنهايت: convert_temperature(celsius=32)\nلو عينت الفهرنهايت فالتحويل لسلزيوس: convert_temperature(fahrenheit=89.6)\n\nوإليك معادلة التحويل بين نوعيْ درجة الحرارة:\n\\[\nF = \\frac{9}{5} C + 32\n\\]\nفأي عامل نعرفه بقيمة ابتدائية فإن بايثون تعتبره اختياريًّا، ولو بالقيمة العدميَّة None. فنعرِّفُ العوامل بقيَم عدميَّة، ونفحص وجودها بالشرط is not None لنُعمِلَها أو نهملها:\n\ndef convert_temperature(celsius = None, fahrenheit = None):\n    if celsius is not None:\n        fahrenheit = (9 / 5) * celsius + 32\n        return fahrenheit\n    elif fahrenheit is not None:\n        celsius = (fahrenheit - 32) * (5 / 9)\n        return celsius\n\nنتأكد:\n\nassert convert_temperature(celsius=32) == 89.6\nassert convert_temperature(fahrenheit=89.6) == 32",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#نطاق-التسمية",
    "href": "chapters/08_procedural/a1_procedural.html#نطاق-التسمية",
    "title": "13  البرمجة الإجرائية",
    "section": "نطاق التسمية",
    "text": "نطاق التسمية\nومن خصائصها أن المتغيرات في الداخل لا تظهر للخارج.\n\ndef calculate_bmi(weight: float, height: float) -&gt; float:\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\n\nفنتوقع وقوع خطأ هنا لأن bmi غير معرفة إلا في نطاق الإجراء:\n\nprint(bmi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 print(bmi)\n\nNameError: name 'bmi' is not defined\n\n\n\nتقول رسالة الخطأ (السطر الأخير) أن المتغير bmi غير معرَّف. وهذا منطقي لأن النطاق الخارجي لا يعلم ما تكنه النطاقات الداخلية الخاصة بالإجراءات. وهو أمر مطلوب جدًّا ومرغوب في البرمجة. وذلك يعني أننا لن نتعب كثيرًا في اختيار الأسماء داخل كل إجراء، مخافة التعارض.\n\nعوامل غير مصرح بها\nوعلى العكس فإن المعرَّفات الخارجة معروفة في الداخل؛ وذلك يعني أنها يمكن أن تعمل في الإجراء بشكل غير مباشر. أي أنها عوامل غير مصرَّح بها (هو: max_length في هذا المثال):\n\nmax_length = 8\n\ndef check_password_strength(password: str) -&gt; str:\n    if len(password) &gt; max_length:\n        return \"strong\"\n    elif len(password) &gt; max_length // 2:\n        return \"medium\"\n    return \"weak\"\n\n\n\n\nمستويات نطاق التسمية\n\n\nنصيحة: اجعل الاستعمال تاليًا لأخص نطاق تسلم. فهو كاستعمال الضمائر في اللغة: لا نحب أن تبعُد عما أبدلت عنه؛ إذ ذلك مظنَّة الإبهام. لكن قد يكون من المعرَّفات ما هو ثابت ومعمولٌ به في كل مكان. فهو أشبه بالإعدادات أو الضبط للبرنامج كله. ومثل ذلك أمره سهل.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#ثمرة-الإجراء",
    "href": "chapters/08_procedural/a1_procedural.html#ثمرة-الإجراء",
    "title": "13  البرمجة الإجرائية",
    "section": "ثمرة الإجراء",
    "text": "ثمرة الإجراء\nتُخرج الإجراءات نتائج معالجتها بإحدى طريقتين:\nالأولى: الرجوع: حيث ترجِع النتيجة بجملة return لموضع طلب الإجراء، وغالبًا ما يتم تعيينه لمتغير، نحو: y = sqrt(x).\nالثانية: المفعول: نحو: list.sort(xs) حيث يعدِّل الإجراء العامل الذي تم تمريره إليه؛ ولذلك نسميه مفعولا به.\nوذلك مثل print() فإن أحد عواملها غير مذكور (وهو المفعول)، وهو: file=sys.stdout ولأجله تكتب النتيجة على الشاشة.\n\nالإجراء الخاوي\nوالإجراء دائمًا يرجع بنهاية آخر جملة فيه، لكن الذي لا يصرَّحُ فيه بكلمة الرجوع return تُقدَّر له القيمة العدمية: None ويسمى الإجراء حنيها خاويًا (void).\nفائدة: إذا رأيت إجراءً خاويًا فاعلم أن له مفعولاً، سواء من عوامله المباشرة أو غير المباشرة. والسبب في ذلك أنه لا بد للإجراء من أن يُثمر، وإلا فالإجراء الذي ليس له أثر، فإن وجوده كعدمه.\nتأمل المثال التالي الذي يأخذ عوامل ثم لا يرجع بشيء، لكنه يُظهر النتيجة على الشاشة:\n\ndef print_decorated(message: str, n: int):\n    print(\"=\" * n)\n    print(message)\n    print(\"=\" * n)\n\nprint_decorated(\"Salam alykom\", 15)\n\n===============\nSalam alykom\n===============",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a1_procedural.html#إطلاق-عدد-العوامل",
    "href": "chapters/08_procedural/a1_procedural.html#إطلاق-عدد-العوامل",
    "title": "13  البرمجة الإجرائية",
    "section": "إطلاق عدد العوامل",
    "text": "إطلاق عدد العوامل\nقد تتساءل كيف تعمل print وهي تأخذ عددًا لا محدودًا من العوامل؟ حتى نجيب عن ذلك ننظر في عملية فك الأقواس وهي علامة النجمة * قبل المتغيِّر المشير لمجموعة، على النحو التالي:\n\nxs = [10, 20, 30]\nprint(xs)\nprint(*xs)\n\n[10, 20, 30]\n10 20 30\n\n\nلاحظ الفرق بين الطلب الأول والثاني:\n\nالأوَّل يطبع المتغير xs ككل، أي: كقائمة من ثلاثة أعناصر\nيُمرر واحدًا تلوَ الآخر للإجراء print بعد فك الأقواس كأنك كتبت: print(10, 20, 30)\n\nوحين تستعمل علامة النجمة في تعريف عوامل الإجراء، فإن أي عامل موضعي زائد عن العدد، يكونُ فيه كصفّ (وسيأتي الكلام عن الصف في باب المجموعة المرتبة). وبالمثال يتضح المقال. وقد اصطُلح على تسميته args وهي اختصار كلمة Arguments:\n\ndef show(a, *args):\n    print(a)\n    print(type(args), args)\n    print('print:', *args)\n\nshow(1, 2, 3, 4, 5)\n\n1\n&lt;class 'tuple'&gt; (2, 3, 4, 5)\nprint: 2 3 4 5\n\n\nوكذلك العوامل المعيَّنة بالاسم، لكن بالنجمتين ** وتكون قاموسًا (وسيأتي الكلام عنه في باب المجموعة المرقومة) ومعنى الكلمة kwargs هو: Keyword Arguments:\n\ndef show(a, **kwargs):\n    print(a)\n    print(type(kwargs), kwargs)\n    print('print:', *kwargs)\n\nshow(a=1, b=2, c=3, d=4, e=5)\n\n1\n&lt;class 'dict'&gt; {'b': 2, 'c': 3, 'd': 4, 'e': 5}\nprint: b c d e\n\n\nوقد يجتمعان في نفس الإجراء *args و **kwargs نحو:\n\ndef show(x, y, *args, **kwargs):\n    print(x, y)\n    print(type(args), args)\n    print(type(kwargs), kwargs)\n\nshow(1, 2, 3, 4, 5, a=1, b=2, c=3)\n\n1 2\n&lt;class 'tuple'&gt; (3, 4, 5)\n&lt;class 'dict'&gt; {'a': 1, 'b': 2, 'c': 3}\n\n\nولا بد من تقديم الموضعية قبل الاسمية.\nللمزيد راجع العوامل الخاصة.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_modules.html",
    "href": "chapters/08_procedural/a2_modules.html",
    "title": "14  الاستيراد والتصدير",
    "section": "",
    "text": "تثبيت حزم\nعندما يكبر النص البرمجي ويتعقد، نلجأ لتقسيمه في ملفات منفصلة تؤدي كل منها وظيفة محددة. وذلك حتى يسهل فهم البرنامج، ويسهل التعديل عليه والإضافة.\nأو قد نرى أن جزءًا من النص البرمجي يستحق الاستعمال في مشروع آخر، فنريد أن نلفَّه في حزمة، ونصدِّره ليكون قابلاً للتثبيت في مشاريع أخرى.\nهاتان الحالتان تستوجبان أن نتعرف على مصطلحين في بايثون: الوحدة والحزمة.\nالوِحدة (Module) هي النص البرمجي في الملف الواحد (مثل: script.py)\nالحزمة (Package) هي مجموعة مكوَّنة من وِحدة أو أكثر؛ وتُعرَّف: بمجلَّد يكون فيه ملف خاص باسم __init.py__ ويوضع فيه النص البرمجي المنشئ الذي يعمل عند فعل استيراد الحزمة بالكلمة import (في المرة الأولى فقط).\nفيما يلي مثال يوضِّح ترتيب حزمة ما (my_package) مكوَّنة من حزم مضمَّنة، وفي المستوى الأخير نرى الوحدات، على النحو التالي:\nدعنا نلقي نظرة على عمليات الاستيراد واحدة تلو الأخرى، انظر (main.py):\nأولاً، لاحظ أن فعل الاستيراد import my_package يحدد حزمة لا وِحدة. وبالتالي، سينفذ الملف __init__.py، الذي يحتوي على عبارات تعيين (مثل __version__، وDEFAULT_TIMEOUT، وما إلى ذلك) سترتبط بمعرف my_package، ويمكن الوصول إليها باستخدام النقطة (.).\nثانيًا لاحظ العبارة: from my_package.pkg1 import module_a فهي تحدد وحدة (module_a)، وبالتالي، يتم تنفيذ جميع التعليمات البرمجية في module_a.py والتعيينات تُسنَد للمعرف module_a ويمكن الوصول إليها باستخدام النقطة (.).\nثالثًا استيراد مباشر للإجراء func_a من وحدة module_a في الحزمة الفرعية pkg2.\nأخيرًا الصيغة from ... import * تستورد جميع (*) الأسماء من الوحدة النمطية (باستثناء تلك التي تبدأ بـ __) إلى نطاق التسمية الحالي (في الوحدة التي نحن فيها). بشكل عام، لا ننصح باستعمال هذه الطريقة، حيث قد تؤدي إلى إلغاء أسماء سبق تعريفها لتحل مكانها هذه الأسماء الجديدة، ولكن لا بأس بها لتقليل جهد الكتابةخصوصًا في الجلسات التفاعلية.\nلتثبيت حزمة من قاعدة بيانات الحزم PyPI نستعمل أداة uv أو pip على النحو التالي:\nأولاً باستعمال أداة uv:\nأو باستعمال أداة pip:\nوبعد تثبيت الحزمة ، نستوردها هكذا ونستعملها:\nimport numpy as np\n\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nprint(np.dot(a, b))\n\n32",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الاستيراد والتصدير</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_modules.html#تثبيت-حزم",
    "href": "chapters/08_procedural/a2_modules.html#تثبيت-حزم",
    "title": "14  الاستيراد والتصدير",
    "section": "",
    "text": "uv add numpy\n\npip install numpy",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الاستيراد والتصدير</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a3_recursion.html",
    "href": "chapters/08_procedural/a3_recursion.html",
    "title": "15  الإجراء المتسلسل",
    "section": "",
    "text": "مثال: المضروب\nالإجراء المتسلسل (Recursive Function): هو إجراء يطلب نفسه؛ بشكل مباشر أو غير مباشر. وحتى يكون مثمرًا: يجب أن تؤول سلسلة الطلبات هذه إلى جملة تُنهي التسلسل.\nفمثلا: تعرف الرياضيات مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots(1)\n\\]\nفهي عملية ضرب لكل عدد مع الذي قبله حتى ينتهي للواحد. ونمثل هنا لمضروب العدد 5:\n\\[\n!5 = (5)(4)(3)(2)(1) = 120\n\\]\nولك أن تصف نفس العملية هكذا:\n\\[\n!n = n !(n-1)\n\\]\nأي أن مضروب العدد هو ضربُ هذا العدد في مضروب العدد الذي قبله. وذلك يتسلسل على النحو التالي:\n\\[\n\\begin{align*}\n!5 &= (5)!(4) \\\\\n   &= (5)(4!(3)) \\\\\n   &= (5)(4(3!(2))) \\\\\n   &= (5)(4(3(2!(1)))) \\\\\n   &= (5)(4(3(2(1)))) \\\\\n   &= (5)(4)(3)(2)(1) \\\\\n   &= 120\n\\end{align*}\n\\]\nإذاً نعرِّف المعادلة في بايثون هكذا:\ndef factorial(n: int) -&gt; int:\n    # Recursive case (تسلسل)\n    if n &gt; 0:\n        recursive_result = factorial(n - 1)\n        return n * recursive_result\n    # Terminal case (نهاية)\n    return 1\n\nfactorial(5)\n\n120\nحيث لدينا حالتان:\nوهنا قطعة نص برمجي نستعملها لتصور تسلسل الطلبات:\nالكود\ndef factorial(n: int, depth: int = 0) -&gt; int:\n\n    # Recursive case (تسلسل)\n    print(f\"{'  ' * depth}Call factorial({n})\")\n    if n &gt; 0:\n        result = n * factorial(n - 1, depth + 1)\n        print(f\"{'  ' * depth}Return {result} from factorial({n})\")\n        return result\n    \n    # Terminal case (نهاية)\n    print(f\"{'  ' * depth}Return 1 from factorial({n})\")\n    return 1\n\nfactorial(5)\n\n\nCall factorial(5)\n  Call factorial(4)\n    Call factorial(3)\n      Call factorial(2)\n        Call factorial(1)\n          Call factorial(0)\n          Return 1 from factorial(0)\n        Return 1 from factorial(1)\n      Return 2 from factorial(2)\n    Return 6 from factorial(3)\n  Return 24 from factorial(4)\nReturn 120 from factorial(5)\n\n\n120\nطلب الإجراء المتسلسل يؤدي إلى ظروف متداخلة تؤول إلى ظرف واحد في النهاية.\nيستعمل الإجراء المتسلسل وكذلك هياكل البيانات المتسلسلة بشكل كبير في الخوارزميات الفعالة.\nيسهل كتابة بعض الخوارزميات باستعمال الإجراء المتسلسل. لكن قد تكون (أحياًنا) أقل أداءً من استعمال الحلقات.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الإجراء المتسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a3_recursion.html#مثال-المضروب",
    "href": "chapters/08_procedural/a3_recursion.html#مثال-المضروب",
    "title": "15  الإجراء المتسلسل",
    "section": "",
    "text": "عندما تكون n &gt; 0 يتم الطلب الذاتي : recursive_result = factorial(n - 1) إذْ هي جملة متسلسلة تكدِّس طلبات فوق طلبات؛ لكنها تؤول في النهاية إلى الجملة التي تُنهي التسلسل\nreturn 1 هي الجملة التي تنهي التسلسل\n\n\n\n\nفكل طلب يُنشأ له ظرف تنفيذ جديد تكون بالنسبة له قيمة n هي المعيَّنة له وقت النداء.\nوهكذا يتم تكديس الطلبات حتى ينتهي التسلسل عند الطلب factorial(0) الذي يؤول لنتيجة مباشرة: return 1 فيخلَّى هذا الظرف من الذاكرة وتعود نتيجته إلى الظرف المباشر الذي استدعاه وهو ظرف factorial(1).\nفتتعين القيمة recursive_result = 1 وينتقل إلى الجملة التي بعدها وهي جملة الرجوع بنتيجة return n * recursive_result وهُما معيَّنان، أي تكون الجملة في واقع الظرف: return 1 * 1.\nوهذه النتيجة تعود للظرف الذي استدعاه وهو factorial(2) … إلخ.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الإجراء المتسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html",
    "href": "chapters/08_procedural/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "طول الخط المستقيم بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nوتذكر أن:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\ndef euclidean_distance(x1: float, y1: float, x2: float, y2: float) -&gt; float:\n    return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5\n\nprint(euclidean_distance(x1=0, y1=0, x2=3, y2=4))\nprint(euclidean_distance(1, 1, -2, -2))\n\n5.0\n4.242640687119285",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#تجزئة-البيانات",
    "href": "chapters/08_procedural/apps.html#تجزئة-البيانات",
    "title": "تطبيقات",
    "section": "تجزئة البيانات",
    "text": "تجزئة البيانات\nهذا الإجراء يقسم قائمة إلى جزئين بنسبة محددة:\n\ndef split(data: list, ratio: float) -&gt; tuple[list, list]:\n    idx = int(len(data) * ratio)\n    return data[:idx], data[idx:]\n\nنختبر الإجراء ونلاحظ أن الناتج من نوع صف (tuple). فنستعمل التعيين المتعدد لاستخراج القيم من الصف:\n\nxs = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\na, b = split(xs, 0.80)\n\nassert a == [10, 20, 30, 40, 50, 60, 70, 80]\nassert b == [90, 100]",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#سحب-الرصيد",
    "href": "chapters/08_procedural/apps.html#سحب-الرصيد",
    "title": "تطبيقات",
    "section": "سحب الرصيد",
    "text": "سحب الرصيد\nنريد أن نعرف إجراء سحب الرصيد لأي مستخدم ولأي جهاز صراف آلي ولأي مبلغ:\n\nأولاً، تأكد من وجود رصيد كافٍ لدى المستخدم.\nإذا كان الأمر كذلك، فتأكد من وجود رصيد كافٍ في جهاز الصراف الآلي لصرف المبلغ المطلوب.\n\n\ndef withdraw_cash(balance, amount, atm_cash):\n    if balance &gt;= amount:\n        if atm_cash &gt;= amount:\n            balance -= amount\n            atm_cash -= amount\n            print(\"Withdrawal successful!\")\n        else:\n            print(\"ATM does not have enough cash.\")\n    else:\n        print(\"Insufficient balance.\")\n\nwithdraw_cash(500, 200, 1000)\nwithdraw_cash(500, 200, 100)\nwithdraw_cash(500, 600, 1000)\n\nWithdrawal successful!\nATM does not have enough cash.\nInsufficient balance.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#الكلمة-المتناظرة",
    "href": "chapters/08_procedural/apps.html#الكلمة-المتناظرة",
    "title": "تطبيقات",
    "section": "الكلمة المتناظرة",
    "text": "الكلمة المتناظرة\nفي هذا المثال نوضح استعمال مؤشرين على نفس النص لمعرفة ما إذا كانت الكلمة متناظرة:\n\nالمؤئر الأول بإصبعك الأيمن: i يبدأ من أول حرف وينتهي عند المنتصف\nالمؤئر الثاني بإصبعك الأيسر: j يبدأ من آخر حرف وينتهي عند المنتصف\n\n\ndef is_palindrome(word):\n    \"\"\"\n    A palindrome word is one that can be read the same way from both ends.\n    \"\"\"\n\n    # إزالة الاختلافات في الحروف الكبيرة والصغيرة\n    word = word.lower()\n    \n    # إزالة الفواصل (لتطابق الكلمات مثل: \"Race car\")\n    word = word.replace(\" \", \"\")\n\n    # التحقق من أن الكلمة متناظرة\n    for i in range(len(word) // 2):\n        j = len(word) - i - 1\n        if word[i] != word[j]:\n            return False\n    return True\n\n# الاختبارات\nassert is_palindrome(\"radar\")\nassert is_palindrome(\"level\") \nassert is_palindrome(\"madam\")\nassert is_palindrome(\"توت\")\nassert is_palindrome(\"خوخ\")\nassert is_palindrome(\"Race car\")\nassert is_palindrome(\"حصان ناصح\")\nassert not is_palindrome(\"python\")\n\nبدل الحلقة، وكان لنا أن نكتب باختصار: word == word[::-1] وهي تعني أن النص متناظر إذا كان مساوياً لنفسه بالمقلوب.\n\ndef is_palindrome(word):\n    word = word.lower()\n    word = word.replace(\" \", \"\")\n    return word == word[::-1]",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#تصحيح-الإملاء",
    "href": "chapters/08_procedural/apps.html#تصحيح-الإملاء",
    "title": "تطبيقات",
    "section": "تصحيح الإملاء",
    "text": "تصحيح الإملاء\nاكتب فعلًا يصحح الإخطاء الشائعة في الإملاء العربي.\n\nإبدال التاء المربوطة بالهاء: مكتبه، لعبه، روايه\nإبدال الظاء بالضاد والعكس: ظابط، قرظ، ضهر\nزيادة الياء: أحسنتي، رأيتكي\n\nوالمطلوب فقط تصحيح الأخطاء المذكورة.\n\ncorrections_map = {\n    'مكتبه': 'مكتبة',\n    'لعبه': 'لعبة',\n    'روايه': 'رواية',\n    'ظابط': 'ضابط',\n    'قرظ': 'قرض',\n    'ضهر': 'ظهر',\n    'أحسنتي': 'أحسنت',\n    'رأيتكي': 'رأيتك',\n}\n\ndef correct_spelling(sentence: str) -&gt; str:\n    words = sentence.split()\n    result = []\n    for word in words:\n        al = word.startswith('ال')\n        if al:\n            word = word[2:]\n        correction = corrections_map.get(word, word)\n        if al:\n            correction = 'ال' + correction\n        result.append(correction)\n    return ' '.join(result)\n\n\nassert (\n    correct_spelling('المكتبه فيها الروايه التي أبحث عنها') ==\n    'المكتبة فيها الرواية التي أبحث عنها'\n)\n\nassert (\n    correct_spelling('أعطاك الظابط القرظ بعد الضهر') ==\n    'أعطاك الضابط القرض بعد الظهر'\n)\n\nassert (\n    correct_spelling('رأيتكي أحسنتي') == 'رأيتك أحسنت')",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html",
    "href": "chapters/08_procedural/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "حساب العمر\nاكتب إجراء يحسب عمرك في أي سنة معينة.\ndef age_at(age_now: int, current_year: int, at_year: int) -&gt; int:\n    pass # اكتب هنا بدل كلمة pass\n\nprint(age_at(0, 2000, 2010)) # بعد الولادة\nprint(age_at(20, 2000, 2010)) # في المستقبل\nprint(age_at(20, 2000, 1995)) # في الماضي\n\nNone\nNone\nNone",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html#حساب-الأجر",
    "href": "chapters/08_procedural/problems.html#حساب-الأجر",
    "title": "مسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\nعرِّف الإجراء الذي يحسب الأجر بعاملين:\n\nhours: float: عدد الساعات التي يعملها الموظف\nper_hour_rate: float: سعر الساعة الواحدة\n\nواجعل نوع العائد float كذلك باستعمال -&gt; float.\n\n# اكتب الإجراء هنا\n\nثم اختبر الإجراء باستعمال جمل توكيدية: assert.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html#توحيد-الصيغة",
    "href": "chapters/08_procedural/problems.html#توحيد-الصيغة",
    "title": "مسائل",
    "section": "توحيد الصيغة",
    "text": "توحيد الصيغة\nفي هذا المثال، تعود هذه النصوص كلها إلى نفس المعنى.\n\n(‘medina’, ‘madinah’, ‘madina’, ‘al madinah’, ‘al madina’, ‘medina’, ‘madinah’, ‘madina’, ‘المدينة’, ‘مدينة’),\n(‘mecca’, ‘makkah’, ‘makka’, ‘makkah’, ‘makkah’, ‘مكة’, ‘مكه’),\n\nالمطلوب إنشاء قاموس بحيث لو أعطيته أحد هذه الكلمات كمفتاح، فإنها جميعًا تؤول إلى صيغة موحدة:\n\ndef normalize_city_name(city_name: str) -&gt; str:\n    pass # اكتب جسد الإجراء هنا\n\nassert (\n    'madinah' ==\n    normalize_city_name('المدينة') ==\n    normalize_city_name('al madinah') ==\n    normalize_city_name('medina')\n)\n\nassert (\n    'makkah' ==\n    normalize_city_name('مكة') ==\n    normalize_city_name('makkah') ==\n    normalize_city_name('makka') ==\n    normalize_city_name('mecca')\n)",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html#حساب-الجمل",
    "href": "chapters/08_procedural/problems.html#حساب-الجمل",
    "title": "مسائل",
    "section": "حساب الجُمَّل",
    "text": "حساب الجُمَّل\n\nحِسَاب الجُمَّل وهو حساب استخدم في اللغات السامية؛ حيث نجده مستعملًا في بلاد الهند قديمًا، وعند اليهود؛ فالأبجدية العبرية تتطابق مع الأبجدية العربية حتى حرف التاء (أبجد، هوز، حطي، كلمن، سعفص، قرشت) أي تتكون من 22 حرفا وتزيد العربية: (ثخذ، ضظغ). واستخدمه المسلمون في تثبيت التاريخ. لكل حرف مدلول رقمي يبدأ بالرقم 1 وينتهي عند الرقم 1000.\n\n\n\n\nحساب الجمَّل\n\n\n\n\n\n\n\n\n\n\n\nا\n1\nي\n10\nق\n100\nغ\n1000\n\n\nب\n2\nك\n20\nر\n200\nبغ\n2000\n\n\nجـ\n3\nل\n30\nش\n300\nجغ\n3000\n\n\nد\n4\nم\n40\nت\n400\nدغ\n4000\n\n\nهـ\n5\nن\n50\nث\n500\nهغ\n5000\n\n\nو\n6\nس\n60\nخ\n600\nوغ\n6000\n\n\nز\n7\nع\n70\nذ\n700\nزغ\n7000\n\n\nح\n8\nف\n80\nض\n800\nحغ\n8000\n\n\nط\n9\nص\n90\nظ\n900\nطغ\n9000\n\n\n\nاكتب تفاصيل الإجراء الذي يحسب الجمَّل لكلمة معينة.\ndef gematria(word: str) -&gt; int:\n    pass\nفإذا أرادوا كتابة الرقم (1240) كتبوا «غرم»، لأن الغين 1,000، والراء 200، والميم 40، فكانوا يراعون عند تركيب الجُمّل أن يكون الحرف المعبر عن العدد الأكبر في المقدمة، ثم يليه الأصغر منه وهكذا دواليك فنجد من الأمثلة على ذلك:\nassert gematria('غرم') == 1240\nassert gematria('رب') == 202\nassert gematria('ريح') == 218\nassert gematria('شعب') == 372\nيقال أنه عندما توفي السلطان الظاهر برقوق أول سلاطين المماليك البرجية، قام بعض الظرفاء بصياغة عبارة تحدد تاريخ وفاته فقال: «وفاة برقوق في المشمش»، وعندما نحسب تاريخ وفاة برقوق وهي «في المشمش» يكون الناتج:\n(80+10+1+30+40+300+40+300) = 801، وبالتالي فتكون العبارة: «وفاة برقوق 801» هجرية وذلك صحيح.\nassert gematria('في المشمش') == 801 == 80+10+1+30+40+300+40+300\nيقال أيضاً أن شاعراً يسمى الدّلنجاوي مات فرثاه صديق له فقال:\n\n\n\nسألتُ الشّعرَ هل لكَ من صديقٍ\nوقد سكنَ الدّلنجاويّ لحــده\n\n\nفصاحَ وخرّ مغشياً عليــــه\nوأصبح راقداً في القبر عنــده\n\n\nفقلتُ لمن يقول الشعر أقْصِــر\nلقد أرّختُ: مات الشعرُ بعـده\n\n\n\nويتضح لنا أن تاريخ الوفاة يكون في معرفة حساب العبارة «مات الشعرُ بعدَهُ»، فيكون الحساب:\n(40+1+400+1+30+300+70+200+2+70+4+5) = (1123)، وذلك يعني أن الشاعر الدلنجاوي توفي في عام 1123 للهجرة.\nassert gematria('مات الشعر بعده') == 1123 == 40+1+400+1+30+300+70+200+2+70+4+5",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html",
    "href": "chapters/08_procedural/solutions.html",
    "title": "الحلول",
    "section": "",
    "text": "حساب العمر\nاكتب إجراء يحسب عمرك في أي سنة معينة.\ndef age_at(age_now: int, current_year: int, at_year: int) -&gt; int:\n    return age_now + (at_year - current_year)\n    \n\nprint(age_at(0, 2000, 2010)) # بعد الولادة\nprint(age_at(20, 2000, 2010)) # في المستقبل\nprint(age_at(20, 2000, 1995)) # في الماضي\n\n10\n30\n15",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#حساب-الأجر",
    "href": "chapters/08_procedural/solutions.html#حساب-الأجر",
    "title": "الحلول",
    "section": "حساب الأجر",
    "text": "حساب الأجر\nعرِّف الإجراء الذي يحسب الأجر بعاملين:\n\nhours: float: عدد الساعات التي يعملها الموظف\nper_hour_rate: float: سعر الساعة الواحدة\n\nواجعل نوع العائد float كذلك باستعمال -&gt; float.\n\ndef salary(hours: float, per_hour_rate: float) -&gt; float:\n    return hours * per_hour_rate\n\nثم اختبر الإجراء باستعمال جمل توكيدية: assert.\n\nassert salary(6, 30) == 180\nassert salary(per_hour_rate=50, hours=10) == 500",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#توحيد-الصيغة",
    "href": "chapters/08_procedural/solutions.html#توحيد-الصيغة",
    "title": "الحلول",
    "section": "توحيد الصيغة",
    "text": "توحيد الصيغة\nفي هذا المثال، تعود هذه النصوص كلها إلى نفس المعنى.\n\n(‘medina’, ‘madinah’, ‘madina’, ‘al madinah’, ‘al madina’, ‘medina’, ‘madinah’, ‘madina’, ‘المدينة’, ‘مدينة’),\n(‘mecca’, ‘makkah’, ‘makka’, ‘makkah’, ‘makkah’, ‘مكة’, ‘مكه’),\n\nالمطلوب إنشاء قاموس بحيث لو أعطيته أحد هذه الكلمات كمفتاح، فإنها جميعًا تؤول إلى صيغة موحدة:\nأولاً نعرّف قاموسًا يحول جميع التصريفات إلى نفس الصيغة:\n\ncity_map = {\n    'medina': 'madinah',\n    'madinah': 'madinah',\n    'madina': 'madinah',\n    'al madinah': 'madinah', \n    'al madina': 'madinah',\n    'المدينة': 'madinah',\n    'مدينة': 'madinah',\n\n    'mecca': 'makkah',\n    'makkah': 'makkah',\n    'makka': 'makkah',\n    'مكة': 'makkah',\n    'مكه': 'makkah',\n}\n\n\nنعرف الإجراء بأنه يأخذ نصًّا str ويُنتج نصًّا str آخر.\nولأن الحروف الإنجليزية قد تحوي أحرفًا كبيرة، فإننا نحولها جميعًا إلى صيغة صغيرة: .lower()\nوأخيرًا نستعمل هذا النص كمفتاح لنسحب القيمة؛ الصيغة الموحَّدة\n\n\ndef normalize_city_name(city_name: str) -&gt; str:\n    text = city_name.lower()\n    return city_map[text]\n\nنختبر الإجراء باستعمال جمل توكيدية: assert.\n\nassert (\n    'madinah' ==\n    normalize_city_name('المدينة') ==\n    normalize_city_name('al madinah') ==\n    normalize_city_name('medina')\n)\n\nassert (\n    'makkah' ==\n    normalize_city_name('مكة') ==\n    normalize_city_name('makkah') ==\n    normalize_city_name('makka') ==\n    normalize_city_name('mecca')\n)",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#حساب-الجمل",
    "href": "chapters/08_procedural/solutions.html#حساب-الجمل",
    "title": "الحلول",
    "section": "حساب الجُمَّل",
    "text": "حساب الجُمَّل\n\nحِسَاب الجُمَّل وهو حساب استخدم في اللغات السامية؛ حيث نجده مستعملًا في بلاد الهند قديمًا، وعند اليهود؛ فالأبجدية العبرية تتطابق مع الأبجدية العربية حتى حرف التاء (أبجد، هوز، حطي، كلمن، سعفص، قرشت) أي تتكون من 22 حرفا وتزيد العربية: (ثخذ، ضظغ). واستخدمه المسلمون في تثبيت التاريخ. لكل حرف مدلول رقمي يبدأ بالرقم 1 وينتهي عند الرقم 1000.\n\n\n\n\nحساب الجمَّل\n\n\n\n\n\n\n\n\n\n\n\nا\n1\nي\n10\nق\n100\nغ\n1000\n\n\nب\n2\nك\n20\nر\n200\nبغ\n2000\n\n\nجـ\n3\nل\n30\nش\n300\nجغ\n3000\n\n\nد\n4\nم\n40\nت\n400\nدغ\n4000\n\n\nهـ\n5\nن\n50\nث\n500\nهغ\n5000\n\n\nو\n6\nس\n60\nخ\n600\nوغ\n6000\n\n\nز\n7\nع\n70\nذ\n700\nزغ\n7000\n\n\nح\n8\nف\n80\nض\n800\nحغ\n8000\n\n\nط\n9\nص\n90\nظ\n900\nطغ\n9000\n\n\n\nاكتب تفاصيل الإجراء الذي يحسب الجمَّل لكلمة معينة.\nأولاً نعرّف قاموسًا يحول الحروف إلى أرقام:\n\ngematria_map = {\n    'ا': 1, 'ي': 10, 'ق': 100, 'غ': 1000,\n    'ب': 2, 'ك': 20, 'ر': 200, 'بغ': 2000,\n    'ج': 3, 'ل': 30, 'ش': 300, 'جغ': 3000,\n    'د': 4, 'م': 40, 'ت': 400, 'دغ': 4000,\n    'ه': 5, 'ن': 50, 'ث': 500, 'هغ': 5000,\n    'و': 6, 'س': 60, 'خ': 600, 'وغ': 6000,\n    'ز': 7, 'ع': 70, 'ذ': 700, 'زغ': 7000,\n    'ح': 8, 'ف': 80, 'ض': 800, 'حغ': 8000,\n    'ط': 9, 'ص': 90, 'ظ': 900, 'طغ': 9000,\n}\n\nثم نعرّف الإجراء بأنه يأخذ نصًّا str ويُنتج رقمًا int:\n\ndef gematria(word: str) -&gt; int:\n    total = 0\n    for i in range(0, len(word), 2):\n        pair = word[i:i+2]\n        if pair in gematria_map:\n            total += gematria_map[pair]\n        else:\n            a, b = pair\n            if a in gematria_map:\n                total += gematria_map[a]\n            if b in gematria_map:\n                total += gematria_map[b]\n    return total\n\n\nيبدأ الحساب بمتغير total يساوي 0\nنأتي على الكلمة حرفين ثم ننتقل منهما إلى الحرفين التاليين (وذلك بتحديد حجم الخطوة: 2) for i in range(0, len(word), 2)\nنقرأ الحرفين معًا: pair = word[i:i+2] من الموضع i إلى الموضع i+2؛ فهذه شريحة مكوَّنة من نص فيه حرفان\nإذا كان هذ الزوج موجودًا في القاموس gematria_map، فإننا نضيف قيمته إلى المتغير total\nفإن لم يكن موجودًا فإننا نعتبر كل حرفٍ على حدة: a, b = pair\nفإن كان الأول موجودًا في القاموس فإننا نضيف قيمته إلى المتغير total\nوإن كان الثاني موجودًا في القاموس فإننا نضيف قيمته إلى المتغير total\nوأخيرًا نعيد المتغير return total\n\nفإذا أرادوا كتابة الرقم (1240) كتبوا «غرم»، لأن الغين 1,000، والراء 200، والميم 40، فكانوا يراعون عند تركيب الجُمّل أن يكون الحرف المعبر عن العدد الأكبر في المقدمة، ثم يليه الأصغر منه وهكذا دواليك فنجد من الأمثلة على ذلك:\n\nassert gematria('غرم') == 1240\nassert gematria('رب') == 202\nassert gematria('ريح') == 218\nassert gematria('شعب') == 372\n\nيقال أنه عندما توفي السلطان الظاهر برقوق أول سلاطين المماليك البرجية، قام بعض الظرفاء بصياغة عبارة تحدد تاريخ وفاته فقال: «وفاة برقوق في المشمش»، وعندما نحسب تاريخ وفاة برقوق وهي «في المشمش» يكون الناتج:\n(80+10+1+30+40+300+40+300) = 801، وبالتالي فتكون العبارة: «وفاة برقوق 801» هجرية وذلك صحيح.\n\nassert gematria('في المشمش') == 801 == 80+10+1+30+40+300+40+300\n\nيقال أيضاً أن شاعراً يسمى الدّلنجاوي مات فرثاه صديق له فقال:\n\n\n\nسألتُ الشّعرَ هل لكَ من صديقٍ\nوقد سكنَ الدّلنجاويّ لحــده\n\n\nفصاحَ وخرّ مغشياً عليــــه\nوأصبح راقداً في القبر عنــده\n\n\nفقلتُ لمن يقول الشعر أقْصِــر\nلقد أرّختُ: مات الشعرُ بعـده\n\n\n\nويتضح لنا أن تاريخ الوفاة يكون في معرفة حساب العبارة «مات الشعرُ بعدَهُ»، فيكون الحساب:\n(40+1+400+1+30+300+70+200+2+70+4+5) = (1123)، وذلك يعني أن الشاعر الدلنجاوي توفي في عام 1123 للهجرة.\n\nassert gematria('مات الشعر بعده') == 1123 == 40+1+400+1+30+300+70+200+2+70+4+5",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#ضم-الأقران",
    "href": "chapters/08_procedural/solutions.html#ضم-الأقران",
    "title": "الحلول",
    "section": "ضم الأقران",
    "text": "ضم الأقران\nماذا لو أردت أن تضم قائمة من الأشخاص بحيث يكون فارق العمر بينهم أقل ما يمكن؟\nAhmad: 24\nMohannad: 17\nMohammed: 16\nSalem: 32\nAli: 26\nSamir: 31\nأولاً سنرتب القائمة بناءً على العمر، ثم نأخذ العناصر اثنين اثنين، وبذلك نكون حققنا الهدف.\n\ndef make_pairs_by_age_diff(items: list[tuple[str, int]]) -&gt; list[tuple[str, str]]:\n    \"\"\"Make pairs of people by their age difference minimum.\"\"\"\n    ages = [age for name, age in items]\n    ages.sort()\n    items_sorted = []\n    for age in ages:\n        for i in items:\n            if i[1] == age:\n                items_sorted.append(i)\n    pairs = []\n    for i in range(len(items_sorted) - 1):\n        pairs.append((items_sorted[i], items_sorted[i+1]))\n    return pairs\n\n\npeers = [\n    (\"Ahmad\", 24),\n    (\"Mohannad\", 17),\n    (\"Mohammed\", 16),\n    (\"Salem\", 32),\n    (\"Ali\", 26),\n    (\"Samir\", 31),\n]\n\nالاختبارات\n\npairs = make_pairs_by_age_diff(peers)\nfor p in pairs:\n    if \"Ahmad\" in p:\n        assert \"Ali\" in p\n    if \"Mohannad\" in p:\n        assert \"Mohammed\" in p\n    if \"Salem\" in p:\n        assert \"Samir\" in p",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#التوفيق-بين-مجموعتين",
    "href": "chapters/08_procedural/solutions.html#التوفيق-بين-مجموعتين",
    "title": "الحلول",
    "section": "التوفيق بين مجموعتين",
    "text": "التوفيق بين مجموعتين\nمسألة التوفيق بين مجموعتين تجدها في سياقات كثيرة.\nنريد في هذا التمرين التوفيق بين أشخاص وما لديهم من مهارات وبين شركات وما تطلبها من هذه المهارات.\nيمكن أن تبدأ بهذا الشكل لإيجاد كمية التوافق:\n\nhave = {\"A\", \"X\", \"Y\"}\nwant = {\"A\", \"B\", \"C\", \"D\"}\nprint(\"نسبة الإعجاب:\", len(set.intersection(have, want)) / len(want))\n\nنسبة الإعجاب: 0.25\n\n\nوفي العادة تكون البيانات مضمنة في قائمة على النحو التالي:\n\nhaves = [\n    {\n        \"name\": \"Ahmad\",\n        \"skills\": [\n            \"Python\",\n            \"Go\",\n            \"JavaScript\",\n        ],\n    },\n    {\n        \"name\": \"Jawad\",\n        \"skills\": [\n            \"Negotiation\",\n            \"Communication\",\n            \"Business\",\n            \"Marketing\",\n        ],\n    },\n]\n\nwants = [\n    {\n        \"job\": \"Data Scientist\",\n        \"requirements\": [\n            \"Python\",\n            \"Machine Learning\",\n            \"Statistics\",\n        ],\n    },\n    {\n        \"job\": \"Sales Manager\",\n        \"requirements\": [\n            \"Negotiation\",\n            \"Communication\",\n        ],\n    },\n]\n\nنعالجها لكل عنصر في قائمة wants:\n\nratios = {}\nfor want in wants:\n    for have in haves:\n        ratio = len(set.intersection(set(want[\"requirements\"]), set(have[\"skills\"]))) / len(want[\"requirements\"])\n        if want['job'] not in ratios:\n            ratios[want['job']] = {}\n        ratios[want['job']][have['name']] = ratio\nratios\n\n{'Data Scientist': {'Ahmad': 0.3333333333333333, 'Jawad': 0.0},\n 'Sales Manager': {'Ahmad': 0.0, 'Jawad': 1.0}}\n\n\nالآن نرتب كل وظيفة بحسب الأعلى توافقًا.\nأولاً نكتب دالة ترتِّب قاموسًا، ثم سنستعملها:\n\ndef sort_nested_dict(d: dict) -&gt; dict:\n    \"\"\"Sorts a dictionary by values\"\"\"\n    result = {}\n    for key in d.keys():\n        result[key] = {}\n        values = [v for v in d[key].values()]\n        values.sort(reverse=True)\n        for v1 in values:\n            for k, v2 in d[key].items():\n                if v2 == v1:\n                    result[key][k] = v2\n    return result\n\n\nsorted_ratios = sort_nested_dict(ratios)\nsorted_ratios\n\n{'Data Scientist': {'Ahmad': 0.3333333333333333, 'Jawad': 0.0},\n 'Sales Manager': {'Jawad': 1.0, 'Ahmad': 0.0}}\n\n\nولكثرة الحاجة لترتيب البيانات، فإن إجراء sorted متعدد الاستعمالات في بايثون. انظر Sorting Basics و Key Functions من توثيق بايثون تحت عنوان: “HOW TO”.\n\nfor k, v in ratios.items():\n    sorted_ratios[k] = sorted(v.items(), key=lambda x: x[1], reverse=True)\nsorted_ratios\n\n{'Data Scientist': [('Ahmad', 0.3333333333333333), ('Jawad', 0.0)],\n 'Sales Manager': [('Jawad', 1.0), ('Ahmad', 0.0)]}\n\n\nفأول المرشحين في علوم البيانات هو:\n\nsorted_ratios[\"Data Scientist\"][0][0]\n\n'Ahmad'\n\n\nوأول المرشحين في المبيعات هو:\n\nsorted_ratios[\"Sales Manager\"][0][0]\n\n'Jawad'",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "الحلول"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a0_path.html",
    "href": "chapters/09_files_and_directories/a0_path.html",
    "title": "16  الإشارة للملفات",
    "section": "",
    "text": "موضع الملفات\nتقع الملفات في جهاز الحاسب ضمن ملفات أخرى على هذا النحو (في أنظمة ويندوز Windows):\nفالحرف الأوَّل في الأعلى (C:) يمثِّل مكان جهاز التخزين. وإن رأيت D: أو E: فيعني أن الملفات تخزن في جهازين آخرين.\nوقد تتساءل لماذا لم نبدأ بالحرف A: أو B:؟ وسبب ذلك تاريخي. وذلك أنَّهما كانا محجوزين للإشارة لجهاز تخزين عتيق يسمى القرص المرن (floppy disk)، ولم يعد يستعمل.\nأما في أنظمة لينكس (Linux) وماك (MacOS) فإن الأصل يعبَّر عنه لا بحرف، وإنما بالمسار الجذر: / على النحو التالي:\nوتسمى الملفات المتضمنة لملفات أخرى: دليل (Directory). وهو الذي يعبَّر عنه فيما ترى في الواجهة الرسومية على شكل مجلَّد (Folder).\nفإذًا الملفات على نوعين:\nصيغة الملف (File Extension) تُعرَفُ بالحروف بعد آخر نقطة. مثل:\nالمسار هو نص يحدد موقع الملف في النظام. وهو ضربان:\nفالمسار الثاني بالنسبة للملف analysis.py صحيح، لكن ليس بالنسبة لأي ملف آخر غيره خارج نفس المجلد. فهو صعودٌ للأعلى مرةً، ثم الدخول إلى الدليل data الذي يقع أسفله، ثم الوصول إلى الملف datafile.csv.",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الإشارة للملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a0_path.html#موضع-الملفات",
    "href": "chapters/09_files_and_directories/a0_path.html#موضع-الملفات",
    "title": "16  الإشارة للملفات",
    "section": "",
    "text": "C:\\\n└── Users\n    └── Adam\n        └── MyProject\n            ├── data\n            │   └── datafile.csv\n            └── scripts\n                └── analysis.py\n\n\n\n/\n└── home\n    └── adam\n        ├── projects\n            └── myproject\n                ├── data\n                │   └── datafile.csv\n                └── scripts\n                    └── analysis.py\n\n\n\n\nFolder Icon\n\n\n\n\nملف (File): وهو الذي يحوي بيانات نصية أو ثنائية. مثل:\n\ndatafile.csv ملف بيانات جدولية \nanalysis.py ملف برنامج بايثون \n\nدليل (Directory): وهو قائمة من الملفات والأدلة. مثل:\n\ndata دليل / مجلد البيانات \nmyproject دليل / مجلد المشروع \n\n\n\n\ndatafile.csv صيغة csv\nanalysis.py صيغة py\n\n\n\nمطلق (absolute): يحدد المسار بشكل كامل بدءًا من الجذر.\nنسبي (relative): يحدد المسار بالنسبة لموقع الملف الحالي.\n\nمعنى النقطة . هو الدليل الحالي.\nمعنى النقطتين .. الصعود مرة\n\n\n\n\n\n\nPath\nExample\n\n\n\n\nAbsolute\n/home/adam/projects/myproject/scripts/analysis.py\n\n\nRelative\n../data/datafile.csv",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الإشارة للملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a0_path.html#قراءة-وكتابة-الملفات",
    "href": "chapters/09_files_and_directories/a0_path.html#قراءة-وكتابة-الملفات",
    "title": "16  الإشارة للملفات",
    "section": "قراءة وكتابة الملفات",
    "text": "قراءة وكتابة الملفات\nفيه ثلاثة خطوات:\n\nنفتح الملف open(): وهذا طلبٌ من نظام التشغيل الإذنَ (بحسب mode الإذن بالقراءة r أو الإذن بالكتابة w أو الإذن بالقراءة والكتابة rw)؛ ونحصل في النتيجة على مؤشر يشير إليه.\n. نقرأ الملفfile.read() فيتم نسخ محتواه من التخزين إلى الذاكرة\nولا بُد من تسريحه بعد الفراغ منه باستعمال file.close()\n\nوذلك على النحو التالي:\n\nf = open(file='../../datasets/example_root/a/a.txt', mode='r')\ncontent = f.read()\nf.close()\n\nprint(content)\n\nlorem ipsum dolfet\nweilfur badem zelfur\n\n\nوهكذا نكتب في الملف باستعمال file.write()، بعد فتح الملف بوضع الكتابة 'w' في open(mode='w'):\n\ncontent = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\n\nf = open(file='../../datasets/example_root/a/zzz.txt', mode='w')\nf.write(content)\nf.close()\n\nprint(content)\n\nSalam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\n\n\nانظر توثيق قراءة وكتابة الملفات.\nولأن الإغلاق ضروري بعد كل فتح؛ فقد وفرت بايثون لذلك مركبًا لغويًّا يُعرف بإدارة السياق. فالملف نوعٌ يعتبر مدير سياق (Context Manager) فيجوز استعمال with وتضمين القطعة في سياقها الذي يتكفل بإغلاق الملف تلقائيّا عند نهاية آخر جملة في قطعة داخلها. وذلك على النحو التالي:\n\ncontents = ''\nwith open(file='../../datasets/example_root/a/a.txt', mode='r') as f:\n    contents = f.read()\nprint(contents)\n\nlorem ipsum dolfet\nweilfur badem zelfur",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الإشارة للملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_serialization.html",
    "href": "chapters/09_files_and_directories/a1_serialization.html",
    "title": "17  صياغة البيانات",
    "section": "",
    "text": "الارتباط والتضمين\nسَلْسَلة البيانات (Data Serialization) تشير لعملية تحويل البيانات في ذاكرة بايثون (مثل القائمة [] والقاموس {}) من صيغتها الثنائية الخاص باللغة إلى تمثيلٍ ليس خاصًّا بلغةٍ معيَّنة؛ بل يتبع صيغةً متفقًا عليها؛ فإما أن يكون:\nفالتمثيل النصي يتميز بأنه مباشر وواضح بالنسبة للبشر. لكنه أبطأ في المعالجة (سواءً في الكتابة أو في القراءة) وأكبرُ حجمًا في التخزين غالبًا. أما التمثيل الثانئي فهو بعكسه: أقرب للآلة وأصعب في التدقيق عند حدوث الخطأ إلا مع وجود أدوات تساعد في ذلك. لكنه أسرع في المعالجة وأقل حجمًا للتخزين.\nوعملية تحويل البيانات المُسَلسَلة (أي المكتوبة بإحدى هذه الصيغ) وقراءَتها في برنامجٍ ما تسمى فك التسلسل (Deserialization). فالتحويل يكون مثلاً من النصي إلى الثنائي في الذاكرة. أو من الثنائي المسلسل إلى الثنائي في الذاكرة.\nفالسلسلة وفكها ما هي إلا صياغة لا تغير المكنون بل شكله.\nويختلف شكل البيانات من ثلاثة أوجه:\nفالصفوف تتميز بكون كل صفٍّ فيها تدوينًا لمجموعة خصائص تشترك في العمود كله. أما الارتباط ففيه مرونة؛ فمجموعة الارتباطات لا تُلزِم كل ارتباط أن يكون له ذات خصائص الارتباط الذي قبله.\nسنمثل باستعمال الوحدة المدمجة json ذات وظائف القراءة والكتابة لملفات مصاغة على شكل json. فإن كنت تتعامل مع صيغ أخرى انظر في الوثائق:\nimport json\nلنفترض أن لدينا user_preferences محفوظًا في القاموس التالي، ونريد حفظه في ملف json:\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\nلنكتبها في الملف نستعمال json.dump على النحو التالي:\nwith open('../../datasets/user_preferences.json', mode='w') as file:\n    json.dump(user_preferences, file)\nفإذا أردنا قراءتها نستعمل json.load على النحو التالي:\nwith open('../../datasets/user_preferences.json') as file:\n    data = json.load(file)\nprint(data)\n\n{'theme': 'dark', 'language': 'Arabic', 'notifications': {'email': True, 'sms': False, 'push': True}, 'last_updated': '2021-09-01', 'emails': ['example1@domain.com', 'example2@domain.com']}",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>صياغة البيانات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_serialization.html#الارتباط-والتضمين",
    "href": "chapters/09_files_and_directories/a1_serialization.html#الارتباط-والتضمين",
    "title": "17  صياغة البيانات",
    "section": "",
    "text": "الوحدة المدمجة xml لصيغة xml.\nأو مكتبة pyyaml لصيغة yaml.",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>صياغة البيانات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_serialization.html#الصف",
    "href": "chapters/09_files_and_directories/a1_serialization.html#الصف",
    "title": "17  صياغة البيانات",
    "section": "الصف",
    "text": "الصف\nتأتي البيانات الجدولية في صيغ متعددة، مثل:\n\nCSV وهي صيغة يكون فيها الصف في سطر، وتكون عناصره مفصولة بعلامة الفاصلة \",\"\nTSV وهي مثل CSV إلا أن الفاصلة علامة \"\\t\"\n\nوغيرها كثير.\nفي هذا القسم، سنركز على ملفات (Comma Separated Values) CSV؛ وتعني حرفيًّا: القيَم المفصولة بالفاصلة.\nتوجد في بايثون وحدة csv فيها إجراءات للقراءة والكتابة على طريقة csv. فلدينا:\n\nكائن reader لعمليات القراءة\nوكائن آخر منفصل اسمه writer يحوي عمليات الكتابة\n\n\nimport csv\n\nلنكتب قائمة من الطلاب إلى ملف CSV. لاحظ، لدينا قائمة من قوائم، حيث تمثل كل قائمة داخلية صفًا لوحدها:\n\nheader = ['Name', 'Age', 'Grade']\nrows = [\n    ['Adam', 22, 90],\n    ['Belal', 23, 92],\n    ['Camal', 24, 91],\n]\n\nنكتبها على النحو التالي:\n\nwith open('../../datasets/students.csv', mode='w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(header)\n    writer.writerows(rows)\n\nملاحظة، يمكنك محاولة فتح الملف مباشرة من مستكشف الملفات. حاول فتحه باستخدام Excel أو Google Sheet أو أي برنامج جداول بيانات آخر. إذا فتحته باستخدام محرر نصوص، سترى البيانات كملف CSV؛ حرفيًا قيم مفصولة بفواصل.\nالآن، دعنا نقرأه كهيكل بيانات في بايثون: كقائمة من القوائم.\n\nwith open('../../datasets/students.csv') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)\n\n['Name', 'Age', 'Grade']\n['Adam', '22', '90']\n['Belal', '23', '92']\n['Camal', '24', '91']\n\n\nلنحاول حساب متوسط درجات الطلاب.\n\nstudents = []\nwith open('../../datasets/students.csv') as file:\n    reader = csv.reader(file)\n    next(reader) # skip the header\n    for row in reader:\n        students.append(row)\n\nالآن بعد أن حفظناها في القائمة students، دعونا نقوم ببعض العمليات الحسابية.\n\ngrades = [s[2] for s in students]\navg = sum(grades) / len(grades)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 2\n      1 grades = [s[2] for s in students]\n----&gt; 2 avg = sum(grades) / len(grades)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nهذا الخطأ متوقع عند قراءة الملفات لأنها دائمًا تعتبر من نوع str، ولذلك نضطر لتحويل القيَم العددية إلى int لفعل عمليات رياضية:\n\ngrades = [int(s[2]) for s in students]\navg = sum(grades) / len(grades)\navg\n\n91.0\n\n\nيمكنك أيضًا قراءة وكتابة البيانات في شكل قاموس باستخدام الكائنات DictReader وDictWriter.\n\nwith open('../../datasets/students.csv') as file:\n    reader = csv.DictReader(file)\n    for row in reader:\n        print(row)\n\n{'Name': 'Adam', 'Age': '22', 'Grade': '90'}\n{'Name': 'Belal', 'Age': '23', 'Grade': '92'}\n{'Name': 'Camal', 'Age': '24', 'Grade': '91'}\n\n\nوالطريقة الموصى بها للتعامل مع البيانات الجدولية (مثل ملفات CSV) هي استخدام مكتبة مثل pandas. توفر هذه المكتبة هيكل بيانات سريع ومرن لمعالجة البيانات وتحليلها. ولا بأس أن تطلع على دليل البداية في مكتبة pandas.\n\nإذا كنت تريد قراءة الملفات وكتابتها بشكل بسيط انظر: open().\nوإذا كنت تريد التعامل مع الملفات المؤقتة فانظر: tempfile.\nوكثير من عمليات التعامل مع الملفات والأدلة تجدها في: shutil.",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>صياغة البيانات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a2_directories.html",
    "href": "chapters/09_files_and_directories/a2_directories.html",
    "title": "18  الدليل",
    "section": "",
    "text": "الدليل\nأحيانًا نريد التعامل مع مجلَّد يحوي مجموعة ملفات، بنقلها أو نسخها أو حذفها ونحو ذلك.\nوالطريق هو الموصل لملفٍّ ما أو دليلٍ ما نحو: datasets/example_root/a/a.txt. وسبق أن بينا أنه على نوعين: مُطلَق ونسبي. وسنعتمد على وحدة pathlib لنرى عمليات تركيب المسار والبحث فيه والاستعلام عن مدلوله ونحو ذلك. وسنبدأ بها.\nلاستعراض عمليات المكتبة، أنشأنا مُسبقًا شجرة تبدأ من دليل example_root تجده داخل datasets في مستودع مشروع الكتاب على النحو التالي:\nالشيء الأساسي الذي نتعامل معه هو المسار (Path):\nيُنشأ المسار من نص أو مجموعة نصوص بينها علامة / (وهي في الأصل علامة قسمة إذا وُضعت بين الأرقام) التي تعني ضم النص إلى المسار.\nلاحظ استعمال النص الخام r'' لكون الحرف \\ له معنىً خاص في نصوص بايثون، فهو يستعمل مثلا \\n للانتقال لسطر جديد. لكن حين نستعمل r'' فإن الحرف \\ لا يعني شيئًا خاصًا.\nملاحظة، عند نسخ المسارات في نظام ويندوز (Windows)، يجب عليك إما استبدال الشرطات المائلة العكسية \\ بالشرطات المائلة الأمامية / أو استخدام السلاسل النصية الخام r'' لتجنب المشاكل (كما فعلنا أعلاه).\nوهكذا نستطيع استعمال الكائن Path في فعل open(file=path) للتعامل مع الملفات:\nولأن الملف يعتبر مدير سياق (Context Manager) فيستحسن الإتيان بجملة السياق with إذ تتكفل بإغلاق الملف تلقائيّا عند نهايتها. وذلك على النحو التالي:\nبدلاً من قراءة الملف جملة واحدة .read() نستطيع القراءة سطرًا بسطر عن طريق الإجراء .readline() على النحو التالي:\nتستعمل .rstrip() لإزالة حرف انتقال السطر \\n .\nانظر قراءة الأدلة.\nلعرض قائمة الدليل، نستعمل المكرر الناتج من فعل .iterdir() ونكرر عليه، وهو بدورِه يُنتج في كل كرةٍ مساراً (x). وهذا المسار يُمكن التحقق من أنه يشير إلى دليل أو لا (x.is_dir()) على النحو التالي:\np = Path('../../datasets/example_root/')\ndirs = [x for x in p.iterdir() if x.is_dir()]\ndirs\n\n[PosixPath('../../datasets/example_root/a'),\n PosixPath('../../datasets/example_root/b'),\n PosixPath('../../datasets/example_root/c')]",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a2_directories.html#تصنيف-عمليات-pathlib-في-بايثون",
    "href": "chapters/09_files_and_directories/a2_directories.html#تصنيف-عمليات-pathlib-في-بايثون",
    "title": "18  الدليل",
    "section": "تصنيف عمليات pathlib في بايثون",
    "text": "تصنيف عمليات pathlib في بايثون\nوإليك تصنيف لعمليات مكتبة pathlib:\n\nعمليات المسار\n\nإنشاء وتعديل المسارات:\n\n.joinpath: دمج مكونات مسار.\n.parent: استخراج الدليل الأب.\n.name: استخراج الاسم الأساسي للملف.\n.stem: استخراج اسم الملف بدون الامتداد.\n.suffix: استخراج امتداد الملف.\n.with_name: إنشاء مسار جديد باسم مختلف.\n.with_suffix: إنشاء مسار جديد بامتداد مختلف.\nrelative_to: إنشاء مسار نسبي.\n\n\n\n\nعمليات على نظام الملفات\n\nاستعلام:\n\nis_absolute: هل هو مطلق؟.\nsamefile: هل مساران يشيران إلى نفس الملف؟.\nexists: هل هو مسار موجود؟.\nis_file: هل هو مسار ملف؟.\nis_dir: هل هو مسار دليل؟.\nis_symlink: هل هو ارتباط رمزي؟.\nstat: سرد إحصائيات نظام الملفات.\nlstat: سرد إحصائيات نظام الملفات دون متابعة الارتباطات الرمزية.\n\nعمليات تغيير:\n\nopen: فتح ملف للقراءة أو الكتابة أو الإضافة.\nmkdir: إنشاء دليل.\nrmdir: حذف دليل فارغ.\nunlink: حذف ملف.\nrename: تعديل اسم ملف.\nreplace: تعديل اسم ملف مع الكتابة فوقه إذا لزم الإجراء.\nchmod: تغيير أذونات الملف.\nlchmod: تغيير أذونات الملف دون متابعة الارتباطات الرمزية.\ntouch: تحديث الطابع الزمني للملف.\n\n\n\n\nالارتباطات الرمزية والصلبة\n\nsymlink_to: إنشاء ارتباط رمزي.\nhardlink_to: إنشاء ارتباط صلب.\nreadlink: قراءة الهدف من ارتباط رمزي.\n\n\n\nالتكرار والبحث\n\niterdir: تكرار على قائمة الدليل.\nglob: البحث عن الملفات المطابقة لنمط.\nrglob: البحث بشكل متكرر عن الملفات المطابقة لنمط.\nwalk: التنقل بشكل متكرر في شجرة الأدلة.",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a2_directories.html#النسخ-والحذف-والنقل-shutil",
    "href": "chapters/09_files_and_directories/a2_directories.html#النسخ-والحذف-والنقل-shutil",
    "title": "18  الدليل",
    "section": "النسخ والحذف والنقل (shutil)",
    "text": "النسخ والحذف والنقل (shutil)\n\nshutil.copy2: نسخ ملف.\nshutil.copytree: نسخ شجرة أدلة.\nshutil.rmtree: حذف شجرة أدلة.\nshutil.move: نقل ملف أو دليل.",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a2_directories.html#المصطلحات",
    "href": "chapters/09_files_and_directories/a2_directories.html#المصطلحات",
    "title": "18  الدليل",
    "section": "المصطلحات",
    "text": "المصطلحات\n\n\n\nالعربية\nالإنجليزية\n\n\n\n\nدليل\nDirectory\n\n\nمجلَّد\nFolder\n\n\nملف\nFile\n\n\nصيغة\nFormat/Extension\n\n\nمخفي\nHidden\n\n\nالطريق/المسار\nPath\n\n\nمُطلَق\nAbsolute\n\n\nنسبي\nRelative\n\n\nالبرمجة الشيئية\nObject-Oriented Programming (OOP)\n\n\nنظام التشغيل\nOperating System (OS)\n\n\nمنخفضة المستوى\nLow-level\n\n\nشجرة\nTree\n\n\nنمط\nPattern\n\n\nالارتباط الرمزي\nSymbolic Link (Symlink)\n\n\nالارتباط الصلب\nHard Link\n\n\nالتكرار\nIteration\n\n\nالبحث\nSearch\n\n\nالنسخ\nCopy\n\n\nالحذف\nDelete/Remove\n\n\nالنقل\nMove\n\n\nالأذونات\nPermissions\n\n\nالطابع الزمني\nTimestamp\n\n\nالدليل الأب\nParent Directory\n\n\nالاسم الأساسي\nBase Name\n\n\nالامتداد\nExtension/Suffix",
    "crumbs": [
      "باب صياغة البيانات",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/b_context.html",
    "href": "chapters/09_files_and_directories/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "تصنيف التغريدات\nلدينا ثلاثة ملفات:\nنريد تصنيف التغريدات بناءً على عدد الكلمات الإيجابية والسلبية فيها.\nfrom pathlib import Path\n\ndata_dir = Path('../../datasets/tweets')\nبعد النظر في شكل الملفات. يتبين لنا أن السطر الواحد يحتوي على “شيء” واحد. وبالتالي سنقسم البيانات على كل سطر.\nونلاحظ أيضًا وجود أسطر خاوية، يجب التخلص منها.\ndef read_lines(file_path: Path) -&gt; list[str]:\n    \"\"\"skips empty lines and converts to lowercase\"\"\"\n    result = []\n    with open(file_path, 'r') as file:\n        for line in file:\n            x = line.strip()\n            if len(x) &gt; 0:\n                x = x.lower()\n                result.append(x)\n    return result\nنستدعي الإجراء لقراءة الملفات الثلاث:\ntweets = read_lines(data_dir / 'tweets.txt')\npositive_words = read_lines(data_dir / 'words_positive.txt')\nnegative_words = read_lines(data_dir / 'words_negative.txt')\nfor i, tweet in enumerate(tweets):\n    print(i, tweet)\n\n0 أشعر بامتنان عميق للأشخاص الرائعين في حياتي! كل يوم معهم هو هدية جميلة\n1 الزهور المتفتحة تملأ المكان بألوانها الزاهية وعطرها الفواح! والعصافير تغرد بأجمل الألحان تحت أشعة الشمس الدافئة! يوم مثالي بكل تفاصيله\n2 الرجل العجوز قدوة في العطاء والكرم! يسعد دائماً بمساعدة الآخرين ويترك أثراً طيباً في كل من حوله! محبوب من الجميع لطيبة قلبه\n3 أتمنى لكم جميعاً يوماً مشرقاً مليئاً بالإنجازات والنجاحات! متحمس جداً لرؤية ابتساماتكم السعيدة!\n4 متحمس جداً للتحديات الجديدة! كل يوم فرصة للتعلم والنمو والتطور!\n5 تعذبت اليوم برحلة مزعجة في طريقي، رأيت مناظر مقرفة من حولي وأنا أتحمل ضجيج الطبيعة المزعجة\n6 صباح سيئ! استيقظت متأخراً وشربت فنجان قهوة مر. متوتر وقلق من لقاء زملائي المزعجين في العمل!\n7 أصوات الحياة من حولي تملأني إرهاقاً! أتعذب بالعمل من المنزل وأشعر بالملل والإحباط!\n8 قضيت أمسية متعبة مع أصدقائي المزعجين! تشاجرنا كثيراً وتذكرنا أسوأ الذكريات! أشعر بالحزن والضيق من وجودهم في حياتي!\nfor p in positive_words:\n    print(p)\n\nممتن\nامتنان\nرائع\nجميل\nهدية\nزاهية\nفواح\nأجمل\nدافئة\nمثالي\nقدوة\nعطاء\nكرم\nيسعد\nمساعدة\nطيب\nمحبوب\nمشرق\nإنجازات\nنجاحات\nمتحمس\nابتسامات\nسعيدة\nتعلم\nنمو\nتطور\nفرصة\nسعيد\nfor n in negative_words:\n    print(n)\n\nتعذب\nمزعج\nمقرف\nضجيج\nسيئ\nمتأخر\nمر\nمتوتر\nقلق\nإرهاق\nأتعذب\nملل\nإحباط\nمتعب\nتشاجر\nأسوأ\nحزن\nضيق\nمزعجين\nمتضايق\nمرهق\nفائت\nغير مرتاح\nوحيد\nحزين\nالآن نقوم بتصنيف التغريدات:\ndef classify(text: str) -&gt; (int, int):\n    \"\"\"Returns the number of positive and negative words in the text\"\"\"\n    \n    positive_count = 0\n    for word in positive_words:\n        if word in text:\n            positive_count += 1\n    \n    negative_count = 0\n    for word in negative_words:\n        if word in text:\n            negative_count += 1\n    \n    return positive_count, negative_count\n\nassert classify('أنا سعيد') == (1, 0)\nassert classify('أنا حزين') == (0, 1)\nassert classify('سعيد حزين اليوم') == (1, 1)\nassert classify('اذهب إلى الدكان') == (0, 0)\nنستدعي الإجراء على التغريدات، ونفرز النتائج في ثلاثة قوائم:\npositive_tweets = []\nnegative_tweets = []\nneutral_tweets = []\nfor tweet in tweets:\n    pos, neg = classify(tweet)\n    score = pos - neg\n    print(f'-{neg} +{pos} = {score:+}')\n    if score &gt; 0:\n        positive_tweets.append((tweet, score))\n    elif score &lt; 0:\n        negative_tweets.append((tweet, score))\n    else:\n        neutral_tweets.append((tweet, score))\n\n-0 +4 = +4\n-0 +5 = +5\n-0 +7 = +7\n-0 +7 = +7\n-0 +5 = +5\n-4 +0 = -4\n-7 +0 = -7\n-5 +0 = -5\n-7 +0 = -7\nنعرض التغريدات بحسب التصنيف مرتبة بقوة التصنيف من الأعلى إلى الأسفل:\nprint('positive_tweets:')\nfor tweet, score in sorted(positive_tweets, key=lambda x: x[1], reverse=True):\n    print(f'{score:+} {tweet}')\n\npositive_tweets:\n+7 الرجل العجوز قدوة في العطاء والكرم! يسعد دائماً بمساعدة الآخرين ويترك أثراً طيباً في كل من حوله! محبوب من الجميع لطيبة قلبه\n+7 أتمنى لكم جميعاً يوماً مشرقاً مليئاً بالإنجازات والنجاحات! متحمس جداً لرؤية ابتساماتكم السعيدة!\n+5 الزهور المتفتحة تملأ المكان بألوانها الزاهية وعطرها الفواح! والعصافير تغرد بأجمل الألحان تحت أشعة الشمس الدافئة! يوم مثالي بكل تفاصيله\n+5 متحمس جداً للتحديات الجديدة! كل يوم فرصة للتعلم والنمو والتطور!\n+4 أشعر بامتنان عميق للأشخاص الرائعين في حياتي! كل يوم معهم هو هدية جميلة\nprint('negative_tweets:')\nfor tweet, score in sorted(negative_tweets, key=lambda x: x[1]):\n    print(f'{score:+} {tweet}')\n\nnegative_tweets:\n-7 صباح سيئ! استيقظت متأخراً وشربت فنجان قهوة مر. متوتر وقلق من لقاء زملائي المزعجين في العمل!\n-7 قضيت أمسية متعبة مع أصدقائي المزعجين! تشاجرنا كثيراً وتذكرنا أسوأ الذكريات! أشعر بالحزن والضيق من وجودهم في حياتي!\n-5 أصوات الحياة من حولي تملأني إرهاقاً! أتعذب بالعمل من المنزل وأشعر بالملل والإحباط!\n-4 تعذبت اليوم برحلة مزعجة في طريقي، رأيت مناظر مقرفة من حولي وأنا أتحمل ضجيج الطبيعة المزعجة\nprint('neutral_tweets:')\nfor tweet, score in neutral_tweets:\n    print(f'{score} {tweet}')\n\nneutral_tweets:",
    "crumbs": [
      "باب صياغة البيانات",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/b_context.html#تصنيف-التغريدات",
    "href": "chapters/09_files_and_directories/b_context.html#تصنيف-التغريدات",
    "title": "تطبيقات",
    "section": "",
    "text": "الأول يحوي تغريدات\nالثاني يحوي كلمات إيجابية\nالثالث يحوي كلمات سلبية",
    "crumbs": [
      "باب صياغة البيانات",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html",
    "href": "chapters/12_oop/a1_objects.html",
    "title": "19  الأنواع",
    "section": "",
    "text": "البرمجة الشيئية\nوقد عرفنا أن من طرائق البرمجة في بايثون:\nوقد كنا نتعامل مع أشياء طيلة هذه الفترة؛ بدءًا بالرقم (Number) ومرورًا بفروعه: (int) و (float) و (bool)، مرورًا بالقائمة (list) والصف (tuple) والنطاق (range) والنص (str)، وكذلك المجموعة (set) والقاموس (dict).\nوكل الأنواع من نوع شيء (Object). ثم تتفرع الأنواع وتتفرع. وقد يدخل النوع في أكثر من نوع بحسب الاعتبار (يأتي تفصيله).\nففكرة البرمجة الشيئية تدور حول إسناد المتغيرات والإجراءات لشيء مُعَيَّنٍ من نوع ما. ونشبه هذه الأشياء بالمحسوسات فيقال أنها أشياء ذات صفات وأفعال؛ إشارةً إلى المتغيرات والإجراءات المسندة إليها. ومن هذه الأفعال ما يكون بين الأشياء؛ فهو تفاعل بين نوع ونوع.\nفمثلاً: نوع القائمة (list) يُنشأُ مِنهُ قائمة معيَّنة (هي الشيء: xs = [1, 2, 3]) يُسنَدُ إليها إجراءات الإضافة (xs.append) والحذف (xs.remove) والتعديل (xs[i] = x) ونحو ذلك.\nوأما التفاعلات؛ فهي علي قسمين:\nالأول: بين الشيء ونظيره (من نفس النوع)؛ وذلك نحو تعريف: list + list = list بحيث تعرَّف علامة + بين الشيئين بعملية الدمج (لا الجمع). وكان من الممكن أن تعرَّف بأنها جمع.\nالثاني: بين الشيء وخلافه (من نوع آخر)؛ وذلك نحو: list.append(Any) فإن القائمة تقبل في فعل الإلحاق (append) أي نوع. ويمكن تقييد النوع الذي يقبله الفعل كما كنا نفعل في الإجراءات؛ إذْ الأفعال ما هي إلا إجراءات مُسندة إلى نوع.",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html#البرمجة-الشيئية",
    "href": "chapters/12_oop/a1_objects.html#البرمجة-الشيئية",
    "title": "19  الأنواع",
    "section": "",
    "text": "الشيء",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html#تعريف-النوع",
    "href": "chapters/12_oop/a1_objects.html#تعريف-النوع",
    "title": "19  الأنواع",
    "section": "تعريف النوع",
    "text": "تعريف النوع\nالشيء: صفات وأفعال.\nتأمل المثال التالي:\n\nclass Counter:\n    def __init__(self, count):\n        self.count = count\n    \n    def increment(self, by=1):\n        self.count += by\n\n\nالنوع (Class): Counter\nالصفات (Properties): فقط count\nالأفعال (Methods): increment\n\nلاحظ:\n\nيتم إسناد المتغيرات للمعيَّن في فعل الإنشاء __init__\nتتقدَّم self (نفس) كعامل في الابتداء في جميع الأفعال؛ وهي تشير إلى الشيء المعيَّن (Instance) ؛ أي: أحد أفراد النوع.\n\n\nإنشاء المعيَّنات\nالمعيَّن: أحد أفراد النوع.\nويسمى الفعل المخصوص __init__ بفعل الإنشاء (Initialization). وذلك أنه يتم تنفيذه عند استدعاء النوع هكذا:\n\nc1 = Counter(10)\n\nونشير للصفة بعلامة النقطة: c1.count والفعل كذلك: c1.increment() على النحو التالي:\n\nprint(c1.count)\nc1.increment(2)\nc1.increment(3)\nprint(c1.count)\n\n10\n15\n\n\nوهذا معيَّن آخر من نفس النوع:\n\nc2 = Counter(0)\n\nprint(c1.count)\nprint(c2.count)\n\n15\n0",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html#تغليف-العمليات",
    "href": "chapters/12_oop/a1_objects.html#تغليف-العمليات",
    "title": "19  الأنواع",
    "section": "تغليف العمليات",
    "text": "تغليف العمليات\nالتغليف (Encapsulation) آلية لإخفاء عمليات تفصيلية معقدة على البيانات المكنونة خلف إجراءات بسيطة.\nفحينما عرفنا المتغير كصفة: count في الشيء Counter، أبرزنا من الإجراءات: increment فقط. وكأننا نقول: لا يمكن أن يعدِّل المستفيد على المتغير count إلا عن طريق الإجراء increment. وصحيح أنك تستطيع الوصول من الخارج إلى صفة المعيَّن: c1.count لتعديلها مباشرةً، إلا أن ذلك يخالف آلية التغليف.\nفي المثال التالي لا نريد للمستفيد أن يعدِّل على الرصيد balance إلا عن طريق الإجراء deposit الذي يضمن أمرين:\n\nقبليات (pre-conditions): كاشتراط أن الزيادة تكون موجبة قبل البدء\nبعديات (post-conditions): ضمان تسجيل تاريخ العملية بعد التمام\n\nيتم ذلك في بايثون عن طريق جعل الصفة نفسها (balance) مخفيَّة، ونبدلها بصفة محميَّة: __balance بشرطتين سفليتين متقدِّمة. ثم نُبرِزُ الصفة عن طريق فعل قراءة؛ وذلك باستعمال المعدِّل @property، وهو يجعل الفعل balance يبرز كصفة بلا قوسين للاستدعاء balance() وذلك يعني أن مجرَّد عملية الوصول إلى الصفة (بعلامة النقطة: .) هو في الحقيقة استدعاء لفعل يعود بقيمة، لا بالصفة التي يمكن تعديلها.\n\nclass Account:\n    def __init__(self, name, balance):\n        self.name = name\n        self.__balance = balance\n\n    # الإيداع\n    def deposit(self, amount):\n        # قبليات الإيداع\n        if amount &lt;= 0:\n            print(\"must be positive\")\n            return\n        \n        # الإيداع نفسه\n        self.__balance += amount\n\n        # بعديات الإيداع\n        print('time of deposit:', '2027-07-07')\n\n    @property\n    def balance(self):\n        return self.__balance\n\nنقوم الآن بإنشاء هذا الشيء الذي يمثِّل حساب المستخدم (Account)، ثم نصِل إلى الصفة بعلامة النقطة: a1.balance؛ فيكون ذلك استدعاءً للإجراء الذي تم وضع المعدِّل @property عليه ليكون الوصول إليه كالصفة:\n\na1 = Account('Adam', 100)\na1.balance\n\n100\n\n\nولو حاولت التغيير مباشرة على الصفة فإنك أصلاً لن تجد اسمها مُسندًا إلى الشيء:\n\na1.balance = 1000\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[26], line 1\n----&gt; 1 a1.balance = 1000\n\nAttributeError: property 'balance' of 'Account' object has no setter\n\n\n\nلكن يجوز فقط قراءة الصفة (قيمتها) لا التعديل عليها، هكذا (بعد الإيداع مثلاً):\n\na1.deposit(100)\na1.balance\n\ntime of deposit: 2027-07-07\n\n\n200\n\n\nوليظهر أثر الحماية، نجرِّب إيداع مبلغ سالب، ولاحظ رسالة الخطأ:\n\na1.deposit(-44)\n\nmust be positive\n\n\nوهكذا نتصوَّر الشيء كأنه آلة مزوَّّدة بآليات عامَّة يسهل استعمالها في ظروف كثيرة بحيث تغير هذه الآليات من حالة الشيء في كل مرة ليؤدي وظائف معقَّدة لا تتم بسهول بمجرَّد إجراء ذو خطوات محددة دائمًا بتسلسل واحد.",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html#العرض",
    "href": "chapters/12_oop/a1_objects.html#العرض",
    "title": "19  الأنواع",
    "section": "العرض",
    "text": "العرض\nنريد أن نعرِّف نوعًا جديدًا للإحداثيات (Point) ونريد أن نعرضها في جملة print بتمثيل يعبِّر عنها كإحداثيات.\nيستعمل الفعل الخاص __repr__، ويعني التمثيل (Representation) لتخصيص طريقة عرض الشيء؛ سواءٌ إذا تم تمرير في print أو في آخر سطر من الخلية. كل ما عليك هو إعادة قيمة نصيَّة من ذلك الفعل.\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\nوالآن إن عرفنا نقطة جديدة، ووضعناها على السطر لوحدها ، ستظهر لنا الإحداثيات، لا عنوانها في الذاكرة:\n\np = Point(3, 4)\np.move(7, 6)\np\n\nPoint(10, 10)",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html#الإجراء-الثابت",
    "href": "chapters/12_oop/a1_objects.html#الإجراء-الثابت",
    "title": "19  الأنواع",
    "section": "الإجراء الثابت",
    "text": "الإجراء الثابت\nالإجراء الثابت: هو الإجراء المسند إلى النوع لا للمعيَّن.\nفيمكن إسناد الإجراء للجنس لا للشيء الواحد، وذلك بإضافة المعدِّل @staticmethod عليه. ونمثل لذلك بإجراء حساب المسافة بين نقطتين: distance. ولاحظ عدم وجود self فيه:\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2, distance_type='euclidean'):\n        if distance_type == 'euclidean':\n            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n        elif distance_type == 'manhattan':\n            return abs(p1.x - p2.x) + abs(p1.y - p2.y)\n\nثم يستعمل كأي إجراء، لكن بإسناده إلى النوع:\n\np1 = Point(3, 4)\np2 = Point(7, 6)\nd = Point.distance(p1, p2, 'manhattan')\nprint('distance:', d)\n\ndistance: 6",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html#المتغير-الثابت",
    "href": "chapters/12_oop/a1_objects.html#المتغير-الثابت",
    "title": "19  الأنواع",
    "section": "المتغير الثابت",
    "text": "المتغير الثابت\nالمتغير الثابت: هو المتغير المسند إلى النوع لا للمعيَّن.\nيُسنَد المتغير للنوع بتعيينه بمحاذاة غيره من الإجراءات نحو ما فعلنا هنا بالمتغير decor. ولاحظ استعماله في الإجراء __repr__ في جملة if-else من غير استعمال self لأننا لا نشير إلى معيَّن.\n\nclass Point:\n    decor = '&lt;&gt;'\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        if Point.decor == '&lt;&gt;':\n            return f\"&lt;{self.x}, {self.y}&gt;\"\n        elif Point.decor == '[]':\n            return f\"[{self.x}, {self.y}]\"\n        else:\n            return f\"({self.x}, {self.y})\"\n\nفيمكن الآن تعديل المتغير decor للنوع:\n\np1 = Point(3, 4)\np2 = Point(7, 6)\nprint(p1, p2)\n\nPoint.decor = '[]'\nprint(p1, p2)\n\n&lt;3, 4&gt; &lt;7, 6&gt;\n[3, 4] [7, 6]",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a1_objects.html#هيكل-البيانات",
    "href": "chapters/12_oop/a1_objects.html#هيكل-البيانات",
    "title": "19  الأنواع",
    "section": "هيكل البيانات",
    "text": "هيكل البيانات\nتختلف كفاءة استرجاع البيانات وكتابتها والتعديل عليها بحسب شكل هذه البيانات في الذاكرة وشكلها على جهاز التخزين فعليًّا. وهذا ما نسميه بهيكلة البيانات (Data Structure). ومن أمثلة ذلك:\n\nالمصفوفة (Array)\nالشجرة (Tree)\nالرسم (Graph)\n\nوغيرها كثير. وسنمثل على ذلك بتشكيل الكومة في بايثون:\n\nالكومة (Stack)\nنريد أن نعرِّف نوعًا من هياكل البيانات يسمى الكومة (Stack)، وكأنه يمثِّل مجموعة مكدسة من الأوراق؛ إذ له فعلين:\n\nوضع ورقة: push(item) وكأنك تضع ورقة فوق الأوراق السابقة\nسحب ورقة: pop() وكأنك تسحب ورقةً من الأعلى\nلمحة سريعة: peek() وكأنك تنظر إلى الورقة العليا دون سحبها\n\nوأقرب شيء له في بايثون هو القائمة (list) ولذلك ستكون هي تمثيلها الداخلي.\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        return self.items.pop()\n    \n    def peek(self):\n        return self.items[-1]\n\n    def __repr__(self):\n        return f\"|{'|'.join(str(item) for item in self.items)}&gt;\"\n\n\nفعل الإنشاء يُسنِد قائمة فارغة إلى الشيء (self)\nفعل push يضيف إلى آخر هذه القائمة بالفعل append\nفعل pop يأخذ آخر عنصر من القائمة بالفعل pop (وهو إزالة مع أخذ)\nفعل __repr__ يعطينا تمثيلاً للكومة بالاعتماد على تمثيل القائمة\n\nنجرب الآن أن ننشئها ثم نضع أربعة عناصر فيها ونظهرها:\n\ns = Stack()\ns.push(10)\ns.push(20)\ns.push(30)\ns.push(400)\nprint(s)\n\n|10|20|30|400&gt;\n\n\nوالآن نسحب عنصرًا (من الأخير)، ونظهرها:\n\ns.pop()\nprint(s)\n\n|10|20|30&gt;\n\n\nويمكن النظر في العنصر الأعلى دون سحبه بالفعل peek:\n\nprint(s.peek())\n\n30",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a2_composition.html",
    "href": "chapters/12_oop/a2_composition.html",
    "title": "20  استمداد الأنواع",
    "section": "",
    "text": "الوراثة\nتستمد الأنواع بأحد طريقتين:\nالأولى: التخصيص؛ كأن تقول المبرَّبع نوع خاص من المستطيلات. وكذلك تقول: المستطيل نوع خاص من الأشكال. وبالتالي فإن علاقة المربَّع بالشكل هي علاقة خاص من عام.\nالثاني: التركيب؛ كأن تقول: الإنسان حيّ والجمل حيّ فكلاهما حيّ. وتقول: الجمل مركوب والسيارة مركوبة؛ فكلاهما مركوبٌ. فيكون الجملُ مركَّبًا بالاعتبارين معًا: (مركوبًا حيًّا).\nوالتصخيص يسمى الوراثة؛ وهو يحتاج لرعاية جميع السلسلة الوراثية ليكون التفريع عنها ذا معنى؛ وذلك صعبٌ ضبطه في الواقع. أما التصنيف الاعتباري فاستعمالها أسهل لكوْن التصنيف المتأخِّر لا يحتاج مراعاة سلسلة معقَّدة أو طويلة من الوراثة.\nالتخصيص بالوراثة (Inheritence): أن يندرج النوع تحت نوعٍ آخر؛ فهو يستمد منه ويزيد عليه صفةً أو فعلاً (أو أكثر). وهو اسميٌّ لأن المعتبر هو أسماء الأنواع؛ فتقول:\nوهذه شجرة التوارث للأنواع المذكورة:\nflowchart BT\n  Shape\n  Rectangle -- \"is a\" --&gt; Shape\n  Square -- \"is a\" --&gt; Rectangle\n  Triangle -- \"is a\" --&gt; Shape\nتذكَّر أن علامة النجمة * في وصف متغيرات الإجراء المُنشئ __init__ (*sides) تجعل عدد عناصره لا محدودة؛ وذلك لأننا لا نريد حصر عدد أضلاع الشكل إلا لاحقًا عند تخصيصه؛ ففي المربَّع سيكون أربعة، وفي المثلث يسكون ثلاثة، وهكذا.\nclass Shape:\n    def __init__(self, *sides):\n        self.sides = sides\n    \n    @property\n    def perimeter(self):\n        return sum(self.sides)\n    \n    @property\n    def area(self):\n        pass\nوليس ثمة شيء هو شكلٌ فقط، ولذلك نعتبر هذا النوع، نوعًا مُجرَّدًا (Abstract)، إذ لن نستعمله مباشرةً أبدًا، بل سنخصصه أولاً. فأول نوع سيرث منه هو المستطيل (Rectangle).\nولاحظ في Rectangle استعمال الإجراء الخاص super() وهو يشير إلى الموروث Shape؛ فيصير معنى الجملة ( super().__init__()) وكوْنها في أوَّل سطرٍ من جملة إجراء الإنشاء: الإنشاء فوق الإنشاء الموروث.\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        super().__init__(width, height, width, height)\n    \n    @property\n    def width(self):\n        return self.sides[0]\n    \n    @property\n    def height(self):\n        return self.sides[1]\n    \n    @property\n    def area(self):\n        return self.width * self.height\nأما المربع، فهو نوعٌ خاص من المستطيل:\nclass Square(Rectangle):\n    def __init__(self, side):\n        super().__init__(side, side)\nوأما المثلث، فهو من الشكل:\nclass Triangle(Shape):\n    def __init__(self, a, b, c):\n        super().__init__(a, b, c)\n\n    @property\n    def a(self):\n        return self.sides[0]\n    \n    @property\n    def b(self):\n        return self.sides[1]\n    \n    @property\n    def c(self):\n        return self.sides[2]\n    \n    @property\n    def area(self):\n        s = self.perimeter / 2\n        return (s * (s - self.a) * (s - self.b) * (s - self.c))**0.5\nوالآن ستلاحظ إمكانية استعمال الشيئين المختلفين (المثلث والمستطيل) باعتبار المشترك بينهما (الشكل). ويتبين ذلك إذا كررنا عليهما في قائمة:\nx = Triangle(10, 10, 10)\ny = Rectangle(10, 20)\nshapes = [x, y]\n\nfor sh in shapes:\n    print(sh.__class__.__name__)\n    print(\"Perimeter:\", sh.perimeter)\n    print(\"Area:\", round(sh.area, 2))\n    print('='*40)\n\nTriangle\nPerimeter: 30\nArea: 43.3\n========================================\nRectangle\nPerimeter: 60\nArea: 200\n========================================\nواستعمال instance.__class__.__name__ يعطي اسم النوع الذي ينتمي إليه الشيء.\nلكنهما يفترقان في بعض الصفات إذ:\nويمكن فحص النوع باستعمال الإجراء isinstance(instance, class) لمعرفة ما إذا كان الشيء ينتمي إلى ذلك النوع أو لا.\nfor sh in shapes:\n    if isinstance(sh, Rectangle):\n        print(f\"Sides: width={sh.width}, height={sh.height}\")\n    elif isinstance(sh, Triangle):\n        print(f\"Sides: a={sh.a}, b={sh.b}, c={sh.c}\")\n\nSides: a=10, b=10, c=10\nSides: width=10, height=20\nوذلك ينطبق في تعريف الإجراءات. فإنك تستطيع تحديد النوع الأعم وتمرير النوع الأخص.\nفهو في التعريف عام:\ndef show(sh: Shape):\n    print(sh.__class__.__name__)\n    print(\"Perimeter:\", sh.perimeter)\n    print(\"Area:\", round(sh.area, 2))\nوفي التمرير خاص:\nx = Triangle(10, 10, 10)\nshow(x)\n\ny = Rectangle(10, 20)\nshow(y)\n\nTriangle\nPerimeter: 30\nArea: 43.3\nRectangle\nPerimeter: 60\nArea: 200",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>استمداد الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a2_composition.html#الوراثة",
    "href": "chapters/12_oop/a2_composition.html#الوراثة",
    "title": "20  استمداد الأنواع",
    "section": "",
    "text": "الشكل: ما كان له محيط\nوالمستطيل شكلٌ (إذًا له محيط) و فوق ذلك فإنه له: طولًا وعرضًا ومساحة\nووالمثلث شكلٌ (إذًا له محيط) و فوق ذلك فإنه له: ثلاثةَ أضلاعٍ ومساحة\nأما المربع فهو مستطيل (إذًا له محيط لأن المستطيل شكل، وله طول وعرض ومساحة): لكن عرضه وطوله متساويان\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nالمستطيل له طول وعرض\nالمثلث له ثلاثة أضلاع\n\n\n\n\n\n\n\n\n\nأمثلة على الوراثة\nوتجد في شجرة المجموعات شكل 1 أن المجموعات المتغيرة نوع مخصص من الأنواع الجامدة:\n\nالقائمة (list) مخصصة من التسلسل المتغير (MutableSequence) الذي هو من نوع التسلسل (Sequence).\nالمجموعة (set) مخصصة من المجموعة المتغيرة (MutableSet) التي هي من نوع المجموعة (Set).\nالقاموس (dict) مخصص من المقابلة المتغيرة (MutableMapping) الذي هو من نوع المقابلة (Mapping).",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>استمداد الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a2_composition.html#التركيب",
    "href": "chapters/12_oop/a2_composition.html#التركيب",
    "title": "20  استمداد الأنواع",
    "section": "التركيب",
    "text": "التركيب\nالتركيب (Composition) ويسمى بالإنجليزية أحيانًا (Duck Typing) إشارة إلى العبارة: “إذا كان الشيء يمشي مثل البطة، ويبطبط مثلها؛ فإنه يعامَل كالبطة!”.\nومثال التركيب في نفس شجرة المجموعات في بايثون شكل 1 هو نوع الجمع (Collection)، حيث له ثلاثة اعتبارات:\n\nالجمع ذو أعضاء: كونه يقبل العضويَّة: x in s وفعلها هو: __contains__؛ وبذلك يصنَّف أنه حاوٍ (Container)\nالجمع ذو تكرار: كونه يقبل التكرار: for x in s وفعله هو: __iter__؛ وذبك يصنف أنه مكرَّر (Iterable)\nالجمع ذو عدد: كونه يقبل العد: len(s) وفعله هو: __len__؛ يصنف أنه محجَّم (Sized)\n\nوكذلك التسلسل (Sequence)؛ فهو يقبل العكس، وفعلها المخصص هو: __reversed__؛ فبهذا الاعتبار هو من النوع القابل للعكس (Reversible).",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>استمداد الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a2_composition.html#النوع-المجرد",
    "href": "chapters/12_oop/a2_composition.html#النوع-المجرد",
    "title": "20  استمداد الأنواع",
    "section": "النوع المجرَّد",
    "text": "النوع المجرَّد\nتعرَّف عناصر المركبات على أنها أنواع مجرَّدة (Abstract Base Classes) ليس لها وجود في ذاتها، لكن ينتمي إليها النوع الذي يحتوي على إجراءاتها.\nتأمل المثال المأخوذ من تفاصيل المكتبة الأساسية في بايثون نفسها:\nfrom abc import abstractmethod\n\nclass Sized:\n\n    @abstractmethod\n    def __len__(self) -&gt; int:\n        return 0\n    \ndef len(sized: Sized) -&gt; int:\n    return sized.__len__()\n\nعرفنا النوع المجرَّد Sized (مُحجَّم) بأن له فعلاً واحدًا مجرَّدًا: __len__ وذلك لوجود المعدِّل @abstractmethod حكمنا أنه مجرد.\nعرفنا إجراءً ليس في داخل هذا الصنف، بل هو إجراء عام كأي إجراء، وجعلنا عامله يكون من جنس ذلك المجرَّد: Sized\n\nوهو بالتالي يقوم باستدعاء الفعل المخصص __len__ للشيء الذي يمرر إليه.\n\n\nبهذه الطريقة فإننا حين نعرِّف أي صنف جديد ونمرره إلى ذلك الإجراء، فإنَّه يبحث عن الفعل __len__ فيه، ويقوم باستدعائه. وتسمى هذه الخاصيَّة تعدد الأشكال (Polymorphism): أي أن الإجراء الواحد يقبل أنواع مختلفة لوجود فعل مشترك بينها.\nويكثر في لغة (جو: Golang) المجرَّداتُ ذات الإجراء الواحد أو الإجراءين. لأننا نريد أشياء كثيرة تنتمي بحسب ما يكون فيها من إجراءات.\n\nتكوين نوع مركَّب\nونمثل لذلك بصنف المتجَّه على النحو التالي:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __len__(self):\n        return 2\n\nفبتعريفنا لفعل معرفة الطول (__len__)، يُعتبر المتجَّه من جنس المحجَّمات (Sized) ولذلك يقبل تمريره إلى إجراء العد (len(Sized)). وانضم بذلك إلى المجموعات مثل القائمة (list) والمجموعة (set) وغيرهما. ولاحظ عدم وجود ذكر للنوع Sized البتة، بل المُعتَبَرُ وجود الإجراء __len__ حتى يُقبل الشيء في len.\nفحين ننشيئ معيَّنًا من هذا الصنف، ثم نمرره للإجراء len فإنه يتصرف كغيره من الجموع:\n\nv = Vector(10, 20)\nprint(len(v))\n\nxs = [10, 20, 30]\nprint(len(xs))\n\n2\n3\n\n\nولتحقق أكثر، لاحظ أنك تستطيع استعمال الفعل المخصوص نفسه (بالشرطتين):\n\nassert len(v) == v.__len__()\nassert len(xs) == xs.__len__()\n\nوالفعل الذي يكون اسمه محصورًا بشرطتين سفليتين نحو: __add__ فإنَّه من الأفعال المخصوصة بشيء من التراكيب اللغوية في بايثون. فهذا الفعل -مثلاً- ينوب عنه في لغة بايثون علامة الجمع: +.",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>استمداد الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a3_operators.html",
    "href": "chapters/12_oop/a3_operators.html",
    "title": "21  المعاملات المخصصة",
    "section": "",
    "text": "معاملات الأرقام\nتأمل التالي وتوقَّع النتيجة وعلل إجابتك. ما هي نتيجة:\nالقطعة الأولى:\nالقطعة الثانية:\nالقطعة الثالثة:\nالقطعة الرابعة:\nكل الذي سبق، قد تم تعريفه في بايثون لهذه الأنواع التي تراها بالتحديد عن طريق إجراءات مخصصة. وإليك هذا الجدول للمعاملات المخصصة:\n(وانظر توثيق بايثون لمحاكاة العمليات الرقمية).\nفنستطيع تعريف نوع المتجَّه (Vector2D) على النحو التالي.\nclass Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"&lt;{self.x}, {self.y}&gt;\"\n    \n    def __add__(self, other):\n        return Vector2D(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Vector2D(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, other):\n        return Vector2D(self.x * other.x, self.y * other.y)\nففي الجمع والطرح والضرب، يكون العائد متجهًا جديدًا هو حاصل العملية على أفراد العناصر المتقابلة بين المتجهين self و other. حيث يمثل الأوَّل (self) المتجَّه في الطرف الأيسر من المعامل، والثاني (other) في الطرف الأيمن.\nوالآن يمكننا إنشاء متجهين ووضع المعاملات بينهما:\nv1 = Vector2D(1, 2)\nv2 = Vector2D(3, 4)\n\nv1 + v2\n\n&lt;4, 6&gt;\nv1 - v2\n\n&lt;-2, -2&gt;\nv1 * v2\n\n&lt;3, 8&gt;\nماذا لو أردنا إضافة عمليات بين المتجه والعدد، نحو: v1 + 3? يتطلب ذلك إضافة شرط لفحص النوع، وهو isinstance كالتالي:\nclass Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x + other.x, self.y + other.y)\n        else:\n            return Vector2D(self.x + other, self.y + other)\n    \n    def __sub__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x - other.x, self.y - other.y)\n        else:\n            return Vector2D(self.x - other, self.y - other)\n    \n    def __mul__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x * other.x, self.y * other.y)\n        else:\n            return Vector2D(self.x * other, self.y * other)\nوهكذا يصبح التفاعل بين المتجَّه والعدد، وهما نوعان مختلفان (int و Vector):\nv1 = Vector2D(1, 2)\nv1 + 3\n\nVector(4, 5)\nلكن لاحظ أنك لو وضعت العدد أولاً فسيظهر خطأ:\n3 + v1\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 3 + v1\n\nTypeError: unsupported operand type(s) for +: 'int' and 'Vector2D'\nهذا لأن عملية الجمع الآن لا تنظر في نوع العدد (int) ولا تجد فيه قبولاً للمتجه (فقد عرفناه للتو). ولحل هذه المشكلة توفر بايثون لكل فعل مخصص مقابل يبدأ بحرف r على النحو التالي:\nنعدل الإجراء بحيث نضيف إليه المقابل:\nclass Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x + other.x, self.y + other.y)\n        else:\n            return Vector2D(self.x + other, self.y + other)\n\n    def __radd__(self, other):\n        return self + other\nوالآن كلاهما يعمل بشكل صحيح:\nv1 = Vector2D(1, 2)\n3 + v1\n\nVector(4, 5)\nv1 + 3\n\nVector(4, 5)",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>المعاملات المخصصة</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a3_operators.html#معاملات-الأرقام",
    "href": "chapters/12_oop/a3_operators.html#معاملات-الأرقام",
    "title": "21  المعاملات المخصصة",
    "section": "",
    "text": "مثال\nالإجراء\n\n\n\n\nself + other\n__add__\n\n\nself - other\n__sub__\n\n\nself * other\n__mul__\n\n\nself / other\n__truediv__\n\n\nself // other\n__floordiv__\n\n\nself % other\n__mod__\n\n\nself ** other\n__pow__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nالمعامل\nالإجراء\n\n\n\n\nother + self\n__radd__\n\n\nother - self\n__rsub__\n\n\nother * self\n__rmul__\n\n\n\n\n\n\n\n\n\nإطلاق العناصر\nوهذا مثال لعدم تقييد المتجَّه بعنصرين (x, y) بل نستطيع إطلاق عدد العناصر باستعمال التسلسل وجعل عناصره عشرية: Sequence[float] ثم تحويل أي تسلسل إلى قائمة: list(components) في إجراء الإنشاء: init على النحو التالي:\n\nfrom typing import Sequence\n\nclass Vector:\n    def __init__(self, components: Sequence[float]):\n        self.components = list(components)\n    \n    def __repr__(self):\n        return f\"&lt;{', '.join(str(c) for c in self.components)}&gt;\"\n    \n    # جمع متجهين أو متجه وعدد\n    def __add__(self, other):\n        # لتخزين الناتج: ننشئ قائمة من الأصفار بنفس طول المتجه\n        result = Vector([0.0] * len(self.components))\n        # إذا كان المدخل متجهًا\n        if isinstance(other, Vector):\n            # يجب أن يكون لهما نفس عدد العناصر\n            assert len(self.components) == len(other.components), f\"Vectors must have the same number of components: {len(self.components)} != {len(other.components)}\"\n            # نجمع العناصر المتقابلة\n            for i in range(len(self.components)):\n                result.components[i] = self.components[i] + other.components[i]\n        # إذا كان المدخل عددًا\n        elif isinstance(other, (float, int)):\n            # نجمع العدد إلى كل عنصر\n            for i in range(len(self.components)):\n                result.components[i] = self.components[i] + other\n        else:\n            raise TypeError(f\"Unsupported operand type(s) for +: 'Vector' and '{type(other)}'\")\n        return result\n    \n    # الجمع حيث يكون المتجه ثانيًا\n    def __radd__(self, other):\n        return self + other\n\n    # وضع علامة السالب للمتجه\n    def __neg__(self):\n        return Vector([-c for c in self.components])\n\n    # الطرح: تطبيقه عن طريق الجمع مع عكس الثاني\n    def __sub__(self, other):\n        return self + (-other)\n    \n    # الطرح حيث يكون المتجه ثانيًا\n    def __rsub__(self, other):\n        return other + (-self)\n    \n    # ضرب متجهين أو متجه وعدد\n    def __mul__(self, other):\n        # لتخزين الناتج: ننشئ قائمة من الأصفار بنفس طول المتجه\n        result = Vector([0.0] * len(self.components))\n        if isinstance(other, Vector):\n            # يجب أن يكون لهما نفس عدد العناصر\n            assert len(self.components) == len(other.components), f\"Vectors must have the same number of components: {len(self.components)} != {len(other.components)}\"\n            # نضرب العناصر المتقابلة\n            for i in range(len(self.components)):\n                result.components[i] = self.components[i] * other.components[i]\n        # إذا كان المدخل عددًا\n        elif isinstance(other, (float, int)):\n            # نضرب العدد في كل عنصر\n            for i in range(len(self.components)):\n                result.components[i] = self.components[i] * other\n        else:\n            raise TypeError(f\"Unsupported operand type(s) for *: 'Vector' and '{type(other)}'\")\n        return result\n    \n    # الضرب حيث يكون العدد أولًا\n    def __rmul__(self, other):\n        return self * other\n\nوالآن يمكننا إنشاء متجهين ووضع المعاملات بينهما:\n\nv1 = Vector((1, 2))\nv2 = Vector((3, 4))\n\nprint(v1 + v2)\nprint(v1 - v2)\n\n&lt;4, 6&gt;\n&lt;-2, -2&gt;\n\n\n\nv1 * v2\n\n&lt;3, 8&gt;\n\n\n\nv1 * 2\n\n&lt;2, 4&gt;\n\n\n\n2 * v1\n\n&lt;2, 4&gt;",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>المعاملات المخصصة</span>"
    ]
  },
  {
    "objectID": "chapters/12_oop/a3_operators.html#معاملات-الحاويات",
    "href": "chapters/12_oop/a3_operators.html#معاملات-الحاويات",
    "title": "21  المعاملات المخصصة",
    "section": "معاملات الحاويات",
    "text": "معاملات الحاويات\nوقد تعرَّفنا على القائمة (dict) التي تقبل مثل هذه العمليات. فهل نستطيع أن نعرِّف هذه العمليات لنوع جديد؟ الجواب: نعم. تسمي بايثون الحروف والعلامات المستعملة مع أنواع الجموع: معاملات الحاويات (أي: التي تحوي عناصر). وهذ ملخصها من توثيق بايثون (محاكاة أنواع الحاويات):\n\nالعد: len(s) يُسمَّى فعله: __len__\nالعضويَّة: x in s يُسمَّى فعله: __contains__\nالتكرار: for x in s يُسمَّى فعله: __iter__\nالإشارة: s[i] يُسمَّى فعلها: __getitem__\nالتعيين: s[i] = p يُسمَّى فعله: __setitem__\nالحذف: del s[i] يُسمَّى فعله: __delitem__\n\n\nالمثال الأول: المضلع\nيتكون المضلَّح من نقاط. فنحتاج أولاً لتعريف النقطة:\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n    \n    # التمثيل\n    def __repr__(self) -&gt; str:\n        return f\"Point({self.x}, {self.y})\"\n    \n    # حساب المسافة\n    @staticmethod\n    def distance(p1: 'Point', p2: 'Point') -&gt; float:\n        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n\nثم نعرف المضلَّع أنه نوع حاوية لمجموعة من النقاط:\n\nclass Polygon:\n    def __init__(self, points: list[Point]):\n        self.points = points\n\n    # العد\n    def __len__(self) -&gt; int:\n        return len(self.points)\n    \n    # الإشارة\n    def __getitem__(self, i: int) -&gt; Point:\n        return self.points[i]\n\n    # التعيين\n    def __setitem__(self, i: int, p: Point):\n        self.points[i] = p\n\n    # الحذف\n    def __delitem__(self, i: int):\n        del self.points[i]\n\n    # حساب المحيط\n    def perimeter(self) -&gt; float:\n        n = len(self.points)\n        s = 0\n        for i in range(n):\n            s += Point.distance(self.points[i], self.points[(i+1)%n])\n        return s\n    \n    # التمثيل\n    def __repr__(self) -&gt; str:\n        # إنشاء لوحة 9x9\n        grid = [[' ' for _ in range(9)] for _ in range(9)]\n        \n        # وضع النجوم في المواقع المناسبة\n        for point in self.points:\n            x = min(max(round(point.x), 0), 8)  # ضبط الموقع بين 0 و8\n            y = min(max(round(point.y), 0), 8)  # ضبط الموقع بين 0 و8\n            grid[y][x] = '*'\n            \n        # بناء التمثيل النصي\n        result = []\n        for row in reversed(grid):  # عكس الصفوف لتطابق الإحداثيات الرياضية\n            result.append('|' + ''.join(row) + '|')\n        \n        # إضافة الحدود العليا والسفلى\n        border = '+' + '-'*9 + '+'\n        result.insert(0, border)\n        result.append(border)\n        \n        return '\\n' + '\\n'.join(result)\n\nلاحظ استعمال الأفعال المخصوصة بالحاويات.\nالآن ننشيء مضلَّع، بسلسلة من النقاط، ونرى كيف يتم تمثيله:\n\npoly = Polygon([\n    Point(0, 0),\n    Point(3, 0),\n    Point(2, 2),\n    Point(0, 6),\n])\npoly\n\n\n+---------+\n|         |\n|         |\n|*        |\n|         |\n|         |\n|         |\n|  *      |\n|         |\n|*  *     |\n+---------+\n\n\nثم الإشارة برقم أو بشريحة:\n\nprint(poly[0])\nprint(poly[-1])\nprint(poly[1:3])\nprint(poly[::-1])\n\nPoint(0, 0)\nPoint(0, 6)\n[Point(3, 0), Point(2, 2)]\n[Point(0, 6), Point(2, 2), Point(3, 0), Point(0, 0)]\n\n\nثم التعيين:\n\npoly[0] = Point(10, 10)\npoly\n\n\n+---------+\n|        *|\n|         |\n|*        |\n|         |\n|         |\n|         |\n|  *      |\n|         |\n|   *     |\n+---------+\n\n\nوأخيرًا الحذف:\n\ndel poly[0]\npoly\n\n\n+---------+\n|         |\n|         |\n|*        |\n|         |\n|         |\n|         |\n|  *      |\n|         |\n|   *     |\n+---------+\n\n\n\n\nالمثال الثاني: جلسات المستخدمين\nبين أيدينا شيء يخزن بيانات (هي قاموس) لمدة مؤقتة ثم يمحى هذا الشيء المخزَّن. وذلك يستعمل بكثرة في المواقع حيث تخزَّن بيانات التسجيل أثناء جلسة التصفح ليكون الوصول إليها سريعًا بدل الرجوع لقاعدة البيانات في كل مرة.\n\nimport uuid\nfrom datetime import datetime\n\n\nclass Session:\n    def __init__(self, expires_at: datetime, data: dict):\n        self.id = uuid.uuid4()\n        self.expires_at = expires_at\n        self.data = data\n        \n    def __repr__(self):\n        return f\"Session(id={self.id}, expires_at={self.expires_at}, data={self.data})\"\n    \n    def is_expired(self):\n        return datetime.now() &gt; self.expires_at\n\n\nنستورد وحدة uuid لإنشاء معرِّفات فريدة\nنستورد وحدة datetime للتعامل مع التاريخ والوقت\nنعرِّف الصنف Session الذي يمثِّل جلسة تسجيل الدخول\nفي إجراء الإنشاء init\n\nنعطي الجلسة نفسها معرِّفًا فريدًا: self.id = uuid.uuid4()\nنُسنِد المتغيرات الأخرى كما هي: self.expires_at = expires_at و self.data = data\n\nفي الفعل repr نتحكم بطريقة عرض الجلسة عندما نستعمل مثلاً: print\nفي الفعل is_expired تحقق من انتهاء صلاحية الجلسة\n\nوالآن سنعرِّف الحاوي الذي يخزَّن جلسات المستخدمين، فهو قاموس:\n\nمفتاحه معرِّف المستخدم\nوقيمته الجلسة التي عرفناها في الأعلى\n\n\nfrom datetime import timedelta\n\nclass SessionStorage:\n    def __init__(self, expires_in: timedelta):\n        # قاموس يخزَّن الجلسات\n        self.sessions = {}\n        # عمر الجلسة الواحدة\n        self.expires_in = expires_in\n\n    # العد\n    def __len__(self):\n        return len(self.sessions)\n    \n    # نتحقق: هل الجلسة موجودة وصالحة؟\n    def is_active(self, key: uuid.UUID):\n        # إن كان معرِّف المستخدم غير موجود فلا توجد جلسة\n        if key not in self.sessions:\n            return False\n        \n        # فإن وجدت جلسة، فتحقق من صلاحيتها\n        # لاحظ استعمال .is_expired() الذي هو فعل الجلسة\n        now = datetime.now()\n        if self.sessions[key].is_expired():\n            del self.sessions[key]\n            return False\n        \n        return True\n    \n    # العضويَّة\n    def __contains__(self, key: uuid.UUID):\n        return self.is_active(key)\n    \n    # الإشارة\n    def __getitem__(self, key: uuid.UUID):\n        if not self.is_active(key):\n            raise KeyError(f\"Session has expired: key={key}\")\n        return self.sessions[key]\n    \n    # التعيين\n    def __setitem__(self, key: uuid.UUID, value: dict):\n        # نتأكد من النوعين المدخليْن\n        assert isinstance(key, uuid.UUID)\n        assert isinstance(value, dict)\n\n        # إن لم تكن الجلسة موجودة فإننا ننشئها\n        if not self.is_active(key):\n            session = Session(\n                expires_at=datetime.now() + self.expires_in,\n                data=value,\n            )\n        else:\n            # إن كانت موجودة فنحدِّث البيانات\n            session = self.sessions[key]\n            session.data = value\n\n        # نحدِّث قاموس الجلسات\n        self.sessions[key] = session\n\n    # الحذف\n    def __delitem__(self, key: uuid.UUID):\n        del self.sessions[key]\n    \n    # التمثيل / العرض\n    def __repr__(self):\n        # تخصيص سطر لكل جلسة\n        return \"\\n\".join(f\"{k}: {v}\" for k, v in self.sessions.items())\n\nوالآن ننشيء هذا الحاوي ونخزِّن فيه جلسات:\n\nstorage = SessionStorage(expires_in=timedelta(days=30))\n\nالتعيين:\n\nuser_id1 = uuid.uuid4()\n\nstorage[user_id1] = {\n    'dark_mode': True,\n}\n\n\nuser_id2 = uuid.uuid4()\n\nstorage[user_id2] = {\n    'language': 'English',\n    'country': 'Egypt',\n}\n\nالعد:\n\nlen(storage)\n\n2\n\n\nالعضوية:\n\nuser_id1 in storage\n\nTrue\n\n\nالإشارة:\n\nstorage[user_id1]\n\nSession(id=54ab55e8-6506-4804-a63a-b8bdfdbabcf8, expires_at=2025-05-02 17:24:13.293590, data={'dark_mode': True})\n\n\nلاحظ كيف تظهر هذه الجلسات:\n\nstorage\n\n3ae3b096-246b-4948-a0c2-291e74b8be81: Session(id=54ab55e8-6506-4804-a63a-b8bdfdbabcf8, expires_at=2025-05-02 17:24:13.293590, data={'dark_mode': True})\n5eb707ed-be91-4f3b-9de2-87d5d6288534: Session(id=4106e04f-b4c7-4818-976e-840eb327588c, expires_at=2025-05-02 17:24:13.305478, data={'language': 'English', 'country': 'Egypt'})\n\n\nوالحذف:\n\ndel storage[user_id1]",
    "crumbs": [
      "باب البرمجة الشيئية",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>المعاملات المخصصة</span>"
    ]
  },
  {
    "objectID": "chapters/14_time/a1_time.html",
    "href": "chapters/14_time/a1_time.html",
    "title": "22  الوقت",
    "section": "",
    "text": "مقدمة",
    "crumbs": [
      "باب الوقت والتاريخ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/14_time/a1_time.html#مقدمة",
    "href": "chapters/14_time/a1_time.html#مقدمة",
    "title": "22  الوقت",
    "section": "",
    "text": "الساعات والأيام\nتذكر بعض المصادر أن الأولين كانوا يقسمون الوقت على 12 ساعة ليلية (تبدأ بعد غروب الشمس) تتلوها 12 ساعة نهارية (تبدأ بعد شروق الشمس). وهي ساعات متغيرة؛ ففي الصيف تزيد طول ساعة النهار (فوق 60 دقيقة معتدلة) بينما تقصر ساعة الليل (دون 60 دقيقة معتدلة)، ويحصل العكس في الشتاء (فيكون الليل أطول والنهار أقصر). أما عند اعتدال الشمس في أشهر معيَّنة في خط الاستواء فإن ساعات الليل والنهار 60 دقيقة (وهو مقياس الاعتدال). والمرجع في ذلك الساعة الشمسية (المزوَّلة). ولحساب الفترة الزمنية كانوا يستعملون ما يُحرَق كالشمع، أو ثقب في وعاء مدرَّج من ماء أو رمل.\nانظر كتاب فقه اللغة للثعالبي:\n\nالفصل السابع عشر “في تَعْدِيدِ سَاعَاتِ النَّهارِ واللَّيل على أربع وعشرين لفظة”.\nعن حمزة بن الحسن وعليه عهدتها:\nسَاعَاتُ النَّهارِ: الشُرُوقُ. ثُمَّ البكورُ. ثُمَّ الغُدْوَةُ. ثُمَّ الضُّحَى. ثُمَّ الهاجِرَةُ. ثُمَّ الظَهِيرَةُ. ثُمَّ الرَّوَاحُ. ثُمَّ العَصْرُ. ثُمَّ القَصْرُ. ثُمَّ الأصِيلُ. ثُمَّ العَشِيُّ. ثُمَّ الغُروبُ. سَاعَاتُ اللَّيلِ: الشَّفَقُ. ثُمَّ الغَسَقُ. ثُمَّ العَتَمَةُ. ثُمَّ السُّدْفَة. ثُمَّ الفَحْمَةُ. ثُمَّ الزُّلَّةُ. ثُمَّ الزُّلْفةُ. ثُمَّ البُهْرَةُ. ثُمَّ السَّحَرُ. ثُمَّ الفَجْرُ. ثُمَّ الصُّبْحُ. ثُمَّ الصَّباحُ\n\nثم جاءت الساعات الميكانيكية الثابتة التي تعمل وكأن جميع الساعات 60 دقيقة؛ ولا تعتبر شتاءً ولا صيْفًا، ولا نهارًا ولا ليلاً .. لكنها أصبحت هي المتداولة. وقد مرَّ ضبط الساعة بأطوار من الدقة، فبدأت من الساعة المتأرجحة (1657) إلى الكرونومتر (1762) إلى مذبذب الكوارتز (1927) إلى الساعة الذرية (1949) إلى ساعة شعاع السيزيوم (1955) إلى ساعة نافورة السيزيوم (1993) إلى الساعة الضوئية (Optical Clock: 2006) والتي تحيد بمقدار ثانية بعد كل 30 مليار سنة.\n\n\nالتوقيت العالمي والمناطق الزمنية\nظهر نظام التوقيت العالمي المنسق (UTC: Coordinated Universal Time) حوالي سنة 1967، لتسهيل التعامل بين الدول والتواصل عبر القارات. فهو نظام للوقت يعتمد على خطوط الطول الأرضية، تقسَّم فيه الجغرافيا لمناطق زمنية بحسب بعدها عن خط طول جرينيتش الذي كان هو نقطة الصفر (UTC+00:00) أي: المرجِع: فما يكون شرقيها يكون الفارق فيه بالموجب، وما يكون غربيَّها يكون الفارق فيه بالسالب.\nوكل منطقة زمنية لها توقيت محلي تعتمده في معاملاتها اليومية فيما يتعلق بالوقت من تواصل وتنسيق ومواعيد ونحو ذلك. في الخريطة أدناه نرى تقسيم المناطق الزمنية:\n\n\n\nخريطة تظهر تقسيم المناطق الزمنية\n\n\nلاحظ أولاً أن الخطوط ليست طوليَّة بالإجراء، انظر إلى الألوان فليست هي مستطيلات بل تتعرَّج بحسب حدود الدُّول في الغالب. فالإجراء ليس بالبساطة التي قد نعتقدها: فليس الوقت المحلي هو فقط زيادة أو نقص من الوقت العالمي .. بل هناك عدة اعتبارات للتحويل بينها:\n\nمناطق عريضة جغرافيًّا: كالصين التي تمتد لتغطي مجموعة خطوط طول إلا أنها تعتمد توقيتًا موحَّدًا.\nالتوقيت الصيفي: بعض المناطق الزمنية تقدِّم الوقت ساعة عند الربيع (أو نهاية الشتاء) ثُم تعيدُه في الخريف، وذلك لتنظيم جدوَل الناس بحيث يتعرضوا للشمس أكثر.\nقرارات سياسية: قررت بعض الدوَّل أن تغير منطقتها الزمنية في سنة من السنوات؛ فذلك يجب أن يؤخذ في عين الاعتبار عند حساب الأوقات قبل أو بعد هذه السنة لهذه الدُّوَل.\n\nمعلومة جانبية: مصطلح التنسيق في التوقيت العالمي المنسق يشير إلى أنه يضع في الحسبان الاختلاف اليسير بسبب الثواني الكبسية، فتعاد ضبط الأوقات لاعتبارها.\nنخلص من ذلك أن التعامل مع الوقت له اعتبارات كثيرة بسبب ظروف تاريخية وسياسية وليس خاضعًا لقوانين فيزيائية أو أرضية أو فلكية بحتة. ولذلك ظهرت قاعدة بيانات للمناطق الزمنية (بمجهود جماعي) تتضمن معلومات الدول بشكل يتم تحديثه بشكل مستمر لمتابعة التغيرات، تسمَّى: (tz database).",
    "crumbs": [
      "باب الوقت والتاريخ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/14_time/a1_time.html#الوقت-في-الحاسب",
    "href": "chapters/14_time/a1_time.html#الوقت-في-الحاسب",
    "title": "22  الوقت",
    "section": "الوقت في الحاسب",
    "text": "الوقت في الحاسب\nيظهر وقت التقويم (Calendar Time) على هذا النحو:\n\nالتاريخ: 2024-11-25\nالساعات: 08:30:25\nالمنطقة الزمنية: GMT+3 (أي: ثلاث ساعات متقدِّمة عن جرينيتش)\n\nلكن تمثيل الزمن في الحاسب هو: عدد صحيح (int) ويمثِّل عدد الثواني من بزوغ فجر نظام يونكس (Unix Epoch) وهو تاريخ ووقت اعتباطي تمَّ وضعه على أن يكون:\n\nتاريخ: 1970-01-01\nالساعة: 00:00:00\nالمنطقة الزمنية: UTC التي هي GMT+0\n\nمثال: لنشير إلى سنة واحدة تمامًا بعد النقطة الصفرية، أي: الساعة 00:00:00 بتاريخ 1 يناير1971 ، فإن السنة الواحدة فيها 31,536,000 ثانية ، وبالتالي يكون هذا الرقم هو الذي يمثل ذلك الوقت.\nولو أردت الترجمة بالعكس، فتقول إن 1,000,000,000 ثانية منذ النقطة الصفرية يوافق 9 سبتمبر 2001 01:46:40 في وقت التقويم على منطقة UTC.\nمشكلة سنة 2038 تحصل في الأنظمة ذات 32-بت؛ إذْ عدد الثواني يصل إلى أقصى مداه عند نقطتين زمنيتين:\n\nففي النزول تستطيع أن تصل إلى: 20:45:52 UTC بتاريخ 1901-12-13 (باختيار عدد سالب)\nوكذلك في الصعود؛ لا يمكن أن تتعدى: 03:14:07 UTC بتاريخ 2038-01-19\n\nوالحل في ذلك بسيط، وهو نقل البرنامج لنظام 64-بت.",
    "crumbs": [
      "باب الوقت والتاريخ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/14_time/a1_time.html#الوقت-في-بايثون",
    "href": "chapters/14_time/a1_time.html#الوقت-في-بايثون",
    "title": "22  الوقت",
    "section": "الوقت في بايثون",
    "text": "الوقت في بايثون\nننتقل الآن إلى الوقت والتاريخ في بايثون، حيث يوجد لدينا المفاهيم التالية:\nأولاً: datetime.date وهو تاريخ مثالي يفترض أن التقويم الغريغوري يمتد إلى ما لا نهاية في المستقبل والماضي (رغم أنه في الحقيقة حل مكان التاريخ الجولياني سنة 1582). سمات هذا الكائن: السنة والشهر واليوم.\nثانيًا: datetime.time هو وقت مثالي يفترض 86,400 ثانية في اليوم (بدون ثوانٍ كبيسة). سمات هذا الكائن: الساعة والدقيقة والثانية والميكروثانية وtzinfo (معلومات المنطقة الزمنية).\nثالثًا: datetime.datetime وهو التاريخ والوقت معًا؛ فلديه سمات كلا الجزئين.\nرابعًا: datetime.timedelta وهو فترة زمنية. ولكننا سنستبدله بـ dateutil.relativedelta إذ هي كذلك فترة زمنية إلا أن نطاقها أوسع (تستوعب السنين والأشهر، وتعتبر السنوات الكبيسة في الحسبان).\nالوقت الصحيح لا بد له من نسبة إلى منطقة زمنيَّة (كأن تقول الساعة 04:00:00 صباحًا بتوقيت UTC+03)؛ فهذا تسميه بايثون وقت واع (Aware)، وأما الوقت الذي لم تحدد منطقته الزمنية (كما لو قُلت في الساعة 04:00:00 صباحًا) فهذا غير منسوب لمنطقة زمنية وبالتالي فهو ساذج (Naive) على تعبيرهم.\nويرشدنا توثيق المكتبة للتوسع في استعمال قاعدة بيانات المناطق الزمنية، والقدرة على تفسير التواريخ والأوقات بمرونة لاستخدام مكتبة dateutil المتوفرة في PyPI.\nلتثبيت المكتبة نستعمل pip على النحو التالي:\npip install python-dateutil\nالآن نستورد المكتبة الأساسية datetime ومكتبة dateutil:\n\nfrom datetime import date, time, datetime, timedelta\nfrom dateutil import tz\n\nنريد الآن معرفة الوقت العالمي والمحلي، وكذلك الوقت في القاهرة، وكذلك الوقت في لندن (هنا قائمة بالأسماء):\n\nprint(datetime.now(tz=tz.tzutc()))\nprint(datetime.now(tz=tz.tzlocal()))\nprint(datetime.now(tz=tz.gettz('Africa/Cairo')))\nprint(datetime.now(tz=tz.gettz('Europe/London')))\n\n2025-03-27 21:03:18.747424+00:00\n2025-03-28 00:03:18.747565+03:00\n2025-03-27 23:03:18.748346+02:00\n2025-03-27 21:03:18.748996+00:00\n\n\nلاحظ أن شكل الوقت كاملاً على النحو التالي:\n    2024-11-19 11:32:35.355104+03:00\n    YYYY-MM-DD HH:MM:SS.ssssss+HH:MM\nنفكك ذلك:\n\nYYYY-MM-DD هو التاريخ (يبدأ بالسنة ثم الشهر ثم اليوم)\nHH:MM:SS.ssssss هو الوقت (بالساعات والدقائق والثواني والميكروثواني)\n+HH:MM هو الفرق بين الوقت المحلي لتلك المنطقة الزمنية والوقت العالمي المنسق (UTC).\n\n\nالتفسير: تحويل النص إلى تاريخ ووقت\nوقراءة التواريخ أفضل بكثير في مكتبة dateutil بدلاً من استعمال المكتبة الأساسية datetime. وتكثر الحاجة لذلك عند استقبال معلومات من الشبكة أو من ملفات أو من المستخدمين:\n\nfrom dateutil.parser import parse\n\nهنا نحدد وقتًا افتراضيًّا عند القراءة، بحيث لو لم توجد المعلومة عند القراءة فإنها تستعمل القيم الابتدائية:\n\nDEFAULT = datetime(2003, 9, 25)\nparse(\"Thu Sep 25 10:36:28\", default=DEFAULT)\n\ndatetime.datetime(2003, 9, 25, 10, 36, 28)\n\n\nونرى كيف أن المفسر يحاول معرفة المعلومات ولو كانت ناقصة:\n\nدون السنة\nدون الشهر\nدون الثواني\nدون اليوم\n\n\nprint(parse(\"Thu Sep 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36\", default=DEFAULT))\nprint(parse(\"10:36\", default=DEFAULT))\n\n2003-09-25 10:36:28\n2003-09-25 10:36:28\n2003-09-25 10:36:00\n2003-09-25 10:36:00\n\n\n\n\nالحسابات الزمنية\n\nfrom dateutil.relativedelta import relativedelta\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nحساب الزمن المنقضي\n\ntoday = datetime.now(tz=tz.tzlocal())\nbirthday = datetime(1970, 1, 1, tzinfo=tz.tzlocal())\nage = relativedelta(today, birthday)\nprint(f'You are {age.years} years and {age.months} months old')\n\nYou are 55 years and 2 months old\n\n\n\n\nحساب الزمن لموعد\n\ntoday = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2025, 1, 15, tzinfo=tz.tzlocal())\ndiff = relativedelta(exam_date, today)\nprint(f'There are {diff.days} days and {diff.hours} hours remaining')\n\nThere are -13 days and 0 hours remaining\n\n\n\n\nمقارنة الوقت\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=9, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif now &gt; exam_date:\n    print('The exam has passed')\nelif now &lt; exam_date:\n    print('The exam is coming')\n\nThe exam has passed\n\n\n\n\nمقارنة الفترة\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=15, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif relativedelta(now, exam_date).hours &lt; 1:\n    print('Hurry up!')\nelif relativedelta(now, exam_date).hours &lt; 4:\n    print(f'Remember you have an exam today at {exam_date:%H:%M}')\nelse:\n    print(f'You have plenty of time to prepare for the exam')\n\nYou have plenty of time to prepare for the exam\n\n\n\n\nالجمعة القادمة\n\ntoday = datetime.now(tz=tz.tzlocal())\nnext_friday = today + relativedelta(days=+1, weekday=FR)\nprint(f'The next Friday is {next_friday:%Y-%m-%d}')\n\nThe next Friday is 2025-04-04\n\n\n\n\nالجمعة الفائتة\n\nlast_friday = today - relativedelta(days=+1, weekday=FR(-1))\nprint(f'The last Friday is {last_friday:%Y-%m-%d}')\n\nThe last Friday is 2025-03-21\n\n\n\n\nحساب الوقت باعتبار منطقتين زمنيتين\nلديك اجتماع في وقت محدد بتوقيت لندن، وتريد معرفة وقت الوصول بالطائرة إن كانت الرحلة تستغرق 4 ساعات والإقلاع من القاهرة في الساعة 01:00:00 صباحًا والوجهة لندن:\n\ndeparture_tz = tz.gettz('Africa/Cairo')\narrival_tz = tz.gettz('Europe/London')\n\ndeparture_time = datetime(2024, 11, 19, hour=1, tzinfo=departure_tz)\n\narrival_time = departure_time + relativedelta(hours=4)\n\nprint(f'You leave at {departure_time.astimezone(departure_tz)} in Cairo time')\nprint(f'You arrive at {arrival_time.astimezone(arrival_tz)} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz)} in Cairo time')\n\nYou leave at 2024-11-19 01:00:00+02:00 in Cairo time\nYou arrive at 2024-11-19 03:00:00+00:00 in London time\nwhich corresponds to 2024-11-19 05:00:00+02:00 in Cairo time\n\n\n\n\n\nتنسيق التاريخ والوقت\nوانظر الجدول لتنسيق مظهر التاريخ والوقت:\n\nprint(f'Departure time: {departure_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\nprint(f'Arrival time: {arrival_time.astimezone(arrival_tz):%d %b, %X %Z} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\n\nDeparture time: 19 Nov, 01:00:00 EET in Cairo time\nArrival time: 19 Nov, 03:00:00 GMT in London time\nwhich corresponds to 19 Nov, 05:00:00 EET in Cairo time\n\n\n\n\nالتكرار\nتكرار التواريخ يتم في هذه المكتبة باستعمال rrule ويحدد على النحو التالي:\n\nfrom dateutil.rrule import rrule\nfrom dateutil.rrule import DAILY, WEEKLY, MONTHLY, YEARLY, HOURLY, MINUTELY, SECONDLY\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nيوم ويوم\nتكرار أوقات بأخذ يوم وترك يوم، ابتداءً من وقت معين في الساعة العاشرة صباحًا:\n\nlist(\n    rrule(DAILY, interval=2, count=10, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 21, 10, 0),\n datetime.datetime(2024, 11, 23, 10, 0),\n datetime.datetime(2024, 11, 25, 10, 0),\n datetime.datetime(2024, 11, 27, 10, 0),\n datetime.datetime(2024, 11, 29, 10, 0),\n datetime.datetime(2024, 12, 1, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 5, 10, 0),\n datetime.datetime(2024, 12, 7, 10, 0)]\n\n\n\n\nأسبوعي\n\nlist(\n    rrule(WEEKLY, interval=1, count=4, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 26, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 10, 10, 0)]\n\n\n\n\nشهريًّا إلى وقت محدد\n\nlist(\n    rrule(MONTHLY, interval=1,\n        dtstart=datetime(2024, 8, 1),\n        until=datetime(2025, 4, 1),\n    )\n)\n\n[datetime.datetime(2024, 8, 1, 0, 0),\n datetime.datetime(2024, 9, 1, 0, 0),\n datetime.datetime(2024, 10, 1, 0, 0),\n datetime.datetime(2024, 11, 1, 0, 0),\n datetime.datetime(2024, 12, 1, 0, 0),\n datetime.datetime(2025, 1, 1, 0, 0),\n datetime.datetime(2025, 2, 1, 0, 0),\n datetime.datetime(2025, 3, 1, 0, 0),\n datetime.datetime(2025, 4, 1, 0, 0)]\n\n\n\n\nكل 15 دقيقة لمدة 6 مرات\n\nlist(\n    rrule(MINUTELY, interval=15, count=6, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 19, 10, 15),\n datetime.datetime(2024, 11, 19, 10, 30),\n datetime.datetime(2024, 11, 19, 10, 45),\n datetime.datetime(2024, 11, 19, 11, 0),\n datetime.datetime(2024, 11, 19, 11, 15)]\n\n\nوندعوك للاطلاع على المزيد من الأمثلة على مكتبة dateutil.",
    "crumbs": [
      "باب الوقت والتاريخ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/14_time/a1_time.html#التاريخ-الهجري-في-بايثون",
    "href": "chapters/14_time/a1_time.html#التاريخ-الهجري-في-بايثون",
    "title": "22  الوقت",
    "section": "التاريخ الهجري في بايثون",
    "text": "التاريخ الهجري في بايثون\nتوفر مكتبة hijridate التعامل مع التاريخ الهجري والتحويل بينه وبين الجريجوري (الميلادي):\nfrom hijridate import Hijri, Gregorian\n\ng = Hijri(1446, 5, 17).to_gregorian()\nh = Gregorian(2024, 11, 19).to_hijri()\n\nprint(g)\nprint(h)",
    "crumbs": [
      "باب الوقت والتاريخ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a1_use_library.html",
    "href": "chapters/15_using/a1_use_library.html",
    "title": "23  مكتبة البرمجيات",
    "section": "",
    "text": "مكتبات العلوم الطبيعية\nأحييك على وصولك إلى نهاية الكتاب. آمل أن يكون الكتاب مهيِّأً لك للبدء في التطبيقات العملية؛ لأنك الآن مهيأ لتفهم أي قطعة برمجية كتبت في بايثون. وحتى تنطلق، إليك بعض مكتاب بايثون التي تعينك على بناء معالجات متخصصة في مجالات مختلفة.",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>مكتبة البرمجيات</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a1_use_library.html#مكتبات-العلوم-الطبيعية",
    "href": "chapters/15_using/a1_use_library.html#مكتبات-العلوم-الطبيعية",
    "title": "23  مكتبة البرمجيات",
    "section": "",
    "text": "الحوسبة الكمومية\n\n\n\n\nQuTiP\n\n\nPyQuil\n\n\nQiskit\n\n\nPennyLane\n\n\n\n\n\nالحوسبة الإحصائية\n\n\n\n\nPandas\n\n\nstatsmodels\n\n\nXarray\n\n\nSeaborn\n\n\n\n\n\nمعالجة الإشارة\n\n\n\n\nSciPy\n\n\nPyWavelets\n\n\npython-control\n\n\nHyperSpy\n\n\n\n\n\nمعالجة الصورة\n\n\n\n\nScikit-image\n\n\nOpenCV\n\n\nMahotas\n\n\n\n\n\n\n\nالرسومات والشبكات\n\n\n\n\nNetworkX\n\n\ngraph-tool\n\n\nigraph\n\n\nPyGSP\n\n\n\n\n\nالفلك\n\n\n\n\nAstroPy\n\n\nSunPy\n\n\nSpacePy\n\n\n\n\n\nالنفسية المعرفية\n\n\n\n\nPsychoPy\n\n\n\n\n\nالمعلوماتية الحيوية\n\n\n\n\nBioPython\n\n\nScikit-Bio\n\n\nPyEnsembl\n\n\nETE\n\n\n\n\n\n\n\nالاستدلال البايزي\n\n\n\n\nPyStan\n\n\nPyMC3\n\n\nArviZ\n\n\nemcee\n\n\n\n\n\nالتحليل الرياضي\n\n\n\n\nSciPy\n\n\nSymPy\n\n\ncvxpy\n\n\nFEniCS\n\n\n\n\n\nالكيمياء\n\n\n\n\nCantera\n\n\nMDAnalysis\n\n\nRDKit\n\n\nPyBaMM\n\n\n\n\n\nعلوم الأرض\n\n\n\n\nPangeo\n\n\nSimpeg\n\n\nObsPy\n\n\nFatiando a Terra",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>مكتبة البرمجيات</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a1_use_library.html#علوم-البيانات-والذكاء-الاصطناعي",
    "href": "chapters/15_using/a1_use_library.html#علوم-البيانات-والذكاء-الاصطناعي",
    "title": "23  مكتبة البرمجيات",
    "section": "علوم البيانات والذكاء الاصطناعي",
    "text": "علوم البيانات والذكاء الاصطناعي\n\n\n\nعلوم البيانات\n\n\n\nاستخراج، تحويل، تحميل: Pandas, Jupyter Notebooks\nتصوير البيانات:\n\nMatplotlib\nSeaborn\nNapari\nPyVista\n\nنمذجة وتقييم:\n\nإحصائية: statsmodels\nتعلم الآلة: scikit-learn\nالتعلم العميق: PyTorch, TensorFlow\n\nإعداد التقارير في لوحة معلومات: Dash\n\n\nالبيانات الضخمة\n\nمعالجة البيانات المتدفقة بسرعة وكفاءة عالية: Dask and Ray.\nأتمتة عمليات البيانات: Airflow, Dagster and Prefect",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>مكتبة البرمجيات</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a2_use_sdk.html",
    "href": "chapters/15_using/a2_use_sdk.html",
    "title": "24  الخدمات البرمجية",
    "section": "",
    "text": "الخادم والعميل\nنتصوَّر الشبكة العالميَّة (الإنْتَرنِت) بأنها مجموعة أجهزة مترابطة بأشكال ارتباطات مختلفة. وكما هي السنة بين الأفراد والمؤسسات أن يخدم بعضهم بعضًا، ويتبادلون المنافع؛ فكذلك صار في العصر الرقمي تخادم عن طريق الحواسيب عبر الشبكة.\nوكما أن المعادن موزعة مكامنها في طيات أطراف الأرض؛ فإن البيانات (المواد الخام) والمعلومات (المعالجة) وآليات المعالجة (الأجهزة والخوارزميات) كذلك؛ يتفاضل الناس فيما بينهم فيها. فيكون بينهم تبادل المنافع.\nفالصورة هذه توضِّح أن الشبكة المحليَّة (Local Area Network - LAN) -الذي يكون جهاز أحدنا فردًا من أفرادها- مرتبطةٌ بموجِّه (Router) يكون بمثابة البوابة إلى الشبكات الأخرى. فأي اتصال يكون بيننا وبين العالم يمرُّ عبره.\nوأما شبكة الشبكات فتسمى (Wide Area Network - WAN)؛ وهكذا ببساطة نتصوَّر الشبكة العالمية؛ الإنترنت.\nوعندما ننظر إلى أفراد التبادلات المعلوماتية بين الحواسيب، فإن أحد الطرفين يكون له دوْر العميل والآخر يكون له دوْر الخادم؛ ثم قد ينعكس الدوْر:",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>الخدمات البرمجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a2_use_sdk.html#الخادم-والعميل",
    "href": "chapters/15_using/a2_use_sdk.html#الخادم-والعميل",
    "title": "24  الخدمات البرمجية",
    "section": "",
    "text": "فأما الخادم (Server) فيسمى كذلك المزوِّد (Provider) باعتبار المنتَج أو الخدمة البرمجية.\nوأما العميل (Client) فيسمى كذلك المستخدم (User) أو المستهلك (Consumer).\n\n\n\n\nخادم لعدة عملاء",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>الخدمات البرمجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a2_use_sdk.html#مكتبة-العميل",
    "href": "chapters/15_using/a2_use_sdk.html#مكتبة-العميل",
    "title": "24  الخدمات البرمجية",
    "section": "مكتبة العميل",
    "text": "مكتبة العميل\nتسهل بعض المكتبات الوصول إلى خوادم مخصوصة؛ وتسمى المكتبة حينئذٍ عدة تطوير البرمجية (SDK - Software Development Kit)، أو: مكتبة العميل (Client Library).\nفأحد طرق التعامل مع الخدمات البرمجية، أن توفِّر هذه الخدمة مكتبةً للاتصال بها، تبدوا كأنها إجراءات مُعرَّفة عاديَّة، لكنَّ تفاصيلها تتضمَّن إرسال طلب للخادم المزوِّد ثم الرجوع بجوابه كقيمة لموضع الاستدعاء.",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>الخدمات البرمجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a2_use_sdk.html#مكتبة-جيوباي-مثالا",
    "href": "chapters/15_using/a2_use_sdk.html#مكتبة-جيوباي-مثالا",
    "title": "24  الخدمات البرمجية",
    "section": "مكتبة جيوباي مثالاً",
    "text": "مكتبة جيوباي مثالاً\nونمثل على ذلك بمكتبة GeoPy حيث كُتِب في الوصف:\n\nجيوباي هو عميل بايثوني لمجموعة من خدمات شائعة على الشبكة للترميز الجغرافي. فهو يسهل تحديد إحداثيات العناوين والمدن والبلدان والمعالم في جميع أنحاء العالم باستخدام برامج ترميز جغرافي خارجية ومصادر بيانات أخرى.\n\nأولاً تثبيت المكتبة باستعمال uv:\nuv add geopy\nوهذا العميل يمكن ضبطه للاختيار من مجموعة خوادم. وسنختار العميل Nominatim الذي يتصل بمزوِّد خدمة خارجية، وهو مزوِّد خدمة جغرافية عالمية تسمى OpenStreetMap.\n\nfrom geopy.geocoders import Nominatim\n\nيطلب منَّا الإجراء المنشئ التصريح بهويَّة للتطبيق؛ وذلك بتعيين user_agent، وهذا بحسب ما ورد في توثيق المكتبة. فنكتب أي اسم يدلُّ على التطبيق الذي نعمل عليه الآن، وسنختار الاسم pythonia .. ولك أن تختار أي اسم آخر.\n\ngeolocator = Nominatim(user_agent=\"pythonia\")\n\nنفترض أننا نريد معرفة إحداثيات مدينة الدمام، وهذا هو عمل الإجراء geocode:\n\ndammam_location = geolocator.geocode(\"Dammam, Saudi Arabia\")\n\nقد يبدوا الإجراء عاديًّا، لكنه في الواقع يتصل بالخادم المزوِّد ويسأله عن إحداثيات المدينة.\n\n\n\n\n\nsequenceDiagram\n    UserCode --&gt;&gt; GeoPy: .geocode(\"...\")\n    GeoPy --&gt;&gt; OpenStreetMap: Request\n    OpenStreetMap --&gt;&gt; GeoPy: Response\n    GeoPy --&gt;&gt; UserCode: Return\n\n\n\n\n\n\nجرب اطبع النتيجة لتعرف ما هو هذا الشيء الذي تتعامل معه. وكذلك اطبع نوعه:\n\nprint(dammam_location)\nprint(type(dammam_location))\n\nالدمام, محافظة الدمام, المنطقة الشرقية, 32242, السعودية\n&lt;class 'geopy.location.Location'&gt;\n\n\nتبيَّن لنا أن النوع هو: geopy.location.Location وبالبحث في توثيق المكتبة، وجدنا تفاصيلها هنا: geopy.location.Location. حيث كُتب:\n\n\nContains a parsed geocoder response. Can be iterated over as (location&lt;String&gt;, (latitude&lt;float&gt;, longitude&lt;float&gt;)). Or one can access the properties address, latitude, longitude, or raw. The last is a dictionary of the geocoder’s response for this item.\n\n\nوبهذا نعرف أنها تتكون من ثلاثة معلومات، ويمكن الوصول لها بطرق مختلفة.\nالطريقة الأولى معقدة ولذلك سنتركها.\nالطريقة الثانية (عن طريق الصفات):\n\nprint(dammam_location.address)\nprint(dammam_location.latitude)\nprint(dammam_location.longitude)\n\nالدمام, محافظة الدمام, المنطقة الشرقية, 32242, السعودية\n26.4367824\n50.1039991\n\n\nالطريقة الثالثة (عن طريق القاموس):\n\nprint(dammam_location.raw)\nprint(type(dammam_location.raw)) # قاموس\n\n{'place_id': 40859854, 'licence': 'Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright', 'osm_type': 'node', 'osm_id': 287865393, 'lat': '26.4367824', 'lon': '50.1039991', 'class': 'place', 'type': 'city', 'place_rank': 16, 'importance': 0.5524619823312412, 'addresstype': 'city', 'name': 'الدمام', 'display_name': 'الدمام, محافظة الدمام, المنطقة الشرقية, 32242, السعودية', 'boundingbox': ['26.2767824', '26.5967824', '49.9439991', '50.2639991']}\n&lt;class 'dict'&gt;\n\n\nوكذلك لمدينة أخرى مثل البحرين:\n\nbahrain_location = geolocator.geocode(\"Bahrain\")\n\nثم بعد أن حصلنا على المعلومات، نستخرج الإحداثيات من المتغيرات التي حصلنا عليها:\n\ndammam_coords = (dammam_location.latitude, dammam_location.longitude)\nbahrain_coords = (bahrain_location.latitude, bahrain_location.longitude)\n\nثم نحسب المسافة بين المدينتين، باستعمال فعل موجود في وحدة geopy.distance، وهو geodesic. وأنبه مرة أخرى أن معرفة مثل ذلك يكون بتصفح فهرس المكتبة.\n\nfrom geopy.distance import geodesic\n\ndistance = geodesic(dammam_coords, bahrain_coords)\nprint(f\"Between Dammam and Bahrain is {distance.kilometers:.2f} km\")\n\nBetween Dammam and Bahrain is 63.61 km\n\n\nوهكذا نكون قد حسبنا المسافة بين المدينتين بالكيلومترات، باستعمال مكتبة أعطتنا الإحداثيات للمدينتين، وكذلك أعطتنا معالجة المسافة بينهما.",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>الخدمات البرمجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a2_use_sdk.html#مفتاح-الواجهة-البرمجية-api_key",
    "href": "chapters/15_using/a2_use_sdk.html#مفتاح-الواجهة-البرمجية-api_key",
    "title": "24  الخدمات البرمجية",
    "section": "مفتاح الواجهة البرمجية (API_KEY)",
    "text": "مفتاح الواجهة البرمجية (API_KEY)\nقلنا أن مكتبة العميل هذه تمكِّنك من الوصول إلى عدة خدمات جيومكانية. ويجدر بالذكر أننها تتفاضل في دقة الحساب، وسرعة الجواب، وكمية الطلبات المسموحة إليها.\nلذلك قد تضطر لتسجيل حساب وتشحنه بالمال برصيد، ثم تستعمل الخدمة عن طريق هذا الحساب. والطريقة التي يعرف بها الخادم أن البرنامج مخوَّل باستعمال رصيد هذا الحساب هي عبر مفتاح الواجهة البرمجية (API Key).\n\n\n\nمكتبة جيوباي وخدمات الترميز الجغرافي\n\n\nفإن أردت تغيير مزوِّد الخدمة (إما لعدم دقتها أو عدم توفر المعلومات أو أي سبب آخر)، فما عليك إلا استعمال استيراد Geocoder آخر. ونمثل لذلك بعميل يتصل بخدمة TomTom:\nfrom geopy.geocoders import TomTom\n\ngeolocator = TomTom(user_agent=\"pythonia\", api_key=\"...\")\nلكن هذا يتطلَّب شيئًا إضافيًّا وهو الحصول على مفتاح متعلِّق بحساب مسجَّل على موقع TomTom نفسه. ثم وضع هذا الفتاح هنا. وبهذا المفتاح المرتبط بهذا الحِساب يتمُّ تعبئة الاشتراك والصرف من رصيده.\nوهذه أحد مصادر دخل شركات المعلومات.",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>الخدمات البرمجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a3_use_http.html",
    "href": "chapters/15_using/a3_use_http.html",
    "title": "25  التخاطب عبر الشبكة",
    "section": "",
    "text": "عنوان المورِد الموحَّد\nرأينا في الدرس السابق كيفية التواصل مع خادم عن طريق مكتبة العميل التابعة للخدمة (GeoPy). لكن ما الآلية التي جرَّدتها عنا هذه المكتبة وأخفتها؟\nتخضع المراسلات بين البرمجيات التطبيقية لقواعد تواصل تسمى HTTP (Hyper-Text Transfer Protocol)؛ وهي حرفيًّا بمعنى قواعد تناقل النص الفائق. وسيأتي بيان معنى الفائقية عند شرح HTML (Hyper-text Markup Language) لأن هذين المفهومين مرتبطان. لكن الذي يهمنا الآن أنها أحد أكثر لغات التواصل استخدامًا على الشبكة. فالاتصال بين الخادم والمخدوم يكون بها وإن كان البرنامج نفسه مكتوبًا بلغة أخرى مثل بايثون. ومن نظائرها:\nوغيرها كثير جدًّا.\nفحتى نصل إلى خدمات كثيرة على الشبكة ونستفيد منها؛ لابد أن نفهم هذه الآلية. وهي مبنيَّة على أمور، منها: العنوان، والطلب، والجواب.\nإن اصطلاح عنوان المورِد الموحَّد URL (Uniform Resource Locator) هو الذي نقصده عندما نقول رابط (Link أو Hyper-link reference وتختصر href) لأن صياغة الروابط عادةً ما تتبع هذه الصيغة الموحَّدة. وهي التي تتضمَّنُ عادةً جزئيَّة com. أو net. ونحوهما؛ وتتضمن بعدها مسارًا فرعيًّا. ونمثل على ذلك بمثال بسيط:\nففيه:\nأما مصطلح المورِد (Resource) فعامٌّ يشمل شيئًا مُجرَّدًا يتم الوصول إليه بعنوان مُصاغٍ بصيغة متفقٍ عليها. سواءٌ كان موجودًا قبل الوصول إليه، أو يتمُّ إنتاجه متى طُلِب. فقد يكون ملفَّ بيانات أو صفحةً تُعرَض أو معالجةً قيِّمة.\nفلو جربت نسخ الرابط السابق ووضعته في الشريط الأعلى للمتصفح وكبست زر Enter فسيأخذك المتصفح إلى تلك الصفحة. وسيأتي الكلام عن بناء الصفحات في حينه إن شاء الله.",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>التخاطب عبر الشبكة</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a3_use_http.html#عنوان-المورد-الموحد",
    "href": "chapters/15_using/a3_use_http.html#عنوان-المورد-الموحد",
    "title": "25  التخاطب عبر الشبكة",
    "section": "",
    "text": "https://github.com/HassanAlgoz/python\n\n\nالصياغة: https\nالعنوان الأساسي: github.com\nالمسار الفرعي: HassanAlgoz/python/\nالمورِد: python",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>التخاطب عبر الشبكة</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a3_use_http.html#الطلب-والجواب",
    "href": "chapters/15_using/a3_use_http.html#الطلب-والجواب",
    "title": "25  التخاطب عبر الشبكة",
    "section": "الطلب والجواب",
    "text": "الطلب والجواب\nومن مفاهيم لغة التخاطب عبر تطبيقات الشبكة أيضًا:\n\nالطلب\nالطلب (Request) وهو الرسالة التي تشمل:\n\nالمحتوى: body / content\nالعميل الذي يمثِّل المستخدم (المُرسِل): user-agent\nالمستضيف الذي عليه الخادم (المُرسَل إليه): Host\n\nنوع الطلب (Method) وأهمها:\n\nGET لطلب الحصول على مورِد معيَّن\nDELETE لطلب حذف مورِد معيَّن\n\nففيهما يتمُّ تحديد عنوان المورِد.\nثم لدينا:\n\nPOST لطلب إنشاء مورِد؛ يتمُّ تحديد تفاصيل الإنشاء في محتوى الرسالة\nPUT لطلب تعديل مورِد؛ يتمُّ تحديد تفاصيل التعديل في محتوى الرسالة\n\nالرؤوس (Headers) هي معلومات عن المعلومات التي في الطلب نفسه أو محتواه؛ بعضها أصلي وبعضها إضافي.\n\nمثلاً: Content-Type: text/csv تعني أن البيانات المرسلة عبارة عن ملف بصيغة CSV. وهو أصلي.\nأما الإضافي فيبدأ بحرف X على هذا النحو: x-api-key: 1234567890 هو مفتاح التطبيق الذي يسمح للطلب بالتعريف بصاحب الحساب لإتاحة الخدمة له.\n\nالمحتوى (Body) هي البيانات المُرْسَلة أو المُسْتَلَمة؛ سواءٌ في الطلب أو جوابه.\nمثلا بيانات عبارة عن قاموس بصيغة JSON:\n{\"name\": \"John\", \"age\": 30}\n\n\nجواب الطلب\nجواب الطلب (Response) وهو مثل الطلب في خصائصه؛ إلا أنَّه بعكس الاتجاه: من الخادم إلى العميل.\nرمز حالة الطلب (Status Code) وتنقسم إلى نطاقات، وكثيرٌ منها مُهمَل غير مُستعمل:\n\nنطاق 100-199 (فقط للعلم - ولا تهمنا)\nنطاق 200-299 تعني أن الطلب تمُّ إنجازه بنجاح.\nنطاق 300-399 إعادة توجيه\nنطاق 400-499 إشكال من جهة العميل\n\n400 -&gt; Bad Request البيانات المُرسلة ليست صالحة\n401 -&gt; Unauthorized المفتاح مفقود أو غير صالح\n403 -&gt; Forbidden المفتاح صالح لكن ليس كافيًا للوصول\n404 -&gt; Not Found ما طلبته غير موجود\n\nنطاق 500-599 إشكال من جهة الخادم\n\nولمزيد من التفاصيل راجع: HTTP overview.",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>التخاطب عبر الشبكة</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a3_use_http.html#مثال-خدمة-صور-القطط",
    "href": "chapters/15_using/a3_use_http.html#مثال-خدمة-صور-القطط",
    "title": "25  التخاطب عبر الشبكة",
    "section": "مثال: خدمة صور القطط",
    "text": "مثال: خدمة صور القطط\nماذا لو لم تتوفَّر مكتبة خاصَّة بمزوِّد الخدمة؟ في هذه الحالة سنكتب نحن تفاصيل الاتصال بالخادم المزوِّد. وذلك يتطلب معرفة لغة التخاطب بين الخادم والعميل (HTTP).\nيجب علينا أولاً تثبيت مكتبة httpx باستعمال uv:\nuv add httpx\nونمثل لمزود خدمة معلومات عن القطط (The Cat API)، وقد حصلنا على مفتاح التطبيق (API KEY) من خلال التسجيل في الموقع.\nولمعرفة الاستفادة من أي مزود خدمة، فإننا ندخل إلى صفحة المطورين، وتسمى (API Documentation). ومنها نعرف أن المسار الذي يجب أن نطلبه هو https://api.thecatapi.com/v1/images/search، وهو يعطينا صورة قط عشوائية.\nباستعمال مكتبة عامة لعميل HTTP يمكننا الوصول لأي خدمة مقدَّمة من جهة خادم يتخاطب بلغة HTTP. وهو ما يُعرف أيضًا بخادم ويب (Web Server). فها نحن هنا نحدد جميع ما نريد:\n\nنوع الطلب: GET\nالمسار: /v1/images/search\nالعنوان الرئيسي: api.thecatapi.com (وهو الموقع الذي يوجد عليه الملف)\nالرؤوس: x-api-key: 1234567890 (وهو مفتاح التطبيق الذي يسمح للطلب بالوصول إلى الخدمة)\n\n\n\n\n\n\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client-&gt;&gt;Server: GET /v1/images/search HTTP/1.1\n    activate Server\n    Server-&gt;&gt;+Client: HTTP/1.1 200 OK\n    deactivate Server\n\n\n\n\n\n\n\nimport httpx\n\nclient = httpx.Client()\n\nrequest = client.build_request(\n    method=\"GET\",\n    url=\"https://api.thecatapi.com/v1/images/search\",\n    headers={\n        \"x-api-key\": \"live_9Cj8P0h75D5h2D7Y2H8MYEuuTmTXjT412xNlbVBouHxn2sEnAjr1dr4JMfIn4Mr4\"\n    }\n)\n\nوفي الواقع يتم تكوين الطلب كنص (string) بهذا الشكل (ونحن هنا نطبعه بصيغته النصية لغرضٍ تعليمي):\n\nprint(f\"\"\"\n{request.method} {request.url.path} HTTP/1.1\n{\"\\n\".join([f\"{k}: {v}\" for k, v in request.headers.items()])}\n\n\"\"\")\n\n\nGET /v1/images/search HTTP/1.1\nhost: api.thecatapi.com\naccept: */*\naccept-encoding: gzip, deflate\nconnection: keep-alive\nuser-agent: python-httpx/0.28.1\nx-api-key: live_9Cj8P0h75D5h2D7Y2H8MYEuuTmTXjT412xNlbVBouHxn2sEnAjr1dr4JMfIn4Mr4\n\n\n\n\nفأما السطر الأول:\nGET /v1/images/search HTTP/1.1\nفمكون من ثلاثة أجزاء:\n\nنوع الطلب: GET ذلك أننا نريد حصول على معلومات (لا إنشاءها ولا تغييرها)\nالمسار: /v1/images/search هو المسار الفرعي الذي يحدد الخدمة المطلوبة\nنسخة قوانين التواصل: HTTP/1.1 فشكل الطلب والجواب يعتمد على هذه النسخة\n\nوأما الوُجهة فمحددة بالرأس Host على هذا النحو:\nhost: api.thecatapi.com\nوالترويسة الأخيرة x-api-key هي ليست من الترويسات المعرَّفة في HTTP، ولكنه اتفاق بين العميل والخادم:\nx-api-key: ...\nوقد أضاف العميل رؤسًا لم نعيِّنها وهي: accept, accept-encoding, connection, user-agent، وإليك معناها:\n\naccept: */* وتعني أننا نقبل الجواب بأي صيغة؛ سواء كانت بصيغة JSON أو HTML أو أي صيغة أخرى\naccept-encoding: gzip, deflate تعني أن العميل يتوقع المحتوى مضغوطًا بصيغة ضغط معينة\nconnection: keep-alive تعني أن العميل يريد الحفاظ على الاتصال بالخادم\nuser-agent: python-httpx/0.28.1 هي ترويسة إجبارية ولا يهم ما تكون قيمتها. لكنها تعرِّف بهوية العميل\n\nوبعد ذلك نرسل الطلب بالإجراء send ونحصل على جواب response:\n\nresponse = client.send(request)\n\nوالجواب نفسه له الصيغة النصية التالية:\n\nprint(f\"\"\"\n{response.status_code} {response.reason_phrase}\n{\"\\n\".join([f\"{k}: {v}\" for k, v in response.headers.items()])}\n\n{response.text}\n\"\"\")\n\n\n200 OK\nx-dns-prefetch-control: off\nx-frame-options: SAMEORIGIN\nstrict-transport-security: max-age=15552000; includeSubDomains\nx-download-options: noopen\nx-content-type-options: nosniff\nx-xss-protection: 1; mode=block\nvary: Origin\nexpires: Tue, 03 Jul 2001 06:00:00 GMT\nlast-modified: Thu Mar 27 2025 21:03:30 GMT+0000 (Coordinated Universal Time)\ncache-control: post-check=0, pre-check=0\nauthenticated: false\ncontent-type: application/json; charset=utf-8\nx-response-time: 236ms\nx-cloud-trace-context: 198a37888b0f0aecb61c4481a201abe7\ndate: Thu, 27 Mar 2025 21:03:30 GMT\nserver: Google Frontend\ncontent-length: 89\n\n[{\"id\":\"2ml\",\"url\":\"https://cdn2.thecatapi.com/images/2ml.jpg\",\"width\":500,\"height\":340}]\n\n\n\nولاحظ أول سطر في نص الجواب: 200 OK تعني أن الطلب تمُّ إنجازه بنجاح. وراجع الرؤس (Headers) إن أردت معرفة معنى كل ترويسة هنا (وليست تهمنا الآن). لكن ما يبدأ بحرف x- هو إضافي وليس من أساس لغة HTTP المتفق عليها، ولذلك قد لا تجده في التوثيق العام، وإنما تجده في توثيق مزوِّد للخدمة.\nولاحظ أن آخر سطرٍ هو المحتوى:\n[{\"id\": ... ,\"url\": ... , ... }]\nوإذا نظرت إلى النصّ الموجود في محتوى الرد (response.text) فإنك ستلاحظ أنه نصُّ مقوْلَب بصيغة JSON التي سبق الحديث عنها:\n\nprint(type(response.text))\nprint(response.text)\n\n&lt;class 'str'&gt;\n[{\"id\":\"2ml\",\"url\":\"https://cdn2.thecatapi.com/images/2ml.jpg\",\"width\":500,\"height\":340}]\n\n\nولكن هذا النص لا يمكن التعامل معه كما هو، لذلك نستخدم الإجراء json() لتفسيره إلى شيء في بايثون (قائمة):\n\ndata = response.json()\nprint(type(data))\nprint(data)\n\n&lt;class 'list'&gt;\n[{'id': '2ml', 'url': 'https://cdn2.thecatapi.com/images/2ml.jpg', 'width': 500, 'height': 340}]\n\n\nالآن أصبح في هيكل بيانات يمكن التعامل معه. فنريد استخراج رابط الصورة منه:\n\nimage_url = data[0][\"url\"]\nprint(image_url)\n\nhttps://cdn2.thecatapi.com/images/2ml.jpg\n\n\nفهذا الرابط، لو نسخته وأدخلته في المتصفح فستظهر لك صورة القط.\n\n\nالكود\nfrom IPython.display import Image, display\n\ndisplay(Image(url=image_url))",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>التخاطب عبر الشبكة</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a3_use_http.html#مثال-خدمة-الطقس",
    "href": "chapters/15_using/a3_use_http.html#مثال-خدمة-الطقس",
    "title": "25  التخاطب عبر الشبكة",
    "section": "مثال: خدمة الطقس",
    "text": "مثال: خدمة الطقس\nوالرابط يشبه استدعاء الإجراء. لاحظ أننا في بايثون نستدعي الإجراء pow من الوحدة math ونمرر العوامل 2, 3 إليه على هذا النحو:\n\nimport math\n\nmath.pow(2, 3)\n\n8.0\n\n\nوهكذا نشبِّه ذلك بطريقة العنوان الموحَّد باعتبار أن المورِد هو معالجة؛ وهي سؤالٌ عن الطقس في مدينة لندن:\n\n\n\n\nOrigin (الأصل)\nPath (المسار)\nQuery (المعاملات)\n\n\n\n\nhttps://api.openweathermap.org\n/weather\n?city=London\n\n\nmath\npow\n2, 3\n\n\n\n\n\nفكما أننا نطلب الإجراء pow من الوحدة math ونمرر العوامل 2, 3 إليه\nفكذلك نطلب المورِد /weather من الموقع https://api.openweathermap.org ونمرر العوامل ?city=London إليه\n\nالعامل يبتدأ بعلامة الاستفهام ? ثم اسم العامل city وقيمته London وهو اسم المدينة\n\n\nلنأخذ مثالاً آخر على استخدام خدمة برمجية، وهي خدمة الطقس من OpenWeatherMap. هذه الخدمة تتيح لنا معرفة حالة الطقس في أي مدينة في العالم.\nأولاً، نحتاج إلى مفتاح API من الموقع (يمكنك الحصول عليه مجاناً بعد التسجيل). ثم نستخدم مكتبة httpx للاتصال بالخدمة.\nففي صفحة التوثيق قالوا إن طريقة الطلب هي على النحو التالي:\nنشرح الرابط حتى تتبين أجزاؤه ليسهل عليك بعد ذلك قراءة أية رابط:\nhttps://api.openweathermap.org/data/3.0/onecall?lat={lat}&lon={lon}&exclude={part}&appid={API key}:\n\nhttps://api.openweathermap.org هو الأصل (Origin)\n/data/3.0/onecall هو المسار الفرعي (Path)\n? العلامة الفاصلة بين المسار والعوامل\n& علامة فاصلة بين العوامل نفسها\nlat={latitude} هو تعيين للعامل الأوَّل بقيمة latitude أي: خط العرض\nlon={longitude} هو تعيين للعامل الثاني بقيمة longitude أي: خط الطول\nexclude={part} اختيار البيانات التي تريد استبعادها في جواب الطلب\nappid={API key} هو مفتاح التطبيق الذي يسمح للطلب بالوصول إلى الخدمة\n\nونحن نكتبها في بايثون مع مكتبة httpx على النحو التالي:\n\nimport httpx\n\nlatitude = 24.7136\nlongitude = 46.6753\n\nclient = httpx.Client()\n\nrequest = client.build_request(\n    method=\"GET\",\n    url=\"https://api.openweathermap.org/data/3.0/onecall\",\n    params={\n        \"lat\": round(latitude, 4),\n        \"lon\": round(longitude, 4),\n        \"appid\": \"4a5417dd3a781b7f64f05178ed423a23\"\n    }\n)\n\nresponse = client.send(request)\nprint(response.text)\n\n{\"cod\":401, \"message\": \"Please note that using One Call 3.0 requires a separate subscription to the One Call by Call plan. Learn more here https://openweathermap.org/price. If you have a valid subscription to the One Call by Call plan, but still receive this error, then please see https://openweathermap.org/faq#error401 for more info.\"}\n\n\nأو اختصارًا باستعمال httpx.get مباشرةً هكذا:\n\nimport httpx\n\nlatitude = 24.7136\nlongitude = 46.6753\n\nresponse = httpx.get(\n    url=\"https://api.openweathermap.org/data/3.0/onecall\",\n    params={\n        \"lat\": round(latitude, 4),\n        \"lon\": round(longitude, 4),\n        \"appid\": \"4a5417dd3a781b7f64f05178ed423a23\"\n    }\n)\nprint(response.text)\n\n{\"cod\":401, \"message\": \"Please note that using One Call 3.0 requires a separate subscription to the One Call by Call plan. Learn more here https://openweathermap.org/price. If you have a valid subscription to the One Call by Call plan, but still receive this error, then please see https://openweathermap.org/faq#error401 for more info.\"}",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>التخاطب عبر الشبكة</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/a3_use_http.html#انطلق-بالتطبيق",
    "href": "chapters/15_using/a3_use_http.html#انطلق-بالتطبيق",
    "title": "25  التخاطب عبر الشبكة",
    "section": "انطلق بالتطبيق",
    "text": "انطلق بالتطبيق\nوبهذا تكون قادرًا على التعامل مع أي برمجيَّة توفِّر خدماتها عبر الشبكة. تحتاج فقط أن تُقدِم وتجرِّب حتى تأخذ يدك على الأمر!\nانتقل إلى المسائل.فإن أردت البحث عن واجهة برمجية لعمل شيء ما، فاكتب الكلمات المفتاحية + “API” في محرك البحث؛ مثلاً: Google Maps API.\nملاحظة: بعض الواجهات تتطلب التسجيل للحصول على مفتاح API. وبعضها يحتاج إضافة إلى ذلك شحن الحساب برصيد مثل 5 دولارات. وكل ذلك مبين في التوثيق نفسه.",
    "crumbs": [
      "تكامل البرمجيات",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>التخاطب عبر الشبكة</span>"
    ]
  },
  {
    "objectID": "chapters/15_using/problems.html",
    "href": "chapters/15_using/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "قراءة توثيق مكتبة (httpx)\nنرجو منك أولاً قراءة صفحة البداية السريعة لـ httpx كاملةً بتأني؛ لأنها ستعطيك نظرة عامة على آليات HTTP وكيفية التعبير عنها بلغة بايثون. وذلك لأن HTTP هي لغة التخاطب على شبكة الإنرتنت بين البرمجيات.",
    "crumbs": [
      "تكامل البرمجيات",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/15_using/problems.html#التطبيق-على-إحدى-الواجهات-البرمجية",
    "href": "chapters/15_using/problems.html#التطبيق-على-إحدى-الواجهات-البرمجية",
    "title": "مسائل",
    "section": "التطبيق على إحدى الواجهات البرمجية",
    "text": "التطبيق على إحدى الواجهات البرمجية\nلابد أن تجد في موقع المزوِّد توثيقًا لجميع تفاصيله للاستفادة منه. ابحث عل كلمة API Documentation أو Developers ونحوهما لتجد التوثيق. وقد تجد عنوانًا مثل: بداية سريعة (Quick Start) أو نحوها للبدء. وعادةً ما يتضمن التوثيق: وصف جميع نقاط الالتقاء (Endpoints) التي تحدد العناوين الفرعية التابعة للعنوان الرئيسي للواجهة. الآن دورك. عليك قراءة التوثيق بتمعُّن، والتجول في صفحاته حتى تتعلم كيفية استخدام الواجهة البرمجية لتحقيق مهمة واحدة.\nجرب استعمال أحد الواجهات البرمجية التالية:\n\npoetrydb\nnewtown\nalquran-cloud\nWikipedia\nnasa\narxiv\nTelegram\nDiscord\nGoogle AI Studio\n\nوهنا تجميع لقائمة كبيرة مقسمة اختر منها ما تريد (وقد يكون بعضها لا يعمل): https://github.com/public-apis/public-apis.\nفإن أردت البحث عن واجهة برمجية لعمل شيء ما، فاكتب الكلمات المفتاحية + “API” في محرك البحث؛ مثلاً: Google Maps API.\nملاحظة: بعض الواجهات تتطلب التسجيل للحصول على مفتاح API. وبعضها يحتاج إضافة إلى ذلك شحن الحساب برصيد مثل 5 دولارات. وكل ذلك مبين في التوثيق نفسه.",
    "crumbs": [
      "تكامل البرمجيات",
      "مسائل"
    ]
  },
  {
    "objectID": "appendix_collections.html",
    "href": "appendix_collections.html",
    "title": "خريطة الجُمُوع",
    "section": "",
    "text": "classDiagram\n    class Container {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n    }\n\n    class Iterable {\n        &lt;&lt;abstract&gt;&gt;\n        +__iter__()\n    }\n\n    class Iterator {\n        &lt;&lt;abstract&gt;&gt;\n        +__next__()\n        +__iter__()\n    }\n\n    class Reversible {\n        &lt;&lt;abstract&gt;&gt;\n        +__reversed__()\n    }\n\n    class Sized {\n        &lt;&lt;abstract&gt;&gt;\n        +__len__()\n    }\n\n    class Collection {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n    }\n\n    class Sequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__len__()\n        +__contains__()\n        +__iter__()\n        +__reversed__()\n        +index()\n        +count()\n    }\n\n    class MutableSequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__len__()\n        +insert()\n        +append()\n        +clear()\n        +reverse()\n        +extend()\n        +pop()\n        +remove()\n        +__iadd__()\n    }\n\n    class Set {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +__le__()\n        +__lt__()\n        +__eq__()\n        +__ne__()\n        +__gt__()\n        +__ge__()\n        +__and__()\n        +__or__()\n        +__sub__()\n        +__xor__()\n        +isdisjoint()\n    }\n\n    class MutableSet {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +add()\n        +discard()\n        +clear()\n        +pop()\n        +remove()\n        +__ior__()\n        +__iand__()\n        +__ixor__()\n        +__isub__()\n    }\n\n    class Mapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__iter__()\n        +__len__()\n        +__contains__()\n        +keys()\n        +items()\n        +values()\n        +get()\n        +__eq__()\n        +__ne__()\n    }\n\n    class MutableMapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__iter__()\n        +__len__()\n        +pop()\n        +popitem()\n        +clear()\n        +update()\n        +setdefault()\n    }\n\n    Iterable &lt;|-- Iterator\n    Iterable &lt;|-- Reversible\n    Sized &lt;|-- Collection\n    Iterable &lt;|-- Collection\n    Container &lt;|-- Collection\n    Reversible &lt;|-- Sequence\n    Collection &lt;|-- Sequence\n    Sequence &lt;|-- MutableSequence\n    Collection &lt;|-- Set\n    Set &lt;|-- MutableSet\n    Collection &lt;|-- Mapping\n    Mapping &lt;|-- MutableMapping\n\n    MutableSequence &lt;-- list\n    Sequence &lt;-- tuple\n    Sequence &lt;-- range\n    Sequence &lt;-- str\n    MutableMapping &lt;-- dict\n    Set &lt;-- frozenset\n    MutableSet &lt;-- set\n\n\n\n\nشكل 1: الأنواع المجردة حول الجمع (Collection)",
    "crumbs": [
      "الملحقات",
      "خريطة الجُمُوع"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "قاموس المصطلحات",
    "section": "",
    "text": "الكود\nfrom IPython.display import display, HTML\nimport pandas as pd\n\n# Read the CSV file\ndf = pd.read_csv('assets/glossary.csv')\n\n# Replace NaN values in the 'comment' column with empty strings\ndf['comment'] = df['comment'].fillna('')\n\ndf.rename(columns={\n    'ar': 'عربي',\n    'en': 'English',\n    'comment': 'تعليق'\n}, inplace=True)\n\n# Display the dataframe as an HTML table\ndf.to_html(index=False)\ndisplay(HTML(df.to_html(index=False)))\n\n\n\n\n\nEnglish\nعربي\nتعليق\n\n\n\n\nIdentifier\nمعرِّف\nبالكسر\n\n\nVariable\nمتغير\n\n\n\nValue\nقيمة\n\n\n\nLiteral\nحرفي\n\n\n\nSimple Statement\nجملة بسيطة\n\n\n\nCompound Statement\nجملة مركبة\n\n\n\nExpression\nتعبير\nمثل: `x + y`\n\n\nClause\nشطر جملة\nمثل: `if x &gt; y`\n\n\nCode Block\nقطعة برمجية\n\n\n\nOperation\nعملية\nمثل: `+` في `x + y` و مثل: `.` في `point.x`\n\n\nFunction\nفعل\nفي سياق البرمجة لا نقول دالة لأن الدالة دائمًا لها مخرجات ولا تتأثر إلا بمدخلاتها\n\n\nMethod\nفعل أو سلوك\nمثل: `append` في `list.append(x)`\n\n\nObject\nشيء أو كائن\n\n\n\nClass\nصنف\nأو فئة\n\n\nType\nنوع\n\n\n\nContainer\nحاوية\nأو حاوي\n\n\nIterable\nمُكرَّر\nبالفتح\n\n\nIterator\nمكرِّر\nبالكسر\n\n\nReversible\nمعكوس\nمفعول به: قابل للعكس\n\n\nGenerator\nمولِّد\nفاعل\n\n\nSized\nمحجَّم\nصفة: ذو حجم\n\n\nCallable\nمنادى\n\n\n\nCollection\nجمع\nعكس المفرد\n\n\nSequence\nتسلسل\n\n\n\nMutable Sequence\nتسلسل متغير\n\n\n\nList\nقائمة\n\n\n\nList Index\nمؤشر قائمة\n\n\n\nDatabase Index\nفهرس قاعدة بيانات\n\n\n\nTuple\nصف\nفرد، زوج) صف ثلاثي، صف رباعي، ...إلخ\n\n\nSet\nمجموعة\n\n\n\nDictionary\nقاموس\n\n\n\nMapping\nدالة\n\n\n\nHashable\nمرقوم\nصفة: يصير رقمًا\n\n\nDictionary Key\nمرقوم قاموس\n\n\n\nDictionary Item\nرابط\n\n\n\nKey\nمفتاح\n\n\n\nValue\nقيمة\n\n\n\nString\nنص\n\n\n\nView\nعرض\n\n\n\nParameter\nمعامل\nوهي المتغيرات الشكلية في تعريف الفعل\n\n\nArgument\nمعامل\nقيم التعيين للمتغيرات الشكلية\n\n\nModule\nوحدة\n\n\n\nPackage\nحزمة\n\n\n\nLibrary\nمكتبة\n\n\n\nFramework\nإطار عمل\n\n\n\nBuilt-in\nمدمج\n\n\n\n{}\nقوسين معوجين أو قوسين متعرجين\n\n\n\n[]\nقوسين مربعين\n\n\n\n()\nقوسين دائريين\n\n\n\n&lt;&gt;\nقوسين زاويين أو قوسين حادين\n\n\n\nFeedback\nتعقيب\nالتعليقات أو الردود التي ترد بعد عرض رأي أو عمل\n\n\nStatic\nثابت\n\n\n\nDynamic\nمتغير\n\n\n\nConstant\nثابت\n\n\n\nVariable\nمتغير\n\n\n\nSystem Time\nوقت النظام\n\n\n\nCalendar Time\nوقت التقويم\n\n\n\nEpoch\nالمرجع الزمني الحاسوبي\n\n\n\nPositional\nمكاني\n\n\n\nSwap\nقَلب\nفعل\n\n\nFile\nملف\n\n\n\nPath\nمسار\n\n\n\nDirectory\nدليل\n\n\n\nAbsolute Path\nمسار مطلق\nيبدأ من الجذر\n\n\nRelative Path\nمسار نسبي\nيبدأ من الموقع الحالي\n\n\nContext Manager\nمدير سياق\nيتحكم في فتح وإغلاق الموارد\n\n\nRecursion\nتسلسل\nفي الفعل فعلٌ بنفس الفعل\n\n\nRecursive Function\nفعل متسلسل\n\n\n\nExecution Frame\nإطار تنفيذ\n\n\n\nObject-Oriented Programming\nبرمجة شيئية\n\n\n\nAttribute\nصفة\nمتغير مسند لمعيَّن من النوع\n\n\nMethod\nفعل\nفعل مسند لمعيَّن من النوع\n\n\nComposition\nتركيب\n\n\n\nInheritance\nتوريث",
    "crumbs": [
      "الملحقات",
      "قاموس المصطلحات"
    ]
  }
]