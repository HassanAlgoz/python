[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "مقدمة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-نبرمج",
    "href": "index.html#لماذا-نبرمج",
    "title": "البايثونية",
    "section": "لماذا نبرمج؟",
    "text": "لماذا نبرمج؟\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nثم أدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة التخزين.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة ويشغِّل هذه الإلكترونيات المجهرية لتحقيق مقصوده منها.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لمن-هذا-الكتاب",
    "href": "index.html#لمن-هذا-الكتاب",
    "title": "البايثونية",
    "section": "لمن هذا الكتاب؟",
    "text": "لمن هذا الكتاب؟\nبدأت بوادر تأليف هذا الكتاب أثناء تدريسي البرمجة بلغة بايثون لخريجي التخصصات التقنية تمهيدًا لهم للدخول في علوم البيانات والذكاء الاصطناعي. فأردت أن أضع مادة جامعة شاملة لأهم مفاهيم البرمجة في مستوى تطبيقي لا ينزل إلى التفاصيل الدقيقة التي لا يحتاج إليها الطالب. وقد راعيت فيه أصحاب التخصصات غير التقنية إذْ لم أغرِق في التفاصيل الرياضية ولا الحاسوبية الدقيقة، ولم أسهب فيها.\n\nفمن أراد أن يبدأ في البرمجة فليبدأ بهذا الكتاب؛ فالمواضيع منظمة بشكل منطقي وعملي مع مسائل نافعة للمبرمج تقترب في كل مرة من الواقع أكثر فأكثر.\nومن أراد مرجِعًا لمواضيع البرمجة بلغة بايثون فهذا الكتاب صديقه؛ فالكتاب مقسَّم بحسب الموضوعات وكل موضوعٍ مقسَّم كذلك لتسهيل الوصول إلى أي مفهوم. كما تستطيع استعمال خاصيَّة البحث.\nوهو كذلك معينٌ لمن أراد تدريس البرمجة منطلقًا من لغة بايثون؛ فقد جمعتُ فيه ما تفرَّق ونظمتُه بعد نظرٍ في عدة مؤلفات مماثلة، وعلى ما رأيتُ أنه أنفع للمتعلم، وأضفتُ بعض الأقسام المتممة لما رأيت أنه ناقص بدونها.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#أهداف-الكتاب",
    "href": "index.html#أهداف-الكتاب",
    "title": "البايثونية",
    "section": "أهداف الكتاب",
    "text": "أهداف الكتاب\n\nاستيعاب ماهية البرمجة، ومعرفة إمكانياتها وحدودها\nإكساب مهارة التعبير الخوارزمي ثم كتابة ذلك بلغة بايثون وتشغيلها والاستفادة من نتائجها\nإكساب مهارة تركيب البرمجيات المعقَّدة عن طريق البحث وتجربة العديد من المكتبات البرمجيَّة المتكاملة مع بايثون\n\nوأرجو الله أنك بتحقيق الهدف الثالث تفتح لك أبواب البرمجة، حيث تبحث وتقلب في مكتبة البرمجيات وتستعمل منها ما تحقق به مقصودك.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#مشاكل-نحاول-تفاديها",
    "href": "index.html#مشاكل-نحاول-تفاديها",
    "title": "البايثونية",
    "section": "مشاكل نحاول تفاديها",
    "text": "مشاكل نحاول تفاديها\nما حاولت تفاديه في الكتاب الذي بين يديك مما قد تجده في مواد أخرى تشرح البرمجة أو بايثون:\n❌ العشوائية: قفز عشوائي بين المواضيع دون تسلسل منطقي؛ بحيث لا يُدرِك المتعلِّم مناسبَة المواضيع! ولا يفهم أن هناك بناءً معرفيًّا يجب أن يتكوَّن لديه في خريطته الذهنية مع كل مفهوم جديد!\n❌ السطحية: سرد كيفية عمل كذا وكذا، ثم كيفية كذا وكذا، ثم كيفية كذا وكذا …إلخ، ولا تعلم لماذا هذه وهنا وتلك هناك؛ فتتكون لدى المتعلم نظرة سطحية أن البرمجة عبارة عن قطع يجب حفظها ونسخها ولصقها لا أكثر ولا أقل!\n❌ السلبية: عدم وجود تطبيقات ومسائل يتمرس عليها الطالب. أو نسخ ولصق ألغاز أكاديمية خارج سياقها. أو عدم ربطها ببعضها وبالمفاهيم النظريَّة بشكل واضح!\n❌ التشويه: تبسيط المفاهيم لدرجة مخلَّة بالحقيقة، أو تعقيدها لدرجة تحيِّر القارئ أكثر. أو الاعتماد على مصادر ثانويَّة ضعيفة مع توفر المصادر أصلية، أو إهمال المصادر وادعاء أشياء ليس لها مستند!\nوغيرها كثير.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-وقع-الاختيار-على-لغة-بايثون",
    "href": "index.html#لماذا-وقع-الاختيار-على-لغة-بايثون",
    "title": "البايثونية",
    "section": "لماذا وقع الاختيار على لغة بايثون؟",
    "text": "لماذا وقع الاختيار على لغة بايثون؟\nصممت بايثون لتكون عالية المستوى: أي مجردة عن كثير من التفاصيل الحاسوبية التي لا يهتم لها غير المختص. وهذا جلعها سهلة: ففي البداية يحس المتعلم أنه يتعلم لغة إنجليزية بقواعد معيَّنة. فزادت المكتباب البرمجية: وهي ما يتشاركه المجتمع من قطع برمجية. وتضافرت الجهود وتنوَّعت المجالات بشكل كبير جدًّا، حتى لا يكاد يوجد مجال إلا ودخلته بايثون.\n\nمجالات لغة بايثون\nإذا نظرنا في إحصاء JetBrains 2023 نجد مجالات استعمال لغة بايثون:\n\n\n\nبم تستعمل لغة بايثون؟\n\n\n\n47% تحليل البيانات\n42% تعلم الآلة (الذكاء الاصطناعي)\n39% تطوير المواقع\n31% برمجة كاسحات المواقع (التي تجمع البيانات)\n30% أتمتة إدارة الأنظمة والبنية التحتية التقنية\n26% أتمتة اختبار البرمجيات\n23% أغراض تعليمية\n22% صناعة برمجيات أوليَّة (أي لسهولتها)\n\nوانظر إحصاء JetBrains 2024 لمقارنة بايثون مع غيرها من اللغات، حيث يظهر في الجدول التالي توزيع استعمال المبرمجين للغات في مختلف المجالات. ويظهر لنا أن بايثون هي أكثر اللغات انتشارًا بين المجالات التقنية؛ فتعلمها يعطيك أوسع فرصة في المجالات:\n\n\n\nتوزيع استعمال اللغات بحسب المجالات التقنية في 2024\n\n\nوإليك بعض الشركات التقنية التي قامت على بايثون: Instagram، Spotify, Reddit, Netflix, Dropbox, Quora, Pintrest.\n\n\nبايثون وحدها لا تكفي\nالواقع أن ليسَ ثمة لغة واحدة تحقق كل متطلبات بناء التطبيق؛ بل يغلب على المشاريع البرمجية تعدد اللغات فيها، وإن كانت مشاريع فردية صغيرة. وليست بايثون مقصودة لذاتها. فإن من منافع التعلم بطريقة تأصيلية صحيحة؛ أن تعلُّمَك للغة الثانية يصبح أسهل؛ وقد تختلف أساليب التعبير بين لغة وأخرى، إلا أن المفاهيم متشابهة.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#منهجية-الكتاب",
    "href": "index.html#منهجية-الكتاب",
    "title": "البايثونية",
    "section": "منهجية الكتاب",
    "text": "منهجية الكتاب\nتم تقسيم الكتاب ليكون في الباب أربعة جوانب:\n\nمفاهيم حيث نشرح المعاني والآليات الأساسية بوجه شامل ومنظم ومختصر جدًّا.\nتطبيقات: حيث نطبق ما تعلمناه على مسائل واقعية متنوعة، ونشرح بالتفصيل القطع البرمجية.\nمسائل: حيث يأتي دوْر المتعلم للممارسة العملية.\nحل المسائل: حيث يقارن المتعلم طريقته مع طريقة أخرى مقترحة لحل كل مسألة.\n\nوقد تم فصل الجانب التطبيقي عن الجانب النظري: حيث نبني التصوُّرات أولاً حتى تتكون لدينا نظرة شموليَّة لأن مفاهيم الباب متعلِّقة ببعضها، ثم نبدأ بتطبيقها واحدًا تلو الآخر في نفس الباب، قبل الانتقال للباب الذي بعده. ويتسنى للمتدرب ممارسة مجموعة لا بأس بها من المسائل تشمل معظم المفاهيم المدروسة أو كلها.\n✅ ونحن نأمِّل في الطالب أن يكون مجتهدًا باحثًا حريصًا على إفهام نفسه بنسخ القطع البرمجية وتغييرها وتشغيلها وتقليبها غير معتمِدٍ على مجرَّد الطرح. فكلّ قطعة تحتاج لتأمُّل.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#موضوعات-الكتاب",
    "href": "index.html#موضوعات-الكتاب",
    "title": "البايثونية",
    "section": "موضوعات الكتاب",
    "text": "موضوعات الكتاب\nنبدأ بمقدمتين:\nالمقدمة الأولى عن لغة البرمجة: مفرداتها وجملها وقواعدها ونموها بالمكتبات الأساسية والخارجية.\nالمقدمة الثانية عن معمارية فون نويمان: الإحساس والاستيعاب والمعالجة والتخزين.\nوبهتين المقدمتين يتكون لدينا تصوُّر عن ماهية لغة البرمجة وأجزاء الحاسب الأساسية التي تعمل فيها اللغة.\nباب الأعداد: ندخل في كيفية التعبير عن الحِساب البسيط كعملية الجمع. ففيه الحساب والمقارنة، وترتيب العمليات، والتعيين النسبي، ووحدة الرياضيات، ومجموعة الأعداد، وأنواع الأعداد (الصحيح والمنطقي والعشري)، والفرق بين النوع العددي والنصي، وكتابة القيم العددية.\nباب الشرط والتكرار: فنتعلم كيفية تعليق تنفيذ جملة على شرط، وكذلك كيف نختار أن نكرر مجموعة من العمليات عددًا من المرات (أيًّا كانت هذه العلميات). ففيه الجملة الشرطية والتعبيرات المنطقية وتركيب الشروط وتضمين الجمل الشرطية، وجمل التكرار وما يتعلق بها من جمل التحكم في التكرار.\nثم الجمع المرتب: إذ ننتقل من التعامل مع أفراد البيانات إلى مجموعات البيانات. ففيه المجموعة المرتبة والصف والقائمة، وعمليات الإشارة والتقطيع والتكرار، وعمليات التعديل والإضافة والحذف، والفرز والترتيب.\nثم الجمع المرقَّم: إذ نتعامل مع المجموعات التي تكون عناصرها ذات رقم / رمز وليسَ لها موضِع في المجموعة. وفيه المجموعة الرياضية والقاموس، وعمليات الإضافة والحذف والتعديل، والبحث والتكرار، والتقاطع والاتحاد والفرق.\nثم النص: وهو سلسلة الرموز (سواءُ كانت حروفًا أو بيانات أو أي سلسلة منسقة أو غير منسقة من البيانات). ففيه النص الطبيعي والمقولب، وإنشاء النص وقراءته، والإشارة والتقطيع، والعمليات الخاصة بالنصوص من استبدال وبحث وفصل ووصل، وتفسير الأرقام وإخراج النص وتنسيقه. وكذلك ترميز يونيكود وتشفير النصوص وتحويلها.\nثم التعامل مع الأخطاء؛ وفيه الخطأ النحوي والخطأ المنطقي والخطأ الواقعي؛ وكيفية التعامل مع الخطأ المتوقع (الاستثناء).\nثم البرمجة الإجرائية: فنتعلم كيفية تعريف الإجراءات لنعطيها أسماءً من عندنا ونستدعيها أينما نريد. ففيه تعريف الإجراء وعوامله المؤثرة والمتأثرة، وطريقتان لتعيين العوامل: بالموضع وبالاسم، وتعريف إجراءات جديدة بتفاصيلها وتنفيذها، والعوامل الجائزة والواجبة، والتصريح بالنوع، ومفهوم نطاق التسمية، وثمرة الإجراء.\nثم صياغة البيانات وانتقالها وتخزينها وقراءتها وكتابتها، وكذلك التعامل مع المجلدات والملفات.\nثم مكتبات المجتمع البرمجي؛ حيث نتعلم كيفية الاستفادة من البرمجيات التي كتبها الآخرون، سواءٌ كانت مكتبة أو خدمة متصلة بالشبكة العالمية.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-نعرب-المصطلحات",
    "href": "index.html#لماذا-نعرب-المصطلحات",
    "title": "البايثونية",
    "section": "لماذا نعرب المصطلحات؟",
    "text": "لماذا نعرب المصطلحات؟\nللإجابة عن هذا السؤال إليك هذه القطعة:\n\nيستيقظ سعد فينظر في موبايله أولاً، ثم يطفئ الكونديشنر ليركب في الكار الإلكيتريك التي تستمد الإنرجي من شغل الماجنيت، متجهًا إلى عمله بينما يستمع للراديو حيث يدور الحديث حول ترانسبلانت الشعر.\n\nوهل صياغتها هكذا أفضل؟\n\nيستيقظ سعد فينظر في جواله أولاً، ثم يطفئ المكيِّف ليركب في سيارته الكهربائية التي تستمد طاقتها من آلية عمل المغناطيس، متجهًا إلى عمله بينما يستمع للمذياع حيث يدور الحديث حول زراعة الشعر.\n\nأزعم أن الفرق واضح. وهل هذه إلا مخترعات جديدة، ومصطلحات معرَّبة؟ فلماذا يُستغرَب تعريب المصطلحات التي تظهر في العلوم التي ظهرت بعد ذلك؟ والجواب فيما يظهر: هو التداول؛ فإذا استعمل الناس المصطلح للتعبير عن مقصودهم بكثرة؛ شاع وتقبلته الأسماع وجرى على الألسن. وإذا مقتوه أو تصلَّبت ألسنتهم عند محاولة النطق به واستبدلوه باللفظ الأعجمي أماتوه؛ وإن كان مكتوبًا في قواميس الدنيا والمعاجم كلها.\nوالمصطلحات العلمية لا تنشأ من غير سياق. فلسيت هي حاصل تعريف الكلمة من حيث هي. بل لا بد من النظر في السياق المكتوب وغير المكتوب حتى يتوصَّل إلى المعنى ثم من بعد ذلك يُؤتى باللفظ المناسب من معاجم اللغة؛ وذلك التناسُب يجب فيه مراعاة المصطلحات المصاحبة كذلك .. فالتعريب السليم فنّ نابعٌ من حب اللغة.\nولو نظرت في اللغة نفسها لرأيت في المصطلح الواحد اختلافًا كثيرًا، وهذا أمر طبعي لاختلاف الأنظار والأذواق والألسن. على سبيل المثال:\n\nمصطلح القيمة التي تدل على العدم: Null, Nil, None\nوكذلك المرادفات: import, include, use, require, using, load, link\nومصطلح الإجراء (Procedure) من مرادفاته المستعملة في لغات دون لغات: Routine, Subroutine, Subprogram, Function, Method.\n\nوأعظم من ذلك؛ عدد لغات البرمجة (250+) التي تعبر كل واحدة منها بأسلوبها الخاص؛ وكلها حروف إنجليزية. والمختصصون يُدركون حجم الاختلاف الكبير في المصطلحات الإنجليزية المستعملة مما يوهم من لم يخبرها أنها مختلفة في المعنى.\nفلماذا تضيق أفهامنا عن استيعاب الاختلاف حين يكون عربيًّا؟ بل يجب أن تتسع صدورنا للاختلاف إذْ لا مشاحة في الإصطلاح؛ وباب الاجتهاد فيه واسعٌ لا يجب التضييق فيه طالما كان المسلك لغويًّا صحيحًا.\nولعل وصف المفاهيم باللغة الأم أقرب للطبع، وأمكن في الذهن وأوعى، وأسهل في التقليب والانتقاد، وأوسع في الاختراع والإبداع. فالمفاهيم لا تتعلق باللغة التي كتبت بحروفها. فالمعنى شيء، واللغة شيء ثاني. بل إن علامة تمكن المرء من العلم حُسن العبارة عنه. فليس بينه وبين المفهوم حاجز اللغة، ولا هالة المصطلح.\nولا يفهم مما سبق أن المصطلح الإنجليزي مُهمَل؛ فقد اجتهدت في البيان العربي مع ذكر المصطلح الإنجليزي أينما وجب؛ وبذلك نضرب عصفورين بحجر. ولا بد للمتعلم من إتقان اللغة الإنجليزية ليستقل ويتبحر: فإنها مفتاحُ كثير من المواد المكتوبة والمسموعة والمرئية اليوم.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#الإسهام",
    "href": "index.html#الإسهام",
    "title": "البايثونية",
    "section": "الإسهام",
    "text": "الإسهام\nنرحب بالمساهمة في تحسين الكتاب:\n\nالتعليق: تجدون خانة لإنشاء تعليق أسفل كل صفحة من صفحات الكتاب (يتطلب ذلك إنشاء حساب على منصة GitHub)\nمنصة GitHub: برفع الملاحظات مباشرة على منصة GitHub",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "إعداد بيئة التطوير",
    "section": "",
    "text": "نبدأ بالتعرف على بيئة التطوير ، وتثبيتها في جهازك؛ وذلك أنني أؤمن بضرورة إكساب الفرد أعلى قدر من التحكم في أدواته حتى يتمكن منها ومن تطويعها لعمل ما يريد بالشكل الأمثل.\nبيئة التطوير هي الأدوات البرمجية الأساسية والمساعدة لعمليات كتابة النص البرمجي وتنفيذه واختباره ونحو ذلك.\n\nمحرر النصوص البرمجية\nأما محرر النص البرمجي فسنختار محرر (Visual Studio Code) التابع لشركة مايكروسوفت.\n\nوهو مفتوح المصدر (أي: يمكن الاطلاع على نصه البرمجي).\nويستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024 وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن.\nوتُعنى الشركة بدعمه وصيانته باستمرار وتطويره، كما يساهم فيه آخرون من خارج الشركة لكوْنه مفتوح المصدر.\nوتم تصميمه كي يقبل الزيادات واللواحق البرمجية ليختار كل مبرمج ما يناسبه من الأدوات حسب احتياجاته.\n\nموقع المحرر: https://code.visualstudio.com/\nولتشغيل القطع البرمجية راجع هذا الرابط: https://code.visualstudio.com/docs/python/run.\n\n\nإدارة حزمة البرمجيات\nوأما تنظيم المشروعات والمكتبات فسنختار uv من Astral إذْ يجمع بين الترتيب (فصل كل مشروع عن الآخر)، والسرعة (فهو أسرع بكثير من pip)، وكذلك السهولة.\nموقع مدير الحزم: https://docs.astral.sh/uv/\nتابع المقطع الذي فيه تفصيل ذلك كله:\n\n\nبعد ذلك تكون جاهزًا للبدء في البرمجة.",
    "crumbs": [
      "إعداد بيئة التطوير"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html",
    "href": "chapters/01_intro/a1_intro.html",
    "title": "المقدمة الأولى: لغة البرمجة",
    "section": "",
    "text": "القطعة البرمجية\nيتألف البرنامج المكتوب بلغة البرمجة من قِطَع 📄📄📄 هي عبارة عن سلسلة من الجُمَل البسيطة والمركبة المكونة من مُفْرَدات للتعبير عن أوامر يكتبها المبرمج ويقرأها الحاسب 💻️، تَتَّبِعُ قَواعِدَ نَحْوِيَّة صارمة حتى لا يشتبه عليه تفسيرها عند تحويلها لتعليمات مفصَّلة على لغة المنطق الرقمي للآلات المكون منها الحاسب لتنفذها.\nوفي هذا المثال عرضٌ لقطع برمجية في بايثون وشرحٌ لعملها، وليس المطلوب أي شيء منها أو تأمُّلَه ومحاولة فهمه بل هذه نظرة عامَّة لتكوين تصوُّر مُجْمَل عمّا سيأتي إن شاء الله.\nتُنَفَّذُ القطعة (Code Snippet) بحسب ترتيب جُمَلِها نزولاً من الأعلى.\npages = 900\nspeed =  50\nfinish_time = pages / speed\n\nif finish_time &lt; 14:\n    print('الوقت كافٍ')\nelse:\n    print('داهمنا الوقت')\n\nداهمنا الوقت\nفي هذه القطعة مجموعة جُمل، نشرحها سطرًا سطرًا:\nفهذه أربعة أنواع من الجُمل في قطعة واحدة. والجملة في بايثون لها أنواعُ كثيرة، وتنقسم إلى قسمين: بسيطة ومركبة:",
    "crumbs": [
      "المقدمة الأولى: لغة البرمجة"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#القطعة-البرمجية",
    "href": "chapters/01_intro/a1_intro.html#القطعة-البرمجية",
    "title": "المقدمة الأولى: لغة البرمجة",
    "section": "",
    "text": "السطرين الأولين: جملة تعيين حرفّيْ (900 و 50) لمتغير (pages و speed).\nالسطر الثالث: جملة تعيين ناتج عبارة القسمة. ولاحظ أن اسم المتغير finish_time يستعمل الشرطة السفلية بدلاً من المسافة (وهذا ضروري)\nجملة شرطية: if (بمعنى إن كان)\n\nالجزء الأول (الشرط): finish_time &lt; 14\nثم ما بعده مباشرة: جملة معلَّقة بالشرط\nالجزء الثاني else (بمعنى فإن لم يكن) جملة معلَّقة بانتفاء الشرط\n\n\n\n\n\nجملة بسيطة وهي 14 جملة:\n\nالتعبير: x + y\nالتعيين: x = y\nالتأكيد: assert condition\nالمرور: pass\nالحذف: del x\nالإرجاع: return y\nالإنتاج: yield y\nرفع الاستثناء: raise Exception\nالكسر: break\nالاستمرار: continue\nالاستيراد: import module\nالعالمية: global x\nغير المحلية: nonlocal x\nالنوع: type(x)\n\n\nجملة مركبة وهي 10 جمل:\n\nالشرط: if ...\nالتكرار: while ...\nالحلقة: for ...\nالمحاولة: try ...\nالسياق: with ...\nالمطابقة: match ...\nتعريف الإجراء: def ...\nتعريف النوع: class ...\nتعريف الإجراء غير المتزامن: async def ...\nقائمة الأنواع المتغيرة: [T1[, T2, ...]]",
    "crumbs": [
      "المقدمة الأولى: لغة البرمجة"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#الكلمات",
    "href": "chapters/01_intro/a1_intro.html#الكلمات",
    "title": "المقدمة الأولى: لغة البرمجة",
    "section": "الكلمات",
    "text": "الكلمات\nأول أنواع الكلمة هو المفردات الأصلية (Keywords) التي لها معنىً خاصّ مفهوم لدى بايثون وتستعمل في جُمَل محددة. وهي 35 كلمة:\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\nومنها كذلك 4 كلمات: match, case, type و _ (الشرطة السفلية).\nوما عدا ذلك …\nفقد تشكِّل الحروف كلمةً تكونُ متغيِّرًا (Variable)، نحو: x أو price أو body_weight فكلها أسماء مقبولة للمتغيرات؛ لا كما في الرياضيات التي عادةً ما تستعمل الحرف الواحد.\nوقد تشكِّل الحروف كلمة تكون حرفيٍّا (Literal)، نحو: 44 أو 3.14 أو \"كيف حالك؟\" ويُسمَّى قيمة (Value).\nومن الحروف علامات الابتداء والوَقف، نحو: ( ) و [ ] و { } والفصل، نحو: , (الفاصلة اللاتينية) و : (النقطتان الرأسِيَّتان) و = (علامة التعيين) ، وتُسمى جميعًا المحددات (Delimiters).\n\nفالأقواس () في العبارة: (y + z) * (a + b) لتحديد ترتيب العمليات\nوالأقواس () في العبارة: print(x, y, z) لتحديد عوامل الإجراء: أي: المتغيرات التي نمررها له\nوالأقواس () في العبارة: (10, 20, 30) لتحديد صف من الأرقام\n\nومن الحروف المعاملات (Operators)، نحو: + و * و / و ** و ==\nفمثلاً: معامل الجمع + يفسَّر بحسب السياق: x + y\n\nفإن كان x = 5 و y = 10 فهما من نوع الرقم (Number) فهي للجمع\nفإن كان x = \"Ahmad\" و y = \"Belal\" فهما من نوع النص (String) فهي للدمج بينهما\nفإن كان x = 5 و y = \"Belal\" فهما من نوع الرقم و النص فليسَ بمعرَّف (خطأ)",
    "crumbs": [
      "المقدمة الأولى: لغة البرمجة"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#الأنواع-والإجراءات-المبنية",
    "href": "chapters/01_intro/a1_intro.html#الأنواع-والإجراءات-المبنية",
    "title": "المقدمة الأولى: لغة البرمجة",
    "section": "الأنواع والإجراءات المبنية",
    "text": "الأنواع والإجراءات المبنية\nومن الأنواع والإجراءات ما هو مبنيُّ (Built-in) في لغة بايثون:\nالأنواع المبنية مثل:\n\nالرقم: int, float, complex للحساب\nالنص: str للتعامل مع الكلام المكتوب\nالجمع: list, tuple, range, set, dict لغير المفرد\n\n\n\n\n\n\ngraph TD\n    A[&lt;b&gt;شيء&lt;/b&gt; &lt;br&gt; &lt;code&gt;Object&lt;/code&gt;] --&gt; B[&lt;b&gt;رقم&lt;/b&gt; &lt;br&gt; &lt;code&gt;Number&lt;/code&gt;]\n    B --&gt; E[&lt;b&gt;صحيح&lt;/b&gt; &lt;br&gt; &lt;code&gt;int&lt;/code&gt;]\n    B --&gt; F[&lt;b&gt;عشري&lt;/b&gt; &lt;br&gt; &lt;code&gt;float&lt;/code&gt;]\n    B --&gt; G[&lt;b&gt;مركب&lt;/b&gt; &lt;br&gt; &lt;code&gt;Complex&lt;/code&gt;]\n    A --&gt; D[&lt;b&gt;جمع&lt;/b&gt; &lt;br&gt; &lt;code&gt;Collection&lt;/code&gt;]\n    D --&gt; M[&lt;b&gt;تسلسل&lt;/b&gt; &lt;br&gt; &lt;code&gt;Sequence&lt;/code&gt;]\n    M --&gt; C[&lt;b&gt;نص&lt;/b&gt; &lt;br&gt; &lt;code&gt;str&lt;/code&gt;]\n    M --&gt; H[&lt;b&gt;قائمة&lt;/b&gt; &lt;br&gt; &lt;code&gt;list&lt;/code&gt;]\n    M --&gt; I[&lt;b&gt;صف&lt;/b&gt; &lt;br&gt; &lt;code&gt;tuple&lt;/code&gt;]\n    M --&gt; J[&lt;b&gt;نطاق&lt;/b&gt; &lt;br&gt; &lt;code&gt;range&lt;/code&gt;]\n    D --&gt; K[&lt;b&gt;مجموعة&lt;/b&gt; &lt;br&gt; &lt;code&gt;set&lt;/code&gt;]\n    D --&gt; L[&lt;b&gt;قاموس&lt;/b&gt; &lt;br&gt; &lt;code&gt;dict&lt;/code&gt;]\n\n\n\n\n\n\nوسيأتي تفصيلها في أبوابها إن شاء الله.\nالإجراءات المبنية مثل: print, sum, max, min, len\n\n\n\nالإجراء\nFunction\n\n\n\n\nالطباعة\nprint\n\n\nالجمع\nsum\n\n\nالأكبر\nmax\n\n\nالأصغر\nmin\n\n\nالطول\nlen\n\n\nإدخال\ninput\n\n\nنوع\ntype\n\n\nأي\nany\n\n\nكل\nall\n\n\nالتالي\nnext\n\n\nتطبيق\nmap\n\n\nتجميع\nzip\n\n\nتقريب\nround\n\n\n\nوغيرها كثير لا يفيد حصره هنا. ولا تزال اللغة تتطوَّر ويُزادُ فيها من هذه الأنواع والإجراءات.",
    "crumbs": [
      "المقدمة الأولى: لغة البرمجة"
    ]
  },
  {
    "objectID": "chapters/01_intro/a1_intro.html#نمو-اللغة",
    "href": "chapters/01_intro/a1_intro.html#نمو-اللغة",
    "title": "المقدمة الأولى: لغة البرمجة",
    "section": "نمو اللغة",
    "text": "نمو اللغة\nومن خواص لغة البرمجة: إنشاء مركبات لغوية جديدة، وذلك بشيئين:\n\nتعريف إجراءات جديدة؛ بجملة def وسيأتي في باب البرمجة الإجرائية\nتعريف أنواع جديدة؛ بجملة class وسيأتي في باب البرمجة الشيئية\n\nفأضاف مطوروا بايثون أنفسهم إلى اللغة ما يسمى بالمكتبة الأساسية (Standard Library)، ومن أقسامها:\n\nوحدة math التي تضم مجموعة إجراءات تعنى بالعمليات الرياضية على الأعداد\nوحدة statistics التي تضم مجموعة إجراءات تعنى بالإحصاء\nوحدة datetime التي تضم مجموعة أنواع وإجراءات تعنى بالوقت والتاريخ\n\n\nالمكتبة الأساسية 📚️\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nالقطعة:\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\nتفصيل هذه القطعة كالتالي:\n\nجملة استيراد المكتبة الرياضية: import math\nتعيين النقطتين: x1, y1 = 0, 0 و x2, y2 = 3, 4\nحساب المسافة: distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) وفيه:\n\nx2 - x1 هو الفرق بين الإحداثيات السينية\ny2 - y1 هو الفرق بين الإحداثيات الصادية\n** هي عملية تربيع العدد\nmath.sqrt هي فعل حساب الجذر التربيعي\n\nطباعة النتيجة: print(distance)\n\n\n\nالمكتبات المساهمة 📦️\nوتسمى المكتبات الخارجية (External Libraries) وهي مكتبات يساهم بها الناس، ويضيفونها إلى اللغة، نجدها في موقع قاعدة بيانات PyPI الذي يضم أكثر من 580 ألف مشروع، أو غيرها من المواقع. وهذه يتم تنزيلها وتثبيتها للاستفادة من لغتها المزيدة.\nعلى سبيل المثال، تختص حزمة pandas المتخصصة في تفكيك وتركيب الجداول والتحليلات الإحصائية عليها؛ فهي أقوى من أي نسخة من إكسل (Excel) أو غيره.\nلتثبيتها نستعمل uv هكذا في سطر الأوامر (النافذة السوداء):\nuv add pandas\nثم نستطيع استعمال المكتبة لقراءة بيانات الطلاب -مثلاً- من ملف CSV:\n\n\nimport pandas as pd\n\ndf = pd.read_csv('../../datasets/students.csv')\ndf\n\n\n\n\n\n\n\n\nName\nAge\nGrade\nDone\n\n\n\n\n0\nAdam\n12\n90\nF\n\n\n1\nBelal\n13\n92\nF\n\n\n2\nCamal\n14\n91\nT\n\n\n3\nDalal\n8\n99\nF\n\n\n4\nEman\n9\n98\nF\n\n\n\n\n\n\n\n\nثم لعرض ملخصات إحصائية:\n\n\ndf.describe(include=['number'])\n\n\n\n\n\n\n\n\nAge\nGrade\n\n\n\n\ncount\n5.000000\n5.0000\n\n\nmean\n11.200000\n94.0000\n\n\nstd\n2.588436\n4.1833\n\n\nmin\n8.000000\n90.0000\n\n\n25%\n9.000000\n91.0000\n\n\n50%\n12.000000\n92.0000\n\n\n75%\n13.000000\n98.0000\n\n\nmax\n14.000000\n99.0000\n\n\n\n\n\n\n\n\nأو تصوير البيانات:\n\n\ndf['Done'].value_counts().plot(kind='bar', color='skyblue', figsize=(4, 3), rot=0)\n\n\n\n\n\n\n\n\n\nهكذا بكل بساطة.\nفإذًا .. هنا دور المجتمع (Community) ليبني باللغة: بمفرداتها وجملها ومكتبتها الأساسية والخارجية، ليبني فوق ذلك ما يخدم أغراضه. فلكل فئة من الناس تركيب حزمة جديدة مكونة من أنواع وإجراءات مركبة مبنية على غيرها ، ثم يوفرونها لغيرهم. وهكذا تنمو اللغة ، حزمةً تِلو الأخرى بحسب إسهامات كل مجتمع برمجي بما يهتم به.\nومن مكامن القوة في لغة بايثون: أنها متوافقة مع لغتي C/C++ إذْ يُمكن كتابة برمجيات عالية الأداء والكفاءة بهما مستفيدين من الحزم الموجودة فيهما، ثم توفيق ذلك ليكون كمكتبة في لغة بايثون.\nفالمجتمعات البرمجية في بايثون كثيرة ومتعددة في اهتماماتها. منها على سبيل المثال:\n\nتطوير مواقع الشبكة: 🌐\n\nDjango - لبناء مواقع متصلة بقواعد بيانات\nFastAPI - حديث وسريع لبناء واجهات برمجية على الشبكة\n\nتحليل البيانات وتصويرها: 📊\n\npandas - لتحليل البيانات المرصوصة\nseaborn - لتصوير البيانات الإحصائية على أساس Matplotlib.\nmatplotlib - مكتبة شاملة لإنشاء تصورات ثابتة ومتحركة وتفاعلية.\n\nالذكاء الاصطناعي وتعلم الآلة: 🤖\n\nstatsmodels - للنماذج الإحصائية\nscikit-learn - لاكتشاف الأنماط والتنبؤ (تعلم الآلة)\nPyTorch - لبناء نماذج التعلم العميق\n\nالتحليل الرياضي والهندسة: 📐\n\nsympy - للرياضيات الرمزية.\nPySR - الانحدار الرمزي.\nSciPy - للرياضيات والعلوم والهندسة.",
    "crumbs": [
      "المقدمة الأولى: لغة البرمجة"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html",
    "href": "chapters/01_intro/a2_intro.html",
    "title": "المقدمة الثانية: جهاز الحاسب",
    "section": "",
    "text": "وحدة المعالجة المركزية\nرغم تعقيد الحواسيب اليوم، فهي ترجع إلى معمارية فون نويمان (بالإنجليزية: Von Neumann architecture) وهي مجموعة من القواعد الأساسية وضعها العالم الرياضي جون فون نويمان ومعاونوه عام 1945م وتُستعمل حتى الأن في تصميم الحاسبات.\nوحدة المعالجة المركزية (Central Processing Unit - CPU) وهي التي يُعبأ فيها البرنامج المترجَم ليتم تنفيذه. وتتكون من شيئين:\nالأول: وحدة التحكم وهي التي تتحكم في سيْر العمليات:\nالثاني: وحدة الحساب والمنطق تنفذ تعليمات المنطق الرقمي كالجمع والطرح والمقارنة والرجوع ونحو ذلك.",
    "crumbs": [
      "المقدمة الثانية: جهاز الحاسب"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#وحدة-المعالجة-المركزية",
    "href": "chapters/01_intro/a2_intro.html#وحدة-المعالجة-المركزية",
    "title": "المقدمة الثانية: جهاز الحاسب",
    "section": "",
    "text": "بقلم براين وونغ - https://www.flickr.com/photos/57993471@N06/37962336546/\n\n\n\n\n\nحين نريد أن نكرر عمليَّةً ما عدة مرات، أو نريد أن نعلق تنفيذ عمليَّة ما بشرط\nحين نريد القراءة أو الكتابة من وإلى خارج وحدة المعالجة المركزيَّة",
    "crumbs": [
      "المقدمة الثانية: جهاز الحاسب"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#أجهزة-الإدخال-والإخراج",
    "href": "chapters/01_intro/a2_intro.html#أجهزة-الإدخال-والإخراج",
    "title": "المقدمة الثانية: جهاز الحاسب",
    "section": "أجهزة الإدخال والإخراج",
    "text": "أجهزة الإدخال والإخراج\nوحتى يكون للبرنامج فائدة؛ فلا بُدَّ له من منفَذٍ تدخل منه المعطيات من الواقع، ومنفذٍ آخر تخرجُ منه نتائج معالجته. وقد اصطلح الناس على الاختصار I / O إشارة إلى الإنجليزية Input / Output لهذين الأمرين. فمن ذلك:\n\nجهاز إدخال: لوحة المفاتيح (Keyboard)، والمؤشر (Mouse)، والكاميرا، ولاقط الصوت\nجهاز إخراج: الطابعة، والسماعات، والشاشة\nجهاز إدخال وإخراج: جهاز التخزين الدائم الذي تُحفظ فيه الملفات، ومِقبَس الشبكة الذي يتصل بالإنترنت (وبالتالي يتصل بالحواسيب الآخرى)\n\n\nويصوِّرُها نظام التشغيل للغة البرمجة على أنها ملفات (Files) مثل سائر الملفات.\n\nفالإدخال يكون بالقراءة منها بالأمر: read\nوالإخراج يكون بالكتابة عليها بالأمر: write\n\nوقد رأينا عملية: print() حيث هي أمر بالكتابة في الملف الذي يمثِّل النافذة المتصل بها البرنامج.",
    "crumbs": [
      "المقدمة الثانية: جهاز الحاسب"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#الذاكرة",
    "href": "chapters/01_intro/a2_intro.html#الذاكرة",
    "title": "المقدمة الثانية: جهاز الحاسب",
    "section": "الذاكرة",
    "text": "الذاكرة\nأما الذاكرة فتحمل البرنامج المترجَم ليتمَّ إدخاله لوحدة المعالجة، وكذلك تحمل البيانات التي نريد معالجتها، والنتائج الجزئية بين عمليَّة والتي بعدها، والنتائج النهائيَّة؛ ربما إلى حين كتابتها في الخارج.",
    "crumbs": [
      "المقدمة الثانية: جهاز الحاسب"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#نظام-التشغيل",
    "href": "chapters/01_intro/a2_intro.html#نظام-التشغيل",
    "title": "المقدمة الثانية: جهاز الحاسب",
    "section": "نظام التشغيل",
    "text": "نظام التشغيل\nويتولى نظام التشغيل إدارة الموارد من ملفات، وأجهزة إدخال وإخراج، وذاكرة ومعالجة؛ بين الجهاز (المعدن) والبرمجيات (المنطق).\n\nفالجهاز له ذاكرة مشتركة يتولى نظام التشغيل توزيعها بين البرامج بحيث لا يتعدَّى برنامجٌ حدوده إلى آخر؛ لأن ذلك يسبب إشكاليات لا يمكن حلها. وإذا انتهى منها برنامجٌ أعادها لنظام التشغيل ليتصرف بها.\nوله معالج مركزي؛ يتولى تشغيل البرامج عليه جدولٌ يضعه نظام التشغيل ويسيِّر البرامج عليه.\nوهكذا في بقية الموارد من أجهزة إخراج وإدخال.\n\n\n\n\n\n\ngraph TD\n    A[التطبيقات البرمجية &lt;br&gt; Application Programs]\n    A --&gt; B[نظام التشغيل &lt;br&gt; Operating System]\n    B --&gt; C[المعدن &lt;br&gt; Hardware]\n    C --&gt; D[وحدة المعالجة المركزية &lt;br&gt; CPU]\n    C --&gt; E[أجهزة الإدخال والإخراج &lt;br&gt; I/O Devices]\n    C --&gt; F[الذاكرة &lt;br&gt; Memory]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#ddf,stroke:#333,stroke-width:2px\n    style D fill:#fdd,stroke:#333,stroke-width:2px\n    style E fill:#fdd,stroke:#333,stroke-width:2px\n    style F fill:#fdd,stroke:#333,stroke-width:2px",
    "crumbs": [
      "المقدمة الثانية: جهاز الحاسب"
    ]
  },
  {
    "objectID": "chapters/01_intro/a2_intro.html#خلاصة",
    "href": "chapters/01_intro/a2_intro.html#خلاصة",
    "title": "المقدمة الثانية: جهاز الحاسب",
    "section": "خلاصة",
    "text": "خلاصة\nتبيَّن لنا أن الجهاز لا يكون مفيدًا إلا باتصاله بالعالَم المحيط به. وذلك يكون بأجهزة الإدخال للنظر في معطياته، وبأجهزة الإخراج للتأثير فيه. والمعالجةُ هي محوَر ذلك كله.",
    "crumbs": [
      "المقدمة الثانية: جهاز الحاسب"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html",
    "href": "chapters/02_numbers/a_numbers.html",
    "title": "1  الأعداد",
    "section": "",
    "text": "الحساب والمقارنة\nالأعداد هي الحجر الأساس في أي برنامج. بل يُبنى عليها فهم البرنامج للنصوص المكتوبة والأصوات والصور وجميع أنواع البيانات. ولذلك وجب معرفة أساسياتها.\nملاحظة: كل ما بعد علامة # يعتبر تعليقًا يتجاهله الحاسب ولا يفسره. فنستخدمه للملاحظات والشرح في ثنايا القطعة البرمجية.\nx = 5\ny = 10\n\nprint(x + y) # الجمع\nprint(x - y) # الطرح\nprint(x * y) # الضرب\nprint(x / y) # القسمة\nprint(x % y) # باقي القسمة\nprint(x ** y) # الأس\n\n15\n-5\n50\n0.5\n5\n9765625\nالمقارنة بين الأعداد:\nx = 5\ny = 10\n\nprint(x == y) # التطابق\nprint(x != y) # الاختلاف\nprint(x &gt; y) # أكبر\nprint(x &lt; y) # أصغر\nprint(x &lt;= y) # أصغر أو يساوي\nprint(x &gt;= y) # أكبر أو يساوي\n\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "href": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "title": "1  الأعداد",
    "section": "ترتيب العمليات",
    "text": "ترتيب العمليات\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\nإليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه. ولاحظ أننا نستعمل جملة التوكيد (assert) التي تسكُت إن كان الشيء الذي أمامها جملة منطقية صحيحة؛ وإلا فهي تظهر رسالة خطأ. وسترى أننا نستعملها بكثرة لتقرير لوازم ما نبينه في الدرس:\n\nassert 3 + 2 * 5 == 13\nassert (3 + 2) * 5 == 25\n\n\nassert 8 - 4 / 2 == 6\nassert (8 - 4) / 2 == 2\n\n\nassert 2 ** 3 * 4 == 32\nassert (2 ** 3) * 4 == 32",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "href": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "title": "1  الأعداد",
    "section": "التعيين النسبي",
    "text": "التعيين النسبي\nيراجع: التعيين النسبي.\nلأن التعيين النسبي يستعمل بكثرة، فوجب علينا التعرف عليه، وأحيانًا نحتاج لاستعماله. فجمل التعيين التالية متكافئة:\n\ni = i + 1 تعادل i += 1\ni = i - 1 تعادل i -= 1\ni = i * 2 تعادل i *= 2\ni = i / 2 تعادل i /= 2\n\nجرب النص البرمجي أدناه لترى النتيجة:\n\ni = 0\ni = i + 1\ni += 1\nprint(i)\n\n2\n\n\nوإن أتيت من لغات أخرى مثل سي أو جافا فإنك تعلم أن تعبير i++ يعني زيادة المتغير i بواحد. لكن في بايثون لا يوجد هذا التعبير. فالنص التالي سيؤدي إلى خطأ:\n\ni++\nprint(i)\n\n\n  Cell In[41], line 1\n    i++\n       ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات-math",
    "href": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات-math",
    "title": "1  الأعداد",
    "section": "وحدة الرياضيات (math)",
    "text": "وحدة الرياضيات (math)\n\nimport math\n\nx = 5.4\n\nكل هذه الطرق الثلاث يتم فيها حساب الأس:\n\nالأولى pow فعل مبني\nالثانية math.pow فعل من وحدة الرياضيات\nالثالثة x ** 2 عن طريق المعامل **\n\n\\[\nx^2 = x \\times x\n\\]\n\nassert(\n    pow(x, 2) ==\n    math.pow(x, 2) ==\n    x ** 2 ==\n    x * x\n)\n\nوكذلك الجذر التربيعي:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\n\nالأولى math.sqrt فعل من وحدة الرياضيات\nالثانية x ** 0.5 عن طريق المعامل **\n\n\nassert (\n    math.sqrt(x) ==\n    x ** 0.5\n)\n\nتقريب لأقرب عدد صحيح أصغر:\n\\[\n\\text{floor}(x) = \\lfloor x \\rfloor\n\\]\n\nmath.floor(5.4)\n\n5\n\n\nتقريب لأقرب عدد صحيح أكبر:\n\\[\n\\text{ceil}(x) = \\lceil x \\rceil\n\\]\n\nmath.ceil(5.4)\n\n6\n\n\nحذف ما بعد الفاصلة:\n\nmath.trunc(5.4)\n\n5\n\n\nتقريب إلى رقمين بعد الفاصلة:\n\nround(5.436, 2)\n\n5.44\n\n\nملاحظة: الإجراء الأخير round ليس مستوردًا من math وإنما هو مُضمَّن في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "href": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "title": "1  الأعداد",
    "section": "مجموعة الأعداد",
    "text": "مجموعة الأعداد\nأما التعامل مع المجموعات (كمجموعة الأعداد) فسيأتي في باب المجموعات المرتبة. لكننا نعرض لمثال بسيط للتعامل مع المجموعات العددية:\n\nxs = [10, 20, 30, 40, 50]\n\nتوفر بايثون الدوال التالية للمجموعة العددية:\n\nالطول (عدد العناصر): len (من كلمة length)\nمجموع العناصر: sum\nالعنصر الأكبر: max\nالعنصر الأصغر: min\n\n\nprint('length:', len(xs))\nprint('total:', sum(xs))\nprint('average:', sum(xs) / len(xs))\nprint('maximum:', max(xs))\nprint('minimum:', min(xs))\n\nlength: 5\ntotal: 150\naverage: 30.0\nmaximum: 50\nminimum: 10\n\n\n\nالإحصاء\nونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:\n\nالمتوسط الحسابي: statistics.mean\nالوسيط: statistics.median\nالمنوال: statistics.mode\nالانحراف المعياري: statistics.stdev\n\n\nimport statistics\n\nxs = [\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20,\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20\n]\n\nprint('mean:', statistics.mean(xs))\nprint('median:', statistics.median(xs))\nprint('mode:', statistics.mode(xs))\nprint('standard deviation:', statistics.stdev(xs))\n\nmean: 20.785714285714285\nmedian: 20.5\nmode: 20\nstandard deviation: 1.8126539343499315",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "href": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "title": "1  الأعداد",
    "section": "أنواع العدد في بايثون",
    "text": "أنواع العدد في بايثون\n\nالعدد الصحيح (int)\nالقيمة المنطقية (bool)\nالعدد العشري (float)\nالعدد المركب (complex)\n\nصفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالإجراء فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.\nفالتمثيل الداخلي للأعداد له أثر:\n\nفي مساحة التخزين\nدقة العدد؛ وبالتالي صحة الحساب\nسرعة الحساب\n\nلكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.\n\nالعدد الصحيح (int)\nالوظيفة: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك\n\nage = 20\nlevel = 3\nindex = -2\nstart, end = -5, 10\nleft, middle, right = 3, 5, 7\n\nيؤتى بالإجراء type لمعرفة نوع المتغير:\n\nassert int == type(age) \nassert int == type(level) \nassert int == type(index) \nassert int == type(start) == type(end)\nassert int == type(left) == type(middle) == type(right)\n\nالمجال: نقصد بالمجال هو أعلى قيمة ممكنة وأقل قيمة ممكنة للنوع. فنوع العدد الصحيح (int ويرمز له بالرياضي \\(\\mathbb{Z}\\)) هو في واقع الحواسيب محكوم بعدد الخانات (Bits) التي يتم استعمالها في تمثيله. ورغم أن بايثون تخفي عنا عدد الخانات؛ إلا أنها تتعامل مع هذا الواقع، ولذلك وجب معرفته:\n\n8-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^7 \\leq x &lt; 2^7\\} = \\{-128, \\ldots, 127\\}\\) أي أن أقل عدد ممكن في 8 خانات: \\(-128\\) وأعلى عدد ممكن: \\(127\\). وهلم جرا.\n16-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{15} \\leq x &lt; 2^{15}\\}\\)\n32-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{31} \\leq x &lt; 2^{31}\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{63} \\leq x &lt; 2^{63}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{127} \\leq x &lt; 2^{127}\\}\\)\n\n\n\n\n\n\n\nملاحظة\n\n\n\n\n\nلاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)\n\n\n\n\n\nالقيمة المنطقية (bool)\nوهي مجموعة العددين: \\(\\{0, 1\\}\\) الذين يمثل لهما بالكلمتين: True و False وذلك لتبيين وظيفتهما المنطقية.\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nالوظيفة: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.\nنلجئ الكلام عنها إلى باب الشرط والتكرار.\n\n\nالعدد العشري (float)\nالوظيفة: تمثيل الكميات مثل المال، المسافة، والوقت\n\ndistance = 100.0\nprice = 10.5\ntime = 1.5\ntemperature = 36.6\ndifference = 0.001\n\nنفحص أنواعها:\n\nassert float == type(distance)\nassert float == type(price)\nassert float == type(time)\nassert float == type(temperature)\nassert float == type(difference)\n\nالمجال: يعبر الرمز \\(\\mathbb{R}\\) عن مجموعة الأعداد العشرية (float). وهي تتبع نظام التمثيل IEEE 754.\n\n32-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{31} \\leq x &lt; 2^{31}\\} = \\{-3.4 \\times 10^9, \\ldots, 3.4 \\times 10^9\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{63} \\leq x &lt; 2^{63}\\} = \\{-1.8 \\times 10^{19}, \\ldots, 1.8 \\times 10^{19}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{127} \\leq x &lt; 2^{127}\\} = \\{-1.2 \\times 10^{38}, \\ldots, 1.2 \\times 10^{38}\\}\\)",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "href": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "title": "1  الأعداد",
    "section": "اختلاف نوع العدد",
    "text": "اختلاف نوع العدد\nإذا اختلف النوع تُقدَّرُ الترقيةُ للأشمل، وذلك بحسب ناتج العملية:\n\nجمع صحيح وعشري = عشري: int + float = float\nقسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): int / int = float\nالقسمة الصحيحة بين صحيح وصحيح = صحيح: int // int = int\n\nالمثال الأول: جمع عدد صحيح وعدد عشري:\n\na = 1 + 1.0\nprint(a)\nassert type(a) == float\n\n2.0\n\n\nالمثال الثاني: قسمة عدد صحيح على عدد عشري:\n\nc = 1 / 2\nprint(c)\nassert type(c) == float\n\n0.5\n\n\nالمثال الثالث: استعمال القسمة الصحيحة //:\n\nb = 9 // 2\nprint(b)\nassert type(b) == int\n\n4\n\n\nس: لماذا النتيجة 4؟\nج: لأن قسمة 9 على 2 تُنتِج 4.5 ولكن بايثون تقربها لأقرب عدد صحيح أصغر وهو 4؛ وذلك لأننا اخترنا القسمة الصحيحة بالعلامة // وليس القسمة العشرية بالعلامة /.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "1  الأعداد",
    "section": "الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "الفرق بين النوع العددي والنوع النصي للعدد\nتأمل المتغيرين\n\na = 50\nb = '50'\n\n\nالأول: عدد صحيح (int)\nالثاني: حرفان (str)\n\nنستعمل جمل التوكيد لبيان ذلك:\n\nassert type(a) == int\nassert type(b) == str\nassert type(a) != type(b)\n\nومقتضى ذلك: امتناع عملية الجمع: a + b\n\n'5' + 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[62], line 1\n----&gt; 1 '5' + 5\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nبل يجب التحويل أولاً باستعمال الإجراء int الذي يفسر الأحرف كعدد صحيح:\n\na = 5\nb = '5'\n\nb = int(b)\n\nassert a + b == 10",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "href": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "title": "1  الأعداد",
    "section": "كتابة القيَم العددية",
    "text": "كتابة القيَم العددية\nالحروفيَّة (Literals) هي رموز للقيم لبعض الأنواع المدمجة. مثال: 42 هو حرفيُّ عدد صحيح و 3.14 هو حرفيُّ عدد عشري.\nوتخصيص الحرفيّ True للعدد 1 و False للعدد 0 ليس من قبيل الضرورة في اللغة وإنما من قبيل التسهيل (وفوق ذلك فإن بايثون تجعل له نوعًا خاصًّا وعمليات مصاحبة).\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nكذلك خصصت بايثون e أو E للترميز العلمي (وجاء الحرف e من كلمة: Exponent) المخصص للأعداد العشرية الكبيرة والصغيرة.\n\nassert 1e2 == 100\nassert 1e9 == 1E9\nassert 1e-4 == 0.0001\n\nويجوز استعمال الشرطة السفلية _ لفاصلة الألوف:\n\nassert 1_000_000 == 1000000\n\nوأما إن كنت تهتم بالتمثيل الثنائي أو الثماني أو الست عشري فذلك أيضًا له تعبيرات مخصصة:\n\n0b أو 0B للأرقام الثنائية\n0o أو 0O للأرقام الثمانية\n0x أو 0X للأرقام الست عشرية\n\nوإليك تطبيق ذلك:\n\nassert 0b1010 == 10\nassert 0o10 == 8\nassert 0x10 == 16\n\nوأخيرًا يمكن استعمال j أو J للأعداد المركبة:\n\nassert 1 + 2j == 2j + 1",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#خلاصة",
    "href": "chapters/02_numbers/a_numbers.html#خلاصة",
    "title": "1  الأعداد",
    "section": "خلاصة",
    "text": "خلاصة\nعرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.\nننتقل الآن لباب الشرط والتكرار حيث الجمل الشرطية والتعيين المشروط.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html",
    "href": "chapters/02_numbers/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "معادلة مساحة المكعب\nلا يلزمنا اشتقاق هذه المعادلات؛ لكن نستعمل النتائج التي خرج بها أهل الرياضيات فنعوض هذه المتغيرات بالقيم التي نريد لنتحصل على الناتج.\nاكتب برنامجًا يحسب مساحة المكعب وفق المعادلة:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\nwidth = 3\nlength = 4\nheight = 5\n\narea = width * length * height\nprint(area)\n\n60",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "href": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "title": "تطبيقات",
    "section": "معادلة تحويل وحدة إلى وحدة أخرى",
    "text": "معادلة تحويل وحدة إلى وحدة أخرى\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n\nc = 32\nf = (9 / 5) * c + 32\n\nprint('Celsius:', c)\nprint('Fahrenheit:', f)\n\nCelsius: 32\nFahrenheit: 89.6",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "href": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "title": "تطبيقات",
    "section": "معادلة مساحة الدائرة",
    "text": "معادلة مساحة الدائرة\nاكتب برنامجًا لحساب مساحة الدائرة وفق المعادلة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nimport math\n\nradius = 5\narea = math.pi * radius**2\nprint(area)\n\n78.53981633974483\n\n\nملاحظة:\n\nتم استعمال radius ** 2 بدلاً من الإجراء math.pow(radius, 2) لتربيع العدد.\nكذلك يجوز استعمال x ** 0.5 بدلاً من الإجراء math.sqrt(x) لحساب الجذر التربيعي.",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "href": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "title": "تطبيقات",
    "section": "معادلة طول الخط المستقيم بين نقطتين",
    "text": "معادلة طول الخط المستقيم بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#الزيادة",
    "href": "chapters/02_numbers/apps.html#الزيادة",
    "title": "تطبيقات",
    "section": "الزيادة",
    "text": "الزيادة\nإذا كنت تقضي في القراءة 15 دقيقة في اليوم. ثم أحببت أن تزيد في كل أسبوع 5 دقائق. فكم ستكون الزيادة في 10 أسابيع؟\n\ntoday = 15\nincrease = 5\nweeks = 9\n\ntotal = today + (increase * weeks)\nprint(total)\n\n60\n\n\nأو لحساب كل أسبوع:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#النمو",
    "href": "chapters/02_numbers/apps.html#النمو",
    "title": "تطبيقات",
    "section": "النمو",
    "text": "النمو\nإذا كان عدد الأرانب في السنة الأولى 100. وكان عدد الأرانب يزيد بنسبة 11.7% في اليوم. فكم سيكون عدد الأرانب في اليوم السابع؟\n\nrabbits = 100\ngrowth_rate = 0.117\ndays = 7\n\ntotal = rabbits * (1 + growth_rate) ** days\nprint(total)\n\n216.9562730596121\n\n\nأو لحساب كل يوم:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#نسبة-التغير",
    "href": "chapters/02_numbers/apps.html#نسبة-التغير",
    "title": "تطبيقات",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كان معدل قراءتك في الأسبوع الثاني 15 دقيقة، وكان معدل قراءتك في الأسبوع الأول 10 دقائق، فكم نسبة الزيادة في معدل قراءتك؟\n\nweek1 = 10\nweek2 = 15\n\nincrease_ratio = (week2 - week1) / week1\nprint(increase_ratio * 100, '%')\n\n50.0 %",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html",
    "href": "chapters/02_numbers/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "كم سيكون عمرك حين كذا؟",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-حين-كذا",
    "href": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-حين-كذا",
    "title": "مسائل",
    "section": "",
    "text": "عرف تاريخ الحدث المستقبلي بالسنوات: future_date\nعرف تاريخ اليوم: today\nعرف المتغير: age\nاحسب عمرك عند حصول الحدث: age_then\nاطبع النتيجة: print(age_then)",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الأجر",
    "href": "chapters/02_numbers/problems.html#حساب-الأجر",
    "title": "مسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nعدد ساعات العمل: hours\nمعدل الأجر لكل ساعة: per_hour_rate\nاحسب الأجر الذي تستحقه بناءً على عدد الساعات ومعدل الأجر: gross_pay\nاطبع النتيجة: print(gross_pay)",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "مسائل",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nسرعة السيارة: speed\nالمسافة: distance\nاحسب الزمن المستغرق للوصول إلى المكان المعيَّن بناءً على السرعة والمسافة: time\nاطبع النتيجة: print(time)",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "مسائل",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\n\n\nمثلث\n\n\nباستخدام معادلة هيرون:\n\\[\n\\text{area} = \\sqrt{s (s - a) (s - b) (s - c)}  \n\\]\nحيث:\n\n\\(a\\), \\(b\\), \\(c\\) هي أطوال أضلاع المثلث\nنصف المحيط:\n\n\\[\ns = \\frac{a + b + c}{2}\n\\]\n\na = 3\nb = 4\nc = 5",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#نسبة-التغير",
    "href": "chapters/02_numbers/problems.html#نسبة-التغير",
    "title": "مسائل",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#التغير-النسبي",
    "href": "chapters/02_numbers/problems.html#التغير-النسبي",
    "title": "مسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\nمساعدة: فكك العبارة واجعلها في متغيرات، وضع لكل أسبوعٍ متغيِّرًا يعتمد على الأسبوع الذي قبله.",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/problems.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "مسائل",
    "section": "الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "الفرق بين النوع العددي والنوع النصي للعدد\nإذا كان عندك هذه المتغيرات الثلاثة، فكيف تقيم عملية الجمع بالشكل الصحيح؟ (أولاً: استعمل type لمعرفة نوع كل متغير)\n\na = 4\nb = 3.14\nc = \"10\"",
    "crumbs": [
      "باب الأعداد",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html",
    "href": "chapters/02_numbers/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "كم سيكون عمرك حين كذا؟\nfuture_date = 2050\ntoday = 2024\nage = 20\nage_then = age + (future_date - today)\nprint('you will be', age_then, 'years old in', future_date)\n\nyou will be 46 years old in 2050",
    "crumbs": [
      "باب الأعداد",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "href": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "title": "حل المسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nhours = 40\nper_hour_rate = 10\ngross_pay = hours * per_hour_rate\nprint('you deserve:', gross_pay, 'SAR')\n\nyou deserve: 400 SAR",
    "crumbs": [
      "باب الأعداد",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "حل المسائل",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nspeed = 100\ndistance = 200\ntime = distance / speed\nprint('it will take you', time, 'hours to reach the destination')\n\nit will take you 2.0 hours to reach the destination",
    "crumbs": [
      "باب الأعداد",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "حل المسائل",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\nimport math\n\na = 3\nb = 4\nc = 5\n\ns = (a + b + c) / 2\narea = math.sqrt(s * (s - a) * (s - b) * (s - c))\nh = 2 * area / c\nprint('the height of the triangle is', h)\n\nthe height of the triangle is 2.4",
    "crumbs": [
      "باب الأعداد",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "href": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "title": "حل المسائل",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟\n\nold_expense = 1000\nnew_expense = 650\n\npercentage = (new_expense - old_expense) / old_expense\nprint(percentage * 100, '%')\n\n-35.0 %",
    "crumbs": [
      "باب الأعداد",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "href": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "title": "حل المسائل",
    "section": "الزيادة النسبية",
    "text": "الزيادة النسبية\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\n\nincrement = 1.10\n\nw1 = 20\nw2 = w1 * increment\nw3 = w2 * increment\nw4 = w3 * increment\n\nprint(round(w4, 1))\n\n26.6",
    "crumbs": [
      "باب الأعداد",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html",
    "href": "chapters/03_control_flow/a_control_flow.html",
    "title": "2  الجملة الشرطية",
    "section": "",
    "text": "الجملة الشرطية\nإن بايثون من اللغات الأمرية (Imperative). أي أن الجمل البرمجية خطوات متتالية تنفذ من الأعلى للأسفل.\nفإن جملة التعيين التالية تكتُب قيمة 2 في نفس المحلّ الذي كتبت عليه جملة التعيين الأولى 1. لذا ظهرت النتيجة: 2.\nكثيرًا ما نحتاج للتحكم فيما يُنفَّذ وما يُهمل أو ما يتكرر من الجمل البرمجية. فمن الحالات التي يتغير فيها الترتيب:\nالجملة الشرطية هي جملة مركَّبة من كلمة if وتعبير منطقي ثم الجمل التي يتعلق تنفيذها بناءً على هذا الشرط. ويجب أن تكون حذوها:",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "title": "2  الجملة الشرطية",
    "section": "",
    "text": "flowchart TD\n    IF{{if cond}} -- False --&gt; X[\"Outside\"]\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n\n  style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ncond = True\nif cond:\n    print('Inside')\nprint('Outside')\n\nInside\nOutside\n\n\n\n\n\nتنبيه: المحاذاة العمودية\nلاحظ أن المحاذاة العمودية (Indentation) (المسافات البيضاء أسفل كلمة if) في القطعة البرمجية أعلاه ليست لمجرد تسهيل القراءة، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال النص البرمجي.\nلاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في النص البرمجي:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    Y[\"Inside\"] --&gt; X[\"Outside\"]\n    style IF fill:#fc0000, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[3], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل النص البرمجي بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n    \n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\n\n\nيؤدي النص البرمجي السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في بايثون!",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التعبير-المنطقي",
    "href": "chapters/03_control_flow/a_control_flow.html#التعبير-المنطقي",
    "title": "2  الجملة الشرطية",
    "section": "التعبير المنطقي",
    "text": "التعبير المنطقي\nأما الشروط فتستند إلى الجبر الثنائي (Boolean Logic) الذي نجد له في بايثون كلمتين من أصل اللغة هما:\n\nكلمة True ويعبَّر عنها بالرقم: 1\nكلمة False ويعبَّر عنها بالرقم: 0\n\nوكلاهُما يندرج تحت نوع خاصّ من نوع الأرقام وهو النوع البولي (bool) نسبةً لعالم الرياضيات جورج بول الذي وضع أسسه.\nأما الجملة الشرطية أو التعيين الشرطي ونحوه، فيتعلَّق بتحقق عبارة منطقية. فمن العبارات المنطقية: عبارة المقارنة:\n\n\n\nالعلامة\nالوصف\n\n\n\n\na == b\nيساوي\n\n\na != b\nلا يساوي\n\n\na &gt; b\nأكبر من\n\n\na &lt; b\nأصغر من\n\n\na &gt;= b\nأكبر من أو يساوي\n\n\na &lt;= b\nأصغر من أو يساوي\n\n\n\nهنا نستكشف عبارات تؤول إلى قيَم منطقية. العبارة الأولى: خمسة أكبر من تسعة؟\n\nb1 = 5 &gt; 9\nprint(type(b1))\nprint(b1)\n\n&lt;class 'bool'&gt;\nFalse\n\n\nالعبارة الثانية: هل طول كذا أكبر من طول كذا؟\n\nb2 = len('12345') &gt; len('123456789')\nprint(b2)\n\nFalse\n\n\n\nتركيب الشروط\nيجوز دمج عدة شروط بعمليات الجمع والتخيير والحصر والعكس، فناتجها المنطقي ملخص في الجدول التالي:\n\n\n\nA\nB\nAND\nOR\nXOR\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n\n\nالجمع: AND (و): تخرج 1 فقط إذا كان كلا المدخلين 1.\nالتخيير: OR (أو): تخرج 1 إذا كان أحد المدخلين على الأقل 1.\nالعكس: NOT (ليس): تخرج عكس المدخل (1 يصبح 0، و0 يصبح 1).\nالحصر: XOR (أو الحصرية): تخرج 1 إذا كان أحد المدخلين 1 والآخر 0.\n\nوهي غير مستعملة في الجمل الشرطية في بايثون\n\n\nعلى سبيل المثال:\n\nage = 20\nweight = 50\n\nif age &gt; 18 and weight &gt; 45:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nيؤول طرفي المعامل and لقيمة منطقية هكذا:\n\nage &gt; 18 تؤول إلى True لأن age=20 وهو أكبر من 18\nweight &gt; 45 تؤول إلى True لأن weight=50 وهو أكبر من 45\nفتكون الجملة إذًا: True and True وهي تؤول إلى True\n\nوهذا تمثيل الشجرة الثنائية للعبارة الشرطية:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{and} -- True --&gt; RESULT\n  middle_left{\"&gt;\"} -- True --&gt; ROOT\n  middle_right{\"&gt;\"} -- True --&gt; ROOT\n  left_left[age] -- \"20\" --&gt; middle_left\n  left_right[18] -- \"18\" --&gt; middle_left\n  right_left[weight] -- \"50\" --&gt; middle_right\n  right_right[45] -- \"45\" --&gt; middle_right\n\n\n\n\n\n\n\n\nتستعمل الأقواس لتجميع الشروط لإيقاع الترتيب المنطقي المراد:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\nage &lt; 16 تؤول إلى False لأن age=16 ليست أصغر من 16\ntemperature &lt; 20 تؤول إلى True لأن temperature=15 أصغر من 20 فعلاً\nnot is_wearing_coat تؤول إلى False لأن is_wearing_coat=True وهي عكسها\nإذًا الجملة بين القوسين (temperature &lt; 20 and not is_wearing_coat) تؤول إلى True and False وهي تؤول إلى False\nإذًا الجملة age &lt; 16 or (False) تؤول إلى False or False وهي تؤول إلى False\n\nوهذا تمثيل الشجرة الثنائية للعبارة الشرطية:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{or} -- False --&gt; RESULT\n  middle_left{\"&lt;\"} -- False --&gt; ROOT\n  middle_right{and} -- False --&gt; ROOT\n  left_left[age] -- \"16\" --&gt; middle_left\n  left_right[16] -- \"16\" --&gt; middle_left\n  right_middle{\"&lt;\"} -- True --&gt; middle_right\n  right_not{not} -- False --&gt; middle_right\n  right_temp[temperature] -- \"15\" --&gt; right_middle\n  right_val[20] -- \"20\" --&gt; right_middle\n  right_coat[is_wearing_coat] -- True --&gt; right_not\n\n\n\n\n\n\n\nيُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون True أو False ولا بأس بتجزئته حينما يسهل بذلك الفهم:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\n\nif is_minor or (is_cold and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\n\nتسلسل المقارنات\nتفهم بايثون المقارنات المتسلسلة. فعبارة x &lt; y &lt;= z تكافئ x &lt; y and y &lt;= z:\n\nlow = 10\nhigh = 20\nx = 15\n\nassert (low &lt; x &lt; high) == (low &lt; x and x &lt; high)\n\nكذلك تراها تستعمل في المساواة:\n\nassert 3 == len('123') == len([10, 20, 30]) == len('abc')",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "title": "2  الجملة الشرطية",
    "section": "الجملة الشرطية المتكاملة",
    "text": "الجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if condition_1}}\n    IF -- False --&gt; ELIF{{elif condition_2}}\n    IF -- True --&gt; code_1\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; code_2\n    ELSE --&gt; code_3\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\n\nكلمة if (إذا) تبدأ الجملة المركبة الشرطية\nقد توجد else (وإلا) مرة. وهي تعمل عند تخلُّف العبارة المنطقية السابقة لها سواءً كانت السابقة لها if أو elif.\nوقد توجد elif بينهما مرة أو أكثر (وهي اختصار لكلمة else if وتعني: وإلا فإن)، فتعمل مثل else معلَّقة بعبارة منطقية مثل if.\n\n\nجرب\nاستكشف المنطق التالي بتغيير قيمة x كل مرة للتبع ما يحصل في كل مرة:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSet to zero\nAlways: 0\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if x &lt; 0}}\n    IF -- False --&gt; ELIF{{elif x == 0}}\n    IF -- True --&gt; S1[x = 0] --&gt; S2[\"Set to zero\"]\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; S3[x = 1] --&gt; S4[\"Single\"]\n    ELSE --&gt; S5[\"More\"]\n\n    Always[Always: x]\n    S2 --&gt; Always\n    S4 --&gt; Always\n    S5 --&gt; Always\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,3 color:red;\n\n\n\n\n\n\nوهذا تصوير لسير الإجراءات لنفس النص البرمجي. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الإجراءية:\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "title": "2  الجملة الشرطية",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nتستطيع في بايثون أن تجعل جملة التعيين تأخذ قيمتها بحسب شرطٍ معين. مثلاً:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if age &gt; 14}}\n    IF -- False --&gt; S2[\"status = 'child'\"]\n    IF -- True --&gt; S1[\"status = 'adult'\"]\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0 color:red;\n\n\n\n\n\n\n\n\nage = 18\nstatus = 'adult' if age &gt; 14 else 'child'\n\nprint(status)\n\nadult\n\n\n\n\nوهي مكافئة للنص البرمجي التالي:\n\nage = 18\n\nif age &gt; 14:\n  status = 'adult'\nelse:\n  status = 'child'\n\nprint(status)\n\nadult\n\n\nويحصل تسلسل التعيين المشروط بالصيغة التالية:\n\nscore = 75\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\"\nprint(grade)\n\nC\n\n\n\n\n\n\n\nflowchart TD\n  S1[\"score = 75\"] --&gt; IF1\n  IF1{{if score &gt;= 90}} -- True --&gt; A[\"grade = 'A'\"]\n  IF1 -- False --&gt; IF2{{if score &gt;= 80}} -- True --&gt; B[\"grade = 'B'\"]\n  IF2 -- False --&gt; C[\"grade = 'C'\"]\n  \n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 2,4 color:red;",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "title": "2  الجملة الشرطية",
    "section": "تضمين الجمل الشرطية",
    "text": "تضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\n\n\n\n\n\n\n\nflowchart TD\n  IF1{{if condition_1}}\n  IF1 -- False --&gt; ELSE1\n  IF1 -- True --&gt; IF2{{if condition_2}}\n  IF2 -- False --&gt; code_2\n  IF2 -- True --&gt; code_1\n  ELSE1[code_3]\n\n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\nننبه مرة أخرى أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\nمثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+\n\n\nوهذا تصوير له:",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "href": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "title": "2  الجملة الشرطية",
    "section": "التكرار",
    "text": "التكرار\nحلقة التكرار: هي الرجوع بالتنفيذ لجملة سابقة (غالبًا تكون سطرًا سابقًا) وذلك يحصل عددًا من المرات أو معلَّقًا بشرط.\nفللتكرار طريقتان:\n\nسرد مكرر (for): حيث يعيَّن متغير التكرار لكل عنصر في المكرر، واحدًا تلوَ الآخر. (وسيأتي ذكره في باب الجمع المرتب)\nالتكرار بشرط (while): حيث يستمر التكرار مادام الشرط متحققًا. (وهو موضوع هذا القسم)\n\n\nالتكرار بشرط\nنبدأ بالتكرار بالطريقة غير المحددة، وهي جُملة تبدأ بالكلمة while على النحو التالي. كأنها if متكررة إلى حين تخلُّف الشرط (أن يصبح False). وإن لم يتحقق الشرط أصلاً فلا ينفذ القطعة المضمَّنة أصلا:\n\n\n\n\n\n\n\nflowchart TD\n  WHILE{{while condition}}\n  WHILE -- False --&gt; END\n  WHILE -- True --&gt; S1[code] --&gt; WHILE\n  \n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\nwhile &lt;boolean expression&gt;:\n    &lt;code&gt;\n\n\nمثال:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; S3[\"Done\"]\n  WHILE -- True --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n3\n4\nDone\n\n\n\n\nلنقم بتتبع الخطوات عندما تكون i = 0:\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\nوهذا تصوير لسير الإجراءات لنفس النص البرمجي. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الإجراءية:\n\n\nلاحظ أن نسيان جملة الزيادة (i += 1) يجعل الشرط دائمًا صحيحًا، فيدور البرنامج في حلقة لا نهيائة ولا يخرج أبدًا. ويعتبر هذا خطأ برمجيًّا يتعذر على البرنامج التعامل معه بنفسه؛ بل يجب على المبرمج أن يكتشفه. وسيأتي الكلام عن أنواع الأخطاء في البرمجة في باب الأخطاء.\n\n\nالخروج من الحلقة\n\nتستخدم كلمة break لإيقاف عملية التكرار كلها.\nتستخدم كلمة continue للانتقال إلى الكرة التالية متخطيةً بقية الخطوات في الكرة الحالية.\n\nأولاً نمثل لاستعمال جملة break على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- break --&gt; Done\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,4 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\n\n\n\n\nوهذا مثال لاستخدام عبارة continue للتخطي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- True --&gt; S3[\"i += 1\"]\n  S3 -- continue --&gt;  WHILE\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,5 color:red;\n  linkStyle 4 color:blue;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\n\n\n\n\nأما جملة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط، ولا يتوقف الخارجي. وهذا مثال:\n\n\n\n\n\n\n\nflowchart TD\n  INIT1[\"i = 0\"] --&gt; WHILE1\n  WHILE1{{\"while i &lt; 3\"}}\n    S3[\"i += 1\"] --&gt; WHILE1\n    WHILE1 -- True --&gt; INIT2[\"j = 0\"] --&gt; WHILE2\n    WHILE2{{\"while j &lt; 3\"}}\n      WHILE2 -- True --&gt; IF1{{\"if i == 1\"}} -- break --&gt; WHILE1\n      IF1 -- False --&gt; S1[\"print(i, j)\"] --&gt; S2[\"j += 1\"] --&gt; WHILE2\n    WHILE2 -- False --&gt; S3\n\n  style WHILE1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style WHILE2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 5,8 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone\n\n\n\n\n\n\n\n\nالملحق بعدم المطابقة\nتعتبر بايثون بعض القيَم تابعة لعدم المطابقة (False) وهي:\n\nFalse\nNone\n0\n0.0\n''\n[]\n()\n{}\nset()\n\nوما عدا ذلك فملحق بالمطابقة (True).\n\nif False or None or 0 or 0.0 or '' or [] or () or {} or set():\n    print('True')\nelse:\n    print('False')\n\nFalse",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#المصطلحات",
    "href": "chapters/03_control_flow/a_control_flow.html#المصطلحات",
    "title": "2  الجملة الشرطية",
    "section": "المصطلحات",
    "text": "المصطلحات\n\n\n\nالعربية\nالإنجليزية\n\n\n\n\nجملة شرطية\nConditional Statement\n\n\nجملة تكرارية\nLoop Statement\n\n\nشرط\nCondition\n\n\nتكرار\nLoop\n\n\nتكرار محدد\nFor Loop\n\n\nتكرار غير محدد\nWhile Loop\n\n\nاستمرار\nContinue\n\n\nتوقف\nBreak\n\n\nتعيين مشروط\nConditional Assignment\n\n\nتعبير شرطي\nConditional Expression\n\n\nتداخل\nNesting\n\n\nتسلسل\nSequence\n\n\nتفرع\nBranching\n\n\nمقارنة\nComparison\n\n\nعملية منطقية\nLogical Operation",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الجملة الشرطية</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html",
    "href": "chapters/03_control_flow/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "تسجيل الدخول\nلاحظ:",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "href": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "title": "تطبيقات",
    "section": "",
    "text": "استخدم الإجراء input() لطلب اسم المستخدم (username) و كلمة المرور (password) من المستخدم وخزن كل منهما في متغير مناسب\nإذا كان اسم المستخدم هو \"admin\" وكلمة المرور هي \"abc123\"، اطبع: \"Welcome admin\"\nأو إذا كان اسم المستخدم هو \"backdoor\" وكلمة المرور هي \"let me in\"، اطبع: \"Nobody knows!\"\nخلاف ذلك، اطبع: \"Access denied!\"\n\nimport getpass\n\nusername = input(\"Enter your username: \")\npassword = getpass.getpass(\"Enter your password: \")\n\nmax_tries = 3\ntries = 0\n\nwhile tries &lt; max_tries:\n  if username == \"admin\" and password == \"abc123\":\n    print(\"Welcome admin\")\n    break\n  elif username == \"backdoor\" and password == \"let me in\":\n    print(\"Nobody knows!\")\n    break\n  else:\n    print(\"Access denied!\")\n    tries += 1\n\n\nوجود حلقة while لإعادة المحاولة ثلاث مرات فقط\nوجود جملة break لإنهاء الحلقة إذا تم التسجيل بنجاح\n\nلا توجد break في جزئية else الأخيرة وذلك لأن عدد المحاولات يزيد في كل مرة ليؤول الإجراء إلى انتفاء شرط الدوران",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "href": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "title": "تطبيقات",
    "section": "حساب مجموع الأعداد المدخلة",
    "text": "حساب مجموع الأعداد المدخلة\nهذا البرنامج الصغير يأخذ مجموعة أعداد، واحدًا تلوَ الآخر، ويجمعها جميعًا.\ntotal = 0\n\nwhile True:\n  user_input = input(\"Enter a number: \")\n  if user_input == \"quit\":\n    break\n  x = int(user_input)\n  total += x\nprint(total)\nإليك شرحه بالتفصيل:\nتذكر: أن لكل متغير قيمة. وأن لكل قيمة نوعًا. وأن النوع يحدد ما يقبله المتغير من عمليات.\n\nنعين المتغير total = 0 لتجميع النتائج\nنستعمل حلقة لا نهائية: while True لأننا نريد أن يستمر البرنامج إلى أن يكتب المستخدم quit\nنطلب من المستخدم أن يدخل عددًا، ونضع ما أدخَل في متغير: user_input\nهذا المتغير نوعه: str (نصي) لأن الإجراء input() يعطينا قيمة نصية\nإن كان المدخل كلمة quit، نكسر الحلقة بـ: break\nوإلا:\n\nننشئ قيمة عددية من المتغير user_input باستخدام int(user_input) أو float(user_input) ونعيِّنُ النتيجة في متغير جديد: x\nنجمع العدد إلى الحاصل: total\nعندها نكسر الحلقة بكلمة: break",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#المكيف",
    "href": "chapters/03_control_flow/apps.html#المكيف",
    "title": "تطبيقات",
    "section": "المكيف",
    "text": "المكيف\nتشغييل المكيف إن كانت درجة الحرارة أعلى من المرغوب، بشرط أن يكون المكيف يعمل:\n\nroom_temp = 30\ndesired_temp = 24\nac_functional = False\n\nif room_temp &gt; desired_temp:\n    if ac_functional:\n        print(\"Turning on AC.\")\n    else:\n        print(\"AC malfunction! Please repair.\")\n\nAC malfunction! Please repair.",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "href": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "title": "تطبيقات",
    "section": "برنامج تفاعلي",
    "text": "برنامج تفاعلي\nجرب انسخ هذا البرنامج واختبره بنفسك حتى تفهمه.\ninventory = 100\n\nwhile True:\n    print(\"Store Menu:\")\n    print(\"1. Buy Apples\")\n    print(\"2. Restock Apples\")\n    print(\"3. Exit\")\n\n    choice = input(\"Enter your choice: \")\n\n    if choice == \"1\":\n        quantity = int(input(\"Enter the quantity of fish to buy: \"))\n\n        if quantity &lt;= inventory:\n            inventory -= quantity\n            print(\"You bought\", quantity, \"fish. Remaining inventory:\", inventory)\n        else:\n            print(\"Insufficient stock. Please try again later.\")\n\n    elif choice == \"2\":\n        quantity = int(input(\"Enter the quantity of fish to restock: \"))\n        inventory += quantity\n        print(\"Restocked\", quantity, \"fish. New inventory:\", inventory)\n\n    elif choice == \"3\":\n        print(\"Exiting the store...\")\n        break\n\n    else:\n        print(\"Invalid choice. Please try again.\")",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "href": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "title": "تطبيقات",
    "section": "حساب مضروب العدد",
    "text": "حساب مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots 1\n\\]\n\ni = 5\nj = i\nwhile j &gt; 1:\n  j -= 1\n  i *= j\nprint(i)\n\n120\n\n\nشرح للخطوات التنفيذية التفصيلية:\n\nأولاً، قم بتعيين المتغير i إلى العدد 5\nثانياً، قم بتعيين المتغير j إلى العدد 5\nثالثاً، استمر في الدوران إلى أن يصل j إلى القيمة 1\n\nفي كل دوران، قم بطرح 1 من j\nثم قم بضرب i بالقيمة الجديدة لـ j: المتحصل هو أن `i = i * (i - 1)\n\nأخيراً، قم بطباعة القيمة النهائية لـ i",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html",
    "href": "chapters/03_control_flow/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "المحاذاة\nما هي المشكلة في هذه القطعة البرمجية؟ وكيف تحلها؟\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[1], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#تركيب-الشروط",
    "href": "chapters/03_control_flow/problems.html#تركيب-الشروط",
    "title": "مسائل",
    "section": "تركيب الشروط",
    "text": "تركيب الشروط\nاعكس هذه العبارة الشرطة المرسومة بكتابة القطعة البرمجية التي تمثلها:\n\n\n\n\n\n\ngraph BT\n  RESULT((if))\n  ROOT{and} -- True --&gt; RESULT\n  middle_left{\"&gt;\"} -- True --&gt; ROOT\n  middle_right{\"&gt;\"} -- True --&gt; ROOT\n  left_left[age] -- \"20\" --&gt; middle_left\n  left_right[18] -- \"18\" --&gt; middle_left\n  right_left[weight] -- \"50\" --&gt; middle_right\n  right_right[45] -- \"45\" --&gt; middle_right",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#ارسم-الشجرة-الثائية",
    "href": "chapters/03_control_flow/problems.html#ارسم-الشجرة-الثائية",
    "title": "مسائل",
    "section": "ارسم الشجرة الثائية",
    "text": "ارسم الشجرة الثائية\nارسم الشجرة الثنائية للعبارة الشرطية في القطعة البرمجية التالية:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/03_control_flow/problems.html#الجملة-الشرطية-المتكاملة",
    "title": "مسائل",
    "section": "الجملة الشرطية المتكاملة",
    "text": "الجملة الشرطية المتكاملة\nما هو حاصل تنفيذ هذه القطعة (فقط بالنظر إليها يجب أن تعرف):\n\nx = 1\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSingle\nAlways: 1",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط",
    "title": "مسائل",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nكيف تكتب هذه الجملة بطريقة مختصرة؟\n\nspeed = 45\n\nif speed &gt; 50:\n  message = 'Too fast!'\nelse:\n  message = 'Okay'\n\nprint(message)\n\nOkay",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط-1",
    "href": "chapters/03_control_flow/problems.html#جملة-التعيين-المشروط-1",
    "title": "مسائل",
    "section": "جملة التعيين المشروط",
    "text": "جملة التعيين المشروط\nوماذا عن هذه الجملة، كيف تكتبها مختصرة؟\n\ntemperature = 25\n\nif temperature &gt; 30:\n  comfort = 'Hot'\nelif temperature &gt; 15:\n  comfort = 'Comfortable'\nelse:\n  comfort = 'Cold'\n\nprint(comfort)\n\nComfortable",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "title": "مسائل",
    "section": "الوزن الطبيعي",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\n\n\n\nالتصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\nالمطلوب:\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية مضمنة تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة\n\nملاحظة: يجب أن تكون الجمل الشرطية تستعمل التضمين على النحو التالي:\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "title": "مسائل",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار",
    "href": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار",
    "title": "مسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة البرمجية التالية بحلقة تكرار:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار-1",
    "href": "chapters/03_control_flow/problems.html#اكتب-القطعة-بحلقة-تكرار-1",
    "title": "مسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nوكذلك اكتب القطعة التالية بحلقة تكرار:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "href": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "title": "مسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "href": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "title": "مسائل",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بمفتاح الدولة، مثلاً بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”",
    "crumbs": [
      "باب الشرط والتكرار",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html",
    "href": "chapters/03_control_flow/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\nالمطلوب:\nheight = 1.70\nweight = 95\nbmi = weight / height**2\n\nword = ''\ncategory = ''\n\nif bmi &lt; 18.5:\n    word = 'thin'\n    if bmi &lt; 16:\n        category = 'severe'\n    elif bmi &lt; 17:\n        category = 'moderate'\n    else:\n        category = 'mild'\nelif bmi &lt; 25:\n    word = 'normal'\nelse:\n    word = 'overweight'\n    if bmi &lt; 30:\n        category = 'class 1'\n    elif bmi &lt; 35:\n        category = 'class 2'\n    elif bmi &lt; 40:\n        category = 'class 3'\n    else:\n        category = 'class 4'\n\nprint(word, category)\n\noverweight class 2",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "title": "حل المسائل",
    "section": "",
    "text": "التصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\n\n\n\n\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\n\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "title": "حل المسائل",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة\n\nuser_input = input(\"Enter a number: \")\nn = int(user_input)\n\ntotal = 0\ni = 1\nwhile i &lt;= n:\n    total += i\n    i += 1\n\nprint('sum is:', total)",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار",
    "href": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار",
    "title": "حل المسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة البرمجية التالية بحلقة تكرار:\n\nincrease = 5\n\nw1 = 15\nw2 = w1 + increase\nw3 = w2 + increase\nw4 = w3 + increase\nw5 = w4 + increase\nw6 = w5 + increase\nw7 = w6 + increase\nw8 = w7 + increase\nw9 = w8 + increase\nw10 = w9 + increase\n\nprint(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10)\n\n15 20 25 30 35 40 45 50 55 60\n\n\nالجواب:\n\nvalue = 15\nincrease = 5\nweeks = 10\n\ni = 0\nwhile i &lt; weeks:\n    value += increase\n    print(value, end=' ')\n    i += 1\n\n20 25 30 35 40 45 50 55 60 65 \n\n\nملاحظة: استعمال print(value, end=' ') يجعل الناتج يظهر في سطر واحد. وذلك لأن end='\\n' في الأصل وتعني سطرًا جديدًا.",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار-1",
    "href": "chapters/03_control_flow/solutions.html#اكتب-القطعة-بحلقة-تكرار-1",
    "title": "حل المسائل",
    "section": "اكتب القطعة بحلقة تكرار",
    "text": "اكتب القطعة بحلقة تكرار\nاكتب القطعة التالية بحلقة تكرار:\n\nimport math\n\ngrowth_rate = 0.117\n\nday1 = 100\nday2 = day1 * (1 + growth_rate)\nday3 = day2 * (1 + growth_rate)\nday4 = day3 * (1 + growth_rate)\nday5 = day4 * (1 + growth_rate)\nday6 = day5 * (1 + growth_rate)\nday7 = day6 * (1 + growth_rate)\n\nprint(math.floor(day1))\nprint(math.floor(day2))\nprint(math.floor(day3))\nprint(math.floor(day4))\nprint(math.floor(day5))\nprint(math.floor(day6))\nprint(math.floor(day7))\n\n100\n111\n124\n139\n155\n173\n194\n\n\nالجواب:\n\nimport math\n\nday = 100\ngrowth_rate = 0.117\n\ni = 0\nwhile i &lt; 6:\n    day *= (1 + growth_rate)\n    print(math.floor(day))\n    i += 1\n\n111\n124\n139\n155\n173\n194",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "href": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "title": "حل المسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)\nقد مرت علينا هذه المسألة، لكن الآن المطلوب حلها بالتكرار.\n\nweight = 20\nfor week in range(12):\n    weight += weight * 0.1\nprint(weight)\n\n62.768567534419994",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "href": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "title": "حل المسائل",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”\n\nprint(\"\"\"مرحبا بك في خدمة التبرع\nفضلا أريد منك تزويدي ببعض المعلومات ..\n\"\"\")\n\nprint('أتشرف باسمك، مثلا: محمد أحمد')\nname = input()\n\nprint('زودنا برقم جوالك، يبدأ بـ966')\nphone = input()\n\nprint('ممكن تحدد مدينتك؟')\ncity = input()\n\nprint('الرجاء قم بكتابة اسم الحي')\nneighborhood = input()\n\nprint('name:', name)\nprint('phone:', phone)\nprint('city:', city)\nprint('neighborhood:', neighborhood)\n\nwhile True:\n    print('هل تود تأكيد طلب التبرع؟')\n    print('1. تأكيد الطلب')\n    print('2. تعديل الطلب')\n    print('3. إلغاء الطلب')\n    user_confirmation = input()\n\n    if user_confirmation == '1':\n        print('تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً')\n        break\n    elif user_confirmation == '2':\n        print('ما الشيء الذي تريد تعديله؟')\n        print('1. الاسم')\n        print('2. رقم الهاتف')\n        print('3. المدينة')\n        print('4. اسم الحي')\n        user_modification = input()\n        match user_modification:\n            case '1':\n                print('اسم الزبون')\n                name = input()\n            case '2':\n                print('رقم الهاتف')\n                phone = input()\n            case '3':\n                print('المدينة')\n                city = input()\n            case '4':\n                print('اسم الحي')\n                neighborhood = input()\n            case _:\n                print('إختيار غير موجود')\n\n    elif user_confirmation == '3':\n        print('تم إلغاء طلب التبرع')\n        break",
    "crumbs": [
      "باب الشرط والتكرار",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html",
    "href": "chapters/05_sequences/a_sequences.html",
    "title": "3  التسلسل",
    "section": "",
    "text": "الجمع (Collection)\nكثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، …إلخ من العمليات التي تعمل على جميع عناصر المجموعة.\nالجمع (Collection) ضد المفرد (Atomic). وهو ما يقبل الإجراءات التالية:\nانظر خريطة الجموع شكل A.1 حيث يتبين أنه مكون من ثلاثة:\nويتفرع منه ثلاثة:\nفالأول موضوع هذا الباب، والآخران في الباب التالي إن شاء الله.",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الجمع-collection",
    "href": "chapters/05_sequences/a_sequences.html#الجمع-collection",
    "title": "3  التسلسل",
    "section": "",
    "text": "ملاحظة\n\n\n\nنرمز للمفرد بـx ولما يدل على الجمع بـc.\n\n\n\nالعضوية: x not in c\nالعد: len(c)\nالتكرار: for x in c\n\n\n\nالحاوي: Container (لقبوله العضوية)\nذو الحجم: Sized (لقبوله العد)\nالمكرر: Iterable (لقبوله التكرار)\n\n\n\nالتسلسل: Sequence\nالمجموعة: Set\nالدالة: Mapping",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#التسلسل-sequence",
    "href": "chapters/05_sequences/a_sequences.html#التسلسل-sequence",
    "title": "3  التسلسل",
    "section": "التسلسل (Sequence)",
    "text": "التسلسل (Sequence)\nالتسلسل (Sequence) جمع مرتب من الأشياء.\n\nجمع: يعني قبوله الإجراءات الثلاثة السابق ذكرها (العضوية والعد والتكرار).\nمرتب: يعني أن لكل عنصرٍ موضعًا بالنسبة لبدايته.\n\nويبدأ ترقيم المواضع بالنسبة لبداية التسلسل لذلك نجعل للعنصر الأوَّل الموضِع 0، إذ نسبةُ ذلك لبداية التسلسل. ويكون موضع الثاني 1 بالنسبة لبداية التسلسل، وللثالث 2، وهكذا إلخ.\nومن أمثلة المجموعات المرتبة:\n\nقائمة الرسائل، إذ هي مرتبة بالوقت واحدة تتلو الأخرى\nمجموعة الحروف في اللغة العربية، إذ تبدأ بالألف وتنتهي بالياء وما بينهما كلٌّ له ما قبله وما بعده\nقائمة الانتظار التي تعطي الأولويَّة لمن يأتي أوَّلاً للدخول على الطبيب\n\nوالمشترك في هذه الأمثلة الثلاثة: أن العناصر لها موضِعٌ بالنسبة لبعضها (مرتَّبة).\nوالأنواع الأربعة التي من جنس التسلسل هي:\n\nالقائمة (list) ويُعبَّرُ عنه بالقوسين المربعين [].\nالصف (tuple) ويُعبَّرُ عنه بالقوسين المنحنيين ().\nالمجال (range) ويُعبَّرُ عنه بالإجراء المنشئ range().\nالنص (str) ويُعبَّرُ عنه بالتنصيص المفرد '' أو المزدوج \"\"\n\n\n\n\n\n\n\n\nflowchart TD\n    Collection[&lt;b&gt;الجمع&lt;/b&gt; &lt;br&gt; &lt;code&gt;Collection&lt;/code&gt;]\n    Collection --&gt; Sequence[&lt;b&gt;التسلسل&lt;/b&gt; &lt;br&gt; &lt;code&gt;Sequence&lt;/code&gt;]\n    Sequence --&gt; MutableSequence[&lt;b&gt;التسلسل المتغير&lt;/b&gt; &lt;br&gt; &lt;code&gt;MutableSequence&lt;/code&gt;]\n    MutableSequence --&gt; list[&lt;b&gt;القائمة&lt;/b&gt; &lt;br&gt; &lt;code&gt;list&lt;/code&gt;]\n    Sequence --&gt; tuple[&lt;b&gt;الصف&lt;/b&gt; &lt;br&gt; &lt;code&gt;tuple&lt;/code&gt;]\n    Sequence --&gt; range[&lt;b&gt;المجال&lt;/b&gt; &lt;br&gt; &lt;code&gt;range&lt;/code&gt;]\n    Sequence --&gt; str[&lt;b&gt;النص&lt;/b&gt; &lt;br&gt; &lt;code&gt;str&lt;/code&gt;]\n\n\n\n\nشكل 3.1: شجرة أنواع التسلسل\n\n\n\n\n\n\nوراجع خريطة المجموعات: شكل A.1\nفهذه الأربعة تقبل الإجراءات التالية (المتغير s هو التسلسل هنا):\n\nالإشارة:\n\nبالموضع: s[i]\nبالقطعة: s[i:j]\nبالقطعة مع خطوة: s[i:j:k]\n\nمعرفة موضع شيء (إن وجد): s.index(x)\nعد تكرارات شيء: s.count(x)\nالبحث عن الأصغر والأكبر: min(s) و max(s)\n\nوتقبل من إجراءات الإنشاء:\n\nالدمج: s1 + s2\nالتكرار: s * n\n\nأما تخصيص حرف + للدمج (لا للجمع) ، وحرف * للتكرار (لا للضرب)؛ فسيأتي معنا -إن شاء الله- في فصل تعريف الإجراءات المخصوصة في باب الأنواع.",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الصف-tuple",
    "href": "chapters/05_sequences/a_sequences.html#الصف-tuple",
    "title": "3  التسلسل",
    "section": "الصف (tuple)",
    "text": "الصف (tuple)\nالصف تسلسل جامد.\nفالجامد هو ما لا يقبل التغيير بعد إنشائه.\n\nالإنشاء\nيكون إنشاء الصف بالقوسين المنحنيين () على النحو التالي:\n\nالفرد: (x,) وهو صف بعنصر واحد\nالزوج: (x, y) وهو صف بعنصرين\nالثلاثي: (x, y, z) وهو صف بثلاثة عناصر\n…إلخ.\n\nولا يشترط تجانس العناصر؛ بل يجوز أن تكون أنواعها مختلفة:\n\ns = (10, 20, 'hello', True, (300, 400))\nprint(s)\n\n(10, 20, 'hello', True, (300, 400))\n\n\nوقد يتألف الإنشاء بالتكرار بعلامة *:\n\ns = (10, 20) * 3\nprint(s)\n\n(10, 20, 10, 20, 10, 20)\n\n\nأو الدمج، بعلامة +:\n\ns = (10, 20) + (30, 40)\nprint(s)\n\n(10, 20, 30, 40)\n\n\nنستعرض هنا العضوية والعد والتكرار:\n\ns = (100, 200, 300)\n\nassert 100 in s\nassert 400 not in s\nassert len(s) == 3\n\nfor x in s:\n    print(x)\n\n100\n200\n300\n\n\n\n\nالإشارة\nتستعمل الإشارة الموضعية لقراءة عنصر من التسلسل.\n\ns = (10, 20, 30, 40, 50)\nassert s[0] == 10\nassert s[-1] == 50\nassert s[len(s) // 2] == 30\n\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\nويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل.\nفهذا يفشل لأن المؤشر ليس رقمًا صحيحًا:\n\ns = (10, 20, 30, 40, 50)\ns['3']\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[149], line 2\n      1 s = (10, 20, 30, 40, 50)\n----&gt; 2 s['3']\n\nTypeError: tuple indices must be integers or slices, not str\n\n\n\nوكذلك هذا لأنه يتجاوز نطاق التسلسل (0 - 4):\n\ns = (10, 20, 30, 40, 50)\ns[5]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[150], line 2\n      1 s = (10, 20, 30, 40, 50)\n----&gt; 2 s[5]\n\nIndexError: tuple index out of range\n\n\n\nشكل الإشارة بالقطعة (slice) على نحو: s[start : end : step]. والقيم الابتدائية عند الإغفال هي: s[0:len(s):1].\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\n\ns = (10, 20, 30, 40, 50)\nassert s[1:3] == (20, 30)\nassert s[::2] == (10, 30, 50)\nassert s[::-1] == (50, 40, 30, 20, 10)\nassert s[1:4:2] == (20, 40) == s[-4:-1:2]\nassert s[1:4:2] == s[slice(1,4,2)] == (20, 40)\n\nلاحظ استعمال الإجراء المنشئ slice() في الإشارة بالقطعة، وقد جعلت بايثون علامة : بديلاً عنه.\nوإذا جعلته صفًّا من صفوف؛ صار مصفوفة:\n\nmatrix = (\n    (10, 20, 30),\n    (40, 50, 60),\n    (70, 80, 90)\n)\n\nassert matrix[0] == (10, 20, 30)\nassert matrix[-1] == (70, 80, 90)\n\nوتستعمل الإشارة مرتين للإشارة إلى العدد، مثلاً للإشارة إلى العنصر الثاني في الصف الثاني:\n\nassert matrix[1][1] == 50\n\n 0              1              2              3\n +--------------+--------------+--------------+\n | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |\n +--------------+--------------+--------------+\n-3             -2             -1\nالإشارة لعناصر الصف الواحد:\n 0    1    2    3\n +----+----+----+\n | 10 | 20 | 30 |\n +----+----+----+\n-3   -2   -1\n 0    1    2    3 \n +----+----+----+\n | 40 | 50 | 60 |\n +----+----+----+\n-3   -2   -1\n 0    1    2    3\n +----+----+----+\n | 70 | 80 | 90 |\n +----+----+----+\n-3   -2   -1\nعناصر نصوص:\n\nss = (\"Apple\", \"Banana\", \"Orange\", \"Lemon\")\nassert ss[1] == \"Banana\"\nassert ss[-1][0] == \"L\"\n\n 0       1        2        3       4\n +-------+--------+--------+-------+\n | Apple | Banana | Orange | Lemon |\n +-------+--------+--------+-------+\n-4      -3       -2       -1\nالإشارة لصف الأحرف في النص الواحد:\n 0   1   2   3   4   5\n +---+---+---+---+---+\n | L | e | m | o | n |\n +---+---+---+---+---+\n-5  -4  -3  -2  -1\nوسيأتي التفصيل في باب النص.\n\n\nالبحث\nالبحث عن موضع العنصر (s.index(x)) وعد تكراره (s.count(x)):\n\ns = ('Python', 'Python', 'Go')\nassert s.index('Go') == 2\nassert s.count('Python') == 2\n\nالبحث عن الأصغر والأكبر:\n\ns = (30, 20, 40, 10, 50)\nassert s.index(min(s)) == 3\nassert s.index(max(s)) == 4",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#القائمة-list",
    "href": "chapters/05_sequences/a_sequences.html#القائمة-list",
    "title": "3  التسلسل",
    "section": "القائمة (list)",
    "text": "القائمة (list)\nالقائمة (list) تسلسل متغير.\nانظر MutableSequence في خريطة المجموعات: شكل A.1.\n\nالتغير\nفالأنواع على قسمين من حيث قبول التغير بعد الإنشاء:\n\nمتغير (Mutable: قابل للتغيير): يعني قبوله الإضافة والحذف والتعديل على عناصرها بعد الإنشاء.\nجامد (Immutable: غير قابل للتغيير): لا يقبل التغير. ومن جهة كونها عوامل للإجراء؛ فإن الجامد لا يقبل أن يكون محل عمل الإجراء.\n\n\n\n\n\n\n\nملاحظة\n\n\n\nالتغير والجمود مفهومان يتكرران كثيرًا في البرمجة. للمزيد راجع: بناء البرمجيات: الفصل التاسع، الجمود (MIT-6.005)\n\n\nالتغير هي الخاصية التي تختلف فيها القائمة عن قسيماتها التسلسلية (الصف والمجال والنص). ومعناه قبولها الإجراءات التالية (نستعمل في المثال حرف l للقائمة):\n\nالاستبدال:\n\nلموضع: l[i] = x\nلقطعة: l[i:j] = t\nلقطعة بخطوة: l[i:j:k] = t\n\nالحذف:\n\nلموضع: del l[i]\nلقطعة: del l[i:j]\nلقطعة بخطوة: del l[i:j:k]\n\nالإزالة: l.remove(x) لحذف أول ورود للعنصر\nالنزع: l.pop([i]) أخذ العنصر من الموضع (مع حذفه من ذلك الموضع)\n\nإن لم يحدد الموضع: نزع الأخير. إذ القوسان [i] هنا في التعريف يعبران عن عامل اختياري وهو الموضع i\n\nالإدراج: l.insert(i, x) لإضافة عنصر في موضع محدد\nالإلحاق: l.append(x) لإضافة عنصر في النهاية\nالترتيب: l.sort() أو بالإجراء المبني sorted(l)\nالعكس: l.reverse() أو بالإجراء المبني reversed(l)\n\nلاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين المنحنيين ()، إذْ هو جامد لا يقبل التغير:\n\nt = (10, 20, 30, 40, 50)\nt[0] = 100\nprint(t)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[157], line 2\n      1 t = (10, 20, 30, 40, 50)\n----&gt; 2 t[0] = 100\n      3 print(t)\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nلكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين []، لأنها متغيرة:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nprint(l)\n\n[100, 20, 30, 40, 50]\n\n\nالاستبدال بالموضع والحذف منه:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nassert l == [100, 20, 30, 40, 50]\n\ndel l[0]\nassert 100 not in l\n\nالاستبدال بالقطعة والحذف منها\n\nl = [10, 20, 30, 40, 50]\nl[1:3] = [200, 300]\nassert l == [10, 200, 300, 40, 50]\n\ndel l[1:3]\nassert l == [10, 40, 50]\n\nالإدراج:\n\nl = [10, 20, 30, 40, 50]\nl.insert(1, 100)\nassert l == [10, 100, 20, 30, 40, 50]\n\nالإزالة:\n\nl = [10, 20, 30, 40, 50]\nl.remove(20)\nassert l == [10, 30, 40, 50]\n\nالإلحاق:\n\nl = [10, 20, 30, 40, 50]\nl.append(60)\nassert l == [10, 20, 30, 40, 50, 60]\n\nالترتيب والعكس:\n\nl = [30, 40, 10, 20, 50]\nl.sort()\nassert l == [10, 20, 30, 40, 50]\n\nl.reverse()\nassert l == [50, 40, 30, 20, 10]\n\nنزع العنصر الأخير:\n\nl = [10, 20, 30, 40, 50]\nx = l.pop()\nassert x == 50\nassert 50 not in l",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#النطاق-range",
    "href": "chapters/05_sequences/a_sequences.html#النطاق-range",
    "title": "3  التسلسل",
    "section": "النطاق (range)",
    "text": "النطاق (range)\nيمثل النطاق (range) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فثلاثة عوامل تحدده:\n\nالبداية (start=0):\n\nمشمولة\nقيمتها الابتدائية 0 (إذا أهملت)\n\nالنهاية (stop):\n\nغير مشمولة\nوهي واجبة (إهمالها ممتنع)\n\nالخطوة (step=1):\n\nمقدار الزيادة أو النقص للعدد في كل كرة\nقيمتها الابتدائية 1 (إذا أهملت)\n\n\nدعونا الآن نلقي نظرة على التعريف كما هو موجود في وثائق بايثون، وذلك لنتعلم كيف نقرؤ التعريف. ادخل الرابط وتأمل معي ..\n\nclass range(stop)\nclass range(start, stop[, step])\n\nأولا: تدل كلمة class على أنها معرَّفة كنوع، فيكون طلب الإجراء بنفس الاسم range للإنشاء.\nثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما يكون؟\nنجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو stop وتأخذ البداية والخطوة قيمتهما الابتدائية: start=0 و step=1 حسب ما كُتب:\n\nIf the step argument is omitted, it defaults to 1.\nIf the start argument is omitted, it defaults to 0\n\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nأما التعريف الثاني فيجب تفكيكه لنفهمه: class range(start, stop[, step]).\nوجود الأقواس المربعة [ ] يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو start, stop؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الابتدائية step=1.\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\nالتكرار والإشارة\n\nxs = [10, 20, 30, 40, 50, 60]\n\nويُسرَد التسلسل بكلمة for، على النحو التالي:\n\nfor x in xs:\n    print(x)\n\n10\n20\n30\n40\n50\n60\n\n\nأو بسرد النطاق (حيث النهاية تكون: len(xs) أي: طول التسلسل) واستعمال الإشارة بالموضع (xs[i])، نحو:\n\nfor i in range(len(xs)):\n    print(xs[i])\n\n10\n20\n30\n40\n50\n60\n\n\nفهذا يفيد في التحكم في السرد، فلو أردنا كل عنصرٍ ثانٍ، نجعل الخطوة 2 ابتداء من العنصر الثاني 1، فنكتبها هكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i])\n\n20\n40\n60\n\n\nأو أردنا قراءة الموضع والذي قبله، فهكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i-1], xs[i])\n\n10 20\n30 40\n50 60\n\n\nفإن جوَّزنا التداخل، جعلنا الخطوة 1، هكذا:\n\nfor i in range(1, len(xs), 1):\n    print(xs[i-1], xs[i])\n\n10 20\n20 30\n30 40\n40 50\n50 60\n\n\nوهلم جرا..\n\n\nتأجيل النتيجة\nويجدر بالذكر أن النطاق لا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وهو كالصف لا يقبل التعديل.\nنستعمل فعل الإنشاء range() لإنشاء نطاق:\n\nr = range(0, 20, 2)\nr\n\nrange(0, 20, 2)\n\n\nفحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:\n\nprint(11 in r)\nprint(10 in r)\n\nFalse\nTrue\n\n\nكذلك الإجراء عند البحث عن موضع رقمٍ ما:\n\nprint(r.index(10))\n\n5\n\n\nوالإشارة لموضع ما أو قطعة كذلك:\n\nprint(r[5])\nprint(r[:5])\nprint(r[-1])\n\n10\nrange(0, 10, 2)\n18\n\n\n\n\nتحقيق النطاق\nالمولِّد لا تتحقق عناصره إلا عند الحاجة إليها؛ أي: عند قراءتها. فإذا جعلناه عاملاً في جملة الإنشاء list؛ تولَّدَت جميع عناصره ووُضِعَت في قائمة:\n\nevens = list(range(0, 10, 2))\nodds = list(range(1, 10, 2))\nprint(evens)\nprint(odds)\n\n[0, 2, 4, 6, 8]\n[1, 3, 5, 7, 9]",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#ضم-التسلسلات-المرتبطة-zip",
    "href": "chapters/05_sequences/a_sequences.html#ضم-التسلسلات-المرتبطة-zip",
    "title": "3  التسلسل",
    "section": "ضم التسلسلات المرتبطة (zip)",
    "text": "ضم التسلسلات المرتبطة (zip)\nهذان تسلسلان مرتبطان:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = [90, 80, 75, 85, 95]\n\nassert len(students) == len(marks)\n\nويُمكن ضمُّ السلسلتين بحيث ينتج في التكرار عُنصران في كل مرة؛ وذلك بفعل الضم zip() الذي يُنتج مُكَرَّرًا -بفتح الراء- (Iterable). فإذا ضممنا سلسلتين، خرج لنا في كل كرَّة زوج (x, y):\n\nfor x, y in zip(students, marks):\n    print(x, y)\n\nAhmad 90\nBelal 80\nCamal 75\nDawud 85\nEmad 95\n\n\n\n\n\n\n\nflowchart LR\n    students --&gt; zip\n    marks --&gt; zip\n    zip --&gt; for\n    for --&gt; x\n    for --&gt; y\n\n\n\n\n\n\n\nضم المكررات\nولاحظ فيما يلي أن:\n\nنوع students قائمة (list)\nونوع marks نطاق (range)\nونوع classes صف (tuple)\n\nومع ذلك فإنه يجوز ضمُّها لأن الإجراء يقبلُ كُل ما هو مُكَرَّر:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = range(75, 95+1, 5)\nclasses = ('A-1', 'A-1', 'A-2', 'A-1', 'A-2')\n\nassert list == type(students)\nassert tuple == type(classes)\nassert range == type(marks)\n\nfor x, y, z in zip(students, marks, classes):\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2\n\n\n\n\nالقراءة بالموضع المشترك\nويكون قراءة التسلسلات المرتبطة أيضًا بسرد مُكَرَّر النطاق، والإشارة إلى كل عنصر بالموضع:\n\nfor i in range(len(students)):\n    x, y, z = students[i], marks[i], classes[i]\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "href": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "title": "3  التسلسل",
    "section": "الإنشاء المختصر: الجملة الثلاثية",
    "text": "الإنشاء المختصر: الجملة الثلاثية\nمما تميزت به لغة بايثون عن غيرها: مختصرة الإنشاء (Comprehension)؛ وهي جملة تُنشئ مجموعة مستمَدَّة من مكرر في ثلاث جُمَل في سطرٍ واحدٍ -غالبًا- ووظيفتها: إنشاء مجموعة مستمَدَّة من مكرر.\nوليسَت زيادتها في اللغة من باب الضرورة وإنما من باب التحسين. إذْ فيها قوة في التعبير عن جمل كثيرة في مساحة صغيرة. فهذا المثال يعبر عن إنشاء قائمة كل عنصرٍ فيها مربَّعٌ من المكرر range(10) في سطرٍ واحد:\n\nsquares = [x ** 2 for x in range(10)]\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nفهي جملة إنشاء مركَّبة من ثلاث جمل:\n\nتعبير (x ** 2) ، الذي يشتمل غالبًا على متغير التكرار (x)\nتكرار: (for x in range(10))\nوشرط: والشرطُ ليسَ بشرط؛ لذا جاز إهماله في هذا المثال\n\nفهي مكافئة للقطعة التالية:\n\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nولو أردنا ترشيح الأعداد الزوجية من قائمة، نستطيع استعمال جملة الشرط في الاختصار على النحو التالي:\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nevens = [x for x in numbers if x % 2 == 0]\nevens\n\n[0, 2, 4, 6, 8]\n\n\n\nالتعبير: (x) فقط\nالتكرار: (for x in numbers)، وتذكر أن القائمة مُكرَّر\nالشرط: (if x % 2 == 0)\n\nوهي مكافئة للقطعة التالية:\n\nevens = []\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\nevens\n\n[0, 2, 4, 6, 8]\n\n\nوأما القوسان المربعان [ ] -في كلا المثالين- فلإنشاء قائمة. وبحسب ما يُراد إنشاؤه تختلف الأقواس:\n\n[expression for item in iterable if condition] للقائمة (list)\n(expression for item in iterable if condition) للمولِّد (Generator)\n{expression for item in iterable if condition} لمجموعة الفرائد (set) وسيأتي الكلام عنها في الباب القادم\n{expression: expression for item in iterable if condition} للقاموس (dict) وسيأتي الكلام عنه في الباب القادم",
    "crumbs": [
      "باب الجمع المرتب",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html",
    "href": "chapters/05_sequences/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "ترتيب قائمة الأسماء\nإن تطبيقات البيانات المتسلسلة كثيرة جدًا وواقعية إلى حد كبير. ولن نتطرق الآن إلى كيفية وصول هذه البيانات إلى بايثون (فذلك موضوع له تفاصيله)، لكننا سنتعامل مع البيانات باعتبار أنها وصلت إلينا.\nلو كان لدينا قائمة من الأسماء ونريد ترتيبها أبجديًّا؛ فإننا نستعمل الإجراء sort() الذي يأخذ القائمة كمفعول به ويرتبها في مكانها:\nnames = [\n    \"Yousef\",\n    \"Ali\",\n    \"Belal\",\n]\nlist.sort(names)\nnames\n\n['Ali', 'Belal', 'Yousef']",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#ضم-القوائم",
    "href": "chapters/05_sequences/apps.html#ضم-القوائم",
    "title": "تطبيقات",
    "section": "ضم القوائم",
    "text": "ضم القوائم\nتأتي البيانات عادة من مصادر متعددة. فلو كان لدينا قائمتان لدرجات الطلاب، بحيث تحتوي القائمة أزواجًا تحوي اسم الطالب ودرجته، فإننا نريد ضمها جميعًا في قائمة واحدة. وهذا يتحقق بعملية الجمع + بين القوائم:\n\nclass1_marks = [\n    (\"Yousef\", 80),\n    (\"Ali\", 70),\n    (\"Belal\", 90),\n]\nclass2_marks = [\n    (\"Dawood\", 85),\n    (\"Muhammad\", 75),\n    (\"Yaser\", 95),\n]\nstudent_marks = class1_marks + class2_marks\nstudent_marks\n\n[('Yousef', 80),\n ('Ali', 70),\n ('Belal', 90),\n ('Dawood', 85),\n ('Muhammad', 75),\n ('Yaser', 95)]\n\n\nنتأكد من عدد الطلاب:\n\nassert len(student_marks) == len(class1_marks) + len(class2_marks)",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#ترتيب-قائمة-صفوف",
    "href": "chapters/05_sequences/apps.html#ترتيب-قائمة-صفوف",
    "title": "تطبيقات",
    "section": "ترتيب قائمة صفوف",
    "text": "ترتيب قائمة صفوف\nوالآن نريد أن نرتب هذه القائمة تصاعديًّا بحسب الدرجات.\n\n# أولاً سنفصل قائمة الدرجات لوحدها\nmarks = [mark for name, mark in student_marks]\n\nresult = []\n# نأتي على قائمة الدرجات بشكل تصاعدي\nfor mark in sorted(marks, reverse=True):\n    # نبحث عن الطلاب الذين حصلوا على هذه الدرجة\n    for row in student_marks:\n        # إذا كانت الدرجة متطابقة\n        if row[1] == mark:\n            # نضيفهم إلى النتيجة\n            result.append(row)\nresult\n\n[('Yaser', 95),\n ('Belal', 90),\n ('Dawood', 85),\n ('Yousef', 80),\n ('Muhammad', 75),\n ('Ali', 70)]\n\n\nولو أردنا أسماء الثلاثة الأوَل:\n\nhigh = [x[0] for x in result[:3]]\nhigh\n\n['Yaser', 'Belal', 'Dawood']\n\n\nونستطيع أن نأخذ أسماء الطلبة الأضعف في الدرجات حتى نفهم الأسباب ونحاول أن نرفع من مستواهم الدراسي. ولاحظ هنا نستعمل فك الأقواس بدل تحديد الموضع بالرقم:\n\nlow = [name for name, mark in result[-3:]]\nlow\n\n['Yousef', 'Muhammad', 'Ali']",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#توزيع-نماذج-الاختبار",
    "href": "chapters/05_sequences/apps.html#توزيع-نماذج-الاختبار",
    "title": "تطبيقات",
    "section": "توزيع نماذج الاختبار",
    "text": "توزيع نماذج الاختبار\nتصور أن لدينا نموذجين من الاختبار، ونريد أن نوزعها بحيث يأخذ نصفهم النموذج الأول والنصف الثاني يأخي النموذج الثاني، لكن نريد أن يكون التوزيع بحسب الصف الذي يجلس فيه الطلاب.\nنفترض أن كل صف يجلس فيه ثلاثة طلاب، ونريد أن نجعل لكل صف نموذجًا.\n\nstudents = [\n    'Ahmad',\n    'Belal',\n    'Camal',\n    'Dawood',\n    'Emad',\n    'Faris',\n    'Ghaith',\n    'Hussain',\n]\n\nنمر على قائمة الأسماء بخطوة مقدارها 3 (عدد الطلاب في كل صف):\n\nfor i in range(0, len(students), 3):\n    print(students[i:i+3])\n\n['Ahmad', 'Belal', 'Camal']\n['Dawood', 'Emad', 'Faris']\n['Ghaith', 'Hussain']\n\n\nوالآن نريد أن نحدد لكل صف نموذجًا. نحقق ذلك بعملية باقي القسمة لمعرفة ما إذا كان العدد يقبل القسمة على 2؛ إذ به يعرف الزوجي، والآخر هو الفردي:\n\nfor i in range(0, len(students), 3):\n    if i % 2 == 0:\n        print(students[i:i+3], 'test1')\n    else:\n        print(students[i:i+3], 'test2')\n\n['Ahmad', 'Belal', 'Camal'] test1\n['Dawood', 'Emad', 'Faris'] test2\n['Ghaith', 'Hussain'] test1",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#فرز-البيانات",
    "href": "chapters/05_sequences/apps.html#فرز-البيانات",
    "title": "تطبيقات",
    "section": "فرز البيانات",
    "text": "فرز البيانات\nتصور أن لدينا قائمة من الأرقام الموجبة والسالبة في مجموعة واحدة، ونريد فصلها لمجموعتين:\n\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = []\nnegatives = []\n\nfor x in numbers:\n    if x &gt; 0:\n        positives.append(x)\n    else:\n        negatives.append(x)\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]\n\n\nأو باستعمال الإنشاء المختصر:\n\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = [x for x in numbers if x &gt; 0]\nnegatives = [x for x in numbers if x &lt; 0]\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#المحاسبة-المالية",
    "href": "chapters/05_sequences/apps.html#المحاسبة-المالية",
    "title": "تطبيقات",
    "section": "المحاسبة المالية",
    "text": "المحاسبة المالية\nافترض أن لديك قائمة بالمصروفات والإيرادات لكل رُبع من السنة، وتريد حساب صافي الربح لكل ربع على حدة، ثم جمعها لتحصل على الربح الإجمالي للسنة.\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet     = [    0,     0,     0,     0]\nfor i in range(len(income)):\n    net[i] = income[i] - expense[i]\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100\n\n\nأو باستعمال zip للتكرار على مضموم القائمتين:\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet = []\nfor inc, exp in zip(income, expense):\n    net.append(inc - exp)\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100\n\n\nأو باستعمال الإنشاء المختصر:\n\nincome  = [52000, 51000, 48000, 50000]\nexpense = [46800, 45900, 43200, 47000]\nnet = [inc - exp for inc, exp in zip(income, expense)]\n\nprint(\"quarterly net:\", net)\nprint(\"   annual net:\", sum(net))\n\nquarterly net: [5200, 5100, 4800, 3000]\n   annual net: 18100",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#أسعار-السلة",
    "href": "chapters/05_sequences/apps.html#أسعار-السلة",
    "title": "تطبيقات",
    "section": "أسعار السلة",
    "text": "أسعار السلة\nلديك قائمة بالأسعار:\n\nprices = [\n    ('apple', 10),\n    ('banana', 20),\n    ('orange', 30),\n    ('mango', 40),\n    ('pineapple', 50),\n]\n\nوتريد حساب مجمل سلة مشتريات لأحد الزبائن:\n\nbasket1 = [\n    ('apple', 2),\n    ('mango', 1)\n]\nbasket2 = [\n    ('banana', 1),\n    ('orange', 2),\n    ('pineapple', 1),\n]\n\nنكرر على العناصر\n\ntotal_basket1 = 0\nfor fruit, count in basket1:\n    for label, price in prices:\n        if fruit == label:\n            total_basket1 += price * count\nprint(total_basket1)\n\n60\n\n\nوكذلك للسلة الثانية:\n\ntotal_basket2 = 0\nfor fruit, count in basket2:\n    for label, price in prices:\n        if fruit == label:\n            total_basket2 += price * count\nprint(total_basket2)\n\n130",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#إدارة-الطلبات",
    "href": "chapters/05_sequences/apps.html#إدارة-الطلبات",
    "title": "تطبيقات",
    "section": "إدارة الطلبات",
    "text": "إدارة الطلبات\n\norders = []\n\nوتدخل الطلبات بإجراء الإلحاق append للقائمة:\n\nx = (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\norders.append(x)\n\nوهكذا الطلبات اللاحقة:\n\norders.append((('falafel', 'hummus', 'tea'), '8:48 PM'))\norders.append((('kabab', 'tabbouleh', 'water'), '8:52 PM'))\n\nوإننا حين ننجز الطلبات أو نعرضها، يكون بالترتيب التي دخلت به من الأول:\n\nfor order in orders:\n    print(order)\n\n(('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n(('kabab', 'tabbouleh', 'water'), '8:52 PM')\n\n\nوإذا أنجزنا الطلب (بالترتيب)، نزيله من القائمة:\n\nfinished = orders.pop(0)\nprint('done:', finished)\n\nprint('remaining:')\nfor order in orders:\n    print(order)\n\ndone: (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM')\nremaining:\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n(('kabab', 'tabbouleh', 'water'), '8:52 PM')\n\n\nأو هب أن الزبون الأخير ألغى الطلب، فإننا نزيله هكذا:\n\ncancelled = orders.pop(-1)\nprint('cancelled:', cancelled)\n\nprint('remaining:')\nfor order in orders:\n    print(order)\n\ncancelled: (('kabab', 'tabbouleh', 'water'), '8:52 PM')\nremaining:\n(('falafel', 'hummus', 'tea'), '8:48 PM')\n\n\nملاحظة: pop(-1) تساوي pop() إذ القيمة الابتدائية هي -1.",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#إزالة-العناصر-المتكررة",
    "href": "chapters/05_sequences/apps.html#إزالة-العناصر-المتكررة",
    "title": "تطبيقات",
    "section": "إزالة العناصر المتكررة",
    "text": "إزالة العناصر المتكررة\nهب أننا وجدنا الطلب أدخل بالخطأ مرتين، ونريد إزالة التكرارات الموجودة في قائمة الطلبات كلها:\n\norders = [\n    (('falafel', 'hummus', 'tea'), '8:42 PM'),\n    (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n    (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n    (('falafel', 'hummus', 'tea'), '8:50 PM'),\n]\n\nلاحظ أن الطلب الأول والأخير ليسا مكررين، وذلك لأنهما في وقتين مختلفين، أم الطلبان في الوسط فهما في نفس الوقت بالضبط، ونريد إزالة مثل هذا التكرار:\n\nresult = []\nfor order in orders:\n    if order not in result:\n        result.append(order)\nresult\n\n[(('falafel', 'hummus', 'tea'), '8:42 PM'),\n (('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM'),\n (('falafel', 'hummus', 'tea'), '8:50 PM')]",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#تعديل-الطلب",
    "href": "chapters/05_sequences/apps.html#تعديل-الطلب",
    "title": "تطبيقات",
    "section": "تعديل الطلب",
    "text": "تعديل الطلب\nنريد أن نتابع حالة الطلب، ونعدلها إذا أنهينا الطلب. لن نستطيع ذلك إذا حاولنا تعديل الصف ()، بل يجب أولًا أن نجعل قائمة الطلبات مكونة من قوائم [] وليس من صفوف:\n\norders = [\n    [('falafel', 'hummus', 'tea'), '8:42 PM', 'PENDING'],\n    [('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM', 'PENDING'],\n    [('falafel', 'hummus', 'tea'), '8:50 PM', 'PENDING'],\n]\n\n\norders[0][2] = 'DONE'\n\nوالآن نستطيع فرز الطلبات بحسب حالة الطلب:\n\norders_done = [order for order in orders if order[2] == 'DONE']\norders_pending = [order for order in orders if order[2] == 'PENDING']\n\nprint('done:')\nfor order in orders_done:\n    print(order)\n\nprint('pending:')\nfor order in orders_pending:\n    print(order)\n\ndone:\n[('falafel', 'hummus', 'tea'), '8:42 PM', 'DONE']\npending:\n[('kabab', 'kabab', 'shawerma', 'water', 'water'), '8:45 PM', 'PENDING']\n[('falafel', 'hummus', 'tea'), '8:50 PM', 'PENDING']",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "href": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "title": "تطبيقات",
    "section": "معرفة النقاط المجاورة",
    "text": "معرفة النقاط المجاورة\nتقول الرياضيات أن المسافة الإقليدية (على سطح مستوي لا متعرج) بين نقطتين تحكمها المعادلة:\n\\[\nd = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nنريد استعماله لقائمة من النقاط لمعرفة النقاط المجاورة.\n\npoints = [(1, 2), (5, 6), (7, 8), (3, 4)]\nx1, y1 = (2, 4)\n\ndistances = []\n\nfor x2, y2 in points:\n  d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n  distances.append(d)\n  print(f'distance from {x1, y1} to {x2, y2} is {d}')\n\nmin_distance = min(distances)\nmin_distance_index = distances.index(min_distance)\n\nprint('min distance index:', min_distance_index, 'with distance:', min_distance)\n\nnearest_point = points[min_distance_index]\n\nprint(f'nearest point to {x1, y1} is {nearest_point}')\n\ndistance from (2, 4) to (1, 2) is 2.23606797749979\ndistance from (2, 4) to (5, 6) is 3.605551275463989\ndistance from (2, 4) to (7, 8) is 6.4031242374328485\ndistance from (2, 4) to (3, 4) is 1.0\nmin distance index: 3 with distance: 1.0\nnearest point to (2, 4) is (3, 4)",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "href": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "أمثلة إضافية على الإنشاء المختصر",
    "text": "أمثلة إضافية على الإنشاء المختصر\nيمكن استعمال اختصار من اختصار على النحو التالي. في هذا المثال نفرد قائمة مكونة من قوائم عددية، فنحوِّلها لتكون قائمة واحدة مكوَّنة من جميع هذه الأرقام:\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nإذا كتبناها من غير اختصار فشكلها كالتالي (لاحظ استعملنا متغير flat لتجميع القيَم المفردة):\n\nflat = []\nfor elem in vec:\n    for num in elem:\n        flat.append(num)\nflat\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nوهذا مثال لحاصل الضرب الديكارتي بين مجموعتين رياضيتين:\n\ncolors = ['red', 'green']\nshapes = ['circle', 'square']\ncartesian_product = [(color, shape) for color in colors for shape in shapes]\ncartesian_product\n\n[('red', 'circle'),\n ('red', 'square'),\n ('green', 'circle'),\n ('green', 'square')]\n\n\nراجع التوثيق لمزيد من الأمثلة.",
    "crumbs": [
      "باب الجمع المرتب",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html",
    "href": "chapters/05_sequences/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "إنشاء قائمة\nلديك مجموعة طلاب في الفصل وتريد تجميع أسمائهم في مجموعة. وهم:",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#إنشاء-قائمة",
    "href": "chapters/05_sequences/problems.html#إنشاء-قائمة",
    "title": "مسائل",
    "section": "",
    "text": "\"عمرو\"\n\"لؤي\"\n\"محمد\"\n\"علي\"\n\"فصيل\"",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#قائمة-الطلاب",
    "href": "chapters/05_sequences/problems.html#قائمة-الطلاب",
    "title": "مسائل",
    "section": "قائمة الطلاب",
    "text": "قائمة الطلاب\nمن القائمة السابقة تريد تحصيل التالي:\n\nهل الطالب “لؤي” في القائمة؟\nكم عدد الطلاب؟\nاسرد الفائمة",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#أضف-طالبا-جديدا",
    "href": "chapters/05_sequences/problems.html#أضف-طالبا-جديدا",
    "title": "مسائل",
    "section": "أضف طالبًا جديدًا",
    "text": "أضف طالبًا جديدًا\nأضف طالبًا جديدًا إلى القائمة، وهو: \"زياد\".",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#بالإشارة",
    "href": "chapters/05_sequences/problems.html#بالإشارة",
    "title": "مسائل",
    "section": "بالإشارة",
    "text": "بالإشارة\n\nمن هو أول طالب؟\nمن هو آخر طالب؟\nمن هو الطالب الذي في المنتصف؟",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#بالقطعة",
    "href": "chapters/05_sequences/problems.html#بالقطعة",
    "title": "مسائل",
    "section": "بالقطعة",
    "text": "بالقطعة\n\nمن هم الطلاب باستثناء الأول والأخير؟\nمن هم الطلاب الثلاثة الأُخَر\nمن هم الطلاب الذين في موضع فردي؟\nمن هم الطلاب الذين في موضع زوجي؟",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "title": "مسائل",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\n\nلديك قائمة بالمبيعات اليومية.\n\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\nوتريد أن تحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الإجراء len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الإجراء sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الإجراء statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "href": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "title": "مسائل",
    "section": "سلة مشتريات",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها:\nfruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\nاحسب حاصل مشتريات كل سلة وفق قائمة الأسعار:\nbasket1 = [\"apple\", \"apple\", \"apple\"]\nbasket2 = [\"banana\", \"apple\"]",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "href": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "title": "مسائل",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\nيوصف ضرب المتجهين بالصيغة:\n\\[\n\\vec{u} \\cdot \\vec{v} = \\sum_{i=1}^{n} u_i v_i\n\\]\nأي أن كل عنصر من المتجه الأول يضرب في العنصر المناظر له في المتجه الثاني، ويُجْمَعُ ناتج ذلك كله.\nu = (1, 2, 3)\nv = (4, 5, 6)\nفهذا التوكيد الأول بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{v} &= [4, 5, 6] \\\\\n\\vec{u} \\cdot \\vec{v} &= (1)(4) + (2)(5) + (3)(6) \\\\\n                     &= 4 + 10 + 18 \\\\\n                     &= 32\n\\end{align*}\n\\]\nوهذا التوكيد الثاني بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{u} \\cdot \\vec{u} &= (1)(1) + (2)(2) + (3)(3) \\\\\n                     &= 1 + 4 + 9 \\\\\n                     &= 14\n\\end{align*}\n\\]",
    "crumbs": [
      "باب الجمع المرتب",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html",
    "href": "chapters/05_sequences/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "إنشاء قائمة\nلديك مجموعة طلاب في الفصل وتريد تجميع أسمائهم في مجموعة. وهم:\nstudents = [\"عمرو\", \"لؤي\", \"محمد\", \"علي\", \"فصيل\"]",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#إنشاء-قائمة",
    "href": "chapters/05_sequences/solutions.html#إنشاء-قائمة",
    "title": "حل المسائل",
    "section": "",
    "text": "\"عمرو\"\n\"لؤي\"\n\"محمد\"\n\"علي\"\n\"فصيل\"",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#قائمة-الطلاب",
    "href": "chapters/05_sequences/solutions.html#قائمة-الطلاب",
    "title": "حل المسائل",
    "section": "قائمة الطلاب",
    "text": "قائمة الطلاب\nمن القائمة السابقة تريد تحصيل التالي:\n\nهل الطالب “لؤي” في القائمة؟\nكم عدد الطلاب؟\nاسرد الفائمة\n\n\nprint(\"لؤي\" in students)\nprint(len(students))\nfor s in students:\n    print(\"Student:\", s)\n\nTrue\n5\nStudent: عمرو\nStudent: لؤي\nStudent: محمد\nStudent: علي\nStudent: فصيل",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#أضف-طالبا-جديدا",
    "href": "chapters/05_sequences/solutions.html#أضف-طالبا-جديدا",
    "title": "حل المسائل",
    "section": "أضف طالبًا جديدًا",
    "text": "أضف طالبًا جديدًا\nأضف طالبًا جديدًا إلى القائمة، وهو: \"زياد\".\n\nstudents.append(\"زياد\")\n\nأو\nstudents = students + [\"زياد\"]",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#بالإشارة",
    "href": "chapters/05_sequences/solutions.html#بالإشارة",
    "title": "حل المسائل",
    "section": "بالإشارة",
    "text": "بالإشارة\n\nمن هو أول طالب؟\nمن هو آخر طالب؟\nمن هو الطالب الذي في المنتصف؟\n\n\nprint(students[0])\nprint(students[-1])\nprint(students[len(students) // 2])\n\nعمرو\nزياد\nعلي",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#بالقطعة",
    "href": "chapters/05_sequences/solutions.html#بالقطعة",
    "title": "حل المسائل",
    "section": "بالقطعة",
    "text": "بالقطعة\n\nمن هم الطلاب باستثناء الأول والأخير؟\nمن هم الطلاب الثلاثة من النهاية\nمن هم الطلاب الذين في موضع فردي؟\nمن هم الطلاب الذين في موضع زوجي؟\n\n\nprint(students[1:-1])\nprint(students[:-3])\nprint(students[::2])\nprint(students[1::2])\n\n['لؤي', 'محمد', 'علي', 'فصيل']\n['عمرو', 'لؤي', 'محمد']\n['عمرو', 'محمد', 'فصيل']\n['لؤي', 'علي', 'زياد']",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/solutions.html#متوسط-المبيعات-اليومية",
    "title": "حل المسائل",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\n\nلديك قائمة بالمبيعات اليومية.\n\n\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\n\nوتريد أن تحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الإجراء len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الإجراء sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الإجراء statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري\n\n\nimport statistics\n\nprint(len(daily_sales))\nfor i in range(0, len(daily_sales), 7):\n    print(\"Week\", i//7+1)\n    print(\"Sales:\", sum(daily_sales[i:i+7]))\n    print(\"Mean:\", round(statistics.mean(daily_sales[i:i+7]), 2))\n    print(\"Std:\",  round(statistics.stdev(daily_sales[i:i+7]), 2))\n    print()\n\n28\nWeek 1\nSales: 84\nMean: 12\nStd: 2.08\n\nWeek 2\nSales: 86\nMean: 12.29\nStd: 3.5\n\nWeek 3\nSales: 85\nMean: 12.14\nStd: 3.53\n\nWeek 4\nSales: 101\nMean: 14.43\nStd: 4.12",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#سلة-مشتريات",
    "href": "chapters/05_sequences/solutions.html#سلة-مشتريات",
    "title": "حل المسائل",
    "section": "سلة مشتريات",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها:\n\nfruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\n\nاحسب حاصل مشتريات كل سلة وفق قائمة الأسعار:\n\nbasket1 = [\"apple\", \"apple\", \"apple\"]\nbasket2 = [\"banana\", \"apple\"]\n\nللسلة الواحدة نكتب هكذا\n\ntotal = 0\nfor item in basket1:\n    total += prices[fruits.index(item)]\nprint(total)\n\n4.5\n\n\nلجميع السلال يمكن أن نضيف حلقة أخرى:\n\ntotals = []\nfor basket in [basket1, basket2]:\n    total = 0\n    for item in basket:\n        total += prices[fruits.index(item)]\n    totals.append(total)\nprint(totals)\n\n[4.5, 3.5]\n\n\nونستطيع أن نجمع المجموعات كلها:\n\nprint(sum(totals))\n\n8.0\n\n\nأو نكتبها التعبير المختصر:\n\nprint(sum([sum(prices[fruits.index(item)] for item in basket) for basket in [basket1, basket2]]))\n\n8.0",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/solutions.html#ضرب-متجهين",
    "href": "chapters/05_sequences/solutions.html#ضرب-متجهين",
    "title": "حل المسائل",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\nيوصف ضرب المتجهين بالصيغة:\n\\[\n\\vec{u} \\cdot \\vec{v} = \\sum_{i=1}^{n} u_i v_i\n\\]\nأي أن كل عنصر من المتجه الأول يضرب في العنصر المناظر له في المتجه الثاني، ويُجْمَعُ ناتج ذلك كله.\n\nu = (1, 2, 3)\nv = (4, 5, 6)\n\nفهذا التوكيد الأول بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{v} &= [4, 5, 6] \\\\\n\\vec{u} \\cdot \\vec{v} &= (1)(4) + (2)(5) + (3)(6) \\\\\n                     &= 4 + 10 + 18 \\\\\n                     &= 32\n\\end{align*}\n\\]\nوهذا التوكيد الثاني بالصيغة الرياضية:\n\\[\n\\begin{align*}\n\\vec{u} &= [1, 2, 3] \\\\\n\\vec{u} \\cdot \\vec{u} &= (1)(1) + (2)(2) + (3)(3) \\\\\n                     &= 1 + 4 + 9 \\\\\n                     &= 14\n\\end{align*}\n\\]\nنضم العناصر المتقابلة من المتجهين ونجمع حاصل ضربهما:\n\nresult = 0\nfor a, b in zip(u, v):\n    result += a * b\nprint(result)\n\n32\n\n\n\nresult = 0\nfor a, b in zip(u, u):\n    result += a * b\nprint(result)\n\n14",
    "crumbs": [
      "باب الجمع المرتب",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html",
    "href": "chapters/06_mapping/a1_set.html",
    "title": "4  المجموعة",
    "section": "",
    "text": "التحقق السريع\nوراجع خريطة المجموعات: شكل A.1\nالمجموعة (set) هي جمع متغير من عناصر مرقَّمة فريدة بلا ترتيب.\nأو بالقوسين المتعرجين {} أو بالإجراء المُنشئ set() على النحو التالي:\nتقبل المجموعة -لكونها من نوع الجمع (Collection)- العمليات التالية:\nوباعتبارها مجموعة متغيرة (MutableSet)، فإنها تقبل الإجراءات التالية:\nولا يشترط تجانس العناصر؛ بل يجوز أن تكون أنواعها مختلفة:\nونرى عمليات المجموعة عليها: العد، والعضوية والتكرار:\nوكون المجموعة غير مرتبة، فإنها لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تقبل الإشارة (xs[i]) أو التقطيع (xs[i:j]) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:\nعرفنا أن المجموعة تقبل إجراء العضوية x in s، ولكن ثمة خصوصية لهذا الإجراء في المجموعة. وهذه الخصوصية تكمن في سرعة هذا الإجراء في المجموعة مقارنة بسرعة عمله في المجموعة المرتبة.\nفهذه المقارنة تكون بالمجموعة {}:\nblack_set = {\"192.168.1.1\", \"10.0.0.5\", \"172.16.0.2\"}\nip = \"10.0.0.5\"\nif ip in black_set:\n    print(\"Access Denied\")\n\nAccess Denied\nوتكون كذلك في القائمة []:\nblack_list = [\"192.168.1.1\", \"10.0.0.5\", \"172.16.0.2\"]\nip = \"10.0.0.5\"\nif ip in black_list:\n    print(\"Access Denied\")\n\nAccess Denied\nلكن الفرق هو تفاصيل هذه العملية، إذ تختلف الكيفية خلف الكواليس. ولن يكون الفرق في السرعة واضحًا إلا حين تكون المجموعة كبيرة جدًّا.\nوهذا يدخل في دراسة الخوارزميات وهيكلة البيانات. فإن أردت مزيد تفصيل فراجع هذه المادة: W3Schools DSA Hash Sets.",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#التحقق-السريع",
    "href": "chapters/06_mapping/a1_set.html#التحقق-السريع",
    "title": "4  المجموعة",
    "section": "",
    "text": "وذلك أننا في القائمة نحتاج أن نمر على العناصر واحدًا تلو الآخر، حتى نجد العنصر أو لا نجده\nأما في المجموعة، فإن القيمة يتم تجزئتها (hash) حتى يُعرف رقم العنصر في المجموعة مباشرة من غير المرور على عناصرها. فعملية التجزئة هذه تعطينا العنوان بشكل رياضي.",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#منطق-المجموعة-الرياضية",
    "href": "chapters/06_mapping/a1_set.html#منطق-المجموعة-الرياضية",
    "title": "4  المجموعة",
    "section": "منطق المجموعة الرياضية",
    "text": "منطق المجموعة الرياضية\nمما تتميز به المجموعة عن بقية أنواع الجمع: قبولها المنطق الرياضي على النحو التالي:\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل).\n\nوهذه القطعة مثال لجميع هذه العمليات الرياضية:\n\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#العمليات-على-المجموعات",
    "href": "chapters/06_mapping/a1_set.html#العمليات-على-المجموعات",
    "title": "4  المجموعة",
    "section": "العمليات على المجموعات",
    "text": "العمليات على المجموعات\n\nالاتحاد\n\n\n\nاتحاد مجموعتين\n\n\n\nset.union(set1, set2)\n\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n\n\n\nالتقاطع\n\n\n\nتقاطع مجموعتين\n\n\n\nset.intersection(set1, set2)\n\n{4, 5}\n\n\n\n\nالفرق\n\n\n\nالفرق\n\n\n\nset.difference(set1, set2)\n\n{1, 2, 3}\n\n\n\nset.difference(set2, set1)\n\n{6, 7, 8}\n\n\n\n\nالفرق التماثلي\n\n\n\nالفرق التماثلي\n\n\n\nset.symmetric_difference(set1, set2)\n\n{1, 2, 3, 6, 7, 8}\n\n\nملاحظة: لكل من الإجراءات السابقة علامة تمثله كما هو موضَّح في الجدول. إلا أن استعمال اسم الإجراء يقبل أي نوع من المتكررات (Iterables) ولا تقتصر على نوع المجموعة فقط (set):\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nالاتحاد\nset1 | set2\nset1.union(set2)\n\n\nالتقاطع\nset1 & set2\nset1.intersection(set2)\n\n\nالفرق\nset1 - set2\nset1.difference(set2)\n\n\nالفرق التماثلي\nset1 ^ set2\nset1.symmetric_difference(set2)",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a1_set.html#العلاقات-بين-المجموعات",
    "href": "chapters/06_mapping/a1_set.html#العلاقات-بين-المجموعات",
    "title": "4  المجموعة",
    "section": "العلاقات بين المجموعات",
    "text": "العلاقات بين المجموعات\n\nالجزئية والشمول\nوكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nتحقق الجزئية (جزء من)\nset1 &lt;= set2\nset1.issubset(set2)\n\n\nتحقق الشمول (يشمل)\nset1 &gt;= set2\nset1.issuperset(set2)\n\n\nتحقق الانفصال (عدم التقاطع)\nlen(set1 & set2) == 0\nset1.isdisjoint(set2)\n\n\n\n\n\n\nالجزئية والشمول\n\n\n\nA = {1, 2, 3}\nB = {1, 2, 3, 4, 5, 6}\n\nوهذا مثال لاستعمالها كما في الجدول:\n\nassert A.issubset(B)\nassert B.issuperset(A)\n\n\n\nالانفصال\nوأما الانفصال، فهو عدم وجود أدنى تقاطع بين المجموعتين:\n\nC = {'Apple', 'Banana'}\nassert C.isdisjoint(A)\nassert C.isdisjoint(B)",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>المجموعة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html",
    "href": "chapters/06_mapping/a2_dict.html",
    "title": "5  القاموس",
    "section": "",
    "text": "استعمالات القاموس\nوراجع خريطة المجموعات: شكل A.1\nالقاموس (dict) جمع متغير مرتب، العنصر فيه مرقَّم فريد مقابل لقيمة.\nينشأ القاموس بالإجراء المنشئ dict() أو بالقوسين المتعرجين {} وذلك على النحو التالي:\nولاحظ أن القاموس عبارة عن مجموعة اقترانات أو مقابلات:\nيستعمل القاموس في كثير من السياقات في البرمجة، وهو من أهم هياكل البيانات.",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#استعمالات-القاموس",
    "href": "chapters/06_mapping/a2_dict.html#استعمالات-القاموس",
    "title": "5  القاموس",
    "section": "",
    "text": "الكلمة ومعناها\nالقاموس بالمعنى الذي يشير إليه اللفظ. نفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:\n\nenglish_to_arabic = {\n    'apple': 'تفاحة',\n    'banana': 'موزة',\n    'orange': 'برتقالة',\n}\n\n\n\nربط الأسماء بالأرقام\nمثلاً: دليل أرقام الهواتف هو قاموس:\n\nname_to_phone = {\n    'Adam': '966xxxxxxxxx',\n    'Mohammed': '966xxxxxxxxx',\n}\n\n\n\nدليل أسماء النطاقات\nوكذلك دليل أسماء النطاقات (DNS: Domain Name System) على شبكة الانرتنت هو قاموس:\n\ndomain_to_ip = {\n    'google.com': '172.217.14.206',\n    'wikipedia.org': '103.86.96.10',\n}\n\n\n\nاختصار الروابط الطويلة\nمن استعمالات القاموس: اختصار الروابط الطويلة في روابط قصيرة.\n\nshort_to_full = {\n    'google': 'https://www.google.com',\n    'python': 'https://www.python.org',\n    'wiki': 'https://www.wikipedia.org',\n}\n\n\n\nالكلمات المختصرة\nأو الاختصارات إلى الكلمة التامة:\n\nabb_to_full = {\n    'ASAP': 'As Soon As Possible',\n    'BRB': 'Be Right Back',\n    'DIY': 'Do It Yourself',\n    'EDA': 'Exploratory Data Analysis',\n    'FYI': 'For Your Information',\n    'SAR': 'Saudi Riyal',\n}",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#القاموس-dict",
    "href": "chapters/06_mapping/a2_dict.html#القاموس-dict",
    "title": "5  القاموس",
    "section": "القاموس (dict)",
    "text": "القاموس (dict)\nومن حيث كون القاموس من نوع الجمع (Collection)، فإنه يقبل الإجراءات ثلاثة:\n\nالعضوية: x not in d\nالعد: len(d)\nالتكرار: for x in d\n\nويقبل القاموس لكونه مقابلة (Mapping) الإجراءات التالية:\n\nالإشارة مفتاح: dict[key]\nالإشارة بمفتاح مع الرجوع بقيمة ابتدائية إن لم يُعثَر عليه: dict.get(key[, default])\n\nولكونه مقابلة متغيرة (MutableMapping)، فإنه يقبل الإجراءات التالية:\n\nالتعديل بمفتاح: dict[key] = value\nالحذف بمفتاح: del dict[key]\nنزع بمفتاح وإرجاع القيمة: x = dict.pop(key)\nالتحديث: dict.update(mapping)\n\nراجع خريطة الجموع: شكل A.1.\nوهذه كذلك، كلها قابلة للتجزئة، ولا يشترط أن تكون متجانسة (من نفس النوع)، كما يلي:\n\ndata = {\n    # مقابلة نص بعدد\n    'key1': 100,\n\n    # مقابلة عدد بنص\n    20: 'value2',\n\n    # مقابلة نص بقائمة\n    'c': [10, 20, 30, True],\n\n    # مقابلة صف من أعداد بنص\n    (1, 2): 'value3',\n\n    # مقابلة صف من نصوص بنص\n    ('a', 'b', 'c'): 'value4',\n}\n\nassert len(data) == 5\ndel data['key1']\nassert 'key1' not in data\n\nونحصل عليها بالإشارة بأحد المفاتيح:\n\nprint(data[20])\nprint(data['c'])\nprint(data[(1, 2)])\nprint(data[('a', 'b', 'c')])\n\nvalue2\n[10, 20, 30, True]\nvalue3\nvalue4",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#التضمين",
    "href": "chapters/06_mapping/a2_dict.html#التضمين",
    "title": "5  القاموس",
    "section": "التضمين",
    "text": "التضمين\nيجوز جعل القيمة نفسها قاموسًا. ومثال ذلك حفظ اختيارات المستخدم هكذا:\n\nuser = {\n    'name': 'Adam',\n    'language': 'Arabic',\n    'phone': '966xxxxxxxxx',\n    'last_updated': '2021-09-01',\n    'age': 25,\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\nوللوصول إلى قيمة مضمَّنة، نستعمل الإشارة بالمفتاح مرتين، هكذا:\n\nuser['notifications']['push']\n\nTrue",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#التكرار",
    "href": "chapters/06_mapping/a2_dict.html#التكرار",
    "title": "5  القاموس",
    "section": "التكرار",
    "text": "التكرار\nويجوز التكرار بثلاثة طرق:\n\nكر المفاتيح: for key in d.keys()\nكر القيم: for value in d.values()\nكر العناصر: for key, value in d.items() (ينتج عنها أزواج (2-tuple) من الفاتيح والقيم)\n\nمثال:\n\nd = {\n    'A': 'Salam',\n    'B': 'Hello',\n    'C': 'Hi',\n}\nfor value in d.values():\n    print(value)\n\nSalam\nHello\nHi",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#عكس-القاموس",
    "href": "chapters/06_mapping/a2_dict.html#عكس-القاموس",
    "title": "5  القاموس",
    "section": "عكس القاموس",
    "text": "عكس القاموس\nإذا أردت عكس القاموس بحيث يصير المفتاح مكان القيمة والقيمة مكان المفتاح، فبهذه الطريقة:\n\nd = {\n    'ASAP': 'As soon as possible',\n    'TBD': 'To be determined',\n    'IDK': 'I don\\'t know',\n}\ninverse = dict()\nfor k, v in d.items():\n    inverse[v] = k\ninverse\n\n{'As soon as possible': 'ASAP',\n 'To be determined': 'TBD',\n \"I don't know\": 'IDK'}\n\n\nأو بالجملة المختصرة:\n\ninverse = {v: k for k, v in d.items()}\ninverse\n\n{'As soon as possible': 'ASAP',\n 'To be determined': 'TBD',\n \"I don't know\": 'IDK'}",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a2_dict.html#إنشاء-قاموس-من-سلسلتين",
    "href": "chapters/06_mapping/a2_dict.html#إنشاء-قاموس-من-سلسلتين",
    "title": "5  القاموس",
    "section": "إنشاء قاموس من سلسلتين",
    "text": "إنشاء قاموس من سلسلتين\nويتحصل القاموس من سلسلتين باستعمال الإجراء zip()، كما يلي:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawood']\nmarks    = [     90,      80,      75,       85]\ndata = dict(zip(students, marks))\ndata\n\n{'Ahmad': 90, 'Belal': 80, 'Camal': 75, 'Dawood': 85}",
    "crumbs": [
      "باب الجمع المرقَّم",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_apps.html",
    "href": "chapters/06_mapping/b_apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "الأجزاء المنتمية إلى الكل\nأو الاختصارات إلى الكلمة التامة:\nanimal_class = {\n    \"Dog\": \"Mammalia\",\n    \"Cat\": \"Mammalia\",\n    \"Elephant\": \"Mammalia\",\n    \"Snake\": \"Reptilia\",\n    \"Lizard\": \"Reptilia\",\n    \"Frog\": \"Amphibia\",\n}\nنريد عكس هذه القائمة أيضًا بحيث نستطيع أن نعرف من الصنف كل الحيوانات المتنمية إليه.\nنأتي على جميع المفاتيح في القاموس الأول ونضيفها بحسب القيمة التي تقابلها:\nclass_animal = {}\nfor animal, clazz in animal_class.items():\n    if clazz not in class_animal:\n        class_animal[clazz] = []\n    class_animal[clazz].append(animal)\nclass_animal\n\n{'Mammalia': ['Dog', 'Cat', 'Elephant'],\n 'Reptilia': ['Snake', 'Lizard'],\n 'Amphibia': ['Frog']}\nلاحظ استعمال اسم clazz بدل class لأن كلمة class أصلية في لغة بايثون فلا يجوز استعمالها كمتغير.",
    "crumbs": [
      "باب الجمع المرقَّم",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_apps.html#سلة-المشتريات",
    "href": "chapters/06_mapping/b_apps.html#سلة-المشتريات",
    "title": "تطبيقات",
    "section": "سلة المشتريات",
    "text": "سلة المشتريات\nنفترض أن لدينا سلة تحتوي على مشتريات العميل (basket)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس prices بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).\n\nprices = {\n    'apple': 15.25,\n    'banana': 10.50,\n    'orange': 5.75,\n    'cantaloupe': 40.00\n}\n\nيجوز تحديث الأسعار هكذا:\n\nprices['banana'] = 12\nprices['orange'] = 15\n\nأو تحديثها بالإجراء update():\n\nprices.update({'banana': 12, 'orange': 15})\nprices\n\n{'apple': 15.25, 'banana': 12, 'orange': 15, 'cantaloupe': 40.0}\n\n\nوالآن نفترض أن لدينا قائمة بالفواكه التي يريدها العميل:\n\nbasket = ['apple', 'apple', 'banana', 'orange', 'banana']\n\nنحسب سعر كل فاكهة في السلة بناءً على الأسعار الموجودة في القاموس:\n\ntotal = 0\n\nfor fruit in basket:\n    total += prices[fruit]\n\nprint(total)\n\n69.5\n\n\nأو تستطيع أن تعدها أولاً ثم تضربها بالسعر:\n\ncounts = dict()\nfor fruit in set(basket):\n    counts[fruit] = basket.count(fruit)\ncounts\n\n{'banana': 2, 'apple': 2, 'orange': 1}\n\n\nثم تضربها بالسعر:\n\ntotal = sum(counts[fruit] * prices[fruit] for fruit in counts)\ntotal\n\n69.5",
    "crumbs": [
      "باب الجمع المرقَّم",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_apps.html#استعمال-الإنشاء-المختصر",
    "href": "chapters/06_mapping/b_apps.html#استعمال-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "استعمال الإنشاء المختصر",
    "text": "استعمال الإنشاء المختصر\nتقدم معنا الكلام عن الإنشاء المختصر. وسنستعرضه الآن مع القاموس.\nهنا مثال لقاموس من الفواكه، نريد ترشيح ما قيمته أقل من 20:\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nfiltered_menu = {k: v for k, v in menu.items() if v &lt; 20}\nfiltered_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5}\n\n\nوهذا مثال أكثر تعقيدًا. نطبق خصم 20% فقط على العناصر التي يكون سعرها أعلى من المتوسط، مع الحفاظ على بقية الأسعار كما هي. لاحظ أن التعبير هنا هو تعيين شرطي: value * (1 - discount) if value &gt; avg_price else value وليس هو قطعة الترشيح (if)؛ إذ تلك تأتي في نهاية الجملة، بعد قطعة التكرار (for).\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\navg_price = sum(menu.values()) / len(menu)\ndiscount = 0.20\n\ndiscounted_menu = {\n    k: v * (1 - discount) if v &gt; avg_price else v\n    for k, v in menu.items()\n}\ndiscounted_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5, 'cantaloupe': 32.0}",
    "crumbs": [
      "باب الجمع المرقَّم",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html",
    "href": "chapters/06_mapping/c_problems.html",
    "title": "مسائل",
    "section": "",
    "text": "قاموس داخل قاموس\nإذا كان لديك قاموس متداخل كالتالي:\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\nالمطلوب أن تسحب من تفضيلات المستخدم المتغيرات التالية:",
    "crumbs": [
      "باب الجمع المرقَّم",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#قاموس-داخل-قاموس",
    "href": "chapters/06_mapping/c_problems.html#قاموس-داخل-قاموس",
    "title": "مسائل",
    "section": "",
    "text": "theme\nsms\nآخر عنصر في: emails",
    "crumbs": [
      "باب الجمع المرقَّم",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html",
    "href": "chapters/07_strings/a1_strings.html",
    "title": "6  النص",
    "section": "",
    "text": "النص الطبيعي\nالنص (str) صف من الأحرف. وهو تسلسل ثابت من أرقام الترميز العالمي (Unicode) التي هي رموز تتبع ترميزًا عالميًا يحوي جميع أحرف اللغات بالإضافة إلى علامات الترقيم والرسوم (مثل: 💡🔍📐) ونحوها.\nالنص الطبيعي (الحر أو البشري) هو ما لا يتبع هيكلاً أو قالبًا يحكم طريقة كتابته؛ وهو يطول ويقصر من الحرف الواحد إلى مجموعة الأحرف إلى الكلمة إلى الجملة وإلى أكبر من ذلك نحو:\nوأوجه معالجة النصوص الحرة كثيرة منها: الفهرسة والبحث والاستبدال والعد والتصنيف والترتيب والقولبة …إلخ.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "href": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "title": "6  النص",
    "section": "",
    "text": "محادثات وسائل التواصل الاجتماعي\nرسائل البريد الإلكتروني\nمقالات\nكتب\nموسوعات\nصفحات الشبكة\nمواقع الشبكة",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "href": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "title": "6  النص",
    "section": "النص المُقَوْلَب",
    "text": "النص المُقَوْلَب\nالنص المقولَب الذي يأخذ شكلاً محددًا؛ وله صيغ متعددة يُنشئ الناس منها قوالب للنص لتمثل مجموعات أو ارتباطات من البيانات، كالجداول ونحوها.\nوصيغ القولبة كثيرة من أشهرها: XML, YAML, JSON, CSV.\nمثال لقالب بصيغة YAML:\n---\nName: Adam\nAge: 25\nCity: Riyadh\nمثال لقالب بصيغة JSON:\n{\n  \"Name\": \"Adam\",\n  \"Age\": 25,\n  \"City\": \"Riyadh\"\n}\nوهذا مثال لقالب بصيغة XML:\n&lt;person&gt;\n  &lt;name&gt;Adam&lt;/name&gt;\n  &lt;age&gt;25&lt;/age&gt;\n  &lt;city&gt;Riyadh&lt;/city&gt;\n&lt;/person&gt;\nوالصيغة التي تستعمل كثيرًا لتمثيل الجداول (صفوف) هي صيغة CSV. فكل سطرٍ هو صفٌّ في الجدول، وأوَّلُ سطرٍ هو رأس الجدول عادةً. وذلك على النحو التالي:\nName,Age,City\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\nجرب أن تُنشئ ملفًّا نصيًّا وتكتب فيه ذلك وتحفظه بصيغة csv ثم سترى أنه يمكنك فتحه بمحرر جداول (:مثل إكسل - Excel).\nوستأتي في فصل حفظ البيانات واسترجاعها إن شاء الله.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "href": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "title": "6  النص",
    "section": "إنشاء النص",
    "text": "إنشاء النص\nجملة إنشاء النص في بايثون تكون كالتالي:\n\nبعلامة اقتباس مفردة: 'السلام عليكم!'\nأو بعلامة اقتباس مزدوجة: \"السلام عليكم!\" وليس بينهما فرق.\nأو بعلامة اقتاس مكررة ثلاثة مرات: \"\"\"السلام عليكم!\"\"\" للنص الجاري على أكثر من سطر.\n\nعلى سبيل المثال:\n\nname = 'Adam'\naddress = \"Makkah, Saudi Arabia\"\n\nتأمل إنشاء هذا النص الذي يبتدئ في السطر الأول ويمتد لأربعة أسطر:\n\nmessage = \"\"\"السلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\"\"\"\nprint(message)\n\nالسلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\n\n\n\nقراءة الملفات النصية\nوكثيرًا ما يكون وجود النص في البرنامج ناتجًا عن قراءة ملف نصي بالإجراء open() وذلك بإضافة الحرف r ميشرًا إلى أن غرض الفتح للقراءة (ويجب أن يكون الملف موجودًا إلى جانب البرنامج - أي: في نفس المجلد الذي يوجد فيه البرنامج):\nfile = open('my_file.txt', 'r')\nmessage = file.read()\nfile.close()\nprint(message)\nوسيأتي مزيد بيان في باب الملفات.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "href": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "title": "6  النص",
    "section": "الإشارة لجزء من النص",
    "text": "الإشارة لجزء من النص\nولكون النص تسلسلاً ثابتًا فإنه يقبل جميع عمليات التسلسل السابق ذكرها (انظر باب المجموعة المرتبة).\n\ns = 'Arabian'\n\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\n 0   1   2   3   4   5   6   7\n +---+---+---+---+---+---+---+\n | A | r | a | b | i | a | n |\n +---+---+---+---+---+---+---+\n-7  -6  -5  -4  -3  -2  -1\n\nجرب\n\ns[1:5]\ns[1:5:2]\ns[::2]\ns[::-1]\n\nلاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:\n\ns = ('A', 'r', 'a', 'b', 'i', 'a', 'n')\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\nلكن الفرق أن النص نوعٌ له إجراءات / عمليات خاصة تتعلق بالنصوص.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "href": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "title": "6  النص",
    "section": "النص ثابت لا يقبل التغير",
    "text": "النص ثابت لا يقبل التغير\nفالنص تسلسل يشبه الصف في كوْنه ثابتًا (أي لا يقبل تعديل عنصر أو إضافته أو حذفه). فلو حاولت تغيير موضعٍ s[i] في النص أو قطعة s[i:j] فإنك ستواجه خطأ:\n\ns = 'Arabian'\ns[0] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 s = 'Arabian'\n----&gt; 2 s[0] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nلكننا لتعديل النص في الواقع نعيِّنُ إلى نفس المتغير نصًّا جديدًا منه:\n\ns = 'Arabian'\ns = 'a' + s[1:]\nprint(s)\n\narabian\n\n\nلاحظ أننا أسندنا النص الجديد إلى المتغير s، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "href": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "title": "6  النص",
    "section": "العمليات الخاصة بالنصوص",
    "text": "العمليات الخاصة بالنصوص\n\nالاستبدال\nلاستبدال جزء من النص، نستخدم فعل .replace():\n\ns = 'Arabian'\ns = s.replace('ian', 'y')\nprint(s)\n\nAraby\n\n\nوللإزالة من البداية والنهاية: .removeprefix() و .removesuffx()\n\nprint('Arabian'.removeprefix('Arab'))\nprint('Arabian'.removesuffix('ian'))\n\nian\nArab\n\n\n\n\nإزالة المسافات\nكما لدينا علميات .strip() لإزالة المسافات البيضاء من بداية ونهاية النص.\n\nassert '  Arabian  '.strip() == 'Arabian'\n\n\n\nالبحث والمطابقة\nوكذلك لدينا عمليات البحث:\n\nالتحقق من البدء والنهاية وما بينهما: .startswith(prefix) و .endswith(suffix) أو sub in string وهي أعم.\nلمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص .find()\n\n\ns = 'Arabian'\nassert s.startswith('A')\nassert not s.startswith('a')\nassert s.endswith('n')\nassert 'rabia' in s\nassert s.find('a') == 2\n\n\n\nالفصل والوصل\n\nفصل النص لقائمة بناءً على جزء فاصل: list.split(seperator)\nوصل عناصر القائمة في نص مفصول بجزء فاصل: seperator.join(list)\n\nأولاً: الفصل: مثاله قراءة سطر في ملف csv إذْ القيم مفصولة بعلامة الفاصلة ,:\n\ncsv = \"Adam,25,Riyadh\"\nassert csv.split(',') == ['Adam', '25', 'Riyadh']\n\nولقراءة الملف كاملاً نكرر:\n\nالقيم في السطر الواحد مفصولة بعلامة الفاصلة ,\nوالصفوف مفصولة بعلامة السطر الجديد \\n\n\nلذلك سنستعمل الاثنين هنا:\n\ncsv = \"\"\"name,age,city\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\"\"\"\n\ndata = []\nfor line in csv.split(sep='\\n'):\n  row = line.split(sep=',')\n  data.append(row)\nprint(data)\n\n[['name', 'age', 'city'], ['Adam', '25', 'Riyadh'], ['Belal', '30', 'Jeddah'], ['Camal', '35', 'Dammam']]\n\n\nثانيًا: الوَصل: مثاله أننا نحول القائمة إلى نص مفصول بعلامة الفاصلة , وذلك ليكون سطرًا في ملف csv:\n\ndata = ['Adam', '25', 'Riyadh']\nseperator = ','\ncsv = seperator.join(data)\nassert csv == 'Adam,25,Riyadh'\n\n\n\nعمليات إنجليزية\nوهنا عمليات خاصة بالنصوص الإنجليزية:\n\nupper() نسخة ذات حروف كبيرة.\nlower() نسخة ذات حروف صغيرة.\ncapitalize() نسخة ذات حرف أول كبير من كل كلمة.\ntitle() نسخة ذات حالة عنوان.\n\n\nname = 'Adam ibraheeM'\nprint(name.upper())\nprint(name.lower())\nprint(name.capitalize())\nprint(name.title())\n\nADAM IBRAHEEM\nadam ibraheem\nAdam ibraheem\nAdam Ibraheem\n\n\nوانظر مستندات النصوص لمعرفة كافة الإجراءات الممكنة على النصوص.\n\n\nتفسير الأرقام\nتفسير الأرقام المكتوبة نصًّا تكثر الحاجة إليه خصوصًا عند قراءة ملفات أو التعامل مع بيانات من المستخدم، إذ يكون الإدخال نصيًّا:\n\nint(x) لتحويل نص إلى عدد صحيح.\nfloat(x) لتحويل نص إلى عدد عشري.\n\nلاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:\n\nx = '20'\ny = '40'\nprint(x + y)\n\n2040\n\n\nالواجب تحويلهما إلى أعداد أولاًً:\n\nx2 = float(x)\ny2 = float(y)\nprint(x2 + y2)\n\n60.0",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "href": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "title": "6  النص",
    "section": "إخراج النص",
    "text": "إخراج النص\nنستعرض ثلاث طرق لدمج النصوص في بايثون:\n\nالأولى: تحويل الشيء إلى نص قبل دمجه مع النص، باستعمال str(x)\nالثانية: استعمال فراغات بالقوسين المعكوفين {} مع الإجراء .format() لاستبدالها.\nالثالثة: استعمال f-string بأن تضع الحرف f قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل الأقواس المعكوفة {}. وهي الطريقة التي نفضلها.\n\n\nname = \"John\"\nlvl = 300\n\ns1 = \"I am \" + name + \" and I want to reach level \" + str(lvl) # + operator\ns2 = \"I am {} and I want to reach level {}\".format(name, lvl)  # .format() method\ns3 = f\"I am {name} and I want to reach level {lvl}\"            # f-strings\nassert s1 == s2 == s3\nprint(s1)\n\nI am John and I want to reach level 300\n\n\nيقبل النص التكرار بعلامة *:\n\nprint('-' * 10)\nprint('*' * 10)\nprint('=' * 10)\n\n----------\n**********\n==========",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "href": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "title": "6  النص",
    "section": "المحاذاة والحشو",
    "text": "المحاذاة والحشو\n\nname = 'Adam'\nprint(name.ljust(15)) \nprint(name.center(15))\n\nAdam           \n      Adam     \n\n\nطريقة ممتعة لتزيين سلسلة نصية باستخدام الإجراء center:\n\nprint('*' * 20)\nprint('Adam'.center(20, \"*\"))\nprint('*' * 20)\n\n********************\n********Adam********\n********************",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "href": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "title": "6  النص",
    "section": "تنسيق الأرقام",
    "text": "تنسيق الأرقام\n\nمحاذاة الأرقام\n\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\n       100\n      1000\n     10000\n\n\nيمكننا أيضًا جعل كل من العدد n والتعبئة p متغيرات:\n\nn = 100\np = 5\nprint(f'{n:{p}}')\n\n  100\n\n\nبشكل افتراضي، يتم محاذاة الرقم إلى اليمين. يمكننا محاذاته إلى اليسار بإضافة &lt;. لاحظ الفرق بين التعبيرين أدناه:\n\nprint(f'{n:&gt;{p}}')\nprint(f'{n:&lt;{p}}')\n\n  100\n100  \n\n\n\n\nفاصل الآلاف\n\nbig_num = 10000\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n10000\n10,000\n\n\n\n\nالترميز العلمي\n\nsmall_num = 0.00001\nprint(f\"{small_num:.2e}\")\n\n1.00e-05\n\n\n\n\nالأعداد العشرية\n\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\nمثال: تنسيق الكم المالي\n\nprice_dollars = 2978.95\nprice_riyals = price_dollars * 3.75\nprint(f\"${price_dollars:,.2f} = {price_riyals:,.2f} SAR\")\n\n$2,978.95 = 11,171.06 SAR",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html",
    "href": "chapters/07_strings/a2_unicode.html",
    "title": "7  ترميز الحروف",
    "section": "",
    "text": "ترميز (Unicode)\nترميز الحروف هي عملية تعيين أرقام للأحرف الرسومية مما يسمح بتخزينها ونقلها وتحويلها باستخدام الحواسيب الرقمية.\nرموز ASCII تحتوي على 128 حرف للغة الإنجليزية وبعض علامات الترقيم. منها 95 فقط هي أحرف قابلة للطباعة أما البقية فتسمى أحرف تحكُّم (مثل حرف السطر الجديد \\n ، وحرف الرجوع لبداية السطر \\r).\nثم امتدت عن طريق رموز ANSII لتغطي أحرف إضافية (من 128 إلى 255) وهي الأحرف الاتينية للغات الأخرى.\nلنستكشف السلاسل عن طريق حزمة من المكتبة الأساسية string. الآتي الأحرف اللاتينية الكبيرة والصغيرة، وعلامات الترقيم:\nواليوم رموز Unicode تحتوي على أكثر من مليون حرف لتغطية لغات العالم كافة: اللاتينية، اليونانية، السيريلية، الأرمنية، العبرية، العربية، السريانية، الثانا، الديفاناغارية، البنغالية، الجورموخية، الأورية، التاميلية، التيلوغوية، الكانادية، المالايالامية، السنهالية، التايلاندية، اللاوية، التبتية، الميانمارية، الجورجية، الهانغول، الإثيوبية، الشيروكية، الرموز الكندية الأصلية، الخميرية، المنغولية، الهان (الأيدوغراف الياباني، الصيني، الكوري)، الهيراغانا، الكاتاكانا، واليي. المصدر. وما يزال أول 128 حرف منها متطابق مع رموز ASCII.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "href": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "title": "7  ترميز الحروف",
    "section": "",
    "text": "مثال\nماذا يحصل لو كتبنا حروف عربية ثم حاولنا حفظ الملف بترميز ASCII ولم نحفظه بترميز Unicode؟\n\n\n\nبرنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات\n\n\nالخطأ يقول: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "href": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "title": "7  ترميز الحروف",
    "section": "كيف يتم تمثيل النصوص في بايثون؟",
    "text": "كيف يتم تمثيل النصوص في بايثون؟\nتمثيل النصوص في بايثون يكون عن طريق النوع str؛ يُعرَّف بكتابة سلسلة من الأحرف لكن في الواقع تتحول إلى سلسلة من رموز Unicode (أي: أرقام). هذا يعني أنها قد تكون سلسلة رموز لاتينية أو عربية أو صينية أو غير ذلك مما تحويه رموز Unicode.\nالإجراء المبني ord() تقوم بتحويل الحرف إلى رقم الرمز. بينما chr() تعكس ذلك (من الرمز إلى الحرف).\nعلى النقيض من سي وجافا؛ لا يوجد نوع خاص بالحرف الواحد (char) في بايثون.\n\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nماذا عن الحروف العربية؟ أين تقع في أرقام ترميز Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nلمعرفة أرقام الحروف في نصٍّ ما؛ نستعمل التكرار هكذا:\n\ns = \"'Arabian'\"\ncodes = []\nfor c in s:\n    codes.append(ord(c))\nprint(codes)\n\n[39, 65, 114, 97, 98, 105, 97, 110, 39]\n\n\n\ns = 'السَّلَامُ عَلَيْكُمْ'\ncodes = []\nfor c in s:\n    codes.append(ord(c))\nprint(codes)\n\n[1575, 1604, 1587, 1614, 1617, 1604, 1614, 1575, 1605, 1615, 32, 1593, 1614, 1604, 1614, 1610, 1618, 1603, 1615, 1605, 1618]\n\n\nفهذه هي الحروف في الواقع، إلا أننا نتعامل مع شيء مجرَّد في لغات البرمجة العالية غالبًا ما يسمى str.\nراجع ويكيبيديا: النص العربي في Unicode لمزيد من التفاصيل.\n\nالأحرف البيضاء\nالأحرف في الأجهزة الرقمية على نوعين:\n\nأحرف طباعة: مثلاً: الأحرف اللاتينية والأرقام وعلامات الترقيم\nأحرف تحكم: مخفيَّة؛ والغرض منها التحكم بمعالج هذا النص\n\nلعرض الأحرف القابلة للطباعة في محارف آسكي (ASCII)، لدينا المتغير printable من مكتبة string:\n\nimport string\nstring.printable\n\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n\n\nكانت أحرف التحكُّم تستخدم لرن جرس الآلة الطابعة ، والتحكم بها ، لكن اليوم الذي يُستخدم منها غالبًا هو الأحرف البيضاء (Whitespace Characters) ويشمل ذلك الأحرف التالية:\n\nspace: \\s ويمثل المسافة التي بين الكلمات\ntab: \\t ويمثل المسافة التي بين أعمدة الجداول\nlinefeed: \\n تعليمة سطر جديد\nreturn: \\r تعليمة العودة لبداية السطر الجديد\nformfeed: \\f تعليمة الصفحة الجديدة\nvertical tab: \\v تعليمة العمود الجديد\nbackspace: \\b تعليمة عودة المؤشر بمقدار حرف واحد للكتابة فوق الحرف السابق\n\nأما الثلاثة الأخيرة فقد كانت تستخدم فيما مضى، لكن اليوم المستخدم هو الأربعة الأولى فقط. ويجدر بالذكر أن ملفات نصوص نظام ويندوز تستعمل \\r\\n للانتقال لسطر جديد بينما تستعمل الأنظمة الأخرى \\n فقط.\nتذكر أن بايثون تعتمد على space و tab للمسافة البادئة للسطر (indentation)، لتحديد نطاقات القطع البرمجية بحسب المحاذاة العمودية.\n\nimport string\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\nيهمنا هنا الأحرف البيضاء لأنها تظهر في النصوص وقد تكون مزعجة عند معالجتها. لنلقي نظرة على ثلاثة من الأحرف البيضاء: المسافة (space)، التبويب (tab)، وتعليمة السطر الجديد (linefeed).\n\n# Tab character: \"\\t\"\nprint('A\\tB')\n\nA   B\n\n\n\n# Space character: \" \"\nprint('   A            B   ')\n\n   A            B   \n\n\n\n# Newline character: '\\n'\nprint('A\\nB')\n\nA\nB\n\n\nلاحظ أن طول السلسلة النصية هو عدد الأحرف في السلسلة، سواء كانت قابلة للطباعة (printable) أو أحرف بيضاء (whitespace).\n\nassert len('A B') == 3\nassert len('A\\tB') == 3\nassert len('A\\nB') == 3\n\n\n\nالأطراف الزائدة\nلاحظ أن هذا الإجراء سيزيل الأحرف البيضاء من بداية ونهاية السلسلة النصية، ولكن ليس الأحرف البيضاء في منتصف السلسلة\nقبل:\n\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\nبعد:\n\nprint(text.strip())\n\nhello    world\n\n\n\n\nتجزئة النص\nانظر: Splitlines\n\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\nإذا تركنا القطعة البرمجية كما هي في السطر من غير print فإن ذلك يعرض السلسلة النصية كما هي (بما في ذلك أحرف المسافات البيضاء)\n\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\nأما إذا وضعنا print فإنه يطبع الأحرف المرئية ، وينسِّقُ المظهر بناءً على أحرف التحكُّم المخفية:\n\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\nإذا لم نحدد محدد الفاصل فإن الفاصل الافتراضي هو المسافة.\n\nprint(\"Hello, world\".split())\n\n['Hello,', 'world']\n\n\nهنا نحدد الفاصل أنه الحرف \"l\":\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\nلإزالة الأحرف البيضاء جميعها؛ نستعمل التكرار هكذا:\n\ntext = '\\t hello    world \\n\\n\\n'\nsp = text.split()\nprint('split:', sp)\nclean = ' '.join(sp)\nprint('clean:', clean)\n\nsplit: ['hello', 'world']\nclean: hello world\n\n\nالفصل في الداخل ينتج قائمة من النصوص، بعضها فارغ لوجود الأحرف البيضاء المتتالية، فلا تتضمن في القائمة الناتجة.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#الطباعة",
    "href": "chapters/07_strings/a2_unicode.html#الطباعة",
    "title": "7  ترميز الحروف",
    "section": "الطباعة",
    "text": "الطباعة\n\nحروف التحكم بآلة الطباعة\nيسمّى الحرف \\r بالعودة للبداية لأنه يعني فعل يقوم بإرجاع المؤشر إلى بداية السطر.\nكانت آلة الطباعة قديمًا يتحرك رأس الطباعة فيها بعد طباعة كل حرف. ثم عندما ينتهي السطر، يجب على الشخص أن يقوم بعمليتين:\n\nالضغط على المفتاح الذي يرفع الورقة بمقدار سطر (ويرمز له بالحرف \\r)\nالضغط على المفتاح الذي يرجع رأس الطباعة لبداية السطر (ويرمز له بالحرف \\n)\n\nوهما مستخدمان اليوم فيما يُعرض على الشاشة.\nففعل print في الحقيقة يضع سطرًا جديدًا (حرف \\n) في الوضع الافتراضي. فإن أردنا ألا يضعه، فنحدد العامل end الذي فيه على النحو التالي:\n\nprint('Hello', end='')\nprint('World', end='')\n\nHelloWorld\n\n\nلاحظ أننا جعلنا (end='') أي: لا نريده أن يضع حرفًا بعد طباعة النص. ولذلك ظهرت الكلمتان في نفس السطر.\nولو أردت أن تعيد الكتابة على نفس السطر، يمكنك أن تضع الحرف (\\r) الذي يفعل رأس الطباعة بالرجوع لبداية السطر:\n\nprint('123', end='\\r')\nprint('45')\n\n12345\n\n\nلاحظ أن النتيجة هي طباعة الحرفين 45 فوق الحرفين 12 مع بقاء الحرف الأخير 3 في الأخير. وذلك لرجوع رأس الطباعة.\nتستعمل هذه اللطيفة في تحديث العداد حتى يظهر على الشاشة وكأنه يزيد شيئًا فشيئًا. وذلك على النحو التالي (لاحظ أننا نستعمل time.sleep(t) حتى نمثِّل وجود عمليَّة تأخذ وقتًا طويلاً فحسب):\nimport time\n\nfor x in range(10 + 1):\n    time.sleep(0.20)\n    print(f'[{x}/10] ' + '===' * x + '&gt;', end='\\r')",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ترميز الحروف</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html",
    "href": "chapters/07_strings/a3_regex.html",
    "title": "8  التعبير النمطي",
    "section": "",
    "text": "فئة الأحرف\nتستعمل التعبيرات النمطية لاستخراج البيانات من النصوص. على سبيل المثال، هذا سجل تمارين فيه في كل سطر نوع من أنواع التمارين وعدد الجلسات ومرات التكرار، لكنها غير مرتبة. فأحيانًا يكون الاسم في البداية، وأحيانا في الأخير … وهكذا.\nالتعبير النمطي (Regular Expression): طريقة لتحديد نمط متسلسل من الأحرف. والغرض منه: البحث عن هذا النمط في نص ما. وله في بايثون مكتبتان:\nالأحرف الخاصة (meta-characters): هي أحرف ذات دلالة معيَّنة غير ما تبدو؛ وهي:\nسنبدأ أولاً بشرح محدد فئة الأحرف [ ] (Character Class) ويعمل كالآتي:\nوبهذا تعرف دلالة:\nتأمل المثال التالي:\ntext = \"I am 21 years old\"\npattern = \"[0-9][0-9]\"\nmatch = re.search(pattern, text)\nprint(match)\n\n&lt;re.Match object; span=(5, 7), match='21'&gt;\nولاستخراج النص المطابق نستعمل الفعل match.group() هكذا:\nif match:\n    print(match.group())\n\n21",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#فئة-الأحرف",
    "href": "chapters/07_strings/a3_regex.html#فئة-الأحرف",
    "title": "8  التعبير النمطي",
    "section": "",
    "text": "[abc] يطابق a أو b أو c\n[^abc] يطابق أي حرف غير a أو b أو c\n[a-c] يطابق أي حرف من a إلى c: a أو b أو c\n[3-7] يطابق أي رقم من 3 إلى 7: 3 أو 4 أو 5 أو 6 أو 7\n[a-zA-Z] يطابق أي حرف صغير أو كبير من a إلى z أو A إلى Z\n[a-zA-Z0-9_] يطابق أي حرف صغير أو كبير أو رقم من a إلى z أو A إلى Z أو 0 إلى 9 أو _ (الشرطة السفلية)\n\n\n\nعلامة ^ في نحو: [^ تدل على عكس الفئة\nعلامة - في نحو: [a-b] تدل على الأحرف بين الحرفين (شاملة لهما)\n\n\n\n\nلاحظ أن النمط: [0-9][0-9] يطابق أي رقمين متتاليين من 0 إلى 9.\nويأتي الإجراء re.search للبحث داخل النص text عن النمط pattern؛ ونوع العائد هو Match إذا وُجد وإلا يكون None.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#فئات-لها-رمز",
    "href": "chapters/07_strings/a3_regex.html#فئات-لها-رمز",
    "title": "8  التعبير النمطي",
    "section": "فئات لها رمز",
    "text": "فئات لها رمز\nينضم إلى الأحرف الآنف ذكرها:\n\n\n\\d وعكسها \\D\n\n\nيطابق أي رقم عشري؛ وهو مكافئ: [0-9].\n\n\n\\w وعكسها \\W\n\n\nيطابق الأحرف الأبجدية والأرقام والشرطة السفلية [a-zA-Z0-9_]. وبالنسبة لأنماط Unicode (str)، فإنه يطابق الأحرف الأبجدية الرقمية في Unicode (كما هو معرّف بواسطة str.isalnum())، بالإضافة إلى الشرطة السفلية _.\n\n\n\\s وعكسها \\S\n\n\nيطابق المسافات البيضاء؛ وهو مكافئ: [ \\t\\n\\r\\f\\v] (لاحظ وجود المسافة).\n\n\n\\b وعكسها \\B\n\n\nيطابق طرف كلمة\n\n\nولأن بايثون تعتبر علامة \\ في النصوص علامةً على أحرف خاصة (Escape Character) مثل:\n\n\\n للسطر الجديد\n\\t للمسافة البيضاء\n\\r للرجوع إلى البداية\n\\f للصفحة\n\\v للمسافة العمودية\n\nولتجنب التعارض بين حرف \\ المقصود في النص البايثوني المعروف، والاختصارات التي نريدها؛ فقد وضعت بايثون حرف r لتعطيل خصوصية الحرف \\ حتى تُكتَب الأنماط النصية بمى يسمى النص الخام (raw string) على النحو التالي:\n\nالأرقام\n\ntext = \"I am 21 years old\"\npattern = r\"\\d\\d\"\nmatch = re.search(pattern, text)\nif match:\n    print(match.group())\n\n21\n\n\nنصيحة: استعمل r دائمًا عند كتابة الأنماط النصية.\n\n\nالحروف\nوأما لمطابقة الحروف فإننا قد نستعمل الاختصار \\w على النحو التالي:\n\nanimals = [\n    \"cat\",\n    \"bat\",\n    \"dog\",\n    \"rat\",\n]\n\npattern = r\"\\wa\\w\"\n\nfor animal in animals:\n    match = re.search(pattern, animal)\n    if match:\n        print(match.group())\n\ncat\nbat\nrat\n\n\n\nلاحظ أن النمط \\wa\\w يتكون من ثلاثة أجزاء:\n\n\\w تطابق الأحرف الأبجدية والأرقام والشرطة السفلية\na تطابق الحرف a كما هو\n\\w تطابق الأحرف الأبجدية والأرقام والشرطة السفلية\n\nوبذلك يصير النمط مطابقًا لأي حرفين يتوسطهما حرف a مثل: cat أو bat أو rat. والخارج من هذا النمط هو كلمة: dog\n\n\n\nطرف الكلمة \\b\nيطابق الرمز \\b، وتستعمل للسياقات التي نريد فيها المطابقة الكليَّة للكلمة، لا أن تكون جُزءًا من كلمة أخرى. وذلك لى النحو التالي:\n\ntext1 = \"My ear\"\ntext2 = \"I arrived early\"\ntext3 = \"This is the end of the year\"\n\n\nentire = r\"\\b\" + \"ear\" + r\"\\b\"\nprint(re.search(entire, text1))\nprint(re.search(entire, text2))\nprint(re.search(entire, text3))\n\n&lt;re.Match object; span=(3, 6), match='ear'&gt;\nNone\nNone\n\n\n\nstarts = r\"\\b\" + \"ear\"\nprint(re.search(starts, text1))\nprint(re.search(starts, text2))\nprint(re.search(starts, text3))\n\n&lt;re.Match object; span=(3, 6), match='ear'&gt;\n&lt;re.Match object; span=(10, 13), match='ear'&gt;\nNone\n\n\n\nends   = \"ear\" + r\"\\b\"\nprint(re.search(ends, text1))\nprint(re.search(ends, text2))\nprint(re.search(ends, text3))\n\n&lt;re.Match object; span=(3, 6), match='ear'&gt;\nNone\n&lt;re.Match object; span=(24, 27), match='ear'&gt;",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#التكرار-والتحديد",
    "href": "chapters/07_strings/a3_regex.html#التكرار-والتحديد",
    "title": "8  التعبير النمطي",
    "section": "التكرار والتحديد",
    "text": "التكرار والتحديد\nتستعمل علامات التكرار / المحددات الكمية (Quantifiers) لتعيين مرات التكرار من النمط السابق. وهي على النحو التالي:\n\n{3} ثلاث مرات بالضبط\n{2,4} من 2 إلى 4 مرات\n{3,} ثلاث مرات أو أكثر\n+ مرة أو أكثر\n* صفر أو أكثر\n? صفر أو مرة واحدة فقط\n\nولتحديد مجموعة من الأحرف ضمن النمط نستعمل القوسين الدائريين: ( ) حول النمط ليكون مجموعة مطابقة (Match Group).\nمثلاً، تريد مطابقة السعر في النصوص التالية:\n\nprices = [\n    \"it costs 123\",\n    \"I bought it for 12.3 last time\",\n    \"I paid 12.34 SAR for it\"\n]\n\nفتستعمل المنط التالي:\n\npattern = r\"\\d+(\\.\\d+)?\"\n\nويتكون من ثلاثة أجزاء:\n\n\\d+ ويتكون من جزئين:\n\n\\d رقم\n+ مرة أو أكثر\n\n(...)? ما بين القوسين: صفر أو مرة واحدة فقط\n\n\\. نحتاج علامة \\ لتعطيل خصوصية حرف النقطة لأنها تدل على مطابقة أي حرف\n\\d+ رقم، مرة أو أكثر\n\n\n\nfor p in prices:\n    match = re.search(pattern, p)\n    if match:\n        print('price:', match.group())\n\nprice: 123\nprice: 12.3\nprice: 12.34",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#المطابقة",
    "href": "chapters/07_strings/a3_regex.html#المطابقة",
    "title": "8  التعبير النمطي",
    "section": "المطابقة",
    "text": "المطابقة\nتوجد في بايثون أربعة أفعال أساسية للمطابقة:\n\nre.match(pattern, string, flags=0) -&gt; Match | None\n\nمطابقة النمط في بداية السلسلة النصية.\n\nre.search(pattern, string, flags=0) -&gt; Match | None\n\nالبحث عن أول تطابق للنمط في السلسلة النصية.\n\nre.findall(pattern, string, flags=0) -&gt; list\n\nإنشاء قائمة من جميع التطابقات للنمط في السلسلة النصية.\n\nre.finditer(pattern, string, flags=0) -&gt; Iterator[Match[str]]\n\nإنشاء مكرر لجميع التطابقات للنمط في السلسلة النصية.\n\n\nفأما الشيء الناتج عن هذه المطابقة، وهو Match؛ فيتضمن أربعة صفات:\n\ngroup()\nstart()\nend()\nspan()\n\nوبالمثال يتضح المقال:\nالأمر الأول: المطابقة بالفعل .match() تكون من بداية النص. وبالتالي فإنك لو طابقت على هذا النص كاملاً فلن تطابقها، مع أن المطابقة تنفع مع الرقم وحده:\n\ntext = \"Pushups 30 reps 3 sets\"\n\npattern = r\"\\d+\"\n\n# مطابقة على النص كاملاً\nprint(re.match(pattern, text))\n\n# مطابقة على الرقم وحده\nprint(re.match(pattern, \"30\"))\n\nNone\n&lt;re.Match object; span=(0, 2), match='30'&gt;\n\n\nلذلك نستعمل المطابقة بالفعل .search() للبحث عن النمط في أي موضع في النص:\n\ntext = \"Pushups 30 reps 3 sets\"\n\npattern = r\"\\d+\"\n\nprint(re.search(pattern, text))\n\n&lt;re.Match object; span=(8, 10), match='30'&gt;\n\n\nويمكننا الوصول لصفات المطابقة:\n\nm = re.search(pattern, text)\nprint(m.group())\nprint(m.start(), m.end())\nprint(m.span())\n\n30\n8 10\n(8, 10)\n\n\nلكن المطابقة أتت بعدد واحد، وقصدنا أن نطابقهما كليهما: 30 و 3 في المثال. ولذلك نستعمل الإجراء .findall() على النحو التالي:\n\ntext = \"Pushups 30 reps 3 sets\"\n\npattern = r\"\\d+\"\n\nol = re.findall(pattern, text)\nprint(ol)\n\n['30', '3']\n\n\nفإن أردت المطابقة (وليس النص المطابَق)، فاستعمال الإجراء .finditer() على النحو التالي:\n\ntext = \"Pushups 30 reps 3 sets\"\n\npattern = r\"\\d+\"\n\nit = re.finditer(pattern, text)\nfor m in it:\n    print(m)\n\n&lt;re.Match object; span=(8, 10), match='30'&gt;\n&lt;re.Match object; span=(16, 17), match='3'&gt;",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#ضبط-عملية-المطابقة",
    "href": "chapters/07_strings/a3_regex.html#ضبط-عملية-المطابقة",
    "title": "8  التعبير النمطي",
    "section": "ضبط عملية المطابقة",
    "text": "ضبط عملية المطابقة\nتستعمل الأعلام لضبط التطابق من عدة وجوه:\n\n\n\nالعلم\nالمعنى\n\n\n\n\nASCII, A\nيجعل بعض الاختصارات مثل \\w, \\b, \\s و \\d تطابق فقط الأحرف ASCII.\n\n\nDOTALL, S\nيجعل . يطابق أي حرف، بما في ذلك الأسطر الجديدة.\n\n\nIGNORECASE, I\nيجعل المطابقة غير حساسة لحالة الأحرف.\n\n\nLOCALE, L\nيجعل المطابقة تأخذ في الاعتبار الإعدادات المحلية.\n\n\nMULTILINE, M\nيتيح المطابقة متعددة الأسطر، مما يؤثر على ^ و $.\n\n\nVERBOSE, X (لـ “الموسعة”)\nيتيح كتابة تعبيرات نمطية منظمة بشكل أوضح وأسهل للفهم.\n\n\n\nونمثل باستعمال العلم re.IGNORECASE إذْ نحتاج إليه في مطابقة الكلمات اللاتينية، لاحظ الفرق في المطابقتين:\n\ntext = \"She is she.\"\n\nfor m in re.finditer(r\"[a-z]+\", text):\n    print(m)\n\nprint()\n\nfor m in re.finditer(r\"[a-z]+\", text, re.IGNORECASE):\n    print(m)\n\n&lt;re.Match object; span=(1, 3), match='he'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n&lt;re.Match object; span=(0, 3), match='She'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n\nولاستعمال مجموعة أعلام فإننا ندمجه بعلامة | على النحو التالي:\nre.search(pattern, text, re.IGNORECASES | re.LOCALE)",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#استخراج-المجموعات-من-النص",
    "href": "chapters/07_strings/a3_regex.html#استخراج-المجموعات-من-النص",
    "title": "8  التعبير النمطي",
    "section": "استخراج المجموعات من النص",
    "text": "استخراج المجموعات من النص\nسبق أن رأينا تحديد المطابقة لوضع المحددات الكمية لغرض التكرار. لكن الآن ننظر إلي كيفية استخراج المجموعات من النص.\n\ntext = \"Muhammad AlKhwarizmi, Polymath\"\n\nm = re.search(r\"(\\w+) (\\w+), \\w+\", text)\nif m:\n    print(m.group(0)) # المجموعة الصفرية هي كامل المطابقة\n    print('first_name:', m.group(1)) # القوسين الأوليين\n    print('last_name:', m.group(2)) # القوسين الثانيين\n\nMuhammad AlKhwarizmi, Polymath\nfirst_name: Muhammad\nlast_name: AlKhwarizmi\n\n\nوهذا مثال آخر فيه تضمين قوسين داخل قوسين، وبه تتضح دلالة الرقم الممررة للفعل .group(n):\n\ntext = \"30 Reps 3 Sets\"\n\nm = re.search(r\"((\\d+) Reps) ((\\d+) Sets)\", text)\nif m:\n    print(m.group(1))\n    print(m.group(2))\n    print(m.group(3))\n    print(m.group(4))\n\n30 Reps\n30\n3 Sets\n3",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#تسمية-المجموعات",
    "href": "chapters/07_strings/a3_regex.html#تسمية-المجموعات",
    "title": "8  التعبير النمطي",
    "section": "تسمية المجموعات",
    "text": "تسمية المجموعات\nمن خصائص محرك مطابقة الأنماط في لغة بايثون خصوصًا؛ إمكانية تسمية المجموعات في النمط، ليتم استخراجها بالاسم. وتكون التسمية بعد القوس الأول هكذا: (?P&lt;name&gt;...) حيث تمثل الـ ... النمط النصي. وذلك على النحو التالي:\n\ntext = \"Muhammad AlKhwarizmi, Polymath\"\n\nm = re.search(r\"(?P&lt;first_name&gt;\\w+) (?P&lt;last_name&gt;\\w+), \\w+\", text)\nif m:\n    print(m.groupdict())\n    print(m.group('first_name'))\n    print(m.group('last_name'))\n\n{'first_name': 'Muhammad', 'last_name': 'AlKhwarizmi'}\nMuhammad\nAlKhwarizmi\n\n\nوكذلك يكون في المجموعات المضمنة:\n\ntext = \"30 Reps 3 Sets\"\n\nm = re.search(r\"((?P&lt;reps&gt;\\d+) Reps) ((?P&lt;sets&gt;\\d+) Sets)\", text)\nif m:\n    print(m.groupdict())\n    print(m.group('reps'))\n    print(m.group('sets'))\n\n{'reps': '30', 'sets': '3'}\n30\n3",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#تفسير-التعبير-النمطي-مرة-واحدة",
    "href": "chapters/07_strings/a3_regex.html#تفسير-التعبير-النمطي-مرة-واحدة",
    "title": "8  التعبير النمطي",
    "section": "تفسير التعبير النمطي مرة واحدة",
    "text": "تفسير التعبير النمطي مرة واحدة\nقد استعملنا إجراءات المكتبة مباشرة في نحو: re.match() و re.search() وغيرها. فهي تأخذ النمط وتفسره ثم تنفذه بحزمة مكتوبة بلغة سي (C). فإذا كان النمط يستعمل كثيرًا فإن عملية التفسير تتم عدة مرات، وذلك هدر. ولتفسير النمط مرة واحدة ثم تطبيقه عدة مرات (من غير تكرار التفسير) نستعمل إجراء التفسير re.compile() على النحو التالي:\n\ntext1 = \"She is she.\"\ntext2 = \"They are they.\"\n\npatternc = re.compile(r\"[a-z]+\", re.IGNORECASE)\n\nfor m in patternc.finditer(text1):\n    print(m)\n\nprint()\n\nfor m in patternc.finditer(text2):\n    print(m)\n\n&lt;re.Match object; span=(0, 3), match='She'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n&lt;re.Match object; span=(0, 4), match='They'&gt;\n&lt;re.Match object; span=(5, 8), match='are'&gt;\n&lt;re.Match object; span=(9, 13), match='they'&gt;\n\n\nوحتى يتبين الفرق، قارنها مع القطعة التي لم نستعمل فيها التفسير المسبق؛ فهو يتكررفي كل مرة:\n\ntext1 = \"She is she.\"\ntext2 = \"They are they.\"\n\nfor m in re.finditer(r\"[a-z]+\", text1, re.IGNORECASE):\n    print(m)\n\nprint()\n\nfor m in re.finditer(r\"[a-z]+\", text2, re.IGNORECASE):\n    print(m)\n\n&lt;re.Match object; span=(0, 3), match='She'&gt;\n&lt;re.Match object; span=(4, 6), match='is'&gt;\n&lt;re.Match object; span=(7, 10), match='she'&gt;\n\n&lt;re.Match object; span=(0, 4), match='They'&gt;\n&lt;re.Match object; span=(5, 8), match='are'&gt;\n&lt;re.Match object; span=(9, 13), match='they'&gt;",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#تحرير-التعبيرات-النمطية",
    "href": "chapters/07_strings/a3_regex.html#تحرير-التعبيرات-النمطية",
    "title": "8  التعبير النمطي",
    "section": "تحرير التعبيرات النمطية",
    "text": "تحرير التعبيرات النمطية\nننصح باستعمال أدوات تحرير التعبير النمطي مثل: regex101 فهي أفضل بكثير من كتابته دون أداة.\n\nفي القائمة الجانبية اختر نكهة (Flavour) Python\nفي الحقل الأول تكتب التعبير النمطي\nفي الصندوق الكبير تضع النص الذي تريد مطابقته\n\nوكذلك يوجد محرر آخر مثل regexr وفي القائمة الجانبية تجد Community Patterns حيث تجد فهرس لأنماط نصية شاركها المبرمجون الآخرون.\nوهكذا فإنك تعدل على النمط وتزيد في النصوص، حتى تصل إلى أفضل نمط لتنسخه وتضع في برنامجك.\nوهذا المحرر يستعمل محرك بايثون نفسه: pythex.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a3_regex.html#مصادر-أخرى-للتعلم",
    "href": "chapters/07_strings/a3_regex.html#مصادر-أخرى-للتعلم",
    "title": "8  التعبير النمطي",
    "section": "مصادر أخرى للتعلم",
    "text": "مصادر أخرى للتعلم\nدروس تفاعلية لتعلم التعبيرات النمطية:\n\nRegexLearn\nRegexOne",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>التعبير النمطي</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html",
    "href": "chapters/09_files_and_directories/a1_file_io.html",
    "title": "9  الملفات",
    "section": "",
    "text": "المسار\nلا يكون البرنامج مفيدًا من غير منفذٍ يُخرِج فيه نتائجه.\nرغم تعقيد الحواسيب اليوم، إلا أنها في الأصل راجعة إلى معمارية فون نويمان (1945م) التي سبق بيانها:\nفتنقسم العمليات الحاسوبية إلى نوعين بحسب المنفذ الحقيقي لها:\nالأول عمليات حساب (Computation): عمليات تنفذها وحدة المعالجة المركزية (CPU). وذلك مثل الجمع والطرح، وفصل النصوص ودمجها، والشرط والتكرار، ونحو ذلك.\nالثاني عمليات إدخال وإخراج (I/O): عمليات تنفذها الأجهزة المرتبطة به؛ بناءً على طلبه. ومثالها مما رأينا:\nومن أجهزة الإدخال والإخراج (I/O) أيضًا:\nوسننظر في كيفية قراءة وكتابة الملفات؛ فهي الشيء البرمجي الذي نتعامل معه لحفظ واسترجاع البيانات من أجهزة التخزين (Storage Devices).\nالمسار هو سلسلة تحدد موقع الملف في النظام. وهو على نوعين:\nوفواصل المسار شرطة مائلة:\nوالنقطة والنقطتان تدل على نسبية المسار:\nيتم ترتيب الملفات شجريًّا.\nففي نظام ويندوز (Windows) تكون الشرطة خلفية (\\):\nفالحرف الأوَّل في الأعلى (C:) يمثِّل مكان جهاز التخزين. وإن رأيت D: أو E: فيعني أن الملفات تخزن في جهازين آخرين.\nوقد تتساءل لماذا لم نبدأ بالحرف A: أو B:؟ وسبب ذلك تاريخي. وذلك أنَّهما كانا محجوزين للإشارة لجهاز تخزين عتيق يسمى القرص المرن (floppy disk)، ولم يعد يستعمل.\nأما في أنظمة لينكس (Linux) وماك (MacOS) فإن الأصل يعبَّر عنه لا بحرف، وإنما بالمسار الجذر: / على النحو التالي:\nوتسمى الملفات المتضمنة لملفات أخرى: دليل (Directory). وهو الذي يعبَّر عنه فيما ترى في الواجهة الرسومية على شكل مجلَّد (Folder).\nفإذًا الملفات على نوعين:\nصيغة الملف (File Extension) تُعرَفُ بالحروف بعد آخر نقطة. مثل:",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#المسار",
    "href": "chapters/09_files_and_directories/a1_file_io.html#المسار",
    "title": "9  الملفات",
    "section": "",
    "text": "مطلق (Absolute): يحدد المسار بشكل كامل بدءًا من الجذر.\nنسبي (Relative): يحدد المسار بالنسبة لموقع الملف الحالي.\n\n\n\n/ تميل للأمام (اليمين) في عُرف أنظمة ويندوز\n\\ تميل للخلف (اليسار) في عُرف أنظمة يونكس\n\n\n\n. للدليل الحالي (هنا)\n.. للدليل الأب (صعود)\n\n\n\n\n\nPath\nExample\n\n\n\n\nAbsolute\n/home/adam/projects/xyz/scripts/analysis.py\n\n\nRelative\n.\n\n\nRelative\n..\n\n\nRelative\n./a/b\n\n\nRelative\n../a/b\n\n\nRelative\na/b\n\n\n\n\n\n\nC:\\\n└── Users\n    └── Adam\n        └── MyProject\n            ├── data\n            │   └── datafile.csv\n            └── scripts\n                └── analysis.py\n\n\n\n/\n└── home\n    └── adam\n        ├── projects\n            └── myproject\n                ├── data\n                │   └── datafile.csv\n                └── scripts\n                    └── analysis.py\n\n\n\n\nFolder Icon\n\n\n\n\nملف (File): وهو الذي يحوي بيانات نصية أو ثنائية. مثل:\n\ndatafile.csv ملف بيانات جدولية \nanalysis.py ملف برنامج بايثون \n\nدليل (Directory): وهو قائمة من الملفات والأدلة. مثل:\n\ndata دليل / مجلد البيانات \nmyproject دليل / مجلد المشروع \n\n\n\n\ndatafile.csv صيغة csv\nanalysis.py صيغة py",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#قراءة-وكتابة-الملفات",
    "href": "chapters/09_files_and_directories/a1_file_io.html#قراءة-وكتابة-الملفات",
    "title": "9  الملفات",
    "section": "قراءة وكتابة الملفات",
    "text": "قراءة وكتابة الملفات\nيتم فتح الملفات لغرض القراءة أو الكتابة بالإجراء open() هكذا:\nf = open(file='salam.txt', mode='r')\ncontent = f.read()\nf.close()\n\nprint(content)\n\nتم تحديد مسار الملف بالنسبة للملف الذي نحن فيه\nتم تحديد وضع القراءة: mode='r' عند الفتح (open())\nيتم قراءة المحتوى النصي للملف بالفعل: .read() المُسنَد إلى الملف file؛ ونعين قيمة ذلك في المتغير content\nيتم إغلاق الملف حتى يستطيع برنامج آخر أن يفتحه؛ إذ لا يجيز نظام التشغيل أن يُفتح الملف في نفس الوقت من برنامجين مختلفين\nتتم طباعة المحتوى الذي قُرئ\n\nأما فتحُ الملف لغرض القراءة، فيتم بتحديد وضعية القراءة open(mode='w') على النحو التالي:\ncontent = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\n\nf = open(file='salam.txt', mode='w')\nf.write(content)\nf.close()\n\nprint(content)\nانظر توثيق قراءة وكتابة الملفات.\nولأن الفتح والإغلاق مقترنان في الموارد (Resources) المتنازع عليها (والذي يديرها نظام التشغيل)؛ فلا بد من الإغلاق بعد كل فتح. ووضع في اللغة مفهوم مدير السياق حيث يستعمل معها جملة with: فيكون ما بداخلها يعمل في سياق توفر المورِد، فإذا انتهت القطعة أغلِق المورِد تلقائيًّا. وبالمثال يتضح المقال:\ncontents = ''\nwith open(file='salam.txt', mode='r') as f:\n    contents = f.read()\nprint(contents)\nلاحظ أننا لم نحتج لفعل الإغلاق: f.close() بل يتم ذلك بعد آخر جملة مضمَّنة داخل نطاق with.",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#مكتبة-المسار-pathlib",
    "href": "chapters/09_files_and_directories/a1_file_io.html#مكتبة-المسار-pathlib",
    "title": "9  الملفات",
    "section": "مكتبة المسار (pathlib)",
    "text": "مكتبة المسار (pathlib)\n\nfrom pathlib import Path\n\nتعنى مكتبة المسار (pathlib) بجميع ما يخص المسار: إنشائه والبحث فيه والاستعلام عن مدلوله والسير فيه.\n\n\n\n\n\n\nملاحظة\n\n\n\nيجدر بالذكر أن مكتبة pathlib جاءت متأخرة في إصدار Python 3.4 لمعالجة الملفات بأسلوب البرمجة الشيئية (OOP)، بينما تستعمل مكتبة os التي سبقتها لأغراض متعددة فيما يخص نظام التشغيل (os = Operating System) من ضمنها خُصِّصَت os.path للتتعامل مع نظام الملفات إلا أنها كُتِبَت بأسلوب إجرائي تأسيًّا بلغة سي (C)، فهي منخفضة المستوى (تتعامل مباشرة مع bytes و str) بالمقارنة بالبرمجة الشيئية الأعلى في التجريد؛ وهو ما نفضله. انظر مقارنة pathlib بوحدات os و os.path.\n\n\nويستعمل المسار Path مكان النص بعد إنشائه على النحو التالي:\np = Path('salam.txt')\n\ncontents = ''\nwith open(file=p, mode='r') as f:\n    contents = f.read()\nprint(contents)",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#الدليل-directory",
    "href": "chapters/09_files_and_directories/a1_file_io.html#الدليل-directory",
    "title": "9  الملفات",
    "section": "الدليل (Directory)",
    "text": "الدليل (Directory)\nأحيانًا نريد التعامل مع مجلَّد يحوي مجموعة ملفات، بنقلها أو نسخها أو حذفها ونحو ذلك.\nانظر قراءة الأدلة.\nلعرض قائمة الدليل، نستعمل المكرر الناتج من فعل .iterdir() ونكرر عليه، وهو بدورِه يُنتج في كل كرةٍ مساراً (x). وهذا المسار يُمكن التحقق من أنه يشير إلى دليل أو لا (x.is_dir()) على النحو التالي:\np = Path('.')\ndirs = [x for x in p.iterdir() if x.is_dir()]\ndirs\n\nجرب\nهل تريد أن تعرف حجم دليل التنزيلات (Downloads) في جهازك؟. لديك الفعل stat() للحصول على بيانات عن الدليل، والتي من ضمنها الحجم (st_size) هكذا:\np = Path.home() / 'Downloads'\nsize = p.stat().st_size\nprint(size, 'bytes')\nثم هذا الإجراء لتحويل الوِحدة من البايت إلى الكيلو والميجا والقيقا:\ndef format_size(size):\n    size_kb = size / 1024\n    size_mb = size_kb / 1024\n    size_gb = size_mb / 1024\n    if size_gb &gt; 0.1:\n        return f'{size_gb:.2f} GB'\n    elif size_mb &gt; 0.1:\n        return f'{size_mb:.2f} MB'\n    return f'{size_kb:.2f} KB'\n\nprint(format_size(size))",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#البحث-العام",
    "href": "chapters/09_files_and_directories/a1_file_io.html#البحث-العام",
    "title": "9  الملفات",
    "section": "البحث العام",
    "text": "البحث العام\nيستعمل البحث العام (Globbing) لمطابقة عدة ملفات تحت مسار معيَّن بنمط معيَّن.\nوهي لغة تنميط بسيطة جدًّا لا تقارن بتعقيد التعبيرات النمطية (Regular Expression) التي سبق ذكرها. وإليك تطبيقًا تفاعليًّا يجمع لك جميع مفاهيمها: globster.\nمثلاً: نبحث في المسار path/to/my/pictures/ عن جميع الصور (ذات الصيغة .jpg) في كل ما يتفرع عن ذلك المسار وإن نزل:\ntotal_size = 0\nfor p in Path('path/to/my/pictures/').glob('**/*.jpg'):\n    total_size += p.stat().st_size\n\nprint('Total size:', total_size, 'bytes')\nprint('Total size:', format_size(total_size))",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a1_file_io.html#المشي-على-جميع-ملفات-الشجرة",
    "href": "chapters/09_files_and_directories/a1_file_io.html#المشي-على-جميع-ملفات-الشجرة",
    "title": "9  الملفات",
    "section": "المشي على جميع ملفات الشجرة",
    "text": "المشي على جميع ملفات الشجرة\nنستعمل الفعل .walk() لطرق جميع فروع المسار:\n\np = Path('../../datasets/example_root/')\nfor dirpath, dirnames, filenames in p.walk(top_down=True):\n    print(dirpath)\n    for file in filenames:\n        print(f'\\t{file}')\n        # print('\\tFULL PATH:', Path(dirpath) / file)\n\n../../datasets/example_root\n    something.txt\n../../datasets/example_root/a\n    A_domestic_cat.jpg\n    zzz.txt\n    A_domestic_cat.jpgZone.Identifier\n    a.txt\n../../datasets/example_root/b\n    DSC0532_(9120523417).jpg\n    A_yellow_and_white_cat.jpg\n    DSC0532_(9120523417).jpgZone.Identifier\n    b.txt\n    A_yellow_and_white_cat.jpgZone.Identifier\n../../datasets/example_root/c\n    c.txt\n../../datasets/example_root/c/c_inner\n    inner.txt\n\n\nلاحظ أن .walk() يعطينا ثلاثة قيَم في كل كرة:\n\ndirpath: المسار الحالي للدليل.\ndirnames: قائمة بأسماء الأدلة التي يدل عليها.\nfilenames: قائمة بأسماء الملفات التي يدل عليها.\n\nلإظهار كامل المسار؛ أزل علامة التعليق # من السطر الأخير لتنفيذه.\nمصادر أخرى\n\nإذا كنت تريد قراءة الملفات وكتابتها بشكل بسيط انظر: open().\nوإذا كنت تريد التعامل مع الملفات المؤقتة فانظر: tempfile.\nوكثير من عمليات التعامل مع الملفات والأدلة تجدها في: shutil.",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a2_data.html",
    "href": "chapters/09_files_and_directories/a2_data.html",
    "title": "10  حفظ البيانات واسترجاعها",
    "section": "",
    "text": "حزمة (csv)\nسَلْسَلة البيانات (Data Serialization) تشير لعملية تحويل البيانات في ذاكرة بايثون (مثل القائمة [] والقاموس {}) من صيغتها الثنائية الخاص باللغة إلى تمثيلٍ ليس خاصًّا بلغةٍ معيَّنة؛ بل يتبع صيغةً متفقًا عليها؛ فإما أن يكون:\nفالتمثيل النصي يتميز بأنه مباشر وواضح بالنسبة للبشر. لكنه أبطأ في المعالجة (سواءً في الكتابة أو في القراءة) وأكبرُ حجمًا في التخزين غالبًا. أما التمثيل الثانئي فهو بعكسه: أقرب للآلة وأصعب في التدقيق عند حدوث الخطأ إلا مع وجود أدوات تساعد في ذلك. لكنه أسرع في المعالجة وأقل حجمًا للتخزين.\nوعملية تحويل البيانات المُسَلسَلة (أي المكتوبة بإحدى هذه الصيغ) وقراءَتها في برنامجٍ ما تسمى فك التسلسل (Deserialization). فالتحويل يكون مثلاً من النصي إلى الثنائي في الذاكرة. أو من الثنائي المسلسل إلى الثنائي في الذاكرة.\nفالسلسلة وفكها ما هي إلا صياغة لا تغير المكنون بل شكله.\nويختلف شكل البيانات من ثلاثة أوجه:\nفالصفوف تتميز بكون كل صفٍّ فيها تدوينًا لمجموعة خصائص تشترك في العمود كله. أما الارتباط ففيه مرونة؛ فمجموعة الارتباطات لا تُلزِم كل ارتباط أن يكون له ذات خصائص الارتباط الذي قبله.\nimport csv\nتسهل حزمة csv المبنية في بايثون التعامل مع البيانات المجدولة المصفصفة.\nمثل الملف abc.csv: حيث تفصل الصفوف بسطر \\n وتفصل القيَم في السطر بالفاصلة ,. حيث يرمز الاختصار CSV لكلمة Comma Separated Values؛ بمعنى: القيَم المفصول بالفاصلة.\nمثالها:\nوكذلك ملف abc.tsv: حيث تفصل الصفوف بسطر \\n وتفصل القَم في السطر بالمسافة البادئة \\t.\nمثالها:",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>حفظ البيانات واسترجاعها</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a2_data.html#حزمة-csv",
    "href": "chapters/09_files_and_directories/a2_data.html#حزمة-csv",
    "title": "10  حفظ البيانات واسترجاعها",
    "section": "",
    "text": "Name,Age,Grade,Done\nAdam,22,90,F\nBelal,23,92,F\nCamal,24,91,T\nDawod,8,99,F\nEmad,9,98,F\n\n\nName    Age    Grade  Done\nAdam    22 90  F\nBelal   23    92 F\nCamal   24    91 T\nDawod   8 99  F\nEmad    9  98   F\n\nحفظ جدول البيانات\nنفترض أن لدينا قائمة من البيانات على النحو التالي:\n\nrows = [\n    ['Adam', 22, 90, 'F'],\n    ['Belal', 23, 92, 'F'],\n    ['Camal', 24, 91, 'T'],\n    ['Dawod', 8, 99, 'F'],\n    ['Emad', 9, 98, 'F'],\n]\nheader = ['Name', 'Age', 'Grade', 'Done']\n\n\nحيث تمثل القائمة rows الصفوف\nوتمثل القائمة header اسم كل عمود\n\nفإن الكتابة تتم بإنشاء الكاتب وتمرير الملف أو مسار الملف إليه (csv.writer(file)) على النحو التالي:\n\nwith open('students.csv', mode='w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(header)\n    writer.writerows(rows)\n\nملاحظة، يمكنك محاولة فتح الملف مباشرة من مستكشف الملفات. حاول فتحه باستخدام Excel أو Google Sheet أو أي برنامج جداول بيانات آخر. إذا فتحته باستخدام محرر نصوص، سترى البيانات كملف CSV؛ حرفيًا قيم مفصولة بفواصل.\n\n\nقراءة جدول البيانات\nالآن، دعنا نقرأه كهيكل بيانات في بايثون: كقائمة من القوائم.\n\ndata = []\nwith open('students.csv') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        data.append(row)\n\nوتستطيع كتابة وقراءة الصفوف أيضًا باستعمال:\n\nقارئ القاموس DictReader\nكاتب القاموس DictWriter\n\n\n\n\n\n\n\nملاحظة\n\n\n\nغالبًا نستعمل مكتبة بانداس (Pandas) للتعامل مع البيانات الجدولية.",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>حفظ البيانات واسترجاعها</span>"
    ]
  },
  {
    "objectID": "chapters/09_files_and_directories/a2_data.html#حزمة-json",
    "href": "chapters/09_files_and_directories/a2_data.html#حزمة-json",
    "title": "10  حفظ البيانات واسترجاعها",
    "section": "حزمة (json)",
    "text": "حزمة (json)\n\nimport json\n\nتسهل حزمة json المبنية في بايثون التعامل مع البيانات المضمنة.\nمثل الملف settings.json:\n{\n    \"theme\": \"dark\",\n    \"language\": \"Arabic\",\n}\nأو الملف students.json:\n[\n    [\"Adam\", 22, 90, \"F\"],\n    [\"Belal\", 23, 92, \"F\"],\n    [\"Camal\", 24, 91, \"T\"],\n    [\"Dawod\", 8, 99, \"F\"],\n    [\"Emad\", 9, 98, \"F\"],\n]\nلنفترض أن لدينا user_preferences محفوظًا في القاموس التالي، ونريد حفظه في ملف json:\n\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\n\nكتابة مستند بيانات\nلنكتبها في الملف نستعمال json.dump على النحو التالي:\n\nwith open('user_preferences.json', mode='w') as file:\n    json.dump(user_preferences, file)\n\n\n\nقراءة مستند بيانات\nفإذا أردنا قراءتها نستعمل json.load على النحو التالي:\n\nwith open('user_preferences.json') as file:\n    data = json.load(file)\nprint(data)\n\n{'theme': 'dark', 'language': 'Arabic', 'notifications': {'email': True, 'sms': False, 'push': True}, 'last_updated': '2021-09-01', 'emails': ['example1@domain.com', 'example2@domain.com']}\n\n\nوانظر:\n\nالمكتبة المبنية xml لصيغة XML\nالمكتبة الخارجية pyyaml لصيغة YAML",
    "crumbs": [
      "باب المدخلات والمخرجات",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>حفظ البيانات واسترجاعها</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a0_function_calling.html",
    "href": "chapters/08_procedural/a0_function_calling.html",
    "title": "11  استدعاء الإجراءات",
    "section": "",
    "text": "الإجراء (Procedure) هو جزء محفوظ من البرنامج يتم استدعاؤه مع تمرير عوامل مختلفة.\nويمكن استدعاؤه بعامل واحد:\n\nنحو: int(x) لإنشاء العدد الصحيح من النص. مثل: int(\"12\") ينتج: 12.\nأو نحو: abs(x) للقيمة المطلقة مثل: abs(-10) ينتج: 10.\n\nوقد يأخذ عاملين:\n\nنحو: round(x, n) مثل: round(10.259, 2) ينتج: 10.26.\nأو نحو: pow(x, y) لرفع العدد x إلى القوة y. مثل: pow(2, 3) ينتج: 8.\n\nوقد يأخذ عاملاً واحدًا لكنَّهُ قائمة:\n\nنحو: sum(numbers) مثل: sum([1, 2, 3, 4, 5]) ينتج: 15.\nأو نحو: max(numbers) لأكبر عدد في القائمة. مثل: max([1, 2, 30, 4, 5]) ينتج: 30.\n\nوقد يكون عدد عوامله لا محدودًا:\n\nنحو: print(*values). فعلامة النجمة (*) تشير لقبول عدد مطلق من العوامل. مثل:\n\n\nname = \"Adam\"\nage = 25\nprint(\"My name is\", name, \"and I'm\", age, \"years old\")\n\nMy name is Adam and I'm 25 years old\n\n\nفإن print قبلت خمسة عوامل:\n\nالنص: \"My name is\"\nقيمة المتغير: name\nالنص: \"and I'm\"\nقيمة المتغير: age\nالنص: \"years old\"\n\nولدينا الإجراء help(func) يطلب مساعدة الإجراء المعيَّن، بلا أقواس، هكذا:\n\nhelp(sum)\n\nHelp on built-in function sum in module builtins:\n\nsum(iterable, /, start=0)\n    Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\n    When the iterable is empty, return the start value.\n    This function is intended specifically for use with numeric values and may\n    reject non-numeric types.\n\n\n\nوقد عرفت أن طلب التنفيذ يكون بالقوسين بعد اسمه ()، وتوضَع العوامل فيهما وهي ضربان:\n\nعامل مؤثر\nعامل متأثر\n\nوفي كل ما سبق كانت العوامل من النوع المؤثر؛ لأنها كانت تؤثر في النتيجة ولا تتأثر بها.\nأما المتأثر فنحو فعل الترتيب من مكتبة القائمة: list.sort(xs) فإن المتأثر به القائمة نفسها، مثل:\n\nxs = [40, 20, 10, 30]\nlist.sort(xs)\n\nفأما جملة list.sort فإننا حددنا اسم النوع list وأردنا منه الإجراء sort، وأتينا بالقوسين لطلب تنفيذه، ووضعنا المتأثر xs فيه.\nومع أننا لم نعيِّن النتيجة (بجملة التعيين =)، فقد تغيَّرت (تأثرت) القائمة بالإجراء:\n\nprint(xs)\n\n[10, 20, 30, 40]\n\n\nبعكس الترتيب بالإجراء الذي ليس من النطاق العام: sorted(xs) فإنَّ القائمة فيه ليست متأثرًا؛ إذْ يُنتِجُ الإجراءُ قائمةً جديدةً ولا يغير القائمة المُدخلة:\n\nxs = [40, 20, 10, 30]\nys = sorted(xs)\nprint(xs, \"لم يعمل الإجراء في القائمة نفسها\")\nprint(ys, \"هي قائمة جديدة\")\n\n[40, 20, 10, 30] لم يعمل الإجراء في القائمة نفسها\n[10, 20, 30, 40] هي قائمة جديدة\n\n\nوقد تتساءل ما الفائدة من وجود طريقتين وكلاهما يعمل نفس العمل؟\n\nالطريقة الأولى: list.sort(xs) لا ترجع بشيء بل تعدل نفس القائمة\nالطريقة الثانية: sorted(xs) ترجع قائمة جديدة\n\nفأما الطريقة الأولى فأصغر في الذاكرة لأنها لا تُنشئ نُسخة كما تفعل الطريقة الثانية. لكن الطريقة الثانية مفيدة إن أردت أن تُبقي القائمة الأصلية كما هي.\nوالأمر كذلك في الإجراءين:\n\nlist.reverse(xs)\nreversed(xs)\n\nويجتمع المؤثر والمتأثر في نحو:\n\nlist.append(xs, 50)\n\nفالإجراء list.append يأخذ القائمة، ويضيف إليها القيمة 50. ولذلك نقول الأوَّل متأثر والثاني مؤثر.\n\nprint(xs)\n\n[40, 20, 10, 30, 50]\n\n\nوقد وضعت اللغات الشيئية (Object-Oriented) مثل بايثون صياغة خاصَّةً: للإجراء المسند إلى الشيء. وبذلك يتحصل لدينا طريقتان كلتاهما تؤديان نفس المعنى:\n\nإسناد الإجراء للنوع: list.append(xs, 25)\nإسناد الإجراء للشيء: xs.append(25)\n\nومثاله أيضًا في الإجراء list.sort للترتيب وكذلك في list.append للإضافة:\n\nxs = [20, 10, 30, 40]\nys = [20, 10, 30, 40]\n\nlist.sort(xs)\nys.sort()\nassert xs == ys\n\nlist.append(xs, 50)\nys.append(50)\nassert xs == ys\n\nويأتي الكلام بالتفصيل عن البرمجة الشيئية في الكتاب الثاني.\nوقد تُعَيَّنُ العوامل بأحد طريقتين:\n\nتعيين بالموضع: نحو: round(3.14159, 2)\nتعيين بالاسم: نحو: round(number=3.14159, ndigits=2) فلا يشترط فيه ترتيب العوامل.\n\nويجوز استعمال الطريقتين معًا في نحو: list.sort(numbers, reverse=True) ويشترط فيه تقدم التعيين بالموضع ليكون في مكانه، ثم يتبعه التعيين بالاسم حيث لا يشترط الترتيب فيه.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>استدعاء الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html",
    "href": "chapters/08_procedural/a2_procedural.html",
    "title": "12  البرمجة الإجرائية",
    "section": "",
    "text": "تعريف الإجراء\nرأينا في جميع ما سبق كيف أن بايثون لغة أمريَّة (Imperative)؛ أي أنها مجموعة متسلسلة من التعليمات البرمجية التي يتبعها المفسِّر حَسَبَ ورودها (من الأعلى إلى الأسفل).\nوفي هذا الفصل نعرف أن بايثون لغة إجرائية (Procedural)؛ وهذا يعني تركيب البرنامج من إجراءات يستدعي كل واحد منها مجموعة أخرى من الإجراءات. فقد يستدعي الإجراء الأول إجرائين، وقد يستدعي كل منهما إجرائين كذلك، …إلخ. حتى تعود النتيجة إلى الإجراء الأوَّل الذي يمثِّل مدخل البرنامج: main. ويتشكل لدينا التسلسل الهرمي كما هو موضح (في الأسفل).\nفأما الإجراء (Procedure) فهو: قطعة نص برمجي مخزَّنة تُستدعى باسمها بعوامل متغيرة. ويسمى الدالة (Function) أو الروتين (Routine) أو البرنامج الفرعي (Sub-Program). ونقول استدعي الإجراء (Call) أو نفذه (Execute). ويسمى مكان القطعة التي قامت بالاستدعاء: موقع الاستدعاء (Call-site).\nأما القطعة الأخيرة: if __name__ == \"__main__\" فإن المتغير __name__ هو متغير مخصوص في لغة بايثون تعطيه القيمة __main__ إذا تم تشغيل البرنامج عن طريق هذا الملف، بخلاف ما لو تم استيراد هذا الملف. وسيأتي بيان ذلك في الفصل التالي، عندما نشرح الحزم والوحدات.\nنصور كومة الاستدعاءات (Call Stack) بمرور الوقت من اليسار إلى اليمين على النحو التالي:\nفأي إجراء يتم تعريفه؛ كالمتغير الذي يتم تعريفه: هو نص برمجي محفوظ ينتظر الاستدعاء حتى يحضر في ذاكرة البرنامج في ظرف تنفيذي ويتم تشغيله بعوامل معيَّنة. ثم يعود إلى الإجراء الذي استدعاه، وهكذا دواليك. لذا فإننا إن لم نشتغل الإجراء الأوَّل main فإن البرنامج وإن كان يحفظ هذه الإجراءات إلا أنها تحتاج إلى الاستدعاء لتعمل.\nيعرَّف الإجراء بـ def ويتكون من قسمين:\nالأول: الحد (Function Signature). وهو ثلاثة أجزاء:\nالثاني: الجسد (Body). وهو القطعة البرمجية التي جُعِلَ اسمه عنوانًا لها. وقد يتضمن الجسد جملة رجوع (Return Statement) للخروج بنتيجة\nتأمل المثال التالي:\ndef add(x, y):\n    result = x + y\n    return result",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#تعريف-الإجراء",
    "href": "chapters/08_procedural/a2_procedural.html#تعريف-الإجراء",
    "title": "12  البرمجة الإجرائية",
    "section": "",
    "text": "الاسم (Name): الذي يُطلَبُ به\nالعوامل (Parameters): وهي متغيرات تؤثر (تعمل) في النتيجة\nنوع العائد (Return Type): نوع القيمة التي يرجع بها الإجراء نتيجة عمله\n\n\n\n\n\nالحد: def add(x, y)\n\nالاسم: add\nالعوامل: x, y ونفترض أنهما من النوع العددي Number\nالعائد: Number (نوع النتيجة)\n\nالجسد:\n\nresult = x + y هنا نرى كيف أن العوامل أُعمِلَت في الإجراء\nreturn result تسمى جملة الرجوع وهي التي؛ ترجع بالنتيجة إلى الموضع الذي طلب الإجراء.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#التصريح-بالأنواع",
    "href": "chapters/08_procedural/a2_procedural.html#التصريح-بالأنواع",
    "title": "12  البرمجة الإجرائية",
    "section": "التصريح بالأنواع",
    "text": "التصريح بالأنواع\nتسمح بايثون بعدم التصريح بأنواع المتغيرات إلا أنه يجوز، وذلك على النحو التالي:\n\nfrom numbers import Number\n\ndef add(x: Number, y: Number) -&gt; Number:\n    result = x + y\n    return result\n\n\nوبهذا نعرف أن التصريح بنوع المتغيِّر يكون بإضافة نقطتين رأسيتين (:) ثم النوع Number بعد كل عامل.\nوبعد السهم لنوع الناتج من الإجراء (-&gt;)\n\nومن الأنواع المبنيَّة (Built-in Types) في بايثون:\n\nNumber وهو النوع الذي ترجع إليه جميع أنواع الأعداد\nint الأعداد الصحيحة، نحو: 10\nfloat الأعداد العشرية، نحو: 10.5\nstr وهي نوع النص، نحو: \"Salam\"\nlist قائمة وإن شئت تحديد نوع العنصر الواحد فيها؛ فإنك تضعه بين القوسين المربعين، نحو:\n\nlist[int]\nlist[float]\nlist[str]",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#ظرف-التنفيذ",
    "href": "chapters/08_procedural/a2_procedural.html#ظرف-التنفيذ",
    "title": "12  البرمجة الإجرائية",
    "section": "ظرف التنفيذ",
    "text": "ظرف التنفيذ\nتأمل الإجراء التالي:\n\ndef calculate_grade(score):\n    if score &gt;= 90:\n        return \"A\"\n    elif score &gt;= 80:\n        return \"B\"\n    elif score &gt;= 70:\n        return \"C\"\n    elif score &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\n\nوعند طلب التنفيذ نعين العوامل. فينتج لنا بطلب calculate_grade(95) نسخة معيَّنة من تفاصيل الإجراء، نسمّيها ظرف التنفيذ (Execution Frame) ؛ يكون فيه المتغير score=95 تكون هذه النسخة حاضرة في ذاكرة البرنامج وقت تنفيذ الإجراء:\nif 95 &gt;= 90:\n    return \"A\"\nelif 95 &gt;= 80:\n    return \"B\"\nelif 95 &gt;= 70:\n    return \"C\"\nelif 95 &gt;= 60:\n    return \"D\"\nelse:\n    return \"F\"\nوبطلب تنفيذ calculate_grade(80) يكون الظرف هكذ:\nif 80 &gt;= 90:\n    return \"A\"\nelif 80 &gt;= 80:\n    return \"B\"\nelif 80 &gt;= 70:\n    return \"C\"\nelif 80 &gt;= 60:\n    return \"D\"\nelse:\n    return \"F\"\nلاحظ أن نتيجة السطرين بحسب الظرفين المختلفين:\n\nprint(calculate_grade(95))\nprint(calculate_grade(80))\n\nA\nB",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#تمرير-العوامل-بالاسم",
    "href": "chapters/08_procedural/a2_procedural.html#تمرير-العوامل-بالاسم",
    "title": "12  البرمجة الإجرائية",
    "section": "تمرير العوامل بالاسم",
    "text": "تمرير العوامل بالاسم\nقد تكون العوامل كثيرة في الإجراء على النحو التالي:\n\ndef weather_condition(temperature, humidity, wind_speed):\n    if temperature &gt;= 30 and humidity &gt;= 60 and wind_speed &gt;= 10:\n        return \"Rainy\"\n    elif temperature &gt;= 20 and humidity &gt;= 50 and wind_speed &gt;= 5:\n        return \"Cloudy\"\n    elif temperature &gt;= 10 and humidity &gt;= 30 and wind_speed &gt;= 0:\n        return \"Sunny\"\n    return \"Normal\"\n\nويكون طلبها بالطريقتين كما تقدَّم، بالموضع أو بالاسم. ولاحظ أن التمرير بالاسم يجوز فيه تبديل الترتيب، وأما القيمة التي تمرر بالموضع فلا بد أن تكون في الموضع.\n\ncond = weather_condition(30, wind_speed=10, humidity=60)\n\nif cond == \"Rainy\":\n    print(\"Don't forget your umbrella!\")\n\nDon't forget your umbrella!",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#العوامل-الجائزة",
    "href": "chapters/08_procedural/a2_procedural.html#العوامل-الجائزة",
    "title": "12  البرمجة الإجرائية",
    "section": "العوامل الجائزة",
    "text": "العوامل الجائزة\nالأصل في العوامل المعرَّفة الوجوب؛. فلو أهملت أحدها فإنك ستواجه بالخطأ:\n\ndef weather_condition(temperature, humidity, wind_speed):\n    pass\n\nweather_condition(30)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[26], line 4\n      1 def weather_condition(temperature, humidity, wind_speed):\n      2     pass\n----&gt; 4 weather_condition(30)\n\nTypeError: weather_condition() missing 2 required positional arguments: 'humidity' and 'wind_speed'\n\n\n\nتقول رسالة الخطأ (السطر الأخير) أن الإجراء يفتقد عاملين موضعيين إلزاميين، وهما: humidity و wind_speed.\nفلو أردنا أن يكون عمل الإجراء بحسب أحد العوامل بالتعيين، على نحو:\n\nلو عينت السلزيوس فالتحويل لفهرنهايت: convert_temperature(celsius=32)\nلو عينت الفهرنهايت فالتحويل لسلزيوس: convert_temperature(fahrenheit=89.6)\n\nوإليك معادلة التحويل بين نوعيْ درجة الحرارة:\n\\[\nF = \\frac{9}{5} C + 32\n\\]\nفأي عامل نعرفه بقيمة ابتدائية فإن بايثون تعتبره اختياريًّا، ولو بالقيمة العدميَّة None. فنعرِّفُ العوامل بقيَم عدميَّة، ونفحص وجودها بالشرط is not None لنُعمِلَها أو نهملها:\n\ndef convert_temperature(celsius = None, fahrenheit = None):\n    if celsius is not None:\n        fahrenheit = (9 / 5) * celsius + 32\n        return fahrenheit\n    elif fahrenheit is not None:\n        celsius = (fahrenheit - 32) * (5 / 9)\n        return celsius\n\nنتأكد:\n\nassert convert_temperature(celsius=32) == 89.6\nassert convert_temperature(fahrenheit=89.6) == 32",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#نطاق-التسمية",
    "href": "chapters/08_procedural/a2_procedural.html#نطاق-التسمية",
    "title": "12  البرمجة الإجرائية",
    "section": "نطاق التسمية",
    "text": "نطاق التسمية\nومن خصائصها أن المتغيرات في الداخل لا تظهر للخارج.\n\ndef calculate_bmi(weight: float, height: float) -&gt; float:\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\n\nفنتوقع وقوع خطأ هنا لأن bmi غير معرفة إلا في نطاق الإجراء:\n\nprint(bmi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[30], line 1\n----&gt; 1 print(bmi)\n\nNameError: name 'bmi' is not defined\n\n\n\nتقول رسالة الخطأ (السطر الأخير) أن المتغير bmi غير معرَّف. وهذا منطقي لأن النطاق الخارجي لا يعلم ما تكنه النطاقات الداخلية الخاصة بالإجراءات. وهو أمر مطلوب جدًّا ومرغوب في البرمجة. وذلك يعني أننا لن نتعب كثيرًا في اختيار الأسماء داخل كل إجراء، مخافة التعارض.\n\nعوامل غير مصرح بها\nوعلى العكس فإن المعرَّفات الخارجة معروفة في الداخل؛ وذلك يعني أنها يمكن أن تعمل في الإجراء بشكل غير مباشر. أي أنها عوامل غير مصرَّح بها (هو: max_length في هذا المثال):\n\nmax_length = 8\n\ndef check_password_strength(password: str) -&gt; str:\n    if len(password) &gt; max_length:\n        return \"strong\"\n    elif len(password) &gt; max_length // 2:\n        return \"medium\"\n    return \"weak\"\n\n\n\nمستويات نطاق التسمية\n\n\n\nمستويات نطاق التسمية\n\n\nمستويات النطاقات (Scopes) من الداخل إلى الخارج:\n\nالنطاق المحلي (Local Scope): المتغيرات المعرفة داخل إجراء.\nالنطاق المحيط (Enclosing Scope): المتغيرات المعرفة في إجراء يتحوي ذلك الإجراء.\nالنطاق العام (Global Scope): المتغيرات المعرفة خارج جميع الإجراءات.\nالنطاق المدمج (Built-in Scope): الإجراءات المدمجة في بايثون مثل print().\n\nنصيحة: اجعل الاستعمال تاليًا لأخص نطاق؛ تَسْلَم. فهو كاستعمال الضمائر في اللغة: لا نحب أن تبعُد عما أُبدلت عنه إذ ذلك مظنَّة الإبهام. لكن قد يكون من المعرَّفات ما هو ثابت ومعمولٌ به في كل مكان. فهو أشبه بالإعدادات أو الضبط للبرنامج كله. ومثل ذلك الأليق فيه أن يكون في نطاقٍ أعم.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#ثمرة-الإجراء",
    "href": "chapters/08_procedural/a2_procedural.html#ثمرة-الإجراء",
    "title": "12  البرمجة الإجرائية",
    "section": "ثمرة الإجراء",
    "text": "ثمرة الإجراء\nتُخرج الإجراءات نتائج معالجتها بإحدى طريقتين:\nالأولى: الرجوع: حيث ترجِع النتيجة بجملة return لموضع طلب الإجراء، وغالبًا ما يتم تعيينه لمتغير، نحو: y = sqrt(x).\nالثانية: المفعول: نحو: list.sort(xs) حيث يعدِّل الإجراء العامل الذي تم تمريره إليه؛ ولذلك نسميه مفعولا به.\nوذلك مثل print() فإن أحد عواملها غير مذكور (وهو المفعول)، وهو: file=sys.stdout ولأجله تكتب النتيجة على الشاشة.\n\nالإجراء الخاوي\nوالإجراء دائمًا يرجع بنهاية آخر جملة فيه، لكن الذي لا يصرَّحُ فيه بكلمة الرجوع return تُقدَّر له القيمة العدمية: None ويسمى الإجراء حنيها خاويًا (void).\nفائدة: إذا رأيت إجراءً خاويًا فاعلم أن له مفعولاً، سواء من عوامله المباشرة أو غير المباشرة. والسبب في ذلك أنه لا بد للإجراء من أن يُثمر، وإلا فالإجراء الذي ليس له أثر، فإن وجوده كعدمه.\nتأمل المثال التالي الذي يأخذ عوامل ثم لا يرجع بشيء، لكنه يُظهر النتيجة على الشاشة:\n\ndef print_decorated(message: str, n: int):\n    print(\"=\" * n)\n    print(message)\n    print(\"=\" * n)\n\nprint_decorated(\"Salam alykom\", 15)\n\n===============\nSalam alykom\n===============",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a2_procedural.html#إطلاق-عدد-العوامل",
    "href": "chapters/08_procedural/a2_procedural.html#إطلاق-عدد-العوامل",
    "title": "12  البرمجة الإجرائية",
    "section": "إطلاق عدد العوامل",
    "text": "إطلاق عدد العوامل\nقد تتساءل كيف تعمل print وهي تأخذ عددًا لا محدودًا من العوامل؟ حتى نجيب عن ذلك ننظر في عملية فك الأقواس وهي علامة النجمة * قبل المتغيِّر المشير لمجموعة، على النحو التالي:\n\nxs = [10, 20, 30]\nprint(xs)\nprint(*xs)\n\n[10, 20, 30]\n10 20 30\n\n\nلاحظ الفرق بين الطلب الأول والثاني:\n\nالأوَّل يطبع المتغير xs ككل، أي: كقائمة من ثلاثة أعناصر\nيُمرر واحدًا تلوَ الآخر للإجراء print بعد فك الأقواس كأنك كتبت: print(10, 20, 30)\n\nوحين تستعمل علامة النجمة في تعريف عوامل الإجراء، فإن أي عامل موضعي زائد عن العدد، يكونُ فيه كصفّ (وسيأتي الكلام عن الصف في باب المجموعة المرتبة). وبالمثال يتضح المقال. وقد اصطُلح على تسميته args وهي اختصار كلمة Arguments:\n\ndef show(a, *args):\n    print(a)\n    print(type(args), args)\n    print('print:', *args)\n\nshow(1, 2, 3, 4, 5)\n\n1\n&lt;class 'tuple'&gt; (2, 3, 4, 5)\nprint: 2 3 4 5\n\n\nوكذلك العوامل المعيَّنة بالاسم، لكن بالنجمتين ** وتكون قاموسًا (وسيأتي الكلام عنه في باب المجموعة المرقمة) ومعنى الكلمة kwargs هو: Keyword Arguments:\n\ndef show(a, **kwargs):\n    print(a)\n    print(type(kwargs), kwargs)\n    print('print:', *kwargs)\n\nshow(a=1, b=2, c=3, d=4, e=5)\n\n1\n&lt;class 'dict'&gt; {'b': 2, 'c': 3, 'd': 4, 'e': 5}\nprint: b c d e\n\n\nوقد يجتمعان في نفس الإجراء *args و **kwargs نحو:\n\ndef show(x, y, *args, **kwargs):\n    print(x, y)\n    print(type(args), args)\n    print(type(kwargs), kwargs)\n\nshow(1, 2, 3, 4, 5, a=1, b=2, c=3)\n\n1 2\n&lt;class 'tuple'&gt; (3, 4, 5)\n&lt;class 'dict'&gt; {'a': 1, 'b': 2, 'c': 3}\n\n\nولا بد من تقديم الموضعية قبل الاسمية.\nللمزيد راجع العوامل الخاصة.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>البرمجة الإجرائية</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a3_modules.html",
    "href": "chapters/08_procedural/a3_modules.html",
    "title": "13  الاستيراد والتصدير",
    "section": "",
    "text": "تثبيت حزم\nعندما يكبر النص البرمجي ويتعقد، نلجأ لتقسيمه في ملفات منفصلة تؤدي كل منها وظيفة محددة. وذلك حتى يسهل فهم البرنامج، ويسهل التعديل عليه والإضافة.\nأو قد نرى أن جزءًا من النص البرمجي يستحق الاستعمال في مشروع آخر، فنريد أن نلفَّه في حزمة، ونصدِّره ليكون قابلاً للتثبيت في مشاريع أخرى.\nهاتان الحالتان تستوجبان أن نتعرف على مصطلحين في بايثون: الوحدة والحزمة.\nالوِحدة (Module) هي النص البرمجي في الملف الواحد (مثل: script.py)\nالحزمة (Package) هي مجموعة مكوَّنة من وِحدة أو أكثر؛ وتُعرَّف: بمجلَّد يكون فيه ملف خاص باسم __init.py__ ويوضع فيه النص البرمجي المنشئ الذي يعمل عند فعل استيراد الحزمة بالكلمة import (في المرة الأولى فقط).\nفيما يلي مثال يوضِّح ترتيب حزمة ما (my_package) مكوَّنة من حزم مضمَّنة، وفي المستوى الأخير نرى الوحدات، على النحو التالي:\nدعنا نلقي نظرة على عمليات الاستيراد واحدة تلو الأخرى، انظر (main.py):\nأولاً، لاحظ أن فعل الاستيراد import my_package يحدد حزمة لا وِحدة. وبالتالي، سينفذ الملف __init__.py، الذي يحتوي على عبارات تعيين (مثل __version__، وDEFAULT_TIMEOUT، وما إلى ذلك) سترتبط بمعرف my_package، ويمكن الوصول إليها باستخدام النقطة (.).\nثانيًا لاحظ العبارة: from my_package.pkg1 import module_a فهي تحدد وحدة (module_a)، وبالتالي، يتم تنفيذ جميع التعليمات البرمجية في module_a.py والتعيينات تُسنَد للمعرف module_a ويمكن الوصول إليها باستخدام النقطة (.).\nثالثًا استيراد مباشر للإجراء func_a من وحدة module_a في الحزمة الفرعية pkg2.\nأخيرًا الصيغة from ... import * تستورد جميع (*) الأسماء من الوحدة النمطية (باستثناء تلك التي تبدأ بـ بالشرطتين السفليتين: __) إلى نطاق التسمية الحالي (في الوحدة التي نحن فيها). بشكل عام، لا ننصح باستعمال هذه الطريقة، حيث قد تؤدي إلى إلغاء أسماء سبق تعريفها لتحل مكانها هذه الأسماء الجديدة، ولكن لا بأس بها لتقليل جهد الكتابةخصوصًا في الجلسات التفاعلية.\nحين لا تجد بايثون اسم الحزمة حاضرًا، فإنها تلجأ إلى البحث في الحزم التي تم تنزيلها وتثبيتها. ولأننا نستعمل uv حيث هو مدير حزم يحافظ على خصوصية الحزم المثبتة لكل مشروع بشكل منفصل، فإننا سنجدها داخل .venv/، وتحديدًا داخل المجلد: .venv/lib/python3.12/site-packages (في حال كنا نستعمل الإصدار 3.12 من بايثون).\nلتثبيت حزمة من قاعدة بيانات الحزم PyPI نستعمل أداة uv على النحو التالي:\nأولاً باستعمال أداة uv:\nوبعد تثبيت الحزمة ، نستوردها هكذا ونستعملها:\nimport numpy as np\n\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nprint(np.dot(a, b))\n\n32\nوستجد أن حزمة numpy أصبحت في هذا المجلد: .venv/lib/python3.12/site-packages/numpy",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>الاستيراد والتصدير</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a3_modules.html#تثبيت-حزم",
    "href": "chapters/08_procedural/a3_modules.html#تثبيت-حزم",
    "title": "13  الاستيراد والتصدير",
    "section": "",
    "text": "uv add numpy",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>الاستيراد والتصدير</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a4_recursion.html",
    "href": "chapters/08_procedural/a4_recursion.html",
    "title": "14  الإجراء المتسلسل",
    "section": "",
    "text": "مثال: المضروب\nالإجراء المتسلسل (Recursive Function): هو إجراء يطلب نفسه؛ بشكل مباشر أو غير مباشر. وحتى يكون مثمرًا: يجب أن تؤول سلسلة الطلبات هذه إلى جملة تُنهي التسلسل.\nفمثلا: تعرف الرياضيات مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots(1)\n\\]\nفهي عملية ضرب لكل عدد مع الذي قبله حتى ينتهي للواحد. ونمثل هنا لمضروب العدد 5:\n\\[\n!5 = (5)(4)(3)(2)(1) = 120\n\\]\nولك أن تصف نفس العملية هكذا:\n\\[\n!n = n !(n-1)\n\\]\nأي أن مضروب العدد هو ضربُ هذا العدد في مضروب العدد الذي قبله. وذلك يتسلسل على النحو التالي:\n\\[\n\\begin{align*}\n!5 &= (5)!(4) \\\\\n   &= (5)(4!(3)) \\\\\n   &= (5)(4(3!(2))) \\\\\n   &= (5)(4(3(2!(1)))) \\\\\n   &= (5)(4(3(2(1)))) \\\\\n   &= (5)(4)(3)(2)(1) \\\\\n   &= 120\n\\end{align*}\n\\]\nإذاً نعرِّف المعادلة في بايثون هكذا:\ndef factorial(n: int) -&gt; int:\n    # Recursive case (تسلسل)\n    if n &gt; 0:\n        recursive_result = factorial(n - 1)\n        return n * recursive_result\n    # Terminal case (نهاية)\n    return 1\n\nfactorial(5)\n\n120\nحيث لدينا حالتان:\nوهنا قطعة نص برمجي نستعملها لتصور تسلسل الطلبات:\nالكود\ndef factorial(n: int, depth: int = 0) -&gt; int:\n\n    # Recursive case (تسلسل)\n    print(f\"{'  ' * depth}Call factorial({n})\")\n    if n &gt; 0:\n        result = n * factorial(n - 1, depth + 1)\n        print(f\"{'  ' * depth}Return {result} from factorial({n})\")\n        return result\n    \n    # Terminal case (نهاية)\n    print(f\"{'  ' * depth}Return 1 from factorial({n})\")\n    return 1\n\nfactorial(5)\n\n\nCall factorial(5)\n  Call factorial(4)\n    Call factorial(3)\n      Call factorial(2)\n        Call factorial(1)\n          Call factorial(0)\n          Return 1 from factorial(0)\n        Return 1 from factorial(1)\n      Return 2 from factorial(2)\n    Return 6 from factorial(3)\n  Return 24 from factorial(4)\nReturn 120 from factorial(5)\n\n\n120\nطلب الإجراء المتسلسل يؤدي إلى ظروف متداخلة تؤول إلى ظرف واحد في النهاية.\nيستعمل الإجراء المتسلسل وكذلك هياكل البيانات المتسلسلة بشكل كبير في الخوارزميات الفعالة.\nيسهل كتابة بعض الخوارزميات باستعمال الإجراء المتسلسل. لكن قد تكون (أحياًنا) أقل أداءً من استعمال الحلقات.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الإجراء المتسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/a4_recursion.html#مثال-المضروب",
    "href": "chapters/08_procedural/a4_recursion.html#مثال-المضروب",
    "title": "14  الإجراء المتسلسل",
    "section": "",
    "text": "عندما تكون n &gt; 0 يتم الطلب الذاتي : recursive_result = factorial(n - 1) إذْ هي جملة متسلسلة تكدِّس طلبات فوق طلبات؛ لكنها تؤول في النهاية إلى الجملة التي تُنهي التسلسل\nreturn 1 هي الجملة التي تنهي التسلسل\n\n\n\n\nفكل طلب يُنشأ له ظرف تنفيذ جديد تكون بالنسبة له قيمة n هي المعيَّنة له وقت النداء.\nوهكذا يتم تكديس الطلبات حتى ينتهي التسلسل عند الطلب factorial(0) الذي يؤول لنتيجة مباشرة: return 1 فيخلَّى هذا الظرف من الذاكرة وتعود نتيجته إلى الظرف المباشر الذي استدعاه وهو ظرف factorial(1).\nفتتعين القيمة recursive_result = 1 وينتقل إلى الجملة التي بعدها وهي جملة الرجوع بنتيجة return n * recursive_result وهُما معيَّنان، أي تكون الجملة في واقع الظرف: return 1 * 1.\nوهذه النتيجة تعود للظرف الذي استدعاه وهو factorial(2) … إلخ.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الإجراء المتسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html",
    "href": "chapters/08_procedural/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "طول الخط المستقيم بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nوتذكر أن:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\ndef euclidean_distance(x1: float, y1: float, x2: float, y2: float) -&gt; float:\n    return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5\n\nprint(euclidean_distance(x1=0, y1=0, x2=3, y2=4))\nprint(euclidean_distance(1, 1, -2, -2))\n\n5.0\n4.242640687119285",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#تجزئة-البيانات",
    "href": "chapters/08_procedural/apps.html#تجزئة-البيانات",
    "title": "تطبيقات",
    "section": "تجزئة البيانات",
    "text": "تجزئة البيانات\nهذا الإجراء يقسم قائمة إلى جزئين بنسبة محددة:\n\ndef split(data: list, ratio: float) -&gt; tuple[list, list]:\n    idx = int(len(data) * ratio)\n    return data[:idx], data[idx:]\n\nنختبر الإجراء ونلاحظ أن الناتج من نوع صف (tuple). فنستعمل التعيين المتعدد لاستخراج القيم من الصف:\n\nxs = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\na, b = split(xs, 0.80)\n\nassert a == [10, 20, 30, 40, 50, 60, 70, 80]\nassert b == [90, 100]",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#سحب-الرصيد",
    "href": "chapters/08_procedural/apps.html#سحب-الرصيد",
    "title": "تطبيقات",
    "section": "سحب الرصيد",
    "text": "سحب الرصيد\nنريد أن نعرف إجراء سحب الرصيد لأي مستخدم ولأي جهاز صراف آلي ولأي مبلغ:\n\nأولاً، تأكد من وجود رصيد كافٍ لدى المستخدم.\nإذا كان الأمر كذلك، فتأكد من وجود رصيد كافٍ في جهاز الصراف الآلي لصرف المبلغ المطلوب.\n\n\ndef withdraw_cash(balance, amount, atm_cash):\n    if balance &gt;= amount:\n        if atm_cash &gt;= amount:\n            balance -= amount\n            atm_cash -= amount\n            print(\"Withdrawal successful!\")\n        else:\n            print(\"ATM does not have enough cash.\")\n    else:\n        print(\"Insufficient balance.\")\n\nwithdraw_cash(500, 200, 1000)\nwithdraw_cash(500, 200, 100)\nwithdraw_cash(500, 600, 1000)\n\nWithdrawal successful!\nATM does not have enough cash.\nInsufficient balance.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#الكلمة-المتناظرة",
    "href": "chapters/08_procedural/apps.html#الكلمة-المتناظرة",
    "title": "تطبيقات",
    "section": "الكلمة المتناظرة",
    "text": "الكلمة المتناظرة\nفي هذا المثال نوضح استعمال مؤشرين على نفس النص لمعرفة ما إذا كانت الكلمة متناظرة:\n\nالمؤئر الأول بإصبعك الأيمن: i يبدأ من أول حرف وينتهي عند المنتصف\nالمؤئر الثاني بإصبعك الأيسر: j يبدأ من آخر حرف وينتهي عند المنتصف\n\n\ndef is_palindrome(word):\n    \"\"\"\n    A palindrome word is one that can be read the same way from both ends.\n    \"\"\"\n\n    # إزالة الاختلافات في الحروف الكبيرة والصغيرة\n    word = word.lower()\n    \n    # إزالة الفواصل (لتطابق الكلمات مثل: \"Race car\")\n    word = word.replace(\" \", \"\")\n\n    # التحقق من أن الكلمة متناظرة\n    for i in range(len(word) // 2):\n        j = len(word) - i - 1\n        if word[i] != word[j]:\n            return False\n    return True\n\n# الاختبارات\nassert is_palindrome(\"radar\")\nassert is_palindrome(\"level\") \nassert is_palindrome(\"madam\")\nassert is_palindrome(\"توت\")\nassert is_palindrome(\"خوخ\")\nassert is_palindrome(\"Race car\")\nassert is_palindrome(\"حصان ناصح\")\nassert not is_palindrome(\"python\")\n\nبدل الحلقة، وكان لنا أن نكتب باختصار: word == word[::-1] وهي تعني أن النص متناظر إذا كان مساوياً لنفسه بالمقلوب.\n\ndef is_palindrome(word):\n    word = word.lower()\n    word = word.replace(\" \", \"\")\n    return word == word[::-1]",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/apps.html#تصحيح-الإملاء",
    "href": "chapters/08_procedural/apps.html#تصحيح-الإملاء",
    "title": "تطبيقات",
    "section": "تصحيح الإملاء",
    "text": "تصحيح الإملاء\nاكتب فعلًا يصحح الإخطاء الشائعة في الإملاء العربي.\n\nإبدال التاء المربوطة بالهاء: مكتبه، لعبه، روايه\nإبدال الظاء بالضاد والعكس: ظابط، قرظ، ضهر\nزيادة الياء: أحسنتي، رأيتكي\n\nوالمطلوب فقط تصحيح الأخطاء المذكورة.\n\ncorrections_map = {\n    'مكتبه': 'مكتبة',\n    'لعبه': 'لعبة',\n    'روايه': 'رواية',\n    'ظابط': 'ضابط',\n    'قرظ': 'قرض',\n    'ضهر': 'ظهر',\n    'أحسنتي': 'أحسنت',\n    'رأيتكي': 'رأيتك',\n}\n\ndef correct_spelling(sentence: str) -&gt; str:\n    words = sentence.split()\n    result = []\n    for word in words:\n        al = word.startswith('ال')\n        if al:\n            word = word[2:]\n        correction = corrections_map.get(word, word)\n        if al:\n            correction = 'ال' + correction\n        result.append(correction)\n    return ' '.join(result)\n\n\nassert (\n    correct_spelling('المكتبه فيها الروايه التي أبحث عنها') ==\n    'المكتبة فيها الرواية التي أبحث عنها'\n)\n\nassert (\n    correct_spelling('أعطاك الظابط القرظ بعد الضهر') ==\n    'أعطاك الضابط القرض بعد الظهر'\n)\n\nassert (\n    correct_spelling('رأيتكي أحسنتي') == 'رأيتك أحسنت')",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html",
    "href": "chapters/08_procedural/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "حساب العمر\nاكتب إجراء يحسب عمرك في أي سنة معينة.\ndef age_at(age_now: int, current_year: int, at_year: int) -&gt; int:\n    pass # اكتب هنا بدل كلمة pass\n\nprint(age_at(0, 2000, 2010)) # بعد الولادة\nprint(age_at(20, 2000, 2010)) # في المستقبل\nprint(age_at(20, 2000, 1995)) # في الماضي\n\nNone\nNone\nNone",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html#حساب-الأجر",
    "href": "chapters/08_procedural/problems.html#حساب-الأجر",
    "title": "مسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\nعرِّف الإجراء الذي يحسب الأجر بعاملين:\n\nhours: float: عدد الساعات التي يعملها الموظف\nper_hour_rate: float: سعر الساعة الواحدة\n\nواجعل نوع العائد float كذلك باستعمال -&gt; float.\n\n# اكتب الإجراء هنا\n\nثم اختبر الإجراء باستعمال جمل توكيدية: assert.",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html#توحيد-الصيغة",
    "href": "chapters/08_procedural/problems.html#توحيد-الصيغة",
    "title": "مسائل",
    "section": "توحيد الصيغة",
    "text": "توحيد الصيغة\nفي هذا المثال، تعود هذه النصوص كلها إلى نفس المعنى.\n\n(‘medina’, ‘madinah’, ‘madina’, ‘al madinah’, ‘al madina’, ‘medina’, ‘madinah’, ‘madina’, ‘المدينة’, ‘مدينة’),\n(‘mecca’, ‘makkah’, ‘makka’, ‘makkah’, ‘makkah’, ‘مكة’, ‘مكه’),\n\nالمطلوب إنشاء قاموس بحيث لو أعطيته أحد هذه الكلمات كمفتاح، فإنها جميعًا تؤول إلى صيغة موحدة:\n\ndef normalize_city_name(city_name: str) -&gt; str:\n    pass # اكتب جسد الإجراء هنا\n\nassert (\n    'madinah' ==\n    normalize_city_name('المدينة') ==\n    normalize_city_name('al madinah') ==\n    normalize_city_name('medina')\n)\n\nassert (\n    'makkah' ==\n    normalize_city_name('مكة') ==\n    normalize_city_name('makkah') ==\n    normalize_city_name('makka') ==\n    normalize_city_name('mecca')\n)",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/problems.html#حساب-الجمل",
    "href": "chapters/08_procedural/problems.html#حساب-الجمل",
    "title": "مسائل",
    "section": "حساب الجُمَّل",
    "text": "حساب الجُمَّل\n\nحِسَاب الجُمَّل وهو حساب استخدم في اللغات السامية؛ حيث نجده مستعملًا في بلاد الهند قديمًا، وعند اليهود؛ فالأبجدية العبرية تتطابق مع الأبجدية العربية حتى حرف التاء (أبجد، هوز، حطي، كلمن، سعفص، قرشت) أي تتكون من 22 حرفا وتزيد العربية: (ثخذ، ضظغ). واستخدمه المسلمون في تثبيت التاريخ. لكل حرف مدلول رقمي يبدأ بالرقم 1 وينتهي عند الرقم 1000.\n\n\n\n\nحساب الجمَّل\n\n\n\n\n\n\n\n\n\n\n\nا\n1\nي\n10\nق\n100\nغ\n1000\n\n\nب\n2\nك\n20\nر\n200\nبغ\n2000\n\n\nجـ\n3\nل\n30\nش\n300\nجغ\n3000\n\n\nد\n4\nم\n40\nت\n400\nدغ\n4000\n\n\nهـ\n5\nن\n50\nث\n500\nهغ\n5000\n\n\nو\n6\nس\n60\nخ\n600\nوغ\n6000\n\n\nز\n7\nع\n70\nذ\n700\nزغ\n7000\n\n\nح\n8\nف\n80\nض\n800\nحغ\n8000\n\n\nط\n9\nص\n90\nظ\n900\nطغ\n9000\n\n\n\nاكتب تفاصيل الإجراء الذي يحسب الجمَّل لكلمة معينة.\ndef gematria(word: str) -&gt; int:\n    pass\nفإذا أرادوا كتابة الرقم (1240) كتبوا «غرم»، لأن الغين 1,000، والراء 200، والميم 40، فكانوا يراعون عند تركيب الجُمّل أن يكون الحرف المعبر عن العدد الأكبر في المقدمة، ثم يليه الأصغر منه وهكذا دواليك فنجد من الأمثلة على ذلك:\nassert gematria('غرم') == 1240\nassert gematria('رب') == 202\nassert gematria('ريح') == 218\nassert gematria('شعب') == 372\nيقال أنه عندما توفي السلطان الظاهر برقوق أول سلاطين المماليك البرجية، قام بعض الظرفاء بصياغة عبارة تحدد تاريخ وفاته فقال: «وفاة برقوق في المشمش»، وعندما نحسب تاريخ وفاة برقوق وهي «في المشمش» يكون الناتج:\n(80+10+1+30+40+300+40+300) = 801، وبالتالي فتكون العبارة: «وفاة برقوق 801» هجرية وذلك صحيح.\nassert gematria('في المشمش') == 801 == 80+10+1+30+40+300+40+300\nيقال أيضاً أن شاعراً يسمى الدّلنجاوي مات فرثاه صديق له فقال:\n\n\n\nسألتُ الشّعرَ هل لكَ من صديقٍ\nوقد سكنَ الدّلنجاويّ لحــده\n\n\nفصاحَ وخرّ مغشياً عليــــه\nوأصبح راقداً في القبر عنــده\n\n\nفقلتُ لمن يقول الشعر أقْصِــر\nلقد أرّختُ: مات الشعرُ بعـده\n\n\n\nويتضح لنا أن تاريخ الوفاة يكون في معرفة حساب العبارة «مات الشعرُ بعدَهُ»، فيكون الحساب:\n(40+1+400+1+30+300+70+200+2+70+4+5) = (1123)، وذلك يعني أن الشاعر الدلنجاوي توفي في عام 1123 للهجرة.\nassert gematria('مات الشعر بعده') == 1123 == 40+1+400+1+30+300+70+200+2+70+4+5",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html",
    "href": "chapters/08_procedural/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "حساب العمر\nاكتب إجراء يحسب عمرك في أي سنة معينة.\ndef age_at(age_now: int, current_year: int, at_year: int) -&gt; int:\n    return age_now + (at_year - current_year)\n    \n\nprint(age_at(0, 2000, 2010)) # بعد الولادة\nprint(age_at(20, 2000, 2010)) # في المستقبل\nprint(age_at(20, 2000, 1995)) # في الماضي\n\n10\n30\n15",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#حساب-الأجر",
    "href": "chapters/08_procedural/solutions.html#حساب-الأجر",
    "title": "حل المسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\nعرِّف الإجراء الذي يحسب الأجر بعاملين:\n\nhours: float: عدد الساعات التي يعملها الموظف\nper_hour_rate: float: سعر الساعة الواحدة\n\nواجعل نوع العائد float كذلك باستعمال -&gt; float.\n\ndef salary(hours: float, per_hour_rate: float) -&gt; float:\n    return hours * per_hour_rate\n\nثم اختبر الإجراء باستعمال جمل توكيدية: assert.\n\nassert salary(6, 30) == 180\nassert salary(per_hour_rate=50, hours=10) == 500",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#توحيد-الصيغة",
    "href": "chapters/08_procedural/solutions.html#توحيد-الصيغة",
    "title": "حل المسائل",
    "section": "توحيد الصيغة",
    "text": "توحيد الصيغة\nفي هذا المثال، تعود هذه النصوص كلها إلى نفس المعنى.\n\n(‘medina’, ‘madinah’, ‘madina’, ‘al madinah’, ‘al madina’, ‘medina’, ‘madinah’, ‘madina’, ‘المدينة’, ‘مدينة’),\n(‘mecca’, ‘makkah’, ‘makka’, ‘makkah’, ‘makkah’, ‘مكة’, ‘مكه’),\n\nالمطلوب إنشاء قاموس بحيث لو أعطيته أحد هذه الكلمات كمفتاح، فإنها جميعًا تؤول إلى صيغة موحدة:\nأولاً نعرّف قاموسًا يحول جميع التصريفات إلى نفس الصيغة:\n\ncity_map = {\n    'medina': 'madinah',\n    'madinah': 'madinah',\n    'madina': 'madinah',\n    'al madinah': 'madinah', \n    'al madina': 'madinah',\n    'المدينة': 'madinah',\n    'مدينة': 'madinah',\n\n    'mecca': 'makkah',\n    'makkah': 'makkah',\n    'makka': 'makkah',\n    'مكة': 'makkah',\n    'مكه': 'makkah',\n}\n\n\nنعرف الإجراء بأنه يأخذ نصًّا str ويُنتج نصًّا str آخر.\nولأن الحروف الإنجليزية قد تحوي أحرفًا كبيرة، فإننا نحولها جميعًا إلى صيغة صغيرة: .lower()\nوأخيرًا نستعمل هذا النص كمفتاح لنسحب القيمة؛ الصيغة الموحَّدة\n\n\ndef normalize_city_name(city_name: str) -&gt; str:\n    text = city_name.lower()\n    return city_map[text]\n\nنختبر الإجراء باستعمال جمل توكيدية: assert.\n\nassert (\n    'madinah' ==\n    normalize_city_name('المدينة') ==\n    normalize_city_name('al madinah') ==\n    normalize_city_name('medina')\n)\n\nassert (\n    'makkah' ==\n    normalize_city_name('مكة') ==\n    normalize_city_name('makkah') ==\n    normalize_city_name('makka') ==\n    normalize_city_name('mecca')\n)",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#حساب-الجمل",
    "href": "chapters/08_procedural/solutions.html#حساب-الجمل",
    "title": "حل المسائل",
    "section": "حساب الجُمَّل",
    "text": "حساب الجُمَّل\n\nحِسَاب الجُمَّل وهو حساب استخدم في اللغات السامية؛ حيث نجده مستعملًا في بلاد الهند قديمًا، وعند اليهود؛ فالأبجدية العبرية تتطابق مع الأبجدية العربية حتى حرف التاء (أبجد، هوز، حطي، كلمن، سعفص، قرشت) أي تتكون من 22 حرفا وتزيد العربية: (ثخذ، ضظغ). واستخدمه المسلمون في تثبيت التاريخ. لكل حرف مدلول رقمي يبدأ بالرقم 1 وينتهي عند الرقم 1000.\n\n\n\n\nحساب الجمَّل\n\n\n\n\n\n\n\n\n\n\n\nا\n1\nي\n10\nق\n100\nغ\n1000\n\n\nب\n2\nك\n20\nر\n200\nبغ\n2000\n\n\nجـ\n3\nل\n30\nش\n300\nجغ\n3000\n\n\nد\n4\nم\n40\nت\n400\nدغ\n4000\n\n\nهـ\n5\nن\n50\nث\n500\nهغ\n5000\n\n\nو\n6\nس\n60\nخ\n600\nوغ\n6000\n\n\nز\n7\nع\n70\nذ\n700\nزغ\n7000\n\n\nح\n8\nف\n80\nض\n800\nحغ\n8000\n\n\nط\n9\nص\n90\nظ\n900\nطغ\n9000\n\n\n\nاكتب تفاصيل الإجراء الذي يحسب الجمَّل لكلمة معينة.\nأولاً نعرّف قاموسًا يحول الحروف إلى أرقام:\n\ngematria_map = {\n    'ا': 1, 'ي': 10, 'ق': 100, 'غ': 1000,\n    'ب': 2, 'ك': 20, 'ر': 200, 'بغ': 2000,\n    'ج': 3, 'ل': 30, 'ش': 300, 'جغ': 3000,\n    'د': 4, 'م': 40, 'ت': 400, 'دغ': 4000,\n    'ه': 5, 'ن': 50, 'ث': 500, 'هغ': 5000,\n    'و': 6, 'س': 60, 'خ': 600, 'وغ': 6000,\n    'ز': 7, 'ع': 70, 'ذ': 700, 'زغ': 7000,\n    'ح': 8, 'ف': 80, 'ض': 800, 'حغ': 8000,\n    'ط': 9, 'ص': 90, 'ظ': 900, 'طغ': 9000,\n}\n\nثم نعرّف الإجراء بأنه يأخذ نصًّا str ويُنتج رقمًا int:\n\ndef gematria(word: str) -&gt; int:\n    total = 0\n    for i in range(0, len(word), 2):\n        pair = word[i:i+2]\n        if pair in gematria_map:\n            total += gematria_map[pair]\n        else:\n            a, b = pair\n            if a in gematria_map:\n                total += gematria_map[a]\n            if b in gematria_map:\n                total += gematria_map[b]\n    return total\n\n\nيبدأ الحساب بمتغير total يساوي 0\nنأتي على الكلمة حرفين ثم ننتقل منهما إلى الحرفين التاليين (وذلك بتحديد حجم الخطوة: 2) for i in range(0, len(word), 2)\nنقرأ الحرفين معًا: pair = word[i:i+2] من الموضع i إلى الموضع i+2؛ فهذه شريحة مكوَّنة من نص فيه حرفان\nإذا كان هذ الزوج موجودًا في القاموس gematria_map، فإننا نضيف قيمته إلى المتغير total\nفإن لم يكن موجودًا فإننا نعتبر كل حرفٍ على حدة: a, b = pair\nفإن كان الأول موجودًا في القاموس فإننا نضيف قيمته إلى المتغير total\nوإن كان الثاني موجودًا في القاموس فإننا نضيف قيمته إلى المتغير total\nوأخيرًا نعيد المتغير return total\n\nفإذا أرادوا كتابة الرقم (1240) كتبوا «غرم»، لأن الغين 1,000، والراء 200، والميم 40، فكانوا يراعون عند تركيب الجُمّل أن يكون الحرف المعبر عن العدد الأكبر في المقدمة، ثم يليه الأصغر منه وهكذا دواليك فنجد من الأمثلة على ذلك:\n\nassert gematria('غرم') == 1240\nassert gematria('رب') == 202\nassert gematria('ريح') == 218\nassert gematria('شعب') == 372\n\nيقال أنه عندما توفي السلطان الظاهر برقوق أول سلاطين المماليك البرجية، قام بعض الظرفاء بصياغة عبارة تحدد تاريخ وفاته فقال: «وفاة برقوق في المشمش»، وعندما نحسب تاريخ وفاة برقوق وهي «في المشمش» يكون الناتج:\n(80+10+1+30+40+300+40+300) = 801، وبالتالي فتكون العبارة: «وفاة برقوق 801» هجرية وذلك صحيح.\n\nassert gematria('في المشمش') == 801 == 80+10+1+30+40+300+40+300\n\nيقال أيضاً أن شاعراً يسمى الدّلنجاوي مات فرثاه صديق له فقال:\n\n\n\nسألتُ الشّعرَ هل لكَ من صديقٍ\nوقد سكنَ الدّلنجاويّ لحــده\n\n\nفصاحَ وخرّ مغشياً عليــــه\nوأصبح راقداً في القبر عنــده\n\n\nفقلتُ لمن يقول الشعر أقْصِــر\nلقد أرّختُ: مات الشعرُ بعـده\n\n\n\nويتضح لنا أن تاريخ الوفاة يكون في معرفة حساب العبارة «مات الشعرُ بعدَهُ»، فيكون الحساب:\n(40+1+400+1+30+300+70+200+2+70+4+5) = (1123)، وذلك يعني أن الشاعر الدلنجاوي توفي في عام 1123 للهجرة.\n\nassert gematria('مات الشعر بعده') == 1123 == 40+1+400+1+30+300+70+200+2+70+4+5",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#ضم-الأقران",
    "href": "chapters/08_procedural/solutions.html#ضم-الأقران",
    "title": "حل المسائل",
    "section": "ضم الأقران",
    "text": "ضم الأقران\nماذا لو أردت أن تضم قائمة من الأشخاص بحيث يكون فارق العمر بينهم أقل ما يمكن؟\nAhmad: 24\nMohannad: 17\nMohammed: 16\nSalem: 32\nAli: 26\nSamir: 31\nأولاً سنرتب القائمة بناءً على العمر، ثم نأخذ العناصر اثنين اثنين، وبذلك نكون حققنا الهدف.\n\ndef make_pairs_by_age_diff(items: list[tuple[str, int]]) -&gt; list[tuple[str, str]]:\n    \"\"\"Make pairs of people by their age difference minimum.\"\"\"\n    ages = [age for name, age in items]\n    ages.sort()\n    items_sorted = []\n    for age in ages:\n        for i in items:\n            if i[1] == age:\n                items_sorted.append(i)\n    pairs = []\n    for i in range(len(items_sorted) - 1):\n        pairs.append((items_sorted[i], items_sorted[i+1]))\n    return pairs\n\n\npeers = [\n    (\"Ahmad\", 24),\n    (\"Mohannad\", 17),\n    (\"Mohammed\", 16),\n    (\"Salem\", 32),\n    (\"Ali\", 26),\n    (\"Samir\", 31),\n]\n\nالاختبارات\n\npairs = make_pairs_by_age_diff(peers)\nfor p in pairs:\n    if \"Ahmad\" in p:\n        assert \"Ali\" in p\n    if \"Mohannad\" in p:\n        assert \"Mohammed\" in p\n    if \"Salem\" in p:\n        assert \"Samir\" in p",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/08_procedural/solutions.html#التوفيق-بين-مجموعتين",
    "href": "chapters/08_procedural/solutions.html#التوفيق-بين-مجموعتين",
    "title": "حل المسائل",
    "section": "التوفيق بين مجموعتين",
    "text": "التوفيق بين مجموعتين\nمسألة التوفيق بين مجموعتين تجدها في سياقات كثيرة.\nنريد في هذا التمرين التوفيق بين أشخاص وما لديهم من مهارات وبين شركات وما تطلبها من هذه المهارات.\nيمكن أن تبدأ بهذا الشكل لإيجاد كمية التوافق:\n\nhave = {\"A\", \"X\", \"Y\"}\nwant = {\"A\", \"B\", \"C\", \"D\"}\nprint(\"نسبة الإعجاب:\", len(set.intersection(have, want)) / len(want))\n\nنسبة الإعجاب: 0.25\n\n\nوفي العادة تكون البيانات مضمنة في قائمة على النحو التالي:\n\nhaves = [\n    {\n        \"name\": \"Ahmad\",\n        \"skills\": [\n            \"Python\",\n            \"Go\",\n            \"JavaScript\",\n        ],\n    },\n    {\n        \"name\": \"Jawad\",\n        \"skills\": [\n            \"Negotiation\",\n            \"Communication\",\n            \"Business\",\n            \"Marketing\",\n        ],\n    },\n]\n\nwants = [\n    {\n        \"job\": \"Data Scientist\",\n        \"requirements\": [\n            \"Python\",\n            \"Machine Learning\",\n            \"Statistics\",\n        ],\n    },\n    {\n        \"job\": \"Sales Manager\",\n        \"requirements\": [\n            \"Negotiation\",\n            \"Communication\",\n        ],\n    },\n]\n\nنعالجها لكل عنصر في قائمة wants:\n\nratios = {}\nfor want in wants:\n    for have in haves:\n        ratio = len(set.intersection(set(want[\"requirements\"]), set(have[\"skills\"]))) / len(want[\"requirements\"])\n        if want['job'] not in ratios:\n            ratios[want['job']] = {}\n        ratios[want['job']][have['name']] = ratio\nratios\n\n{'Data Scientist': {'Ahmad': 0.3333333333333333, 'Jawad': 0.0},\n 'Sales Manager': {'Ahmad': 0.0, 'Jawad': 1.0}}\n\n\nالآن نرتب كل وظيفة بحسب الأعلى توافقًا.\nأولاً نكتب دالة ترتِّب قاموسًا، ثم سنستعملها:\n\ndef sort_nested_dict(d: dict) -&gt; dict:\n    \"\"\"Sorts a dictionary by values\"\"\"\n    result = {}\n    for key in d.keys():\n        result[key] = {}\n        values = [v for v in d[key].values()]\n        values.sort(reverse=True)\n        for v1 in values:\n            for k, v2 in d[key].items():\n                if v2 == v1:\n                    result[key][k] = v2\n    return result\n\n\nsorted_ratios = sort_nested_dict(ratios)\nsorted_ratios\n\n{'Data Scientist': {'Ahmad': 0.3333333333333333, 'Jawad': 0.0},\n 'Sales Manager': {'Jawad': 1.0, 'Ahmad': 0.0}}\n\n\nولكثرة الحاجة لترتيب البيانات، فإن إجراء sorted متعدد الاستعمالات في بايثون. انظر Sorting Basics و Key Functions من توثيق بايثون تحت عنوان: “HOW TO”.\n\nfor k, v in ratios.items():\n    sorted_ratios[k] = sorted(v.items(), key=lambda x: x[1], reverse=True)\nsorted_ratios\n\n{'Data Scientist': [('Ahmad', 0.3333333333333333), ('Jawad', 0.0)],\n 'Sales Manager': [('Jawad', 1.0), ('Ahmad', 0.0)]}\n\n\nفأول المرشحين في علوم البيانات هو:\n\nsorted_ratios[\"Data Scientist\"][0][0]\n\n'Ahmad'\n\n\nوأول المرشحين في المبيعات هو:\n\nsorted_ratios[\"Sales Manager\"][0][0]\n\n'Jawad'",
    "crumbs": [
      "باب البرمجة الإجرائية",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/10_interface/a0_interface.html",
    "href": "chapters/10_interface/a0_interface.html",
    "title": "15  معمارية الطبقات الثلاثة",
    "section": "",
    "text": "الترتيب بين الطبقات\nيمكن تصوُّر البرمجيات بثلاثة طبقات (Three-tier Architecture) منفصلة لكلٍّ منها شقَّان، شقُّ قراءة وشقُّ كتابة:\nالأولى: 🎨 طبقة العَرض (Presentation Tier):\nومثال الكتابة بعد القراءة، الإجراءان:\nوكذلك تشغيل الأصوات باستعمال المكتبة الخارجية playsound. وذلك بعد تنزيلها وتثبيتها عن طريق مدير الحزم uv:\nومثال ذلك أيضًا عرض الصور. ولهذا الغرض نحتاج لمكتبة خراجية مثل Pillow لنعرض صورة معمارية الطبقات الثلاث. وذلك بعد تنزيلها وتثبيتها عن طريق مدير الحزم uv:\nالثانية: ⚙️ طبقة المنطق (Logic Tier):\nوقد أخذت هذه الطبقة الجانب الأكبر من هذا الكتاب. فتعيين المتغيرات واستدعاء الإجراءات وتعريفها وكتابة الشروط والحلقات ونحو ذلك كله من هذه الطبقة.\nالثالثة: 💽 طبقة البيانات (Data Tier):\nومثالها إجراءات قراءة الملفات وكتابتها:\nوهذا الترتيب من جهتين:\nأحدهما: من طبقة البيانات إلى طبقة العَرض. حيث يتم عند تشغيل البرنامج سحب البيانات المستودعة ثم معالجتها منطقيًّا ثم عرض الشاشة للمستخدم حتى يستجيب لذلك.\nوالآخر: من طبقة العرَض، حيث يتفاعل المستخدم مع البرنامج بأي طريقة بحسب ما يرى أو يسمع (طبقة العرض) فيُنقَلُ ذلك لطبقة المنطق ومنها إلى طبقة البيانات.\nويدخل في الطبقات:\nلكن المجال لن يتسع لهما في هذا الكتاب.\nلكننا في الفصل القادم سنتحدث عن واجهة للمستخدم (من طبقة العرض) تسمى سطر الأوامر (Command-line Interface) إذْ هي أبسط طرق العرض والتفاعل مع المستفيد من حيث البرمجة.",
    "crumbs": [
      "باب الواجهة",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>معمارية الطبقات الثلاثة</span>"
    ]
  },
  {
    "objectID": "chapters/10_interface/a0_interface.html#الترتيب-بين-الطبقات",
    "href": "chapters/10_interface/a0_interface.html#الترتيب-بين-الطبقات",
    "title": "15  معمارية الطبقات الثلاثة",
    "section": "",
    "text": "قواعد البيانات (Databases): في طبقة البيانات\nالواجهة البرمجية للتبيقات (API): في طبقة العَرض حيث يكون المستفيدُ ليسَ شخصًا آدميًّا وإنما برنامجًا آخر قد لا يكون في نفس الجهاز",
    "crumbs": [
      "باب الواجهة",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>معمارية الطبقات الثلاثة</span>"
    ]
  },
  {
    "objectID": "chapters/10_interface/a1_cli.html",
    "href": "chapters/10_interface/a1_cli.html",
    "title": "16  سطر الأوامر",
    "section": "",
    "text": "مكتبة (typer)\nواجهة سطر الأوامر (Command-line Interface) هي واجهة نصية تُستخدم للتفاعل مع نظام التشغيل بكتابة أوامر مباشرة، بدلاً مما يظهر على الشاشة من تطبيقات ونوافذ.\nوهي صالحة للمبرمج أو التقني الذي ألِف استعمال الشاشة السوداء.\nومن ميزاتها أنها لا تتطلَّب جهدًا كبيرًا في صناعتها مقارنة بالواجهة الرسومية لذا فإن كثيرًا من البرمجيات المفيدة تبدأ بهذا الشكل. وبعضها لا يفيد المستخدم العادي لأنها أدوات مخصوصة في البرمجة أو البرمجيات فتبقى هكذا.\nوفيها مسلكان:\nالأول: واجهة نصية؛ ولها مكتبة أساسية في بايثون هي argparse ومكتبات خارجية أسهل منها وأسهل في التعبير مثل: typer أو click.\nالثاني: واجهة رسوميَّة على شكل واجهة نصية (Terminal User Interface - TUI) وهي أجمل. ومن أشهر مكتباتها Textualize، وقد تكون أصعب من مكتبات الواجهة النصية.\nتعتبر Typer مكتبة لبناء تطبيقات سطر الأوامر (CLI) بطريقة مناسبة، تعتمد على ميزة التصريح بالأنواع في بايثون.\nأولا تثبيت المكتبة باستعمال uv على النحو التالي:",
    "crumbs": [
      "باب الواجهة",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>سطر الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/10_interface/a1_cli.html#مكتبة-typer",
    "href": "chapters/10_interface/a1_cli.html#مكتبة-typer",
    "title": "16  سطر الأوامر",
    "section": "",
    "text": "يحب المستخدمون استعمالها ويستمتع المطورون بإنشائها.\nسهلة الاستخدام: سهلة على المستخدم بتوليد تلقائي لنص المساعدة، وإكمال تلقائي للأوامر في جميع نوافذ سطر الأوامر.\nتستوعب التعقيد: حيث تنمو حتى مع التطبيقات المعقدة بمزايا مثل شجرة الأوامر والمجموعات.\n\n\nuv add typer\n\nأبسط برنامج\nimport typer\n\n\ndef main(name: str):\n    print(f\"Hello {name}\")\n\n\nif __name__ == \"__main__\":\n    typer.run(main)\nثم نشغل الوحدة البرمجية باستعمال بايثون:\npython main.py Pythonia",
    "crumbs": [
      "باب الواجهة",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>سطر الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/10_interface/a1_cli.html#برنامج-بأمرين",
    "href": "chapters/10_interface/a1_cli.html#برنامج-بأمرين",
    "title": "16  سطر الأوامر",
    "section": "برنامج بأمريْن",
    "text": "برنامج بأمريْن\nوهذا برنامج يحتوي على أمرين:\n\nhello\ngoodbye\n\nوهكذا نكتبه:\nimport typer\n\napp = typer.Typer()\n\n\n@app.command()\ndef hello(name: str):\n    print(f\"Hello {name}\")\n\n\n@app.command()\ndef goodbye(name: str, formal: bool = False):\n    \"\"\"Says goodbay to the person either formally or informally\"\"\"\n    if formal:\n        print(f\"Goodbye Mr. {name}. Have a good day.\")\n    else:\n        print(f\"Bye {name}!\")\n\n\nif __name__ == \"__main__\":\n    app()\nويمكننا الآن أن نطلب المساعدة --help من البرنامج على النحو التالي:\npython main.py --help\nفيخرج لنا التالي ..\nالشكل العام للاستعمال، وهو: اسم البرنامج متبوعًا بالخيارات ثم الأمر ثم العوامل:\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\nالخيارات (Options) تتميز بعلامة الشرطتين (--) قبل اسمها، وهي ليست بلازمة\n╭─ Options ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ --install-completion          Install completion for the current shell.                                                           │\n│ --show-completion             Show completion for the current shell, to copy it or customize the installation.                    │\n│ --help                        Show this message and exit.                                                                         │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\nالأوامر (Commands) مجردة عن الشرطات ويلزم تحديدها.\n╭─ Commands ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ hello                                                                                                                             │\n│ goodbye   Says goodbay to the person either formally or informally                                                                                                                           │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\nوقد استعملنا خيار المساعدة --help بعد اسم البرنامج. والآن نستعمل أمر goodbye ونضع له هو خيار المساعدة --help:\npython main goodbye --help\nفيخرج لنا التالي ..\nالشكل العام للاستخدام، وهو اسم البرنامج متبوعًا باسم الأمر مبتوعًا بالخيارات وبعدها الاسم NAME وهو العامل الوحيد:\nUsage: app.py goodbye [OPTIONS] NAME\n\nSays goodbay to the person either formally or informally\nالعوامل (Arguments) مثل NAME فهي موضعيَّة ولازمة: يجب الإتيان بها ولابد أن يكون في ترتيبه الصحيح.\n╭─ Arguments ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ *    name      TEXT  [default: None] [required]                                                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\nالخيارات (Options) هنا هي للأمر نفسه لا للبرنامج ككل.\n╭─ Options ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ --formal    --no-formal      [default: no-formal]                                                                                 │\n│ --help                       Show this message and exit.                                                                          │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\nلاحظ أننا في الحد الذي يعرِّف الإجراء عرَّفنا العامل formal: bool = False وهذا جعله:\n\nمن النوع المنطقي (bool) فاستفاد بذلك أن يكون له خياران متضادان:\n\n--formal وهو اسم العامل\n--no-formal وهو كلمة no- قبل اسم العامل\n\nواستفاد بتعيين القيمة الافتراضية عند التعريف False أنه:\n\nيندرج تحت الخيارات لا العوامل\n\n\nفلك أن تكتب الأمر بهذا الشكل:\npython main.py goodbye Hani --formal\nأو بتقديم الخيار على العامل:\npython main.py goodbye --formal Hani\nلترى:\nGoodbye Mr. Hani. Have a good day.",
    "crumbs": [
      "باب الواجهة",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>سطر الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/10_interface/a1_cli.html#تطبيق-معمارية-الطبقات-الثلاث",
    "href": "chapters/10_interface/a1_cli.html#تطبيق-معمارية-الطبقات-الثلاث",
    "title": "16  سطر الأوامر",
    "section": "تطبيق معمارية الطبقات الثلاث",
    "text": "تطبيق معمارية الطبقات الثلاث\nوهذا مثال لبرنامج يقرأ الملف المعطى فيعالجه ثم نتيجة المعالجة بنفس اسم الملف متبوعًا بكلمة _processed:\nfrom pathlib import Path\n\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef hello(name: str):\n    print('Hello', name)\n\n@app.command()\ndef uppercase(file_path: str):\n    # قراءة الملف\n    p = Path(file_path).resolve()\n    with open(file=p, mode='r') as file:\n        content = file.read()\n    \n    # معالجة النص\n    content = content.upper()\n\n    # كتابة النتيجة\n    p = p.with_stem(f'{p.stem}_processed')\n    with open(file=p, mode='w') as file:\n        file.write(content)\n\nif __name__ == \"__main__\":\n    app()\nمثال لتشغيل البرنامج:\npython main.py uppercase ./relative/path/to/file.txt\nفإن كان الملف موجودًا فستلاحظ وجود ملف جديد باسم: file_processed.txt.\nوفي هذا المثال رأينا الطبقات الثلاث جميعًا:\n\nطبقة العرض: يتكفل typer بطبقة العرض؛ وهي الكيفية التي يستخدم بها المستفيد البرنامج (وهي سطر الأوامر)\nطبقة المنطق: وتتمثل في السطر content = content.upper()\nطبقة البيانات: وهي في الأول والأخير: قراءة الملف المحدد في المدخلات ثم كتابة النتيجة في ملف",
    "crumbs": [
      "باب الواجهة",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>سطر الأوامر</span>"
    ]
  },
  {
    "objectID": "chapters/apps/sentiment_analysis.html",
    "href": "chapters/apps/sentiment_analysis.html",
    "title": "تحليل المشاعر",
    "section": "",
    "text": "تحليل المشاعر (Sentiment Analysis) هو فرع من فروع معالجة اللغة الطبيعية (NLP) المندرجة تحت الذكاء الاصطناعي (AI) يهدف إلى تصنيف النصوص المكتوبة من جهة المشاعر المعبر عنها: إيجابية 😀 أو سلبية 😡 أو محايدة 😐️.\nوغالباً ما يطبَّق لأتمتة معرفة الرأي العام على المنتجات بشكل مباشر في استطلاعات الرأي، أو بشكل غير مباشر من التعليقات على وسائل التواصل.\nمهمتنا: بناء نموذج إحصائي مبني على قوائم كلمات مصنَّفة مُسبقًا.\nلدينا ثلاثة ملفات:\n\nالأول يحوي تغريدات: tweets.txt\nالثاني يحوي كلمات إيجابية: words_positive.txt\nالثالث يحوي كلمات سلبية: words_negative.txt\n\nنريد تصنيف التغريدات بناءً على عدد الكلمات الإيجابية والسلبية فيها.\n\nfrom pathlib import Path\n\ndata_dir = Path('../../datasets/tweets')\n\nبعد النظر في شكل الملفات. يتبين لنا أن السطر الواحد يحتوي على “شيء” واحد. وبالتالي سنقسم البيانات على كل سطر.\nونلاحظ أيضًا وجود أسطر خاوية، يجب التخلص منها.\n\ndef read_lines(file_path: Path) -&gt; list[str]:\n    \"\"\"skips empty lines and converts to lowercase\"\"\"\n    result = []\n    with open(file_path, 'r') as file:\n        for line in file:\n            x = line.strip()\n            if len(x) &gt; 0:\n                x = x.lower()\n                result.append(x)\n    return result\n\nنستدعي الإجراء لقراءة الملفات الثلاث:\n\ntweets = read_lines(data_dir / 'tweets.txt')\npositive_words = read_lines(data_dir / 'words_positive.txt')\nnegative_words = read_lines(data_dir / 'words_negative.txt') \n\n\nfor i, tweet in enumerate(tweets):\n    print(i, tweet)\n\n0 أشعر بامتنان عميق للأشخاص الرائعين في حياتي! كل يوم معهم هو هدية جميلة\n1 الزهور المتفتحة تملأ المكان بألوانها الزاهية وعطرها الفواح! والعصافير تغرد بأجمل الألحان تحت أشعة الشمس الدافئة! يوم مثالي بكل تفاصيله\n2 الرجل العجوز قدوة في العطاء والكرم! يسعد دائماً بمساعدة الآخرين ويترك أثراً طيباً في كل من حوله! محبوب من الجميع لطيبة قلبه\n3 أتمنى لكم جميعاً يوماً مشرقاً مليئاً بالإنجازات والنجاحات! متحمس جداً لرؤية ابتساماتكم السعيدة!\n4 متحمس جداً للتحديات الجديدة! كل يوم فرصة للتعلم والنمو والتطور!\n5 تعذبت اليوم برحلة مزعجة في طريقي، رأيت مناظر مقرفة من حولي وأنا أتحمل ضجيج الطبيعة المزعجة\n6 صباح سيئ! استيقظت متأخراً وشربت فنجان قهوة مر. متوتر وقلق من لقاء زملائي المزعجين في العمل!\n7 أصوات الحياة من حولي تملأني إرهاقاً! أتعذب بالعمل من المنزل وأشعر بالملل والإحباط!\n8 قضيت أمسية متعبة مع أصدقائي المزعجين! تشاجرنا كثيراً وتذكرنا أسوأ الذكريات! أشعر بالحزن والضيق من وجودهم في حياتي!\n\n\n\nfor p in positive_words:\n    print(p)\n\nممتن\nامتنان\nرائع\nجميل\nهدية\nزاهية\nفواح\nأجمل\nدافئة\nمثالي\nقدوة\nعطاء\nكرم\nيسعد\nمساعدة\nطيب\nمحبوب\nمشرق\nإنجازات\nنجاحات\nمتحمس\nابتسامات\nسعيدة\nتعلم\nنمو\nتطور\nفرصة\nسعيد\n\n\n\nfor n in negative_words:\n    print(n)\n\nتعذب\nمزعج\nمقرف\nضجيج\nسيئ\nمتأخر\nمر\nمتوتر\nقلق\nإرهاق\nأتعذب\nملل\nإحباط\nمتعب\nتشاجر\nأسوأ\nحزن\nضيق\nمزعجين\nمتضايق\nمرهق\nفائت\nغير مرتاح\nوحيد\nحزين\n\n\nالآن نقوم بتصنيف التغريدات:\n\ndef classify(text: str) -&gt; (int, int):\n    \"\"\"Returns the number of positive and negative words in the text\"\"\"\n    \n    positive_count = 0\n    for word in positive_words:\n        if word in text:\n            positive_count += 1\n    \n    negative_count = 0\n    for word in negative_words:\n        if word in text:\n            negative_count += 1\n    \n    return positive_count, negative_count\n\nassert classify('أنا سعيد') == (1, 0)\nassert classify('أنا حزين') == (0, 1)\nassert classify('سعيد حزين اليوم') == (1, 1)\nassert classify('اذهب إلى الدكان') == (0, 0)\n\nنستدعي الإجراء على التغريدات، ونفرز النتائج في ثلاثة قوائم:\n\npositive_tweets = []\nnegative_tweets = []\nneutral_tweets = []\nfor tweet in tweets:\n    pos, neg = classify(tweet)\n    score = pos - neg\n    print(f'-{neg} +{pos} = {score:+}')\n    if score &gt; 0:\n        positive_tweets.append((tweet, score))\n    elif score &lt; 0:\n        negative_tweets.append((tweet, score))\n    else:\n        neutral_tweets.append((tweet, score))\n\n-0 +4 = +4\n-0 +5 = +5\n-0 +7 = +7\n-0 +7 = +7\n-0 +5 = +5\n-4 +0 = -4\n-7 +0 = -7\n-5 +0 = -5\n-7 +0 = -7\n\n\nنعرض التغريدات بحسب التصنيف مرتبة بقوة التصنيف من الأعلى إلى الأسفل:\n\nprint('positive_tweets:')\nfor tweet, score in sorted(positive_tweets, key=lambda x: x[1], reverse=True):\n    print(f'{score:+} {tweet}')\n\npositive_tweets:\n+7 الرجل العجوز قدوة في العطاء والكرم! يسعد دائماً بمساعدة الآخرين ويترك أثراً طيباً في كل من حوله! محبوب من الجميع لطيبة قلبه\n+7 أتمنى لكم جميعاً يوماً مشرقاً مليئاً بالإنجازات والنجاحات! متحمس جداً لرؤية ابتساماتكم السعيدة!\n+5 الزهور المتفتحة تملأ المكان بألوانها الزاهية وعطرها الفواح! والعصافير تغرد بأجمل الألحان تحت أشعة الشمس الدافئة! يوم مثالي بكل تفاصيله\n+5 متحمس جداً للتحديات الجديدة! كل يوم فرصة للتعلم والنمو والتطور!\n+4 أشعر بامتنان عميق للأشخاص الرائعين في حياتي! كل يوم معهم هو هدية جميلة\n\n\n\nprint('negative_tweets:')\nfor tweet, score in sorted(negative_tweets, key=lambda x: x[1]):\n    print(f'{score:+} {tweet}')\n\nnegative_tweets:\n-7 صباح سيئ! استيقظت متأخراً وشربت فنجان قهوة مر. متوتر وقلق من لقاء زملائي المزعجين في العمل!\n-7 قضيت أمسية متعبة مع أصدقائي المزعجين! تشاجرنا كثيراً وتذكرنا أسوأ الذكريات! أشعر بالحزن والضيق من وجودهم في حياتي!\n-5 أصوات الحياة من حولي تملأني إرهاقاً! أتعذب بالعمل من المنزل وأشعر بالملل والإحباط!\n-4 تعذبت اليوم برحلة مزعجة في طريقي، رأيت مناظر مقرفة من حولي وأنا أتحمل ضجيج الطبيعة المزعجة\n\n\n\nprint('neutral_tweets:')\nfor tweet, score in neutral_tweets:\n    print(f'{score} {tweet}')\n\nneutral_tweets:",
    "crumbs": [
      "تطبيقات ومسائل",
      "تحليل المشاعر"
    ]
  },
  {
    "objectID": "chapters/apps/ceasar_cipher.html",
    "href": "chapters/apps/ceasar_cipher.html",
    "title": "التشفير",
    "section": "",
    "text": "التعمية أو التشفير المُلغَّز أو الإلغاز (بالإنجليزية: Cryptography) هو فرع من علم التعمية يهتم بممارسة بعض التقنيات لتأمين عملية التواصل بوجود أشخاص أخرين والذين يسمون أعداء (adversaries). بصوره عامة، تهتم التعمية بإنشاء الأنظمة التي تمنع الأعداء أو العامة من قراءة الرسائل الخاصة. أي بوسائل تحويل البيانات (مثل الكتابة) من شكلها الطبيعي المفهوم لأي شخص إلى شكل غير مفهوم بحيث يتعذّر على من لا يملك معرفة سرية محددة معرفة فحواها.\nكان غايوس يوليوس قيصر (44 ق.م) يواجه خطر تسرب المعلومات في رسائله العسكرية في حال وقعت رسائله في أيدي العدو، فابتكر وسيلة بسيطة لإخفاء مضمونها: كان يُبدل كل حرف في النص بحرف آخر يليه بعدد معين من الخانات هذه الطريقة أصبحت تُعرف اليوم بـ شيفرة قيصر (Caesar Cipher).\nفإذا كان مقدار الإزاحة 3 مثلاً يصير:\n\nحرف a يصير d\nحرف b يصير e\nحرف c يصير f\n\nوأما الحروف الأخيرة فتدور، فيكون:\n\nحرف x يصير a\nحرف y يصير b\nحرف z يصير c\n\nومهمتنا تطبيقها بخوارزمية تأخذ نصًّا وتعميه.\n\n\n\nشيفرة سيزر بإزاحة مقدارها 3 خطوات\n\n\nأولاً نعرف الحروف الكبيرة والصغيرة:\n\nalphabet_lower = \"abcdefghijklmnopqrstuvwxyz\"\nalphabet_upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nتذكر أن لدينا في بايثون الفعل: str.index(sub: str) -&gt; int حيث يأخذ هذا الفعل جُزءًا نصيًّا ويأتي على النص من أوله إلى آخر باحثًا عن موضعه. ونحن سنستعمل ذلك في البحث عن موضع الحرف فسيكون على النحو التالي:\n\nprint(alphabet_lower.index('a'))\nprint(alphabet_lower.index('z'))\n\n0\n25\n\n\nوالأمر الآخر الذي سيفيدنا في تدوير الأرقام هو:\nالحسابيات المقاسية (Modular Arithmetic) تتحرك فيه الأرقام بالجمع والضرب ونحوه بحيث تلتف الأرقام حول بعضها البعض عند الوصول إلى قيمة معينة، تسمى القياس (Modulus).\n\n\n\nنستعمل في ساعة الحائط القياس 12 في حساب الوقت\n\n\nوهذه العملية في بايثون هي % وتعبر عن باقي القسمة:\n\n(9 + 4) % 12\n\n1\n\n\nوالآن نعرف الدالة التي ستأخذ حرفًا (char) ومقدار الإزاحة (shift) لتعيد الحرف البديل عنه بعد الإزاحة.\n\ndef encode(char: str, shift: int) -&gt; str:\n    if char in alphabet_lower:\n        alphabet = alphabet_lower\n    elif char in alphabet_upper:\n        alphabet = alphabet_upper\n    else:\n        return char\n    \n    code = alphabet.index(char)\n    new_code = (code + shift) % len(alphabet)\n    new_char = alphabet[new_code]\n    return new_char\n\n\nأولاً نبحث عن الحرف في سلسلة الأحرف الصغيرة، ثم الكبيرة، ثم إن لم يوجد في أي منها فإننا نعيد الحرف كما هو، ولا نزيحه\nفإن وجدنا الحرف في إحدى السلسلتين (الكبيرة أو الصغيرة) فإننا نعين المتغير alphabet لهذه السلسلة التي سيتم البحث فيها بعد ذلك\nنبحث في هذه السلسلة بالفعل .index() لنعرف موضِع الحرف، حيث سيكون هذا هو رمزه الرقمي (code).\nنزيح الرقم بالمقدار المعطى (shift) ونُدير الناتج بعملية باقي القسمة وهي التعبير: (% len(alphabet))\nنعين المتغير new_char للحرف الذي في موضع الرقم بعد الإزاحة\nنعيد الحرف البديل\n\nنختبر الدالة ببعض التوكيادت:\n\nassert encode('a', 3) == 'd'\nassert encode('b', 3) == 'e'\n\nassert encode('x', 3) == 'a'\nassert encode('y', 3) == 'b'\n\nأما دالة عكس التعمية، فهي ببساطة تعكس الإزاحة بطرح الرقم بعد جمعه.\n\ndef decode(char: str, shift: int) -&gt; str:\n    if char in alphabet_lower:\n        alphabet = alphabet_lower\n    elif char in alphabet_upper:\n        alphabet = alphabet_upper\n    else:\n        return char\n    \n    code = alphabet.index(char)\n    new_code = (code - shift) % len(alphabet)\n    new_char = alphabet[new_code]\n    return new_char\n\nفأما دالة استخراج المعمى، فنريدها أن تكون فعلاً تعكِس، ولذلك سنستعمل التوكيد بتمرير المعمة لعكسه مباشرة بهذه الطريقة:\n\nassert decode(encode('a', 3), 3) == 'a'\nassert decode(encode('z', 3), 3) == 'z'\n\nوالآن بعد أن تأكدنا من عمل ذلك على مستوى الحرف الواحد، نريد أن نأخذ النص كاملاً فنعميه:\n\ndef encode_text(text: str, shift: int) -&gt; str:\n    result = \"\"\n    for char in text:\n        result += encode(char, shift)\n    return result\n\n\nنبدأ بنص فارغ: result = \"\"\nنأتي على الحروف حرفًا حرفًا كما في النص text ونستعمل فعل التعمية encode لذلك النص، ونضيف الحرف العائد إلى النص الناتج result\n\nأما عكس التعمية فباستعمال decode بدلاً من encode بمثل ما تقدَّم:\n\ndef decode_text(text: str, shift: int) -&gt; str:\n    result = \"\"\n    for char in text:\n        result += decode(char, shift)\n    return result\n\nوالآن نريد أن نختبر، ولذلك سنستعين بموقع تفاعلي قد تم فيه عمل ذلك قبلنا، وهو موقع: cryptii.com فنأخذ النص ونستعمله ونتأكد أن ما نخرج به نفس ما خرجوا به:\n\nassert (\n    encode_text(\"If he had anything confidential to say, he wrote it in cipher, that is, by so changing the order of the letters of the alphabet, that not a word could be made out\", 3) ==\n    \"Li kh kdg dqbwklqj frqilghqwldo wr vdb, kh zurwh lw lq flskhu, wkdw lv, eb vr fkdqjlqj wkh rughu ri wkh ohwwhuv ri wkh doskdehw, wkdw qrw d zrug frxog eh pdgh rxw\"\n)\n\nأخيرًا نستعمل ذلك بعد أن تأكدنا من صحته كاملاً:\n\ntext = \"If he had anything confidential to say, he wrote it in cipher, that is, by so changing the order of the letters of the alphabet, that not a word could be made out.\"\n\nprint(\"## Text\")\nprint(text)\n\ntext_encoded = encode_text(text, 3)\ntext_decoded = decode_text(text_encoded, 3)\n\nprint(\"## Encoded\")\nprint(text_encoded)\n\nprint(\"## Decoded\")\nprint(text_decoded)\n\n## Text\nIf he had anything confidential to say, he wrote it in cipher, that is, by so changing the order of the letters of the alphabet, that not a word could be made out.\n## Encoded\nLi kh kdg dqbwklqj frqilghqwldo wr vdb, kh zurwh lw lq flskhu, wkdw lv, eb vr fkdqjlqj wkh rughu ri wkh ohwwhuv ri wkh doskdehw, wkdw qrw d zrug frxog eh pdgh rxw.\n## Decoded\nIf he had anything confidential to say, he wrote it in cipher, that is, by so changing the order of the letters of the alphabet, that not a word could be made out.\n\n\n\nرسالة في استخراج المعمى\nعهد الخليفة المأمون إلى الكندي، وهو أبو يُوسُفَ يَعْقُوبُ بنُ إِسْحاقَ الكِنْدِيُّ (185- 256 هـ / 801- 873 م) بإدارة بيت الحكمة، وكان ذلك بعد إتمام دراسته، حيث بدأ العمل في ترجمة المخطوطات اليونانية لأرسطو وغيره من الفلاسفة إلى اللغة العربية. واجه الكندي أول مرة خلال عمله الحاجة إلى استخراج النصوص المعماة، حيث كانت بعض المخطوطات التي كان عليه ترجمتها معماة.\nقدم الكندي جدولاً بالتكرارات المطلقة لحروف الأبجدية العربية، والتي حسبها في عينة من سبع أوراق من النص.\n\n\n\nالحرف\nتكراره\nالحرف\nتكراره\nالحرف\nتكراره\nالحرف\nتكراره\n\n\n\n\nا\n600\nر\n155\nس\n91\nش\n—\n\n\nل\n437\nع\n131\nق\n63\nض\n—\n\n\nم\n320\nف\n122\nح\n57\nخ\n—\n\n\nه\n273\nت\n120\nج\n46\nث\n17\n\n\nو\n262\nب\n112\nذ\n35\nط\n15\n\n\nي\n252\nك\n112\nص\n32\nغ\n15\n\n\nن\n221\nد\n92\nخ\n20\nظ\n8\n\n\n\nملاحظة: لم يشر المؤلف إلى تكرارات حروف الشين والضاد والخاء، مع الإشارة إلى مكانها في الجدول، مرتبة حسب الترتيب التنازلي للتكرارات.\nيصف المؤلف طريقة استخراج المعمى التكراري على النحو التالي:\n\nفمما نحتال به لاستنباط الكتاب المعمى إذا عرف بأي لسان هو، أن يوجد من ذلك اللسان كتاب قدر ما يقع في جلد أو ما أشبهه، فنعد ما فيه من كل نوع من أنواع حروفه، فنكتب على أكثرها عددًا الأول، والذي يليه في الكثرة الثاني، والذي يلى ذلك في الكثرة الثالث، وكذلك حتى نأتي على جميع أنواع الحروف، ثم ننظر في الكتاب الذي نريد استخراجه فنصنف أيضًا أنواع صوره، فتنظر إلى أكثرها عددًا، فنسمه بسمة الحرف الأول، والذي يليه في الكثرة فنسمه بسمة الحرف الثاني، والذي يليه في الكثرة فنسمه بسمة الحرف الثالث، ثم كذلك حتى تنفد أنواع صور حروف الكتاب المعماة التي قصد لاستنباطه\n\nالتمرين: هل تستطيع كتابة خوارزمية استخراج المعمى، كما بينها الكندي؟",
    "crumbs": [
      "تطبيقات ومسائل",
      "التشفير"
    ]
  },
  {
    "objectID": "chapters/apps/dates_in_arabic.html",
    "href": "chapters/apps/dates_in_arabic.html",
    "title": "التاريخ بالعربية",
    "section": "",
    "text": "كيف نقرأ التواريخ نحو: 84هـ ، 612هـ ، 800هـ ، 1351هـ ، 2025 م؟\nلدينا طريقتان:\nالطريقة الأولى: من اليمين إلى اليسار، حيث نبدأ من خانة الآحاد إلى العشرات إلى المئات إلى الألوف وهلم جرا.\nالطريقة المعاصرة: من اليسار إلى اليمين وهي الطريقة الشائعة في العربية المعاصرة.\nففي هذا الجدول نقدِّر قولنا: “في سنة” قبل كل جملة حتى تكون في محل جر:\n\n\n\n\n\n\n\n\nالتاريخ (هـ/م)\nالطريقة الأولى\nالطريقة المعاصرة\n\n\n\n\n84 هـ\nأربع وثمانين\nأربع وثمانين\n\n\n612 هـ\nاثنين وعشرين وستِّ مئة\nستِّ مئة واثني عشر\n\n\n800 هـ\nثمان مئة\nثمان مئة\n\n\n1351 هـ\nواحدٍ وخمسين وثلاثِ مئة وألف\nألفٍ وثلاثِ مئة وواحدٍ وخمسين\n\n\n2025 م\nخمسٍ وعشرين وألفين\nألفينِ وخمسةٍ وعشرين\n\n\n\nالمطلوب: اكتب خوارزمية تحول التاريخ من الرقم إلى الكلمات. استعمل إحدى الطريقتين أو كليهما. وإذا راعيت الحالة الإعرابية فذلك أحسن.",
    "crumbs": [
      "تطبيقات ومسائل",
      "التاريخ بالعربية"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_use_library.html",
    "href": "chapters/15_community/a1_use_library.html",
    "title": "17  المكتبات الخارجية",
    "section": "",
    "text": "مكتبات العلوم الطبيعية\nأحييك على وصولك إلى نهاية الكتاب. آمل أن يكون الكتاب مهيِّأً لك للبدء في التطبيقات العملية؛ لأنك الآن مهيأ لتفهم أي قطعة برمجية كتبت في بايثون. وحتى تنطلق، إليك بعض مكتاب بايثون التي تعينك على بناء معالجات متخصصة في مجالات مختلفة.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>المكتبات الخارجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_use_library.html#مكتبات-العلوم-الطبيعية",
    "href": "chapters/15_community/a1_use_library.html#مكتبات-العلوم-الطبيعية",
    "title": "17  المكتبات الخارجية",
    "section": "",
    "text": "الحوسبة الكمومية\n\n\n\n\nQuTiP\n\n\nPyQuil\n\n\nQiskit\n\n\nPennyLane\n\n\n\n\n\nالحوسبة الإحصائية\n\n\n\n\nPandas\n\n\nstatsmodels\n\n\nXarray\n\n\nSeaborn\n\n\n\n\n\nمعالجة الإشارة\n\n\n\n\nSciPy\n\n\nPyWavelets\n\n\npython-control\n\n\nHyperSpy\n\n\n\n\n\nمعالجة الصورة\n\n\n\n\nScikit-image\n\n\nOpenCV\n\n\nMahotas\n\n\n\n\n\n\n\nالرسومات والشبكات\n\n\n\n\nNetworkX\n\n\ngraph-tool\n\n\nigraph\n\n\nPyGSP\n\n\n\n\n\nالفلك\n\n\n\n\nAstroPy\n\n\nSunPy\n\n\nSpacePy\n\n\n\n\n\nالنفسية المعرفية\n\n\n\n\nPsychoPy\n\n\n\n\n\nالمعلوماتية الحيوية\n\n\n\n\nBioPython\n\n\nScikit-Bio\n\n\nPyEnsembl\n\n\nETE\n\n\n\n\n\n\n\nالاستدلال البايزي\n\n\n\n\nPyStan\n\n\nPyMC3\n\n\nArviZ\n\n\nemcee\n\n\n\n\n\nالتحليل الرياضي\n\n\n\n\nSciPy\n\n\nSymPy\n\n\ncvxpy\n\n\nFEniCS\n\n\n\n\n\nالكيمياء\n\n\n\n\nCantera\n\n\nMDAnalysis\n\n\nRDKit\n\n\nPyBaMM\n\n\n\n\n\nعلوم الأرض\n\n\n\n\nPangeo\n\n\nSimpeg\n\n\nObsPy\n\n\nFatiando a Terra",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>المكتبات الخارجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_use_library.html#علوم-البيانات-والذكاء-الاصطناعي",
    "href": "chapters/15_community/a1_use_library.html#علوم-البيانات-والذكاء-الاصطناعي",
    "title": "17  المكتبات الخارجية",
    "section": "علوم البيانات والذكاء الاصطناعي",
    "text": "علوم البيانات والذكاء الاصطناعي\n\n\n\nعلوم البيانات\n\n\n\nكاسحات المواقع - Selenium لتصفح المواقع بشكل آلي وسحب البيانات منها\nاستخراج، تحويل، تحميل: Pandas, Jupyter Notebooks\nتصوير البيانات:\n\nMatplotlib\nSeaborn\nNapari\nPyVista\n\nنمذجة وتقييم:\n\nإحصائية: statsmodels\nتعلم الآلة: scikit-learn\nالتعلم العميق: PyTorch, TensorFlow\n\nإعداد التقارير في لوحة معلومات: Dash\n\n\nالبيانات الضخمة\n\nمعالجة البيانات المتدفقة بسرعة وكفاءة عالية: Dask and Ray.\nأتمتة عمليات البيانات: Airflow, Dagster and Prefect",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>المكتبات الخارجية</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_time.html",
    "href": "chapters/15_community/a1_time.html",
    "title": "18  الوقت",
    "section": "",
    "text": "مقدمة",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_time.html#مقدمة",
    "href": "chapters/15_community/a1_time.html#مقدمة",
    "title": "18  الوقت",
    "section": "",
    "text": "الساعات والأيام\nتذكر بعض المصادر أن الأولين كانوا يقسمون الوقت على 12 ساعة ليلية (تبدأ بعد غروب الشمس) تتلوها 12 ساعة نهارية (تبدأ بعد شروق الشمس). وهي ساعات متغيرة؛ ففي الصيف تزيد طول ساعة النهار (فوق 60 دقيقة معتدلة) بينما تقصر ساعة الليل (دون 60 دقيقة معتدلة)، ويحصل العكس في الشتاء (فيكون الليل أطول والنهار أقصر). أما عند اعتدال الشمس في أشهر معيَّنة في خط الاستواء فإن ساعات الليل والنهار 60 دقيقة (وهو مقياس الاعتدال). والمرجع في ذلك الساعة الشمسية (المزوَّلة). ولحساب الفترة الزمنية كانوا يستعملون ما يُحرَق كالشمع، أو ثقب في وعاء مدرَّج من ماء أو رمل.\nانظر كتاب فقه اللغة للثعالبي:\n\nالفصل السابع عشر “في تَعْدِيدِ سَاعَاتِ النَّهارِ واللَّيل على أربع وعشرين لفظة”.\nعن حمزة بن الحسن وعليه عهدتها:\nسَاعَاتُ النَّهارِ: الشُرُوقُ. ثُمَّ البكورُ. ثُمَّ الغُدْوَةُ. ثُمَّ الضُّحَى. ثُمَّ الهاجِرَةُ. ثُمَّ الظَهِيرَةُ. ثُمَّ الرَّوَاحُ. ثُمَّ العَصْرُ. ثُمَّ القَصْرُ. ثُمَّ الأصِيلُ. ثُمَّ العَشِيُّ. ثُمَّ الغُروبُ. سَاعَاتُ اللَّيلِ: الشَّفَقُ. ثُمَّ الغَسَقُ. ثُمَّ العَتَمَةُ. ثُمَّ السُّدْفَة. ثُمَّ الفَحْمَةُ. ثُمَّ الزُّلَّةُ. ثُمَّ الزُّلْفةُ. ثُمَّ البُهْرَةُ. ثُمَّ السَّحَرُ. ثُمَّ الفَجْرُ. ثُمَّ الصُّبْحُ. ثُمَّ الصَّباحُ\n\nثم جاءت الساعات الميكانيكية الثابتة التي تعمل وكأن جميع الساعات 60 دقيقة؛ ولا تعتبر شتاءً ولا صيْفًا، ولا نهارًا ولا ليلاً .. لكنها أصبحت هي المتداولة. وقد مرَّ ضبط الساعة بأطوار من الدقة، فبدأت من الساعة المتأرجحة (1657) إلى الكرونومتر (1762) إلى مذبذب الكوارتز (1927) إلى الساعة الذرية (1949) إلى ساعة شعاع السيزيوم (1955) إلى ساعة نافورة السيزيوم (1993) إلى الساعة الضوئية (Optical Clock: 2006) والتي تحيد بمقدار ثانية بعد كل 30 مليار سنة.\n\n\nالتوقيت العالمي والمناطق الزمنية\nظهر نظام التوقيت العالمي المنسق (UTC: Coordinated Universal Time) حوالي سنة 1967، لتسهيل التعامل بين الدول والتواصل عبر القارات. فهو نظام للوقت يعتمد على خطوط الطول الأرضية، تقسَّم فيه الجغرافيا لمناطق زمنية بحسب بعدها عن خط طول جرينيتش الذي كان هو نقطة الصفر (UTC+00:00) أي: المرجِع: فما يكون شرقيها يكون الفارق فيه بالموجب، وما يكون غربيَّها يكون الفارق فيه بالسالب.\nوكل منطقة زمنية لها توقيت محلي تعتمده في معاملاتها اليومية فيما يتعلق بالوقت من تواصل وتنسيق ومواعيد ونحو ذلك. في الخريطة أدناه نرى تقسيم المناطق الزمنية:\n\n\n\nخريطة تظهر تقسيم المناطق الزمنية\n\n\nلاحظ أولاً أن الخطوط ليست طوليَّة بالإجراء، انظر إلى الألوان فليست هي مستطيلات بل تتعرَّج بحسب حدود الدُّول في الغالب. فالإجراء ليس بالبساطة التي قد نعتقدها: فليس الوقت المحلي هو فقط زيادة أو نقص من الوقت العالمي .. بل هناك عدة اعتبارات للتحويل بينها:\n\nمناطق عريضة جغرافيًّا: كالصين التي تمتد لتغطي مجموعة خطوط طول إلا أنها تعتمد توقيتًا موحَّدًا.\nالتوقيت الصيفي: بعض المناطق الزمنية تقدِّم الوقت ساعة عند الربيع (أو نهاية الشتاء) ثُم تعيدُه في الخريف، وذلك لتنظيم جدوَل الناس بحيث يتعرضوا للشمس أكثر.\nقرارات سياسية: قررت بعض الدوَّل أن تغير منطقتها الزمنية في سنة من السنوات؛ فذلك يجب أن يؤخذ في عين الاعتبار عند حساب الأوقات قبل أو بعد هذه السنة لهذه الدُّوَل.\n\nمعلومة جانبية: مصطلح التنسيق في التوقيت العالمي المنسق يشير إلى أنه يضع في الحسبان الاختلاف اليسير بسبب الثواني الكبسية، فتعاد ضبط الأوقات لاعتبارها.\nنخلص من ذلك أن التعامل مع الوقت له اعتبارات كثيرة بسبب ظروف تاريخية وسياسية وليس خاضعًا لقوانين فيزيائية أو أرضية أو فلكية بحتة. ولذلك ظهرت قاعدة بيانات للمناطق الزمنية (بمجهود جماعي) تتضمن معلومات الدول بشكل يتم تحديثه بشكل مستمر لمتابعة التغيرات، تسمَّى: (tz database).",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_time.html#الوقت-في-الحاسب",
    "href": "chapters/15_community/a1_time.html#الوقت-في-الحاسب",
    "title": "18  الوقت",
    "section": "الوقت في الحاسب",
    "text": "الوقت في الحاسب\nيظهر وقت التقويم (Calendar Time) على هذا النحو:\n\nالتاريخ: 2024-11-25\nالساعات: 08:30:25\nالمنطقة الزمنية: GMT+3 (أي: ثلاث ساعات متقدِّمة عن جرينيتش)\n\nلكن تمثيل الزمن في الحاسب هو: عدد صحيح (int) ويمثِّل عدد الثواني من بزوغ فجر نظام يونكس (Unix Epoch) وهو تاريخ ووقت اعتباطي تمَّ وضعه على أن يكون:\n\nتاريخ: 1970-01-01\nالساعة: 00:00:00\nالمنطقة الزمنية: UTC التي هي GMT+0\n\nمثال: لنشير إلى سنة واحدة تمامًا بعد النقطة الصفرية، أي: الساعة 00:00:00 بتاريخ 1 يناير1971 ، فإن السنة الواحدة فيها 31,536,000 ثانية ، وبالتالي يكون هذا الرقم هو الذي يمثل ذلك الوقت.\nولو أردت الترجمة بالعكس، فتقول إن 1,000,000,000 ثانية منذ النقطة الصفرية يوافق 9 سبتمبر 2001 01:46:40 في وقت التقويم على منطقة UTC.\nمشكلة سنة 2038 تحصل في الأنظمة ذات 32-بت؛ إذْ عدد الثواني يصل إلى أقصى مداه عند نقطتين زمنيتين:\n\nففي النزول تستطيع أن تصل إلى: 20:45:52 UTC بتاريخ 1901-12-13 (باختيار عدد سالب)\nوكذلك في الصعود؛ لا يمكن أن تتعدى: 03:14:07 UTC بتاريخ 2038-01-19\n\nوالحل في ذلك بسيط، وهو نقل البرنامج لنظام 64-بت.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_time.html#الوقت-في-بايثون",
    "href": "chapters/15_community/a1_time.html#الوقت-في-بايثون",
    "title": "18  الوقت",
    "section": "الوقت في بايثون",
    "text": "الوقت في بايثون\nننتقل الآن إلى الوقت والتاريخ في بايثون، حيث يوجد لدينا المفاهيم التالية:\nأولاً: datetime.date وهو تاريخ مثالي يفترض أن التقويم الغريغوري يمتد إلى ما لا نهاية في المستقبل والماضي (رغم أنه في الحقيقة حل مكان التاريخ الجولياني سنة 1582). سمات هذا الكائن: السنة والشهر واليوم.\nثانيًا: datetime.time هو وقت مثالي يفترض 86,400 ثانية في اليوم (بدون ثوانٍ كبيسة). سمات هذا الكائن: الساعة والدقيقة والثانية والميكروثانية وtzinfo (معلومات المنطقة الزمنية).\nثالثًا: datetime.datetime وهو التاريخ والوقت معًا؛ فلديه سمات كلا الجزئين.\nرابعًا: datetime.timedelta وهو فترة زمنية. ولكننا سنستبدله بـ dateutil.relativedelta إذ هي كذلك فترة زمنية إلا أن نطاقها أوسع (تستوعب السنين والأشهر، وتعتبر السنوات الكبيسة في الحسبان).\nالوقت الصحيح لا بد له من نسبة إلى منطقة زمنيَّة (كأن تقول الساعة 04:00:00 صباحًا بتوقيت UTC+03)؛ فهذا تسميه بايثون وقت واع (Aware)، وأما الوقت الذي لم تحدد منطقته الزمنية (كما لو قُلت في الساعة 04:00:00 صباحًا) فهذا غير منسوب لمنطقة زمنية وبالتالي فهو ساذج (Naive) على تعبيرهم.\nويرشدنا توثيق المكتبة للتوسع في استعمال قاعدة بيانات المناطق الزمنية، والقدرة على تفسير التواريخ والأوقات بمرونة لاستخدام مكتبة dateutil المتوفرة في PyPI.\nلتثبيت المكتبة نستعمل pip على النحو التالي:\npip install python-dateutil\nالآن نستورد المكتبة الأساسية datetime ومكتبة dateutil:\n\nfrom datetime import date, time, datetime, timedelta\nfrom dateutil import tz\n\nنريد الآن معرفة الوقت العالمي والمحلي، وكذلك الوقت في القاهرة، وكذلك الوقت في لندن (هنا قائمة بالأسماء):\n\nprint(datetime.now(tz=tz.tzutc()))\nprint(datetime.now(tz=tz.tzlocal()))\nprint(datetime.now(tz=tz.gettz('Africa/Cairo')))\nprint(datetime.now(tz=tz.gettz('Europe/London')))\n\n2025-04-13 05:14:39.141028+00:00\n2025-04-13 08:14:39.141205+03:00\n2025-04-13 07:14:39.142757+02:00\n2025-04-13 06:14:39.144287+01:00\n\n\nلاحظ أن شكل الوقت كاملاً على النحو التالي:\n    2024-11-19 11:32:35.355104+03:00\n    YYYY-MM-DD HH:MM:SS.ssssss+HH:MM\nنفكك ذلك:\n\nYYYY-MM-DD هو التاريخ (يبدأ بالسنة ثم الشهر ثم اليوم)\nHH:MM:SS.ssssss هو الوقت (بالساعات والدقائق والثواني والميكروثواني)\n+HH:MM هو الفرق بين الوقت المحلي لتلك المنطقة الزمنية والوقت العالمي المنسق (UTC).\n\n\nالتفسير: تحويل النص إلى تاريخ ووقت\nوقراءة التواريخ أفضل بكثير في مكتبة dateutil بدلاً من استعمال المكتبة الأساسية datetime. وتكثر الحاجة لذلك عند استقبال معلومات من الشبكة أو من ملفات أو من المستخدمين:\n\nfrom dateutil.parser import parse\n\nهنا نحدد وقتًا افتراضيًّا عند القراءة، بحيث لو لم توجد المعلومة عند القراءة فإنها تستعمل القيم الابتدائية:\n\nDEFAULT = datetime(2003, 9, 25)\nparse(\"Thu Sep 25 10:36:28\", default=DEFAULT)\n\ndatetime.datetime(2003, 9, 25, 10, 36, 28)\n\n\nونرى كيف أن المفسر يحاول معرفة المعلومات ولو كانت ناقصة:\n\nدون السنة\nدون الشهر\nدون الثواني\nدون اليوم\n\n\nprint(parse(\"Thu Sep 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36\", default=DEFAULT))\nprint(parse(\"10:36\", default=DEFAULT))\n\n2003-09-25 10:36:28\n2003-09-25 10:36:28\n2003-09-25 10:36:00\n2003-09-25 10:36:00\n\n\n\n\nالحسابات الزمنية\n\nfrom dateutil.relativedelta import relativedelta\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nحساب الزمن المنقضي\n\ntoday = datetime.now(tz=tz.tzlocal())\nbirthday = datetime(1970, 1, 1, tzinfo=tz.tzlocal())\nage = relativedelta(today, birthday)\nprint(f'You are {age.years} years and {age.months} months old')\n\nYou are 55 years and 3 months old\n\n\n\n\nحساب الزمن لموعد\n\ntoday = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2025, 1, 15, tzinfo=tz.tzlocal())\ndiff = relativedelta(exam_date, today)\nprint(f'There are {diff.days} days and {diff.hours} hours remaining')\n\nThere are -29 days and -8 hours remaining\n\n\n\n\nمقارنة الوقت\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=9, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif now &gt; exam_date:\n    print('The exam has passed')\nelif now &lt; exam_date:\n    print('The exam is coming')\n\nThe exam has passed\n\n\n\n\nمقارنة الفترة\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=15, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif relativedelta(now, exam_date).hours &lt; 1:\n    print('Hurry up!')\nelif relativedelta(now, exam_date).hours &lt; 4:\n    print(f'Remember you have an exam today at {exam_date:%H:%M}')\nelse:\n    print(f'You have plenty of time to prepare for the exam')\n\nYou have plenty of time to prepare for the exam\n\n\n\n\nالجمعة القادمة\n\ntoday = datetime.now(tz=tz.tzlocal())\nnext_friday = today + relativedelta(days=+1, weekday=FR)\nprint(f'The next Friday is {next_friday:%Y-%m-%d}')\n\nThe next Friday is 2025-04-18\n\n\n\n\nالجمعة الفائتة\n\nlast_friday = today - relativedelta(days=+1, weekday=FR(-1))\nprint(f'The last Friday is {last_friday:%Y-%m-%d}')\n\nThe last Friday is 2025-04-11\n\n\n\n\nحساب الوقت باعتبار منطقتين زمنيتين\nلديك اجتماع في وقت محدد بتوقيت لندن، وتريد معرفة وقت الوصول بالطائرة إن كانت الرحلة تستغرق 4 ساعات والإقلاع من القاهرة في الساعة 01:00:00 صباحًا والوجهة لندن:\n\ndeparture_tz = tz.gettz('Africa/Cairo')\narrival_tz = tz.gettz('Europe/London')\n\ndeparture_time = datetime(2024, 11, 19, hour=1, tzinfo=departure_tz)\n\narrival_time = departure_time + relativedelta(hours=4)\n\nprint(f'You leave at {departure_time.astimezone(departure_tz)} in Cairo time')\nprint(f'You arrive at {arrival_time.astimezone(arrival_tz)} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz)} in Cairo time')\n\nYou leave at 2024-11-19 01:00:00+02:00 in Cairo time\nYou arrive at 2024-11-19 03:00:00+00:00 in London time\nwhich corresponds to 2024-11-19 05:00:00+02:00 in Cairo time\n\n\n\n\n\nتنسيق التاريخ والوقت\nوانظر الجدول لتنسيق مظهر التاريخ والوقت:\n\nprint(f'Departure time: {departure_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\nprint(f'Arrival time: {arrival_time.astimezone(arrival_tz):%d %b, %X %Z} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\n\nDeparture time: 19 Nov, 01:00:00 EET in Cairo time\nArrival time: 19 Nov, 03:00:00 GMT in London time\nwhich corresponds to 19 Nov, 05:00:00 EET in Cairo time\n\n\n\n\nالتكرار\nتكرار التواريخ يتم في هذه المكتبة باستعمال rrule ويحدد على النحو التالي:\n\nfrom dateutil.rrule import rrule\nfrom dateutil.rrule import DAILY, WEEKLY, MONTHLY, YEARLY, HOURLY, MINUTELY, SECONDLY\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nيوم ويوم\nتكرار أوقات بأخذ يوم وترك يوم، ابتداءً من وقت معين في الساعة العاشرة صباحًا:\n\nlist(\n    rrule(DAILY, interval=2, count=10, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 21, 10, 0),\n datetime.datetime(2024, 11, 23, 10, 0),\n datetime.datetime(2024, 11, 25, 10, 0),\n datetime.datetime(2024, 11, 27, 10, 0),\n datetime.datetime(2024, 11, 29, 10, 0),\n datetime.datetime(2024, 12, 1, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 5, 10, 0),\n datetime.datetime(2024, 12, 7, 10, 0)]\n\n\n\n\nأسبوعي\n\nlist(\n    rrule(WEEKLY, interval=1, count=4, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 26, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 10, 10, 0)]\n\n\n\n\nشهريًّا إلى وقت محدد\n\nlist(\n    rrule(MONTHLY, interval=1,\n        dtstart=datetime(2024, 8, 1),\n        until=datetime(2025, 4, 1),\n    )\n)\n\n[datetime.datetime(2024, 8, 1, 0, 0),\n datetime.datetime(2024, 9, 1, 0, 0),\n datetime.datetime(2024, 10, 1, 0, 0),\n datetime.datetime(2024, 11, 1, 0, 0),\n datetime.datetime(2024, 12, 1, 0, 0),\n datetime.datetime(2025, 1, 1, 0, 0),\n datetime.datetime(2025, 2, 1, 0, 0),\n datetime.datetime(2025, 3, 1, 0, 0),\n datetime.datetime(2025, 4, 1, 0, 0)]\n\n\n\n\nكل 15 دقيقة لمدة 6 مرات\n\nlist(\n    rrule(MINUTELY, interval=15, count=6, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 19, 10, 15),\n datetime.datetime(2024, 11, 19, 10, 30),\n datetime.datetime(2024, 11, 19, 10, 45),\n datetime.datetime(2024, 11, 19, 11, 0),\n datetime.datetime(2024, 11, 19, 11, 15)]\n\n\nوندعوك للاطلاع على المزيد من الأمثلة على مكتبة dateutil.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a1_time.html#التاريخ-الهجري-في-بايثون",
    "href": "chapters/15_community/a1_time.html#التاريخ-الهجري-في-بايثون",
    "title": "18  الوقت",
    "section": "التاريخ الهجري في بايثون",
    "text": "التاريخ الهجري في بايثون\nتوفر مكتبة hijridate التعامل مع التاريخ الهجري والتحويل بينه وبين الجريجوري (الميلادي):\nfrom hijridate import Hijri, Gregorian\n\ng = Hijri(1446, 5, 17).to_gregorian()\nh = Gregorian(2024, 11, 19).to_hijri()\n\nprint(g)\nprint(h)",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a2_use_sdk.html",
    "href": "chapters/15_community/a2_use_sdk.html",
    "title": "19  البرمجية كخدمة (SaaS)",
    "section": "",
    "text": "الخادم والعميل\nنتصوَّر الشبكة العالميَّة (الإنْتَرنِت) بأنها مجموعة أجهزة مترابطة بأشكال ارتباطات مختلفة. وكما هي السنة بين الأفراد والمؤسسات أن يخدم بعضهم بعضًا، ويتبادلون المنافع؛ فكذلك صار في العصر الرقمي تخادم عن طريق الحواسيب عبر الشبكة.\nوكما أن المعادن موزعة مكامنها في طيات أطراف الأرض؛ فإن البيانات (المواد الخام) والمعلومات (المعالجة) وآليات المعالجة (الأجهزة والخوارزميات) كذلك؛ يتفاضل الناس فيما بينهم فيها. فيكون بينهم تبادل المنافع.\nفالصورة هذه توضِّح أن الشبكة المحليَّة (Local Area Network - LAN) -الذي يكون جهاز أحدنا فردًا من أفرادها- مرتبطةٌ بموجِّه (Router) يكون بمثابة البوابة إلى الشبكات الأخرى. فأي اتصال يكون بيننا وبين العالم يمرُّ عبره.\nوأما شبكة الشبكات فتسمى (Wide Area Network - WAN)؛ وهكذا ببساطة نتصوَّر الشبكة العالمية؛ الإنترنت.\nوعندما ننظر إلى أفراد التبادلات المعلوماتية بين الحواسيب، فإن أحد الطرفين يكون له دوْر العميل والآخر يكون له دوْر الخادم؛ ثم قد ينعكس الدوْر:",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>البرمجية كخدمة (SaaS)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a2_use_sdk.html#الخادم-والعميل",
    "href": "chapters/15_community/a2_use_sdk.html#الخادم-والعميل",
    "title": "19  البرمجية كخدمة (SaaS)",
    "section": "",
    "text": "فأما الخادم (Server) فيسمى كذلك المزوِّد (Provider) باعتبار المنتَج أو الخدمة البرمجية.\nوأما العميل (Client) فيسمى كذلك المستخدم (User) أو المستهلك (Consumer).\n\n\n\n\nخادم لعدة عملاء",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>البرمجية كخدمة (SaaS)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a2_use_sdk.html#مكتبة-العميل",
    "href": "chapters/15_community/a2_use_sdk.html#مكتبة-العميل",
    "title": "19  البرمجية كخدمة (SaaS)",
    "section": "مكتبة العميل",
    "text": "مكتبة العميل\nتسهل بعض المكتبات الوصول إلى خوادم مخصوصة؛ وتسمى المكتبة حينئذٍ عدة تطوير البرمجية (SDK - Software Development Kit)، أو: مكتبة العميل (Client Library).\nفأحد طرق التعامل مع الخدمات البرمجية، أن توفِّر هذه الخدمة مكتبةً للاتصال بها، تبدوا كأنها إجراءات مُعرَّفة عاديَّة، لكنَّ تفاصيلها تتضمَّن إرسال طلب للخادم المزوِّد ثم الرجوع بجوابه كقيمة لموضع الاستدعاء.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>البرمجية كخدمة (SaaS)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a2_use_sdk.html#مكتبة-جيوباي-مثالا",
    "href": "chapters/15_community/a2_use_sdk.html#مكتبة-جيوباي-مثالا",
    "title": "19  البرمجية كخدمة (SaaS)",
    "section": "مكتبة جيوباي مثالاً",
    "text": "مكتبة جيوباي مثالاً\nونمثل على ذلك بمكتبة GeoPy حيث كُتِب في الوصف:\n\nجيوباي هو عميل بايثوني لمجموعة من خدمات شائعة على الشبكة للترميز الجغرافي. فهو يسهل تحديد إحداثيات العناوين والمدن والبلدان والمعالم في جميع أنحاء العالم باستخدام برامج ترميز جغرافي خارجية ومصادر بيانات أخرى.\n\nأولاً تثبيت المكتبة باستعمال uv:\nuv add geopy\nوهذا العميل يمكن ضبطه للاختيار من مجموعة خوادم. وسنختار العميل Nominatim الذي يتصل بمزوِّد خدمة خارجية، وهو مزوِّد خدمة جغرافية عالمية تسمى OpenStreetMap.\n\nfrom geopy.geocoders import Nominatim\n\nيطلب منَّا الإجراء المنشئ التصريح بهويَّة للتطبيق؛ وذلك بتعيين user_agent، وهذا بحسب ما ورد في توثيق المكتبة. فنكتب أي اسم يدلُّ على التطبيق الذي نعمل عليه الآن، وسنختار الاسم pythonia .. ولك أن تختار أي اسم آخر.\n\ngeolocator = Nominatim(user_agent=\"pythonia\")\n\nنفترض أننا نريد معرفة إحداثيات مدينة الدمام، وهذا هو عمل الإجراء geocode:\n\ndammam_location = geolocator.geocode(\"Dammam, Saudi Arabia\")\n\nقد يبدوا الإجراء عاديًّا، لكنه في الواقع يتصل بالخادم المزوِّد ويسأله عن إحداثيات المدينة.\n\n\n\n\n\nsequenceDiagram\n    UserCode --&gt;&gt; GeoPy: .geocode(\"...\")\n    GeoPy --&gt;&gt; OpenStreetMap: Request\n    OpenStreetMap --&gt;&gt; GeoPy: Response\n    GeoPy --&gt;&gt; UserCode: Return\n\n\n\n\n\n\nجرب اطبع النتيجة لتعرف ما هو هذا الشيء الذي تتعامل معه. وكذلك اطبع نوعه:\n\nprint(dammam_location)\nprint(type(dammam_location))\n\nالدمام, محافظة الدمام, المنطقة الشرقية, 32242, السعودية\n&lt;class 'geopy.location.Location'&gt;\n\n\nتبيَّن لنا أن النوع هو: geopy.location.Location وبالبحث في توثيق المكتبة، وجدنا تفاصيلها هنا: geopy.location.Location. حيث كُتب:\n\n\nContains a parsed geocoder response. Can be iterated over as (location&lt;String&gt;, (latitude&lt;float&gt;, longitude&lt;float&gt;)). Or one can access the properties address, latitude, longitude, or raw. The last is a dictionary of the geocoder’s response for this item.\n\n\nوبهذا نعرف أنها تتكون من ثلاثة معلومات، ويمكن الوصول لها بطرق مختلفة.\nالطريقة الأولى معقدة ولذلك سنتركها.\nالطريقة الثانية (عن طريق الصفات):\n\nprint(dammam_location.address)\nprint(dammam_location.latitude)\nprint(dammam_location.longitude)\n\nالدمام, محافظة الدمام, المنطقة الشرقية, 32242, السعودية\n26.4367824\n50.1039991\n\n\nالطريقة الثالثة (عن طريق القاموس):\n\nprint(dammam_location.raw)\nprint(type(dammam_location.raw)) # قاموس\n\n{'place_id': 39502325, 'licence': 'Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright', 'osm_type': 'node', 'osm_id': 287865393, 'lat': '26.4367824', 'lon': '50.1039991', 'class': 'place', 'type': 'city', 'place_rank': 16, 'importance': 0.5524619823312412, 'addresstype': 'city', 'name': 'الدمام', 'display_name': 'الدمام, محافظة الدمام, المنطقة الشرقية, 32242, السعودية', 'boundingbox': ['26.2767824', '26.5967824', '49.9439991', '50.2639991']}\n&lt;class 'dict'&gt;\n\n\nوكذلك لمدينة أخرى مثل البحرين:\n\nbahrain_location = geolocator.geocode(\"Bahrain\")\n\nثم بعد أن حصلنا على المعلومات، نستخرج الإحداثيات من المتغيرات التي حصلنا عليها:\n\ndammam_coords = (dammam_location.latitude, dammam_location.longitude)\nbahrain_coords = (bahrain_location.latitude, bahrain_location.longitude)\n\nثم نحسب المسافة بين المدينتين، باستعمال فعل موجود في وحدة geopy.distance، وهو geodesic. وأنبه مرة أخرى أن معرفة مثل ذلك يكون بتصفح فهرس المكتبة.\n\nfrom geopy.distance import geodesic\n\ndistance = geodesic(dammam_coords, bahrain_coords)\nprint(f\"Between Dammam and Bahrain is {distance.kilometers:.2f} km\")\n\nBetween Dammam and Bahrain is 63.61 km\n\n\nوهكذا نكون قد حسبنا المسافة بين المدينتين بالكيلومترات، باستعمال مكتبة أعطتنا الإحداثيات للمدينتين، وكذلك أعطتنا معالجة المسافة بينهما.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>البرمجية كخدمة (SaaS)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a2_use_sdk.html#مفتاح-الواجهة-البرمجية-api_key",
    "href": "chapters/15_community/a2_use_sdk.html#مفتاح-الواجهة-البرمجية-api_key",
    "title": "19  البرمجية كخدمة (SaaS)",
    "section": "مفتاح الواجهة البرمجية (API_KEY)",
    "text": "مفتاح الواجهة البرمجية (API_KEY)\nقلنا أن مكتبة العميل هذه تمكِّنك من الوصول إلى عدة خدمات جيومكانية. ويجدر بالذكر أننها تتفاضل في دقة الحساب، وسرعة الجواب، وكمية الطلبات المسموحة إليها.\nلذلك قد تضطر لتسجيل حساب وتشحنه بالمال برصيد، ثم تستعمل الخدمة عن طريق هذا الحساب. والطريقة التي يعرف بها الخادم أن البرنامج مخوَّل باستعمال رصيد هذا الحساب هي عبر مفتاح الواجهة البرمجية (API Key).\n\n\n\nمكتبة جيوباي وخدمات الترميز الجغرافي\n\n\nفإن أردت تغيير مزوِّد الخدمة (إما لعدم دقتها أو عدم توفر المعلومات أو أي سبب آخر)، فما عليك إلا استعمال استيراد Geocoder آخر. ونمثل لذلك بعميل يتصل بخدمة TomTom:\nfrom geopy.geocoders import TomTom\n\ngeolocator = TomTom(user_agent=\"pythonia\", api_key=\"...\")\nلكن هذا يتطلَّب شيئًا إضافيًّا وهو الحصول على مفتاح متعلِّق بحساب مسجَّل على موقع TomTom نفسه. ثم وضع هذا الفتاح هنا. وبهذا المفتاح المرتبط بهذا الحِساب يتمُّ تعبئة الاشتراك والصرف من رصيده.\nوهذه أحد مصادر دخل شركات المعلومات.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>البرمجية كخدمة (SaaS)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a3_use_http.html",
    "href": "chapters/15_community/a3_use_http.html",
    "title": "20  التخاطب عبر الشبكة (HTTP)",
    "section": "",
    "text": "عنوان المورِد الموحَّد\nرأينا في الدرس السابق كيفية التواصل مع خادم عن طريق مكتبة العميل التابعة للخدمة (GeoPy). لكن ما الآلية التي جرَّدتها عنا هذه المكتبة وأخفتها؟\nتخضع المراسلات بين البرمجيات التطبيقية لقواعد تواصل تسمى HTTP (Hyper-Text Transfer Protocol)؛ وهي حرفيًّا بمعنى قواعد تناقل النص الفائق. وسيأتي بيان معنى الفائقية عند شرح HTML (Hyper-text Markup Language) لأن هذين المفهومين مرتبطان. لكن الذي يهمنا الآن أنها أحد أكثر لغات التواصل استخدامًا على الشبكة. فالاتصال بين الخادم والمخدوم يكون بها وإن كان البرنامج نفسه مكتوبًا بلغة أخرى مثل بايثون. ومن نظائرها:\nوغيرها كثير جدًّا.\nفحتى نصل إلى خدمات كثيرة على الشبكة ونستفيد منها؛ لابد أن نفهم هذه الآلية. وهي مبنيَّة على أمور، منها: العنوان، والطلب، والجواب.\nإن اصطلاح عنوان المورِد الموحَّد URL (Uniform Resource Locator) هو الذي نقصده عندما نقول رابط (Link أو Hyper-link reference وتختصر href) لأن صياغة الروابط عادةً ما تتبع هذه الصيغة الموحَّدة. وهي التي تتضمَّنُ عادةً جزئيَّة com. أو net. ونحوهما؛ وتتضمن بعدها مسارًا فرعيًّا. ونمثل على ذلك بمثال بسيط:\nففيه:\nأما مصطلح المورِد (Resource) فعامٌّ يشمل شيئًا مُجرَّدًا يتم الوصول إليه بعنوان مُصاغٍ بصيغة متفقٍ عليها. سواءٌ كان موجودًا قبل الوصول إليه، أو يتمُّ إنتاجه متى طُلِب. فقد يكون ملفَّ بيانات أو صفحةً تُعرَض أو معالجةً قيِّمة.\nفلو جربت نسخ الرابط السابق ووضعته في الشريط الأعلى للمتصفح وكبست زر Enter فسيأخذك المتصفح إلى تلك الصفحة. وسيأتي الكلام عن بناء الصفحات في حينه إن شاء الله.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>التخاطب عبر الشبكة (HTTP)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a3_use_http.html#عنوان-المورد-الموحد",
    "href": "chapters/15_community/a3_use_http.html#عنوان-المورد-الموحد",
    "title": "20  التخاطب عبر الشبكة (HTTP)",
    "section": "",
    "text": "https://github.com/HassanAlgoz/python\n\n\nالصياغة: https\nالعنوان الأساسي: github.com\nالمسار الفرعي: HassanAlgoz/python/\nالمورِد: python",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>التخاطب عبر الشبكة (HTTP)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a3_use_http.html#الطلب-والجواب",
    "href": "chapters/15_community/a3_use_http.html#الطلب-والجواب",
    "title": "20  التخاطب عبر الشبكة (HTTP)",
    "section": "الطلب والجواب",
    "text": "الطلب والجواب\nومن مفاهيم لغة التخاطب عبر تطبيقات الشبكة أيضًا:\n\nالطلب\nالطلب (Request) وهو الرسالة التي تشمل:\n\nالمحتوى: body / content\nالعميل الذي يمثِّل المستخدم (المُرسِل): user-agent\nالمستضيف الذي عليه الخادم (المُرسَل إليه): Host\n\nنوع الطلب (Method) وأهمها:\n\nGET لطلب الحصول على مورِد معيَّن\nDELETE لطلب حذف مورِد معيَّن\n\nففيهما يتمُّ تحديد عنوان المورِد.\nثم لدينا:\n\nPOST لطلب إنشاء مورِد؛ يتمُّ تحديد تفاصيل الإنشاء في محتوى الرسالة\nPUT لطلب تعديل مورِد؛ يتمُّ تحديد تفاصيل التعديل في محتوى الرسالة\n\nالرؤوس (Headers) هي معلومات عن المعلومات التي في الطلب نفسه أو محتواه؛ بعضها أصلي وبعضها إضافي.\n\nمثلاً: Content-Type: text/csv تعني أن البيانات المرسلة عبارة عن ملف بصيغة CSV. وهو أصلي.\nأما الإضافي فيبدأ بحرف X على هذا النحو: x-api-key: 1234567890 هو مفتاح التطبيق الذي يسمح للطلب بالتعريف بصاحب الحساب لإتاحة الخدمة له.\n\nالمحتوى (Body) هي البيانات المُرْسَلة أو المُسْتَلَمة؛ سواءٌ في الطلب أو جوابه.\nمثلا بيانات عبارة عن قاموس بصيغة JSON:\n{\"name\": \"John\", \"age\": 30}\n\n\nجواب الطلب\nجواب الطلب (Response) وهو مثل الطلب في خصائصه؛ إلا أنَّه بعكس الاتجاه: من الخادم إلى العميل.\nرمز حالة الطلب (Status Code) وتنقسم إلى نطاقات، وكثيرٌ منها مُهمَل غير مُستعمل:\n\nنطاق 100-199 (فقط للعلم - ولا تهمنا)\nنطاق 200-299 تعني أن الطلب تمُّ إنجازه بنجاح.\nنطاق 300-399 إعادة توجيه\nنطاق 400-499 إشكال من جهة العميل\n\n400 -&gt; Bad Request البيانات المُرسلة ليست صالحة\n401 -&gt; Unauthorized المفتاح مفقود أو غير صالح\n403 -&gt; Forbidden المفتاح صالح لكن ليس كافيًا للوصول\n404 -&gt; Not Found ما طلبته غير موجود\n\nنطاق 500-599 إشكال من جهة الخادم\n\nولمزيد من التفاصيل راجع: HTTP overview.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>التخاطب عبر الشبكة (HTTP)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a3_use_http.html#مثال-خدمة-صور-القطط",
    "href": "chapters/15_community/a3_use_http.html#مثال-خدمة-صور-القطط",
    "title": "20  التخاطب عبر الشبكة (HTTP)",
    "section": "مثال: خدمة صور القطط",
    "text": "مثال: خدمة صور القطط\nماذا لو لم تتوفَّر مكتبة خاصَّة بمزوِّد الخدمة؟ في هذه الحالة سنكتب نحن تفاصيل الاتصال بالخادم المزوِّد. وذلك يتطلب معرفة لغة التخاطب بين الخادم والعميل (HTTP).\nيجب علينا أولاً تثبيت مكتبة httpx باستعمال uv:\nuv add httpx\nونمثل لمزود خدمة معلومات عن القطط (The Cat API)، وقد حصلنا على مفتاح التطبيق (API KEY) من خلال التسجيل في الموقع.\nولمعرفة الاستفادة من أي مزود خدمة، فإننا ندخل إلى صفحة المطورين، وتسمى (API Documentation). ومنها نعرف أن المسار الذي يجب أن نطلبه هو https://api.thecatapi.com/v1/images/search، وهو يعطينا صورة قط عشوائية.\nباستعمال مكتبة عامة لعميل HTTP يمكننا الوصول لأي خدمة مقدَّمة من جهة خادم يتخاطب بلغة HTTP. وهو ما يُعرف أيضًا بخادم ويب (Web Server). فها نحن هنا نحدد جميع ما نريد:\n\nنوع الطلب: GET\nالمسار: /v1/images/search\nالعنوان الرئيسي: api.thecatapi.com (وهو الموقع الذي يوجد عليه الملف)\nالرؤوس: x-api-key: 1234567890 (وهو مفتاح التطبيق الذي يسمح للطلب بالوصول إلى الخدمة)\n\n\n\n\n\n\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client-&gt;&gt;Server: GET /v1/images/search HTTP/1.1\n    activate Server\n    Server-&gt;&gt;+Client: HTTP/1.1 200 OK\n    deactivate Server\n\n\n\n\n\n\n\nimport httpx\n\nclient = httpx.Client()\n\nrequest = client.build_request(\n    method=\"GET\",\n    url=\"https://api.thecatapi.com/v1/images/search\",\n    headers={\n        \"x-api-key\": \"live_9Cj8P0h75D5h2D7Y2H8MYEuuTmTXjT412xNlbVBouHxn2sEnAjr1dr4JMfIn4Mr4\"\n    }\n)\n\nوفي الواقع يتم تكوين الطلب كنص (string) بهذا الشكل (ونحن هنا نطبعه بصيغته النصية لغرضٍ تعليمي):\n\nprint(f\"\"\"\n{request.method} {request.url.path} HTTP/1.1\n{\"\\n\".join([f\"{k}: {v}\" for k, v in request.headers.items()])}\n\n\"\"\")\n\n\nGET /v1/images/search HTTP/1.1\nhost: api.thecatapi.com\naccept: */*\naccept-encoding: gzip, deflate\nconnection: keep-alive\nuser-agent: python-httpx/0.28.1\nx-api-key: live_9Cj8P0h75D5h2D7Y2H8MYEuuTmTXjT412xNlbVBouHxn2sEnAjr1dr4JMfIn4Mr4\n\n\n\n\nفأما السطر الأول:\nGET /v1/images/search HTTP/1.1\nفمكون من ثلاثة أجزاء:\n\nنوع الطلب: GET ذلك أننا نريد حصول على معلومات (لا إنشاءها ولا تغييرها)\nالمسار: /v1/images/search هو المسار الفرعي الذي يحدد الخدمة المطلوبة\nنسخة قوانين التواصل: HTTP/1.1 فشكل الطلب والجواب يعتمد على هذه النسخة\n\nوأما الوُجهة فمحددة بالرأس Host على هذا النحو:\nhost: api.thecatapi.com\nوالترويسة الأخيرة x-api-key هي ليست من الترويسات المعرَّفة في HTTP، ولكنه اتفاق بين العميل والخادم:\nx-api-key: ...\nوقد أضاف العميل رؤسًا لم نعيِّنها وهي: accept, accept-encoding, connection, user-agent، وإليك معناها:\n\naccept: */* وتعني أننا نقبل الجواب بأي صيغة؛ سواء كانت بصيغة JSON أو HTML أو أي صيغة أخرى\naccept-encoding: gzip, deflate تعني أن العميل يتوقع المحتوى مضغوطًا بصيغة ضغط معينة\nconnection: keep-alive تعني أن العميل يريد الحفاظ على الاتصال بالخادم\nuser-agent: python-httpx/0.28.1 هي ترويسة إجبارية ولا يهم ما تكون قيمتها. لكنها تعرِّف بهوية العميل\n\nوبعد ذلك نرسل الطلب بالإجراء send ونحصل على جواب response:\n\nresponse = client.send(request)\n\nوالجواب نفسه له الصيغة النصية التالية:\n\nprint(f\"\"\"\n{response.status_code} {response.reason_phrase}\n{\"\\n\".join([f\"{k}: {v}\" for k, v in response.headers.items()])}\n\n{response.text}\n\"\"\")\n\n\n200 OK\nx-dns-prefetch-control: off\nx-frame-options: SAMEORIGIN\nstrict-transport-security: max-age=15552000; includeSubDomains\nx-download-options: noopen\nx-content-type-options: nosniff\nx-xss-protection: 1; mode=block\nvary: Origin\nexpires: Tue, 03 Jul 2001 06:00:00 GMT\nlast-modified: Sun Apr 13 2025 05:14:53 GMT+0000 (Coordinated Universal Time)\ncache-control: post-check=0, pre-check=0\nauthenticated: false\ncontent-type: application/json; charset=utf-8\nx-response-time: 208ms\nx-cloud-trace-context: c0bc923974f33dc6844b382a6623e9ba\ndate: Sun, 13 Apr 2025 05:14:53 GMT\nserver: Google Frontend\ncontent-length: 89\n\n[{\"id\":\"3l2\",\"url\":\"https://cdn2.thecatapi.com/images/3l2.jpg\",\"width\":500,\"height\":332}]\n\n\n\nولاحظ أول سطر في نص الجواب: 200 OK تعني أن الطلب تمُّ إنجازه بنجاح. وراجع الرؤس (Headers) إن أردت معرفة معنى كل ترويسة هنا (وليست تهمنا الآن). لكن ما يبدأ بحرف x- هو إضافي وليس من أساس لغة HTTP المتفق عليها، ولذلك قد لا تجده في التوثيق العام، وإنما تجده في توثيق مزوِّد للخدمة.\nولاحظ أن آخر سطرٍ هو المحتوى:\n[{\"id\": ... ,\"url\": ... , ... }]\nوإذا نظرت إلى النصّ الموجود في محتوى الرد (response.text) فإنك ستلاحظ أنه نصُّ مقوْلَب بصيغة JSON التي سبق الحديث عنها:\n\nprint(type(response.text))\nprint(response.text)\n\n&lt;class 'str'&gt;\n[{\"id\":\"3l2\",\"url\":\"https://cdn2.thecatapi.com/images/3l2.jpg\",\"width\":500,\"height\":332}]\n\n\nولكن هذا النص لا يمكن التعامل معه كما هو، لذلك نستخدم الإجراء json() لتفسيره إلى شيء في بايثون (قائمة):\n\ndata = response.json()\nprint(type(data))\nprint(data)\n\n&lt;class 'list'&gt;\n[{'id': '3l2', 'url': 'https://cdn2.thecatapi.com/images/3l2.jpg', 'width': 500, 'height': 332}]\n\n\nالآن أصبح في هيكل بيانات يمكن التعامل معه. فنريد استخراج رابط الصورة منه:\n\nimage_url = data[0][\"url\"]\nprint(image_url)\n\nhttps://cdn2.thecatapi.com/images/3l2.jpg\n\n\nفهذا الرابط، لو نسخته وأدخلته في المتصفح فستظهر لك صورة القط.\n\n\nالكود\nfrom IPython.display import Image, display\n\ndisplay(Image(url=image_url))",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>التخاطب عبر الشبكة (HTTP)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a3_use_http.html#مثال-خدمة-الطقس",
    "href": "chapters/15_community/a3_use_http.html#مثال-خدمة-الطقس",
    "title": "20  التخاطب عبر الشبكة (HTTP)",
    "section": "مثال: خدمة الطقس",
    "text": "مثال: خدمة الطقس\nوالرابط يشبه استدعاء الإجراء. لاحظ أننا في بايثون نستدعي الإجراء pow من الوحدة math ونمرر العوامل 2, 3 إليه على هذا النحو:\n\nimport math\n\nmath.pow(2, 3)\n\n8.0\n\n\nوهكذا نشبِّه ذلك بطريقة العنوان الموحَّد باعتبار أن المورِد هو معالجة؛ وهي سؤالٌ عن الطقس في مدينة لندن:\n\n\n\n\nOrigin (الأصل)\nPath (المسار)\nQuery (المعاملات)\n\n\n\n\nhttps://api.openweathermap.org\n/weather\n?city=London\n\n\nmath\npow\n2, 3\n\n\n\n\n\nفكما أننا نطلب الإجراء pow من الوحدة math ونمرر العوامل 2, 3 إليه\nفكذلك نطلب المورِد /weather من الموقع https://api.openweathermap.org ونمرر العوامل ?city=London إليه\n\nالعامل يبتدأ بعلامة الاستفهام ? ثم اسم العامل city وقيمته London وهو اسم المدينة\n\n\nلنأخذ مثالاً آخر على استخدام خدمة برمجية، وهي خدمة الطقس من OpenWeatherMap. هذه الخدمة تتيح لنا معرفة حالة الطقس في أي مدينة في العالم.\nأولاً، نحتاج إلى مفتاح API من الموقع (يمكنك الحصول عليه مجاناً بعد التسجيل). ثم نستخدم مكتبة httpx للاتصال بالخدمة.\nففي صفحة التوثيق قالوا إن طريقة الطلب هي على النحو التالي:\nنشرح الرابط حتى تتبين أجزاؤه ليسهل عليك بعد ذلك قراءة أية رابط:\nhttps://api.openweathermap.org/data/3.0/onecall?lat={lat}&lon={lon}&exclude={part}&appid={API key}:\n\nhttps://api.openweathermap.org هو الأصل (Origin)\n/data/3.0/onecall هو المسار الفرعي (Path)\n? العلامة الفاصلة بين المسار والعوامل\n& علامة فاصلة بين العوامل نفسها\nlat={latitude} هو تعيين للعامل الأوَّل بقيمة latitude أي: خط العرض\nlon={longitude} هو تعيين للعامل الثاني بقيمة longitude أي: خط الطول\nexclude={part} اختيار البيانات التي تريد استبعادها في جواب الطلب\nappid={API key} هو مفتاح التطبيق الذي يسمح للطلب بالوصول إلى الخدمة\n\nونحن نكتبها في بايثون مع مكتبة httpx على النحو التالي:\n\nimport httpx\n\nlatitude = 24.7136\nlongitude = 46.6753\n\nclient = httpx.Client()\n\nrequest = client.build_request(\n    method=\"GET\",\n    url=\"https://api.openweathermap.org/data/3.0/onecall\",\n    params={\n        \"lat\": round(latitude, 4),\n        \"lon\": round(longitude, 4),\n        \"appid\": \"4a5417dd3a781b7f64f05178ed423a23\"\n    }\n)\n\nresponse = client.send(request)\nprint(response.text)\n\n{\"cod\":401, \"message\": \"Please note that using One Call 3.0 requires a separate subscription to the One Call by Call plan. Learn more here https://openweathermap.org/price. If you have a valid subscription to the One Call by Call plan, but still receive this error, then please see https://openweathermap.org/faq#error401 for more info.\"}\n\n\nأو اختصارًا باستعمال httpx.get مباشرةً هكذا:\n\nimport httpx\n\nlatitude = 24.7136\nlongitude = 46.6753\n\nresponse = httpx.get(\n    url=\"https://api.openweathermap.org/data/3.0/onecall\",\n    params={\n        \"lat\": round(latitude, 4),\n        \"lon\": round(longitude, 4),\n        \"appid\": \"4a5417dd3a781b7f64f05178ed423a23\"\n    }\n)\nprint(response.text)\n\n{\"cod\":401, \"message\": \"Please note that using One Call 3.0 requires a separate subscription to the One Call by Call plan. Learn more here https://openweathermap.org/price. If you have a valid subscription to the One Call by Call plan, but still receive this error, then please see https://openweathermap.org/faq#error401 for more info.\"}",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>التخاطب عبر الشبكة (HTTP)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/a3_use_http.html#انطلق-بالتطبيق",
    "href": "chapters/15_community/a3_use_http.html#انطلق-بالتطبيق",
    "title": "20  التخاطب عبر الشبكة (HTTP)",
    "section": "انطلق بالتطبيق",
    "text": "انطلق بالتطبيق\nوبهذا تكون قادرًا على التعامل مع أي برمجيَّة توفِّر خدماتها عبر الشبكة. تحتاج فقط أن تُقدِم وتجرِّب حتى تأخذ يدك على الأمر!\nانتقل إلى المسائل.فإن أردت البحث عن واجهة برمجية لعمل شيء ما، فاكتب الكلمات المفتاحية + “API” في محرك البحث؛ مثلاً: Google Maps API.\nملاحظة: بعض الواجهات تتطلب التسجيل للحصول على مفتاح API. وبعضها يحتاج إضافة إلى ذلك شحن الحساب برصيد مثل 5 دولارات. وكل ذلك مبين في التوثيق نفسه.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>التخاطب عبر الشبكة (HTTP)</span>"
    ]
  },
  {
    "objectID": "chapters/15_community/problems.html",
    "href": "chapters/15_community/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "قراءة توثيق مكتبة (httpx)\nنرجو منك أولاً قراءة صفحة البداية السريعة لـ httpx كاملةً بتأني؛ لأنها ستعطيك نظرة عامة على آليات HTTP وكيفية التعبير عنها بلغة بايثون. وذلك لأن HTTP هي لغة التخاطب على شبكة الإنرتنت بين البرمجيات.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/15_community/problems.html#التطبيق-على-إحدى-الواجهات-البرمجية",
    "href": "chapters/15_community/problems.html#التطبيق-على-إحدى-الواجهات-البرمجية",
    "title": "مسائل",
    "section": "التطبيق على إحدى الواجهات البرمجية",
    "text": "التطبيق على إحدى الواجهات البرمجية\nلابد أن تجد في موقع المزوِّد توثيقًا لجميع تفاصيله للاستفادة منه. ابحث عل كلمة API Documentation أو Developers ونحوهما لتجد التوثيق. وقد تجد عنوانًا مثل: بداية سريعة (Quick Start) أو نحوها للبدء. وعادةً ما يتضمن التوثيق: وصف جميع نقاط الالتقاء (Endpoints) التي تحدد العناوين الفرعية التابعة للعنوان الرئيسي للواجهة. الآن دورك. عليك قراءة التوثيق بتمعُّن، والتجول في صفحاته حتى تتعلم كيفية استخدام الواجهة البرمجية لتحقيق مهمة واحدة.\nجرب استعمال أحد الواجهات البرمجية التالية:\n\npoetrydb\nnewtown\nalquran-cloud\nWikipedia\nnasa\narxiv\nTelegram\nDiscord\nGoogle AI Studio\n\nوهنا تجميع لقائمة كبيرة مقسمة اختر منها ما تريد (وقد يكون بعضها لا يعمل): https://github.com/public-apis/public-apis.\nفإن أردت البحث عن واجهة برمجية لعمل شيء ما، فاكتب الكلمات المفتاحية + “API” في محرك البحث؛ مثلاً: Google Maps API.\nملاحظة: بعض الواجهات تتطلب التسجيل للحصول على مفتاح API. وبعضها يحتاج إضافة إلى ذلك شحن الحساب برصيد مثل 5 دولارات. وكل ذلك مبين في التوثيق نفسه.",
    "crumbs": [
      "باب مكتبات المجتمع البرمجي",
      "مسائل"
    ]
  },
  {
    "objectID": "appendix/appendix_collections.html",
    "href": "appendix/appendix_collections.html",
    "title": "ملحق A — خريطة الجُمُوع",
    "section": "",
    "text": "Type\nInheritance Chain\n\n\n\n\nlist\nMutableSequence -&gt; Sequence -&gt; Collection\n\n\ntuple\nSequence -&gt; (Collection + Reversible)\n\n\nrange\nSequence -&gt; (Collection + Reversible)\n\n\nstr\nSequence -&gt; (Collection + Reversible)\n\n\ndict\nMutableMapping -&gt; Mapping -&gt; Collection\n\n\nfrozenset\nSet -&gt; Collection\n\n\nset\nMutableSet -&gt; Collection\n\n\nCollection\n(Iterable + Sized + Container)\n\n\n\n\n\n\n\n\n\n\n\nclassDiagram\n    class Container {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n    }\n\n    class Iterable {\n        &lt;&lt;abstract&gt;&gt;\n        +__iter__()\n    }\n\n    class Iterator {\n        &lt;&lt;abstract&gt;&gt;\n        +__next__()\n        +__iter__()\n    }\n\n    class Reversible {\n        &lt;&lt;abstract&gt;&gt;\n        +__reversed__()\n    }\n\n    class Sized {\n        &lt;&lt;abstract&gt;&gt;\n        +__len__()\n    }\n\n    class Collection {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n    }\n\n    class Sequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__len__()\n        +__contains__()\n        +__iter__()\n        +__reversed__()\n        +index()\n        +count()\n    }\n\n    class MutableSequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__len__()\n        +insert()\n        +append()\n        +clear()\n        +reverse()\n        +extend()\n        +pop()\n        +remove()\n        +__iadd__()\n    }\n\n    class Set {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +__le__()\n        +__lt__()\n        +__eq__()\n        +__ne__()\n        +__gt__()\n        +__ge__()\n        +__and__()\n        +__or__()\n        +__sub__()\n        +__xor__()\n        +isdisjoint()\n    }\n\n    class MutableSet {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +add()\n        +discard()\n        +clear()\n        +pop()\n        +remove()\n        +__ior__()\n        +__iand__()\n        +__ixor__()\n        +__isub__()\n    }\n\n    class Mapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__iter__()\n        +__len__()\n        +__contains__()\n        +keys()\n        +items()\n        +values()\n        +get()\n        +__eq__()\n        +__ne__()\n    }\n\n    class MutableMapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__iter__()\n        +__len__()\n        +pop()\n        +popitem()\n        +clear()\n        +update()\n        +setdefault()\n    }\n\n    Iterable &lt;|-- Iterator\n    Iterable &lt;|-- Reversible\n    Sized &lt;|-- Collection\n    Iterable &lt;|-- Collection\n    Container &lt;|-- Collection\n    Reversible &lt;|-- Sequence\n    Collection &lt;|-- Sequence\n    Sequence &lt;|-- MutableSequence\n    Collection &lt;|-- Set\n    Set &lt;|-- MutableSet\n    Collection &lt;|-- Mapping\n    Mapping &lt;|-- MutableMapping\n\n    MutableSequence &lt;-- list\n    Sequence &lt;-- tuple\n    Sequence &lt;-- range\n    Sequence &lt;-- str\n    MutableMapping &lt;-- dict\n    Set &lt;-- frozenset\n    MutableSet &lt;-- set\n\n\n\n\nشكل A.1: الأنواع المجردة حول الجمع (Collection)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>خريطة الجُمُوع</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html",
    "href": "appendix/functions_and_methods.html",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "",
    "text": "الأعداد (الأعداد الصحيحة int والأعداد العشرية float)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#القائمة-القوائم-list",
    "href": "appendix/functions_and_methods.html#القائمة-القوائم-list",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "القائمة (القوائم list)",
    "text": "القائمة (القوائم list)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#القاموس-القواميس-dict",
    "href": "appendix/functions_and_methods.html#القاموس-القواميس-dict",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "القاموس (القواميس dict)",
    "text": "القاموس (القواميس dict)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#المجموعة-المجموعات-set",
    "href": "appendix/functions_and_methods.html#المجموعة-المجموعات-set",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "المجموعة (المجموعات set)",
    "text": "المجموعة (المجموعات set)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#النص-str",
    "href": "appendix/functions_and_methods.html#النص-str",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "النص (str)",
    "text": "النص (str)\n\nإجراءات مبنيَّة\n\n\n\n\n\n\n\nالإجراء\nالوصف\n\n\n\n\nlen(obj) -&gt; int\nلمعرفة عدد العناصر.• obj: كائن قابل للعد مثل السلسلة النصية أو القائمة.\n\n\nprint(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False)\nطباعة.• objects: الكائنات المراد طباعتها.• sep: الفاصل بين الكائنات (افتراضيًا مسافة).• end: النهاية (افتراضيًا سطر جديد).• file: وجهة الطباعة (افتراضيًا الشاشة).• flush: تنظيف المخزن المؤقت فورًا.\n\n\nord(c) -&gt; int\nلمعرفة رمز Unicode لحرف.• c: حرف واحد كسلسلة نصية.\n\n\nint(x=0, base=10) -&gt; int\nتحويل سلسلة نصية إلى عدد صحيح.• x: القيمة المراد تحويلها.• base: النظام العددي (افتراضيًا عشري).\n\n\nfloat(x) -&gt; float\nتحويل سلسلة نصية إلى عدد عشري.• x: القيمة المراد تحويلها.\n\n\n\n\n\nأفعال شائعة الاستعمال\n\n\n\n\n\n\n\nالفعل\nالوصف\n\n\n\n\nstr.upper() -&gt; str\nتحويل السلسلة النصية إلى أحرف كبيرة.\n\n\nstr.lower() -&gt; str\nتحويل السلسلة النصية إلى أحرف صغيرة.\n\n\nstr.find(sub[, start[, end]]) -&gt; int\nالبحث عن موضع سلسلة نصية فرعية داخل سلسلة نصية.• sub: السلسلة النصية المراد البحث عنها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.replace(old, new[, count]) -&gt; str\nاستبدال تكرارات سلسلة نصية فرعية داخل سلسلة نصية.• old: السلسلة النصية المراد استبدالها.• new: السلسلة النصية البديلة.• count: عدد مرات الاستبدال (اختياري).\n\n\nstr.split(sep=None, maxsplit=-1) -&gt; list\nتقسيم السلسلة النصية إلى قائمة من السلاسل النصية الفرعية.• sep: المحدد (افتراضيًا المسافات البيضاء).• maxsplit: أقصى عدد للتقسيمات.\n\n\nstr.join(iterable) -&gt; str\nدمج عناصر من iterable إلى سلسلة نصية باستخدام فاصل.• iterable: مجموعة من السلاسل النصية.\n\n\nstr.strip([chars]) -&gt; str\nإزالة المسافات البيضاء من بداية ونهاية السلسلة النصية.• chars: الأحرف المراد إزالتها (اختياري).\n\n\nstr.startswith(prefix[, start[, end]]) -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تبدأ بمقدمة محددة.• prefix: المقدمة المراد التحقق منها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.endswith(suffix[, start[, end]]) -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تنتهي بنهاية محددة.• suffix: النهاية المراد التحقق منها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.count(sub[, start[, end]]) -&gt; int\nعد عدد تكرارات سلسلة نصية فرعية داخل سلسلة نصية.• sub: السلسلة النصية المراد عدها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.format(*args, **kwargs) -&gt; str\nإنشاء سلسلة نصية منسقة باستخدام عناصر نائبة.• args: المتغيرات المراد تنسيقها بالترتيب.• kwargs: المتغيرات المراد تنسيقها بالاسم.\n\n\n\n\n\nأفعال معروفة\n\n\n\n\n\n\n\nالفعل\nالوصف\n\n\n\n\nstr.encode(encoding='utf-8', errors='strict') -&gt; bytes\nترميز السلسلة النصية باستخدام ترميز محدد.• encoding: نوع الترميز.• errors: كيفية معالجة الأخطاء.\n\n\nstr.casefold() -&gt; str\nتحويل السلسلة النصية إلى نسخة casefold للمقارنات غير الحساسة لحالة الأحرف.\n\n\nstr.capitalize() -&gt; str\nتحويل الحرف الأول من السلسلة النصية إلى حرف كبير.\n\n\nstr.center(width[, fillchar]) -&gt; str\nتوسيط السلسلة النصية داخل عرض حقل محدد.• width: العرض المطلوب.• fillchar: حرف التعبئة (اختياري).\n\n\nstr.translate(table) -&gt; str\nاستبدال الأحرف في السلسلة النصية باستخدام جدول ترجمة.• table: جدول الترجمة.\n\n\nstr.expandtabs(tabsize=8) -&gt; str\nتوسيع أحرف الجدولة في السلسلة النصية.• tabsize: حجم التبويب (افتراضيًا 8).\n\n\nstr.index(sub[, start[, end]]) -&gt; int\nالبحث عن موضع سلسلة نصية فرعية، وإثارة استثناء إذا لم يتم العثور عليها.• sub: السلسلة النصية المراد البحث عنها.• start: موضع بداية البحث (اختياري).• end: موضع نهاية البحث (اختياري).\n\n\nstr.rjust(width[, fillchar]) -&gt; str\nمحاذاة السلسلة النصية إلى اليمين.• width: العرض المطلوب.• fillchar: حرف التعبئة (اختياري).\n\n\nstr.ljust(width[, fillchar]) -&gt; str\nمحاذاة السلسلة النصية إلى اليسار.• width: العرض المطلوب.• fillchar: حرف التعبئة (اختياري).\n\n\nstr.swapcase() -&gt; str\nتبديل حالة الأحرف في السلسلة النصية.\n\n\nstr.title() -&gt; str\nتحويل السلسلة النصية إلى حالة عنوان.\n\n\nstr.zfill(width) -&gt; str\nملء السلسلة النصية بالأصفار على اليسار.• width: العرض المطلوب.\n\n\nstr.splitlines([keepends]) -&gt; list\nتقسيم السلسلة النصية إلى قائمة من الأسطر.• keepends: الاحتفاظ بنهايات الأسطر (اختياري).\n\n\nstr.partition(sep) -&gt; tuple\nتقسيم السلسلة النصية إلى ثلاثة أجزاء.• sep: الفاصل.\n\n\n\n\n\nأفعال نادرة الاستعمال\n\n\n\n\n\n\n\nالفعل\nالوصف\n\n\n\n\nstr.isalnum() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف أبجدية رقمية.\n\n\nstr.isalpha() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف أبجدية.\n\n\nstr.isdecimal() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف عشرية.\n\n\nstr.isdigit() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أرقام.\n\n\nstr.isidentifier() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية معرف بايثون صالح.\n\n\nstr.islower() -&gt; bool\nالتحقق مما إذا كانت جميع الأحرف المكونة في السلسلة النصية صغيرة.\n\n\nstr.isnumeric() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف رقمية.\n\n\nstr.isprintable() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من أحرف قابلة للطباعة.\n\n\nstr.isspace() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية تتكون فقط من مسافات بيضاء.\n\n\nstr.istitle() -&gt; bool\nالتحقق مما إذا كانت السلسلة النصية في حالة عنوان.\n\n\nstr.isupper() -&gt; bool\nالتحقق مما إذا كانت جميع الأحرف المكونة في السلسلة النصية كبيرة.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#التعبير-النمطي-re",
    "href": "appendix/functions_and_methods.html#التعبير-النمطي-re",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "التعبير النمطي (re)",
    "text": "التعبير النمطي (re)\n\n\n\n\n\n\n\nالإجراء\nالوصف\n\n\n\n\nre.match(pattern, string, flags=0) -&gt; Match or None\nمطابقة النمط في بداية السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.\n\n\nre.search(pattern, string, flags=0) -&gt; Match or None\nالبحث عن أول تطابق للنمط في السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.\n\n\nre.findall(pattern, string, flags=0) -&gt; list\nإنشاء قائمة من جميع التطابقات للنمط في السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.\n\n\nre.finditer(pattern, string, flags=0) -&gt; Iterator[Match[str]]\nإنشاء مكرر لجميع التطابقات للنمط في السلسلة النصية.• pattern: النمط المراد مطابقته.• string: السلسلة النصية المراد البحث فيها.• flags: أعلام اختيارية لتعديل السلوك.\n\n\n\n\nالمطابق (Match)\n\n\n\n\n\n\n\nالإجراء\nالوصف\n\n\n\n\nmatch.group([group]) -&gt; str\nإرجاع النص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاعها (افتراضيًا المجموعة الكاملة).\n\n\nmatch.groups(default=None) -&gt; tuple\nإرجاع جميع المجموعات الفرعية كنصوص.• default: القيمة الافتراضية للمجموعات غير المطابقة.\n\n\nmatch.groupdict(default=None) -&gt; dict\nإرجاع القاموس الذي يحتوي على المجموعات المسماة.• default: القيمة الافتراضية للمجموعات غير المطابقة.\n\n\nmatch.start([group]) -&gt; int\nإرجاع موضع بداية النص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاع موضع بدايتها (اختياري).\n\n\nmatch.end([group]) -&gt; int\nإرجاع موضع نهاية النص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاع موضع نهايتها (اختياري).\n\n\nmatch.span([group]) -&gt; tuple\nإرجاع موضع البداية والنهاية للنص المطابق أو مجموعة فرعية منه.• group: رقم المجموعة المراد إرجاع مواضعها (اختياري).\n\n\nmatch.pos -&gt; int\nموضع بداية البحث في السلسلة النصية.\n\n\nmatch.endpos -&gt; int\nموضع نهاية البحث في السلسلة النصية.\n\n\nmatch.lastindex -&gt; int or None\nرقم آخر مجموعة فرعية مطابقة أو None إذا لم توجد.\n\n\nmatch.lastgroup -&gt; str or None\nاسم آخر مجموعة فرعية مطابقة أو None إذا لم توجد.\n\n\nmatch.re -&gt; Pattern\nكائن النمط المستخدم في المطابقة.\n\n\nmatch.string -&gt; str\nالسلسلة النصية التي تم مطابقتها.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#الملفات-file",
    "href": "appendix/functions_and_methods.html#الملفات-file",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "الملفات (file)",
    "text": "الملفات (file)",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#مكتبة-المسار-pathlib",
    "href": "appendix/functions_and_methods.html#مكتبة-المسار-pathlib",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "مكتبة المسار (pathlib)",
    "text": "مكتبة المسار (pathlib)\nوإليك تصنيف لعمليات مكتبة pathlib:\n\nعمليات المسار\n\nإنشاء وتعديل المسارات:\n\n.joinpath: دمج مكونات مسار.\n.parent: استخراج الدليل الأب.\n.name: استخراج الاسم الأساسي للملف.\n.stem: استخراج اسم الملف بدون الامتداد.\n.suffix: استخراج امتداد الملف.\n.with_name: إنشاء مسار جديد باسم مختلف.\n.with_suffix: إنشاء مسار جديد بامتداد مختلف.\nrelative_to: إنشاء مسار نسبي.\n\n\n\n\nعمليات على نظام الملفات\n\nاستعلام:\n\nis_absolute: هل هو مطلق؟.\nsamefile: هل مساران يشيران إلى نفس الملف؟.\nexists: هل هو مسار موجود؟.\nis_file: هل هو مسار ملف؟.\nis_dir: هل هو مسار دليل؟.\nis_symlink: هل هو ارتباط رمزي؟.\nstat: سرد إحصائيات نظام الملفات.\nlstat: سرد إحصائيات نظام الملفات دون متابعة الارتباطات الرمزية.\n\nعمليات تغيير:\n\nopen: فتح ملف للقراءة أو الكتابة أو الإضافة.\nmkdir: إنشاء دليل.\nrmdir: حذف دليل فارغ.\nunlink: حذف ملف.\nrename: تعديل اسم ملف.\nreplace: تعديل اسم ملف مع الكتابة فوقه إذا لزم الإجراء.\nchmod: تغيير أذونات الملف.\nlchmod: تغيير أذونات الملف دون متابعة الارتباطات الرمزية.\ntouch: تحديث الطابع الزمني للملف.\n\n\n\n\nالارتباطات الرمزية والصلبة\n\nsymlink_to: إنشاء ارتباط رمزي.\nhardlink_to: إنشاء ارتباط صلب.\nreadlink: قراءة الهدف من ارتباط رمزي.\n\n\n\nالتكرار والبحث\n\niterdir: تكرار على قائمة الدليل.\nglob: البحث عن الملفات المطابقة لنمط.\nrglob: البحث بشكل متكرر عن الملفات المطابقة لنمط.\nwalk: التنقل بشكل متكرر في شجرة الأدلة.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/functions_and_methods.html#النسخ-والحذف-والنقل-shutil",
    "href": "appendix/functions_and_methods.html#النسخ-والحذف-والنقل-shutil",
    "title": "ملحق B — مرجع الإجراءات والأفعال",
    "section": "النسخ والحذف والنقل (shutil)",
    "text": "النسخ والحذف والنقل (shutil)\n\nshutil.copy2: نسخ ملف.\nshutil.copytree: نسخ شجرة أدلة.\nshutil.rmtree: حذف شجرة أدلة.\nshutil.move: نقل ملف أو دليل.",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>مرجع الإجراءات والأفعال</span>"
    ]
  },
  {
    "objectID": "appendix/glossary.html",
    "href": "appendix/glossary.html",
    "title": "ملحق C — قاموس المصطلحات",
    "section": "",
    "text": "الكود\nfrom IPython.display import display, HTML\nimport pandas as pd\n\n# Read the CSV file\ndf = pd.read_csv('../assets/glossary.csv')\n\n# Replace NaN values in the 'comment' column with empty strings\ndf['comment'] = df['comment'].fillna('')\n\ndf.rename(columns={\n    'ar': 'عربي',\n    'en': 'English',\n    'comment': 'تعليق'\n}, inplace=True)\n\n# Display the dataframe as an HTML table\ndf.to_html(index=False)\ndisplay(HTML(df.to_html(index=False)))\n\n\n\n\n\nEnglish\nعربي\nتعليق\n\n\n\n\nIdentifier\nمعرِّف\nبالكسر\n\n\nVariable\nمتغير\n\n\n\nValue\nقيمة\n\n\n\nLiteral\nحرفي\n\n\n\nSimple Statement\nجملة بسيطة\n\n\n\nCompound Statement\nجملة مركبة\n\n\n\nExpression\nتعبير\nمثل: `x + y`\n\n\nClause\nشطر جملة\nمثل: `if x &gt; y`\n\n\nCode Block\nقطعة برمجية\n\n\n\nOperation\nعملية\nمثل: `+` في `x + y` و مثل: `.` في `point.x`\n\n\nFunction\nفعل\nفي سياق البرمجة لا نقول دالة لأن الدالة دائمًا لها مخرجات ولا تتأثر إلا بمدخلاتها\n\n\nMethod\nفعل أو سلوك\nمثل: `append` في `list.append(x)`\n\n\nObject\nشيء أو كائن\n\n\n\nClass\nصنف\nأو فئة\n\n\nType\nنوع\n\n\n\nContainer\nحاوية\nأو حاوي\n\n\nIterable\nمُكرَّر\nبالفتح\n\n\nIterator\nمكرِّر\nبالكسر\n\n\nReversible\nمعكوس\nمفعول به: قابل للعكس\n\n\nGenerator\nمولِّد\nفاعل\n\n\nSized\nمحجَّم\nصفة: ذو حجم\n\n\nCallable\nمنادى\n\n\n\nCollection\nجمع\nعكس المفرد\n\n\nSequence\nتسلسل\n\n\n\nMutable Sequence\nتسلسل متغير\n\n\n\nList\nقائمة\n\n\n\nList Index\nمؤشر قائمة\n\n\n\nDatabase Index\nفهرس قاعدة بيانات\n\n\n\nTuple\nصف\nفرد، زوج) صف ثلاثي، صف رباعي، ...إلخ\n\n\nSet\nمجموعة\n\n\n\nDictionary\nقاموس\n\n\n\nMapping\nدالة\n\n\n\nHashable\nمرقوم\nصفة: يصير رقمًا\n\n\nDictionary Key\nمرقوم قاموس\n\n\n\nDictionary Item\nرابط\n\n\n\nKey\nمفتاح\n\n\n\nValue\nقيمة\n\n\n\nString\nنص\n\n\n\nView\nعرض\n\n\n\nParameter\nمعامل\nوهي المتغيرات الشكلية في تعريف الفعل\n\n\nArgument\nمعامل\nقيم التعيين للمتغيرات الشكلية\n\n\nModule\nوحدة\n\n\n\nPackage\nحزمة\n\n\n\nLibrary\nمكتبة\n\n\n\nFramework\nإطار عمل\n\n\n\nBuilt-in\nمدمج\n\n\n\n{}\nقوسين معوجين أو قوسين متعرجين\n\n\n\n[]\nقوسين مربعين\n\n\n\n()\nقوسين دائريين\n\n\n\n&lt;&gt;\nقوسين زاويين أو قوسين حادين\n\n\n\nFeedback\nتعقيب\nالتعليقات أو الردود التي ترد بعد عرض رأي أو عمل\n\n\nStatic\nثابت\n\n\n\nDynamic\nمتغير\n\n\n\nConstant\nثابت\n\n\n\nVariable\nمتغير\n\n\n\nSystem Time\nوقت النظام\n\n\n\nCalendar Time\nوقت التقويم\n\n\n\nEpoch\nالمرجع الزمني الحاسوبي\n\n\n\nPositional\nمكاني\n\n\n\nSwap\nقَلب\nفعل\n\n\nFile\nملف\n\n\n\nPath\nمسار\n\n\n\nDirectory\nدليل\n\n\n\nAbsolute Path\nمسار مطلق\nيبدأ من الجذر\n\n\nRelative Path\nمسار نسبي\nيبدأ من الموقع الحالي\n\n\nContext Manager\nمدير سياق\nيتحكم في فتح وإغلاق الموارد\n\n\nRecursion\nتسلسل\nفي الفعل فعلٌ بنفس الفعل\n\n\nRecursive Function\nفعل متسلسل\n\n\n\nExecution Frame\nإطار تنفيذ\n\n\n\nObject-Oriented Programming\nبرمجة شيئية\n\n\n\nAttribute\nصفة\nمتغير مسند لمعيَّن من النوع\n\n\nMethod\nفعل\nفعل مسند لمعيَّن من النوع\n\n\nComposition\nتركيب\n\n\n\nInheritance\nتوريث",
    "crumbs": [
      "الملحقات",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>قاموس المصطلحات</span>"
    ]
  }
]