[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "فاتحة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.\nكتبت هذا الكتاب لمن أراد تعلم البرمجة بلغة عربية سهلة ، وبطريقة منهجية مرتبة مع مراعاة الجانبين: النظري والعملي. وليس الهدف منه تعلم طريقة التفكير، فهذا يُدرس في الخوارزميات وهياكل البيانات، ولكن الهدف هو التعرف على الأدوات البرمجية نفسها عن طريق طرح مسائل نستعمل فيها هذه الأدوات.\nولم يكن الهدف من الكتاب ترجمة كتب علمية أو مقالات برمجية إلى اللغة العربية؛ بل الهدف هو تعلم البرمجة. فحرصت على أن يكون الكلام متداولاً ولو لم تكن المصطلحات قاموسية. واخترت من الاصطلاح ما يزول به الغموض مراعيًا السياقات المختلفة لتكون أقرب لفهم المتعلم العربي.\nواخترت لغة بايثون لتعليم البرمجة لسهولتها وشهرتها مما يجعل كثيرًا من التطبيقات في المتناول، إذ الجهود متظافرة على خدمةمكتباتها من المجتمعات التي تتمحور حول صنف ما من التطبيقات. وقد نقسم أنواع التطبيقات إلى ثلاثة:\nأنظمة تحاكي الواقع: مثلاً برنامج لمحاكاة القوى المؤثرة وتوزيع الأحمال على جسر (أو عمارة أو باخرة أو طائرة) يساعد المهندسين على بناء الجسر (وربما خطة تفصيلية متدرِّجة).\nأنظمة فاعلة في الواقع: مثلاً في المصنع: الذراع الآلية ، وآلة القص ، وآلة الكبس ، …إلخ. من الآلات التي تعمل ضمن مجموعة متسقة لتنتج ما تنتج على خط الإنتاج.\nأنظمة المعلومات: تُعنى بجمع المعلومات وحفظها وفهرستها وترتيبها وتقسيمها وعرضها وتسهيل الحصول عليها بالسؤال المباشر وغير المباشر، والتحقق منها وتوفيرها والاستفادة منها وترجمتها ونحو ذلك. وهذا النوع هو الأغلب. مثل: محرك بحث قوقل (يعمل على ترتيب شبكة الإنترنت) ، ونظام الدفع عبر البطاقة ، والبرمجيات المكتيبة (تقارير ، محاسبة ، تخطيط، …إلخ) ، ونحو ذلك .",
    "crumbs": [
      "فاتحة"
    ]
  },
  {
    "objectID": "index.html#تمهيد",
    "href": "index.html#تمهيد",
    "title": "البايثونية",
    "section": "تمهيد",
    "text": "تمهيد\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nوأدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة الحفظ.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة المتعددة.",
    "crumbs": [
      "فاتحة"
    ]
  },
  {
    "objectID": "01_setup.html",
    "href": "01_setup.html",
    "title": "1  إعداد بيئة التطوير",
    "section": "",
    "text": "نبدأ بالتعرف على بيئة التطوير ، وتثبيتها في جهازك؛ وذلك أنني أؤمن بضرورة إكساب الفرد أعلى قدر من التحكم في أدواته حتى يتمكن منها ومن تطويعها لعمل ما يريد بالشكل الأمثل.\nبيئة التطوير هي الأدوات البرمجية الأساسية والمساعدة لعمليات كتابة الكود وتنفيذه واختباره ونحو ذلك.\nأول ما نحتاج إليه هو حزمة برمجيات بايثون التي تتضمَّن الأداة التي تترجم ما نكتبه من كود بلغة بايثون لأوامِر ثنائية (صفر وواحد) لتكون مفهومة على مستوى نظام التشغيل ومعمارية الحاسب (إذ هي مستويات أكثر تفصيلاً)؛ ونسميه المُفَسِّر (Interpreter) وإن شئت قُل مترجم.\nكما تتضمن هذه الحزمة برنامج pip المسؤول عن تثبيت الحِزَم البرمجية المكتوبة بلغة بايثون؛ وذلك حتى تتمكن من البناء عليها عند كتابة أكواد بايثون (وبهذا الاعتبار تسمى مكتبات)، أو فقط لاستعمال برمجيات مكتوبة ببايثون (وبهذا الاعتبار تسمى برمجيات).\nأما محرر الكود فسنختار استوديو البرمجة المرئية (Visual Studio Code) (وهو مختلف عن بيئة تطوير فيجوال ستوديو (Visual Studio)) ولعلنا نسميه محرر أكواد مايكروسوفت (الذي يستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024) لأن الشركة أسسته ثم فتحت للمجتمع البرمجي أكواده. وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن. وتعني الشركة بدعمه وصيانته باستمرار وتطويره، كما أتيح بفتح أكواده سهولة كشف الأخطاء فيه، وأتيح بفضل تصميمه لأن يُخصص وتمتد إمكانياته بإضافات برمجيَّة قابلة للتثبيت يقوم بتزويدها لبعضهم البعض المجتمع البرمجي على مختلف لغاته واستعمالاته.\nونرى أن التعلم يكون أسهل على دفتر جوبيتر (Jupyter Notebook) داخل محرر الأكواد ، وذلك لأنه يتيح تجربة قطع الكود بطريقة مباشرة ومنفصلة سنراها في حينها بدل تنفيذ الكود كملف كامل.\nنأتي الآن على كيفية تثبيت هذه المكونات في الجهاز.\n\nتنزيل مثبِّت حزمة برمجيات بايثون؛ بالذهاب لصفحة https://www.python.org/ والضغط على زر (Download).\n\n\n\n\nHow to download Python from https://www.python.org/\n\n\n\nتنزيل مثبِّت محرر الأكواد من: Visual Studio Code\nلربط لغة البايثون في محرر الكود .. قم بتثبيت Python Extension.\nولربط المحرر بدفتر جوبيتر ، قم بتثبيت Jupyter Extension.\nقم بتثبيت حزمة ipykernel عن طريق pip وذلك لتتمكن من تنفيذ قطع الكود الواقعة في دفتر جوبيتر. يستلزم ذلك أن تفتح نافذة الأوامر (Terminal) ثم تكتب فيها هذا السطر:\n\npip install ipykernel\n\nأنشئ دفتر جوبيتر، وذلك بإنشاء ملف جديد بصيغة ipynb. عن طريق محرر الكود.\n\nبعد ذلك تكون جاهزًا للبدء في الدرس الأول!",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>إعداد بيئة التطوير</span>"
    ]
  },
  {
    "objectID": "02_intro.html",
    "href": "02_intro.html",
    "title": "2  مقدمة",
    "section": "",
    "text": "2.1 الشيء المفرد\nويندرج تحت صنف الأرقام مجموعة أصناف وإن شئت قل: أنواع، وهي: (العدد الصحيح، والعدد العشري، والعدد التخيلي) وكذلك يندرج تحتها في نموذج بايثون (العدد الثنائي) الذي يكون إما صفرًا أو واحدًا (0 أو 1).\nفاشتراكها في صفة الرقمية (الذي جعلها تحت صنف الأرقام) أتى من حيث أنها تقبل عمليات الجمع والطرح والقسمة ، وكذلك عمليات المقارنة (أكبر من ، وأصغر من ، والمساواة) ونحو ذلك مما تقبله الأرقام. وسيأتي الحديث عنها بالتفصيل في باب الأرقام.\nمثال بلغة البرمجة نقول:\nx = 123\nfoo = 123.45\nok = True\nnot_ok = False\nفالسطر الأول يعين قيمة 123 (وهي من جنس الأعداد الصحيحة) للاسم x وذلك عن طريق عملية التعيين (=). والثاني مثله لكن عدد عشري (لاحظ أنه يمكن للمسمى أن يكون كلمة ولا يشترط أن يكون حرفًا كما في الرياضيات). والثالث مثله لكن قيمة ثنائي تساوي 1 (“نعم”). والخامس مثله لكن تساوي 0 (“لا”). فكل هذه أرقام.\nونستعرض الآن كيف نجري عمليات على الأرقام:\nx = 5\ny = 10\nz = x + y\nprint(z)\n\n15\nلاحظ أن علامة الـ(=) ليست تعني مساواة الطرفين كما في المعدالات الرياضية. وإنما هي عمليَّة تعيين (مثلها مثل عملية الجمع +) تقوم بإسناد قيمة لمسمى (وهو x هنا)؛ كأنما تُخزِّن القيمة في صندوقٍ معنوَن بالاسم x. وقل مثل ذلك في y وكذلك في z.\nوتستطيع أن تقول إن ما قبل علامة التعيين (=) أصبح اسمًا مُعرَّفًا يُشير إلى شيء. وما بعد العلامة هو الشيء: وله صفتان أساسيتان: البيانات (5) والعمليات التي تُعرَف ضِمنيًّا بحسب النوع (int) وتعني صِنف الأعداد الصحيحة (Integers)، الذي يندرج تحت صنف الأرقام (numbers).\nلو أردنا معرفة نوع الشيء، فلدينا عملية type(x) نستخدمها هكذا:\nprint(type(10))\n\n&lt;class 'int'&gt;\nprint(type(100 + 200))\n\n&lt;class 'int'&gt;",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "02_intro.html#الشيء-المفرد",
    "href": "02_intro.html#الشيء-المفرد",
    "title": "2  مقدمة",
    "section": "",
    "text": "في السطر الأول: قمنا بتعيين القيمة 5 لمعرف x\nفي السطر الثاني: مثل الأول لمعرف y\nفي السطر الثالث: تعيين ناتج عملية الجمع (+) بين عددين\nفي السطر الرابع: print هي عملية تقدَّم تعريفها ضمن المكتبة الأساسية في حزمة البايثون، تعمل هنا على الكائن الرقمي z ليكون حاصلها: كتابة قيمة الرقم على الشاشة.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "02_intro.html#الشيء-المجموع",
    "href": "02_intro.html#الشيء-المجموع",
    "title": "2  مقدمة",
    "section": "2.2 الشيء المجموع",
    "text": "2.2 الشيء المجموع\nتعلمنا كيف نخزن قيمة عدد في x وقيمة عدد آخر في y. لكن لو أردنا التعامل مع مجموعة أعداد معًا لنحسب جمعها أو متوسطها أو غير ذلك من العمليات سواءً البسيطة منها والمعقدة، فإن لغة بايثون تستطيع التعبير عن ذلك. بل إن الشيء المعبر عن ذلك هو المتسلسلة: مجموعة مرتَّبة من الأشياء.\nففي المثال التالي تعيين شيئين من نوع متسلسلة متغيرة (وكونها متغيرة يعني أنها تقبل الزيادة والنقص)، تحوي أشياء؛ وهذه الأشياء هي أعدادًا صحيحة في هذه الحالة. ثم نرى كيفية إجراء عملية محددة بعلامة + بين المتسلسلتين.\n\none = [10, 20, 30]\ntwo = [40, 50, 60]\ncombined = one + two\nprint(combined)\n\n[10, 20, 30, 40, 50, 60]\n\n\nلاحظ أن النتيجة هي إضافة المتسلسلة الثانية للمتسلسلة الأولى لتصبح متسلسلة جديدة فيها العناصر الأولى تتبعها الثانية عناصر الثانية. وقد تتساءل لماذا لم تكن النتيجة جمع الأعداد المتقابلة؟ والإجابة هي: أنها عُرِّفَت هكذا هذه العملية للأشياء التي من نوع متسلسلة.\nكما يوجد لنوع المتسلسلة (سواءً المتغيرة والثابتة) عمليات خاصة مثل len التي ناتجها عدد عناصرها؛ وتستعمل على النحو التالي:\n\nx = len(one)\nprint(x)\n\n3\n\n\nنقرأ القطعة السابقة فنقول: إن عمليَّة len تأخذ قيمة المعرف one (أو نقول: إننا نُمرِّر قيمة المعرف)؛ لتعطينا عدد العناصر (الذي هو عدد صحيح)؛ فنُعيِّن تلك القيمة بعلامة (=) للمعرف x. ثم نطبع ذلك باستخدام عملية print.\nولسنا بحاجة للمعرف x إذ يُمكن كتابة العملية على ناتج العملية السابقة مباشرة بحيث تكون التي في الأقواس أوَّل تنفيذًا ثم التي الأقواس الأشمل، وهكذا على النحو التالي:\n\nprint(len(one))\n\n3\n\n\nونأتي الآن لنوع آخر يكثر استخدامه وهو متسلسلة الأحرف وهي في الحقيقة صنف مركَّب من المتسلسلة (سنتعلم كيفية التركيب في باب: الأصناف). فهي تستمد منها خصائصها (مثل أنها تقبل الدمج بعلامة +) وتضيف فوق ذلك عمليات إضافية خاصة للتعامل مع الأحرف.\nولكثرة استخدامها جُعل لها في اللغة علامة التنصيص (\") لتحدد عناصرها بدلا من الأقواس المربعة ([ ]) التي تحدد عناصر السلسلة المتغيرة.\nانظر هذا المثال الذي نعرف فيه message ليشير إلى متسلسلة أحرف. ثم نستخدم نفس العملية التي استخدمناها مع المتسلسلة التي كانت تحتوي على أرقام لمعرفة عدد العناصر (len) ونخزن ذلك في مُعرَّف length ثم نقوم بطباعته عن طريق عملية print.\n\nmessage = \"Adam\"\nlength = len(message)\nprint(length)\n\n4",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "02_intro.html#عملية-مسندة-لشيء",
    "href": "02_intro.html#عملية-مسندة-لشيء",
    "title": "2  مقدمة",
    "section": "2.3 عملية مُسندة لشيء",
    "text": "2.3 عملية مُسندة لشيء\nوللعمليات شكلٌ آخر تستخدمه لغات البرمجة الشيئية، وهو أن توضَع علامة نقطة . بعد الشيء ثم كتابة اسم العمليَّة على النحو التالي:\n\nmessage = \"hello adam\"\nup = message.upper()\nprint(up)\n\nHELLO ADAM\n\n\nوقد تتساءل عن الأقواس الفارغة فتقول: ما هي مدخلات هذه العملية؟ فنقول: في البرمجة الشيئية: هذه العبارة تجعل العامل الأوَّل (المُدخل الأوَّل) لها هو ذات الشيء المذكور. ثم ما تضعه في الأقواس يكون مُدخلاً ثانيًا وثالثًا وهكذا إن وُجدوا.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "02_intro.html#علامة-بين-الأشياء",
    "href": "02_intro.html#علامة-بين-الأشياء",
    "title": "2  مقدمة",
    "section": "2.4 علامة + بين الأشياء",
    "text": "2.4 علامة + بين الأشياء\nوننبه هنا على أمرٍ يختلط على المبتدئ في البرمجة، وهو التفريق بين صنف الرقم وصنف متسلسلة الأحرف، كما في المثال الآتي. فنقول: علامة + بين عددين تشير لعملية الجمع بينهما:\n\nx = 20 + 20\nprint(x)\n\n40\n\n\nبينما تعريف علامة + بين متسلسلتين من الحروف (وذلك لوجود علامة التنصيص \")، تكون عملية دمج:\n\ny = '20' + \"20\"\nprint(y)\n\n2020\n\n\nملاحظة: لغة بايثون لا تفرق بين علامة التنصيص المفرد ('A') والتنصيص المزدوج (\"A\") كما تفرق بينهما لغات أخرى مثل سي (C) أو جافا (Java).\nأما إن حاولت وضع علامة (+) بين شيئين لم تُعرَّف العملية هذه بينهما فإن البرنامج سيقف برسالة خطأ، تفيد بأن العلامة غير مُسندة لعملية مُعرَّفة بين هذين الشيئين (هو لم يجد أنها جمع ولا دمج). لاحظ هنا أن العملية بين عدد ومتسلسلة نصية:\n\nprint(x + y) \n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 print(x + y) \n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nفيمثل الشيء x قيمة عدد صحيح يُمكن جمعه وطرحه وقسمته ونحو ذلك، أما y فيشير لمتسلسلة حروف؛ لا تتيح الحساب الرقمي ، وإنما يمكن دمجها وفصلها وتكرارها ونحو ذلك؛ لأنها في الحقيقة حرفان وليست عددًا.\nوإن أردت تحويل نوع لنوع، فذلك عادة يكون باستعمال عملية لها نفس اسم ذلك النوع. تأمثل المثال التالي:\n\nx = 40\ny = \"2020\"\nz =  int(y)\nprint(type(x))\nprint(type(y))\nprint(type(z))\nprint(x + z)\n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'int'&gt;\n2060",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "02_intro.html#نمو-اللغة-بتراكم-البنى-المنطقية",
    "href": "02_intro.html#نمو-اللغة-بتراكم-البنى-المنطقية",
    "title": "2  مقدمة",
    "section": "2.5 نمو اللغة بتراكم البنى المنطقية",
    "text": "2.5 نمو اللغة بتراكم البنى المنطقية\nتتضمن بايثون مركبات لغوية تسمح بتعريف الأشياء (مثل =) وتسمح بالعبارات الشرطية (if و else) وحلقات التكرار (for) ونحو ذلك كثير مما سنراه في الدروس القادمة إن شاء الله. وفوق ذلك نجد في حزمة بايثون المكتبة الأساسية (المكتبة: حزمة عمليات وأشياء) تعتبر هي والمركبات اللغوية حجر أساس في بناء البرمجيات فوقها. وهي التي تحدد الحدود التي يمكن أن تصل إليها أيها المبرمج بهذه اللغة.\nونستعرض هنا بعض العمليات الأساسية (مثل: sum, len, max, min)، وذلك باستعمال المفردات المُعرَّفة علنًا. (لاحظ أن ما يُكتب بعد علامة # فإنه يعتبر كلامًا عاديًّا ولا يُعدُّ من البرمجة)\nxs = [1, 2, 3, 4, 5]\n\n# length\nl = len(xs)\n\n# sum\nresult = sum(xs)\n\n# max and min\na = max(xs)\nb = min(xs)\n\nif a &gt; 100:\n    print('do this')\n\nif b &lt; 0:\n    print('do that')\nوسيأتي بالتفصيل الكلام عن هذا.\nثم نستعرض هنا الحزم الأساسية كحزمة math وهي ضمن المكتبة الأساسية:\n\nimport math\n\nsq = math.sqrt(16)\nprint(sq)\n\n4.0\n\n\nفهذه عملية الجذر التربيعي أتينا بها بطلب الحزمة (math) ثم أشرنا إلى المُعرَّف sqrt المندرج تحتها عن طريق علامة النقطة . مع القوسين لتعمل هذه العملية على مدخلات معيَّنة (16) فتنتج لنا شيئًا نعيِّنُه عن طريق عملية (=) للمُعرَّف sq.\nبهذا تبيَّن أن لغة بايثون قابلة للتطوُّر بشكل قوي جدًّا، بحيث يبني كل شخص على:\n\nالعبارات البرمجية (عبارة تعيين ، عبارة شرط ، عبارة تكرار، …إلخ) التي تستعمل كلمات أصلية في اللغة\nالمكتبة الأساسية التي تتضمن عمليات أساسية وحِزَمًا تتضمن أشياء وعمليات إضافية\n\nفيستطيع كل شخص تركيب حزمة جديدة مكونة من أشياء مركبة وعمليات مركبة يستفيد هو في ذلك من حزم أشخاص آخرين ، ثم يوفرها هو لأشخاص آخرين. وهكذا ينمو النتاج البرمجي ، حزمةً تِلو الأخرى بحسب اهتمامات كل مجتمع برمجي.\nفالمجتمعات البرمجية التي تدور حوْل حزم تطوِّرها بالتشارك العلني في بايثون متعددة جدًا باهتمامات مختلفة، منها على سبيل المثال لا على سبيل الحصر:\n\nتطوير مواقع شبكة الانترنت: Django و FastAPI\nبناء نماذج البيانات: statsmodels, scikit-learn, TensorFlow, PyTorch\nتصوير البيانات: seaborn, matplotlib\nالتحليل الرياضي والهندسة: sympy, PySR, SciPy\nأتمتة عمليات نظم المعلومات: ansible, salt\n\nوتصل عدد المشاريع (تقريبًا عدد الحزم) في قاعدة بيانات (PyPI) اليوم ما يزيد على 580,000 مشروع. وتجد الكود مشاعًا على أكبر منصة لإدارة الأكواد البرمجية: GitHub.\nبعد أن أخذنا نظرة عامة على لغة بايثون، سنأتي على المفاهيم الأساسية على وجه التفصيل في الدروس القادمة.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html",
    "href": "03_control-flow.html",
    "title": "3  التحكم في سير الأوامر",
    "section": "",
    "text": "3.1 التعبير المنطقي\nأما الشروط فتستند إلى المنطق الرقمي الثنائي الذي نجد له في بايثون كلمتين من أصل اللغة هما: True (تساوي الرقم 1) وتعبِّر عن تحقق الأمر، وكلمة: False (تساوي الرقم 0) وتعبِّر عن عدم التحقق. وكلاهُما شيء من الصنف: ثنائي.\nالتعبيرات المنطقية هي تعبيرات تؤول إما إلى True أو False. ولذا فإن منها جُمل المقارنة:\nلنستكشف سويًّا التعبيرات المنطقية وما يمكن بينها:\nb1 = 5 &gt; 9\nprint(b1)\n\nFalse\nb2 = len('12345') &gt; len('123456789')\nprint(b2)\n\nFalse\nيمكن دمج التعبيرات المنطقية باستخدام العوامل and، or، و not:\nb3 = b1 and b2\nprint(b3)\n\nFalse\nb4 = b1 or b2 or b3\nprint(b4)\n\nFalse\nb5 = not b1\nprint(b5)\n\nTrue",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html#التعبير-المنطقي",
    "href": "03_control-flow.html#التعبير-المنطقي",
    "title": "3  التحكم في سير الأوامر",
    "section": "",
    "text": "العلامة\nالوصف\n\n\n\n\na == b\nيساوي\n\n\na != b\nلا يساوي\n\n\na &gt; b\nأكبر من\n\n\na &lt; b\nأصغر من\n\n\na &gt;= b\nأكبر من أو يساوي\n\n\na &lt;= b\nأصغر من أو يساوي\n\n\n\n\n\n\n\n\n\n\nA\nB\nAND\nOR\nXOR\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n\n\nAND (و): تُعطي النتيجة 1 فقط إذا كان كلا المدخلين 1.\nOR (أو): تُعطي النتيجة 1 إذا كان أحد المدخلين على الأقل 1.\nXOR (أو الحصرية): تُعطي النتيجة 1 إذا كان المدخلان مختلفين.\nNOT (ليس): يعكس المدخل (1 يصبح 0، و0 يصبح 1).",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html#جملة-التوكيد",
    "href": "03_control-flow.html#جملة-التوكيد",
    "title": "3  التحكم في سير الأوامر",
    "section": "3.2 جملة التوكيد",
    "text": "3.2 جملة التوكيد\nتُدرَج جُملَ التوكيد في ثنايا الكود للتحقق من صحَّة التسلسل المنطقي. فالتوكيد يُحدثُ خطأ إذا كانت القيمة التي نؤكدها خاطئة. مثلاً:\n\nassert False\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 assert False\n\nAssertionError: \n\n\n\nكما تُسحتب الكتابة بلغة البشر لما يجب أن يكون ، بعد الفاصلة، هكذا ، لتظهر في رسالة الخطأ واضحة:\n\nx = 10\ny = 20\nassert x &gt; y, 'x should be greater than y'\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[8], line 3\n      1 x = 10\n      2 y = 20\n----&gt; 3 assert x &gt; y, 'x should be greater than y'\n\nAssertionError: x should be greater than y\n\n\n\nأما إذا كانت العبارة صحيحة فلا خطأ:\n\nassert True\n\n\nx = 2 ** 4\ny = pow(2, 4)\nassert x == x, 'x should be equal to x'\n\nهذه الجُمَل البسيطة تساعد في اختبار الكود وكشف الأخطاء في وقتٍ مبكِّر ، كما أنها تساعد في التعلُّم (الآن عرفت أن ** هي عملية الأس pow) كما سنستخدمها الآن لأنها تحقق ما نحن بصدد التحقق منه. وهي تغنينا عن كثيرٍ من جُمَل print().",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html#الجملة-الشرطية",
    "href": "03_control-flow.html#الجملة-الشرطية",
    "title": "3  التحكم في سير الأوامر",
    "section": "3.3 الجملة الشرطية",
    "text": "3.3 الجملة الشرطية\nتُستخدم العبارات الشرطية لتنفيذ أجزاء مختلفة من الكود بناءً على قيمة تعبير منطقي. مثال:\n\nif b5:\n    print('Inside')\nprint('Outside')\n\nInside\nOutside\n\n\n\n3.3.1 المحاذاة العمودية (Indentation)\nلاحظ أن المحاذاة العمودية (المسافات البيضاء أسفل كلمة if) في الكود أعلاه ليست لمجرد تسهيل قراءة الكود، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال الكود.\nلاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في الكود:\n\nif b5:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[12], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل الكود بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\nif b5:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\nيؤدي الكود السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في كتابة كود بايثون!\n\n\n3.3.2 تركيب الشروط\nيمكنك دمج شروط متعددة باستخدام العوامل and، or، و not، لأنها تنتج قيمة منطقية (boolean value). على سبيل المثال:\n\nage = 20\nheight = 175\n\nif age &gt; 18 and height &gt; 170:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nيمكننا استخدام الأقواس لتجميع الشروط معًا. كما أنها تزيل أي غموض في ترتيب العمليات:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\nيُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون True أو False ولا بأس بتجزئته حينما يسهل بذلك الفهم:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\nb = is_minor or (is_cold and not is_wearing_coat)\n\nif b:\n  print(\"I suggest you don't go outside\")\n\n\n\n3.3.3 الجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية على النحو التالي:\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelse:\n    &lt;code&gt;\nقد يوجد elif واحدة أو أكثر، وقد توجد else واحدة فقط. أما الكلمة elif فهي اختصار لـ else if. تسلسل if … elif … elif … هو بديل لجمل switch أو case الموجودة في لغات أخرى.\nجرب الكود التالي بقيم مختلفة لـ x وحاول تتبع تدفق التحكم:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Negative changed to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nNegative changed to zero\nAlways: 0\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.\n\n\n3.3.4 تضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\nلاحظ أيضًا أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\n3.3.4.1 مثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "04_functions.html",
    "href": "04_functions.html",
    "title": "4  العمليات",
    "section": "",
    "text": "4.1 العوامل بين الترتيب والتسمية\nنفهم من تعريف العملية pow(base, exp, mod=None) أن لديها ثلاثة عوامل: base، exp، و mod بهذا الترتيب. لاحظ أن العامل mod اختياري (لوجود التعيين الافتراضي mode=None). هذا يعني أن العملية يمكن استعمالها بطرق مختلفة:\nprint(pow(2, 4))\nprint(pow(2, exp=4))\nprint(pow(base=2, exp=4))\nprint(pow(exp=4, base=2))\n\n16\n16\n16\n16\nفإن أردنا تعريف عوامل تستعمل بهذه الطريقة، فإننا نضعها في التعريف على النحو التالي:\ndef calculate_bmi(weight, height, unit='metric'):\n    \"\"\" Calculate the Body Mass Index (BMI)\n        \n        weight and height must be of the same unit.\n\n        unit is either 'metric' or 'imperial'.\n    \"\"\"\n    if unit == 'imperial':\n        weight *= 0.453592\n        height *= 0.0254\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\nالآن يمكننا استعمال العملية بطرق مختلفة. لاحظ أن استخدام assert هنا للتحقق من أن العملية تنتج نفس القيمة بغض النظر عن كيفية تمرير العوامل.\nw = 70   # kg\nh = 1.75 # meters\n\nprint(calculate_bmi(w, h))\n\nassert (\n    calculate_bmi(w, h) ==\n    calculate_bmi(w, height=h) ==\n    calculate_bmi(weight=w, height=h) ==\n    calculate_bmi(height=h, weight=w)\n)\n\n22.86\nونفس الأمر بالنسبة للعامل الذي عينت له قيمة افتراضية units='imperial':\nw = 154 # pounds\nh = 70  # inches\n\nprint(calculate_bmi(w, h, 'imperial'))\n\nassert (\n    calculate_bmi(w, h, 'imperial') ==\n    calculate_bmi(w, h, unit='imperial')\n)\n\n22.1",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>العمليات</span>"
    ]
  },
  {
    "objectID": "04_functions.html#التعليق-في-مقدمة-العملية",
    "href": "04_functions.html#التعليق-في-مقدمة-العملية",
    "title": "4  العمليات",
    "section": "4.2 التعليق في مقدمة العملية",
    "text": "4.2 التعليق في مقدمة العملية\nتحتوي بايثون على عملية أساسية تسمى help() تظهر معلومات عن عملية ما:\n\nhelp(pow)\n\nHelp on built-in function pow in module builtins:\n\npow(base, exp, mod=None)\n    Equivalent to base**exp with 2 arguments or base**exp % mod with 3 arguments\n\n    Some types, such as ints, are able to use a more efficient algorithm when\n    invoked using the three argument form.\n\n\n\nكذلك يمكن استعمالها في أي عملية مُعرَّفة، فهي تأخذ التعليق الذي يبدأ بثلاثة علامات تنصيص (\"\"\") بداية العملية (انظر كيف استعملناها في العملية calculate_bmi):\n\nhelp(calculate_bmi)\n\nHelp on function calculate_bmi in module __main__:\n\ncalculate_bmi(weight, height, unit='metric')\n    Calculate the Body Mass Index (BMI)\n\n    weight and height must be of the same unit.\n\n    unit is either 'metric' or 'imperial'.",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>العمليات</span>"
    ]
  },
  {
    "objectID": "05_loops.html",
    "href": "05_loops.html",
    "title": "5  الحلقات",
    "section": "",
    "text": "5.1 التعيين النسبي\nملاحظة جانبية: انظر التعيين النسبي (Augmented assignment statements) فإنها عند التدقيق تختلف.\nجرب الكود أدناه لترى النتيجة:\ni = 0\nprint(i)\n\n0\ni = i + 1\nprint(i)\n\n1\ni += 1\nprint(i)\n\n2\nلاحظ أن i++ تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:\ni++\nprint(i)\n\n\n  Cell In[19], line 1\n    i++\n       ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#التعيين-النسبي",
    "href": "05_loops.html#التعيين-النسبي",
    "title": "5  الحلقات",
    "section": "",
    "text": "i = i + 1 تعادل i += 1\ni = i - 1 تعادل i -= 1\ni = i * 2 تعادل i *= 2\ni = i / 2 تعادل i /= 2",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#الحلقة-المطلقة",
    "href": "05_loops.html#الحلقة-المطلقة",
    "title": "5  الحلقات",
    "section": "5.2 الحلقة المُطْلقة",
    "text": "5.2 الحلقة المُطْلقة\nالحلقة المُطْلقة (لها كلمة while) هي مثل if لكن مكررة، فكلما انتهت العبارات المضمَّنة داخلها، تعود لسطر الشرط وتنفذه مرة أخرى؛ إلى حين انتفاء الشرط (False).\nأما كونُها مطقلة يعني أن الكود المضمَّن داخل الحلقة هو الذي يحدد متى تتوقف. بينما المقيَّدة يكون التكرار فيها مُحددًّا بعدد معيَّن في نفس الجُملة، وهو على النحو التالي: (for x in items) سيأتي الحديث عنه إن شاء الله في درس قادم.\nصيغة حلقة while كما يلي:\nwhile &lt;boolean expression&gt;:\n    &lt;code&gt;\nيتم تكرار اللبنة الواقعة في نطاق جملة الشرط ما بقي الشرط (True). وإذا انتفى الشرط (False) في البداية، فلن يتم الدخول في اللبنة أصلاً.\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\nونلاحظ هنا أنك إذا نسيت زيادة قيمة i، فإن الحلقة لن تنتهي أبدًا؛ وهذا ما يسمى حلقة لانهائية (infinite loop).\nلنقم بتتبع الخطوات عندما تكون i = 0:\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\nنستخدم دالة input() حيث تقطَع سير البرنامج (Interrupt) فيتوقَّف لتمنح التحكم للمستخدم لتقديم بعض المدخلات، وتنتظر حتى يتم الضغط على مفتاح Enter للإشارة إلى أن الإدخال اكتمل ، ليعود التحكم للبرنامج كي يُكمِل سيره.\nيمكن استعمال الحلقة المطلقة مثلاً لتكرار السؤال عن رقم حتى يتم تخمينه بشكل صحيح:\nnum = \"9\"\nguess = input(\"Guess the number (0-9): \")\nwhile guess != num:\n    guess = input(\"Try again: \")\nprint(\"You guessed it!\")\nوهكذا معظم البرامج كالخوادم (Servers) يكون في داخلها حلقة مطلقة وذلك لاستقبال طلبات المتسفيدين من البرنامج.\n\n5.2.1 تكرار القطع البرمجية\n\nتستخدم كلمة break لإيقاف التكرار تمامًا.\nتستخدم كلمة continue للانتقال إلى التكرار التالي متخطيةً بقية الخطوات في التكرار الحالي.\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\nوهذا مثال لاستخدام continue:\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\nأما عبارة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط. وهذا مثال:\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#المتتالية",
    "href": "05_loops.html#المتتالية",
    "title": "5  الحلقات",
    "section": "5.3 المتتالية",
    "text": "5.3 المتتالية\nنستخدم الجملة: for item in iterable لقراءة متتالية (Iterable). والتي تتضمن المجموعات (Collections) وهي معظم الكائنات الحاوية للبيانات. (وسيأتي الحديث عنها في درس قادم).\n\nfor x in (1, 20, 'ABB', True, False, 1.234):\n    print(x)\n\n1\n20\nABB\nTrue\nFalse\n1.234\n\n\nوهذا البرنامج يصفي قائمة أرقام إلى قائمتين: إحداها زوجية والأخرى فدرية. ملاحظة: علامة % تعني باقي القسمة. فإذا كان الباقي يساوي صفر، فهذا يعني أن العدد زوجي:\n\nnumbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nevens = []\nodds = []\n\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\n    else:\n        odds.append(x)\n\nprint('list of evens:', evens)\nprint('list of odds:', odds)\n\nlist of evens: [12, 14, 16, 18, 20]\nlist of odds: [11, 13, 15, 17, 19]",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#النطاق-range",
    "href": "05_loops.html#النطاق-range",
    "title": "5  الحلقات",
    "section": "5.4 النطاق (range)",
    "text": "5.4 النطاق (range)\nنوع range يمثل تسلسلًا غير قابل للتغيير من الأرقام. ويستخدم عادةً للتكرار عددًا محددًا من المرات في حلقات for.\nوفقًا لوثائق بايثون فإن النطاق له شكلان:\n\nclass range(stop)\nclass range(start, stop[, step])\n\nنشرح العوامل:\n\nstart: موضع الابتداء (وهو مشمول في النطاق). (القيمة الافتراضية 0)\nstop: موضع الانتهاء (وهو غير مشمول في النطاق).\nstep: الخطوة، أي: مقدار الزياة أو النقص بعد كل كرة (القيمة الافتراضية 1)\n\nفإذا قمت بتعيين عامل واحد فسيكون هو stop:\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nوإذا قمت بتعيين عاملين فسيكون الأول start والثاني stop:\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، مع قلب البداية والنهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\nالتكرار على قوائم باستخدام النطاق:\n\nnumbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nfor i in range(1, len(numbers), 2):\n    print(numbers[i])\n\n20\n40\n60\n80\n100",
    "crumbs": [
      "المنهج",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "zz_numbers.html",
    "href": "zz_numbers.html",
    "title": "Appendix A — الأعداد",
    "section": "",
    "text": "A.1 وظيفة الأعداد في لغة البرمجة\nx = 5\ny = 3.0\nz = -10\nb = True\nc = 1 + 2j\nprint(type(x))\nprint(type(y))\nprint(type(z))\nprint(type(b))\nprint(type(c))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'int'&gt;\n&lt;class 'bool'&gt;\n&lt;class 'complex'&gt;",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "zz_numbers.html#وظيفة-الأعداد-في-لغة-البرمجة",
    "href": "zz_numbers.html#وظيفة-الأعداد-في-لغة-البرمجة",
    "title": "Appendix A — الأعداد",
    "section": "",
    "text": "الأعداد الصحيحة (Integers) للفهرسة والعد والترتيب: ..., -2, -1, 0, 1, 2, ...\nالأعداد العشرية (Floats) لتمثيل الكميات مثل المال، المسافة، والوقت: 3.14, 2.718, 0.0, 15.0\nالأعداد المركبة (Complex) في الرياضيات والهندسة: (1 + 2j), (1.0 - 2.0j)\nالقيم المنطقية (Booleans) لتمثيل قيم الحقيقة: True, False\n\n\n\n\nA.1.1 العمليات الحسابية (Arithmetic operations)\n\nprint(x + y) # الجمع (Addition)\nprint(x - y) # الطرح (Subtraction)\nprint(x * y) # الضرب (Multiplication)\nprint(x / y) # القسمة (Division)\nprint(x % y) # باقي القسمة (Remainder)\nprint(x ** y) # الأس (Exponentiation)\n\n8.0\n2.0\n15.0\n1.6666666666666667\n2.0\n125.0\n\n\n\n\nA.1.2 ماذا تعني صفة العددية؟\nالاشتراك في صفة العددية يعني أنها تقبل العمليات الحسابية ، مع ملاحظة أن النوع الأقل دقة يتحول إلى النوع الأعلى دقة:\n\nفمثلاً: int + float = float\nوكذلك: int / int = float\nوأيضًا: bool * int = int\nوهكذا: int * complex = complex\n\n\nprint(x + z)\nprint(x + y)\nprint(y * z)\nprint(b * x)\nprint(c + x)\n\n-5\n8.0\n-30.0\n5\n(6+2j)\n\n\nلاحظ أن قسمة الصحيح تقوم بتقريب النتيجة إلى الأقرب:\n\nprint(7 / 2)  # قسمة صحيحٍ تنتج عشريًا\nprint(7 // 2) # قسمة صحيح تنتج صحيحًا\n\n3.5\n3\n\n\n\nA.1.2.1 تمرين\nتحقق من نوع كل من التعبيرين السابقين باستخدام الدالة type(). هل يمكنك استخراج قاعدة من هذه الأمثلة؟\n\n7 / 2\n7 // 2\n7.0 / 2\n7 / 2.0\n\n# try it\nجرب الآتي حتى تستكشف ماذا يحصل لو:\n\nint + bool\nint * str\nstr * int\nstr + str\nint + str (لاحظ أن هذه العملية ستفشل)\n\n\ni = 5\nb = True\ns1 = '5'\ns2 = '11'\n\nprint(i + b)  # int + bool\n# ... أكمل البقية ...\n\n6\n\n\n\n\n\nA.1.3 ترتيب العمليات (Operator precedence)\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\n\nA.1.3.1 تمرين\nأضف أقواس لتغيير النتيجة لتطابق التوكيد:\n\nassert 3 + 2 * 5 == 25\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 assert 3 + 2 * 5 == 25\n\nAssertionError: \n\n\n\nالحل:\n\nassert (3 + 2) * 5 == 25\n\nمثال آخر:\n\nassert 8 - 4 / 2 == 2\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 assert 8 - 4 / 2 == 2\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n# try it\nمثال أخير:\n\nassert 2 ** 3 * 4 == 4096\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 assert 2 ** 3 * 4 == 4096\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n# try it",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "zz_numbers.html#الدوال-المدمجة-ودوال-المكتبة-الأساسية-built-in-and-standard-library-functions",
    "href": "zz_numbers.html#الدوال-المدمجة-ودوال-المكتبة-الأساسية-built-in-and-standard-library-functions",
    "title": "Appendix A — الأعداد",
    "section": "A.2 الدوال المدمجة ودوال المكتبة الأساسية (Built-in and Standard Library Functions)",
    "text": "A.2 الدوال المدمجة ودوال المكتبة الأساسية (Built-in and Standard Library Functions)\nتتضمن لغات البرمجة دوال مساعدة مكتوبة من قِبل فريق اللغة ومضمَّنة مع حزمة تثبيت اللغة؛ أي أنها لا تستدعي من المبرمج تثبيت حِزَم إضافية. وهي على قسمين:\n\nدوال مدمجة (Built-in functions)\nدوال المكتبة الأساسية ، وتسمى (Standard Library) وتختصر stdlib\n\n\nA.2.1 دوال مدمجة\nوهي الدوال المتاحة المعرَّفة من غير أن نعرِّفها نحن. مثلاً:\n\nprint(abs(-99)) # القيمة المطلقة\nprint(pow(2, 4)) # القوة\nprint(max(10, 20)) # القيمة العظمى\nprint(min(10, 20)) # القيمة الصغرى\n\n99\n16\n20\n10\n\n\nوهنا قائمة بجميع الدوال المدمجة.\n\n\nA.2.2 دوال المكتبة الأساسية\nوهي دوالّ متوفِّرة لكن يجب استيرادها من المكتبة الأساسية بجملة import.\nفمثلاً للوصول إلى دوال رياضية إضافية: import math، ثم نستخدم البادئة math. للوصول إلى الدوال.\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تُحسب باستخدام الصيغة التالية:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\n\nimport math\n\nx = 5.4\nprint(math.floor(x)) # تقريب لأقرب عدد صحيح أصغر\nprint(math.ceil(x)) # تقريب لأقرب عدد صحيح أكبر\nprint(math.trunc(x)) # حذف ما بعد الفاصلة\nprint(round(x, 2)) # تقريب إلى رقمين بعد الفاصلة\n\n5\n6\n5\n5.4\n\n\nملاحظة: الدالة الأخيرة round ليست مستوردة من math وإنما هي مُدمجة.\nوهنا مرجع المكتبة الأساسية لبايثون.\n\nA.2.2.1 تمرين\nاكتب برنامجًا ليعرف رقمين ثم اطبع مجموعهما، الفرق بينهما، حاصل ضربهما، خارج القسمة، وباقي القسمة. استخدم أسماء متغيرات وتعليقات مناسبة.\n# try it\n\n\nA.2.2.2 تمرين\nاحسب مساحة المكعب باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\n\nقم بتعيين العرض (width)، الطول (length)، والارتفاع (height) إلى متغيرات.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\n# try it\n\n\nA.2.2.3 تمرين\nاكتب برنامجًا يطلب من المستخدم إدخال عدد الساعات (hours) ومعدل الأجر لكل ساعة (rate per hour) لحساب الأجر الإجمالي (gross pay).\n# your code here\n\n\nA.2.2.4 تمرين\nاكتب برنامجًا يحسب مساحة الدائرة باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nقم بتعيين نصف القطر إلى متغير.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\nتلميح: يمكنك استخدام الثابت math.pi للحصول على قيمة \\(\\pi\\).\n# your code here\n\n\nA.2.2.5 تمرين\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n# your code here",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "zz_numbers.html#المراجع",
    "href": "zz_numbers.html#المراجع",
    "title": "Appendix A — الأعداد",
    "section": "A.3 المراجع",
    "text": "A.3 المراجع\n\nhttps://docs.python.org/3/reference/simple_stmts.html",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  }
]