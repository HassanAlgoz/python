[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "مقدمة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nثم أدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة التخزين.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة ويشغِّل هذه الإلكترونيات المجهرية لتحقيق مقصوده منها.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#سبب-تأليف-الكتاب",
    "href": "index.html#سبب-تأليف-الكتاب",
    "title": "البايثونية",
    "section": "سبب تأليف الكتاب",
    "text": "سبب تأليف الكتاب\nأردت أنْ أُسْهِمَ في تعليم من هم على أبواب البرمجة ينظرون وليس عندهم دليل يرشدهم في طُرُقاتها. فهم مع ما عندهم من العلوم، لم يدرسوا دراسةً منهجيَّة في علوم الحاسب أو فروعه المهتمَّة بالبرمجة: كأصحاب التخصصات الإنسانية واللغوية والتجريبية والمنطقية والشرعية، ممن يجد في نفسه ميلاً إلى التحليل الرياضي والتدقيق المنطقي. وأرى أن تيسير البرمجة لتكون في أيديهم بابُ خيرٍ عظيم في علومهم وأعمالهم.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-لغة-بايثون-بالتحديد",
    "href": "index.html#لماذا-لغة-بايثون-بالتحديد",
    "title": "البايثونية",
    "section": "لماذا لغة بايثون بالتحديد؟",
    "text": "لماذا لغة بايثون بالتحديد؟\nلغات البرمجة هي أدوات لكن بدل أن تكون هذه الأداة لها أزرار ومقبض ومؤشر وما إلى ذلك من المحسوسات؛ استعمال الأداة هذه يكون بكتابة قطعة برمجية تتبع قواعد اللغة. لذا تتنافس المؤسسات بصناعة لغات تتزاحم في خدمة نفس الأغراض، لذا ينتج لدينا مثل هذه الخريطة:\n\n\n\n\n\n\nflowchart LR\n    subgraph Application_Level\n        direction LR\n        subgraph Web_Application_Servers\n            WebBack1[C# .NET]\n            WebBack2[Java Spring]\n            WebBack3[Python Django]\n        end\n        subgraph Web_Application_Frontends\n            direction TB\n            WebFront1[JavaScript]\n            WebFront1 --&gt; WebFront2[React]\n            WebFront1 --&gt; WebFront3[Vue]\n            WebFront1 --&gt; WebFront4[Angular]\n        end\n        subgraph Mobile_Apps\n            direction TB\n            Mobile1[iOS]\n            Mobile2[Android]\n            Mobile3[Swift] --&gt; Mobile1\n            Mobile4[Flutter]\n            Mobile4 --&gt; Mobile1\n            Mobile4 --&gt; Mobile2\n            Mobile5[Kotlin] --&gt; Mobile2\n        end\n        subgraph Desktop_Apps\n            direction LR\n            Desk1[C# WinUI]\n            Desk2[Java FX]\n            Desk3[\"C++ Qt\"]\n            Desk4[JS Electron]\n        end\n    end\n\n\n\n\nشكل 1: تصنيف لغات البرمجة حسب المجال\n\n\n\n\n\n\n\n\n\n\nflowchart RL\n    subgraph System_Level\n        direction TB\n        subgraph Operating_Systems\n            OS1[C]\n            OS2[Rust]\n        end\n        subgraph Databases\n            DB1[C/C++]\n\n        end\n        subgraph Networking\n            Net1[C/C++]\n            Net2[Go]\n            Net3[Python]\n        end\n    end\n\n\n\n\n\n\nومن اللغات ما هو واسع جدًّا من ناحية الاستعمال إلا أن استعمالها محدد لمجال معيَّن وليسَت لغة عامة يُكتب بها أي شيء؛ وهي اللغات الوصفية (Declarative Languages) وللتكميل نضيفها في الرسم:\n\n\n\n\n\nflowchart RL\n    subgraph Declarative_Languages\n        subgraph Markup\n            Markup1[HTML]\n            Markup2[CSS]\n            Markup3[Markdown]\n            Markup4[LaTeX]\n        end\n        subgraph Query\n            Query1[GraphQL]\n            Query2[SQL]\n        end\n        subgraph Data\n            Data1[JSON]\n            Data2[CSV]\n            Data3[XML]\n            Data4[YAML]\n        end\n    end\n    subgraph Scripting\n        Script1[Bash]\n        Script2[Python]\n        Script3[\"Deno (JS)\"]\n    end\n\n\n\n\n\n\nويقع الاختيار على لغة بايثون كثيرًا لأمور:\n\nالسهولة نسبةً إلى أخواتها؛ حيث يجد فيها المبتدئ قُربًا إلى اللغة الإنجليزية\nالعموم (عدم اختصاصها بمجال ضيق) وذلك يتمثل في تنوع تطبيقاتها\nالقبول فالجهود متظافرة على خدمة مكتباتها من المجتمعات التي تتمحور حول صنف ما من التطبيقات. وهذا التراكم يعني أن كثيرًا من الأوامِِر يعبَّر عنه بأسطر قليلة\n\nومن تطبيقاتها:\n\nتطوير مواقع الشبكة\nالذكاء الاصطناعي وتعلم الآلة:\nتحليل البيانات\nتصوير البيانات\nالتحليل الرياضي والهندسة\n\nوغيرها كثير جدًّا، ويندرج معظمها في أنظمة المعلومات: التي تختص بجمع المعلومات وحفظها وفهرستها وترتيبها وتقسيمها وعرضها وتسهيل الحصول عليها بالسؤال المباشر وغير المباشر، والتحقق منها وتوفيرها والاستفادة منها وترجمتها ونحو ذلك. وهذا النوع هو الأغلب. مثل: محرك بحث قوقل (يعمل على ترتيب شبكة الإنترنت) ، ونظام الدفع عبر البطاقة ، والبرمجيات المكتيبة (تقارير ، محاسبة ، تخطيط، …إلخ) ، ونحو ذلك .",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#عناصر-الكتاب",
    "href": "index.html#عناصر-الكتاب",
    "title": "البايثونية",
    "section": "عناصر الكتاب",
    "text": "عناصر الكتاب\nينقسم الكتاب إلى أبواب: يعالج كل منها موضوعًا في لغة البرمجة.\nينقسم كل باب إلى ثلاثة أجزاء:\n\nالآلية: شرح الكلمات والجمل البرمجية\nالتطبيق: يرى المتعلم استعمال الآليات في سياقات مختلفة\nالتمرين: لترسيخ المفاهيم واكتساب المهارات بالممارسة\nالحل: للتحقق من صحَّة حلك للتمرين",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "إعداد بيئة التطوير",
    "section": "",
    "text": "نبدأ بالتعرف على بيئة التطوير ، وتثبيتها في جهازك؛ وذلك أنني أؤمن بضرورة إكساب الفرد أعلى قدر من التحكم في أدواته حتى يتمكن منها ومن تطويعها لعمل ما يريد بالشكل الأمثل.\nبيئة التطوير هي الأدوات البرمجية الأساسية والمساعدة لعمليات كتابة الكود وتنفيذه واختباره ونحو ذلك.\nأول ما نحتاج إليه هو حزمة برمجيات بايثون التي تتضمَّن الأداة التي تترجم ما نكتبه من كود بلغة بايثون لأوامِر ثنائية (صفر وواحد) لتكون مفهومة على مستوى نظام التشغيل ومعمارية الحاسب (إذ هي مستويات أكثر تفصيلاً)؛ ونسميه المُفَسِّر (Interpreter) وإن شئت قُل مترجم.\nكما تتضمن هذه الحزمة برنامج pip المسؤول عن تثبيت الحِزَم البرمجية المكتوبة بلغة بايثون؛ وذلك حتى تتمكن من البناء عليها عند كتابة أكواد بايثون (وبهذا الاعتبار تسمى مكتبات)، أو فقط لاستعمال برمجيات مكتوبة ببايثون (وبهذا الاعتبار تسمى برمجيات).\nأما محرر الكود فسنختار محرر (VS Codium) وهو مفتوح المصدر، وقد بنت عليه شركة مايكروسوفت محررها (Visual Studio Code) (الذي يستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024) لأن الشركة أسسته ثم فتحت للمجتمع البرمجي أكواده. وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن. وتعني الشركة بدعمه وصيانته باستمرار وتطويره، كما أتيح بفتح أكواده سهولة كشف الأخطاء فيه، وأتيح بفضل تصميمه لأن يُخصص وتمتد إمكانياته بإضافات برمجيَّة قابلة للتثبيت يقوم بتزويدها لبعضهم البعض المجتمع البرمجي على مختلف لغاته واستعمالاته.\nوهناك طريقتان في العمل مع كود البايثون:\n\nالكتابة على ملف .py وتشغيله من أوله إلى آخره\nالكتابة على دفتر جوبتر (.ipynb) وتشغيل كل جزء على حدة (وهذه الطريقة التي نفضلها)\n\nنأتي الآن على كيفية تثبيت هذه المكونات في الجهاز.\n\nتنزيل مثبِّت حزمة برمجيات بايثون؛ بالذهاب لصفحة https://www.python.org/ والضغط على زر التنزيل (Download).\n\n\n\n\nHow to download Python from https://www.python.org/\n\n\n\nتنزيل مثبِّت محرر الأكواد وتثبيته:\n\nالنسخة المعدلة من مايكروسوفت (التي تتضمن متابعتك والربط مع خدماتها السحابية المدفوعة): Visual Studio Code\nالنسخة الحرة مفتوحة المصدر: VS Codium\n\nيجب أن نربط المحرر باللغة: يجب تثبيت وصلة البايثون: Python Extension.\nكما يجب ربط المحرر بدفتر جوبتر: يجب أن نثبت وصلة جوبيتر: Jupyter Extension.\nلتشغيل الكود في دفتر جوبتر يجب تثبيت حزمة ipykernel عن طريق مدير الحزم pip. يستلزم ذلك أن تفتح نافذة الأوامر (Terminal) ثم تكتب فيها السطر التالي:\n\npip install ipykernel\nأخيرًا:\n\nإن أردت كتابة الكود في دفتر جوبتر: أنشئ ملف جديد بصيغة ipynb. وافتحه.\nإن أردت كتابة الكود في ملف بايثون عادي: أنشئ ملف جديد بصيغة .py وافتحه.\n\nبعد ذلك تكون جاهزًا للبدء في الدرس الأول!",
    "crumbs": [
      "إعداد بيئة التطوير"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html",
    "href": "chapters/01_intro/introduction.html",
    "title": "1  لغة البرمجة",
    "section": "",
    "text": "1.1 أصول اللغة\nيتألف البرنامج المكتوب بلغة بايثون من قطع برمجية هي عبارة عن سلسلة من الجُمَل البسيطة والمركبة المكونة من مفردات للتعبير عن الأوامِر بطريقة سهلة على المبرمج كتابتها ، وفي نفس الوقت تتبع قواعد نحوية صارمة لا تشتبه عند ترجمتها لتعليمات مفصَّلة ودقيقة بلغة المنطق الرقمي لآلة لتنفذها.\nوقد تكون هذه الجمل البرمجية أصلية في اللغة وقد تكون مزيدة مما أضيف لاحقًا. فأما المفردات الأصلية في لغة بايثون فهي:\nومنها كذلك: match, case, type و _.\nأما الجمل فتنقسم إلى قسمين:\nثم لدينا المعاملات والمحددات.\nتنبيه: ليس المطلوب حفظ ذلك الآن، وإنما هذه نظرة عامَّة لتكوين تصوُّر مجمل.\nإذاً في لغة بايثون:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#أصول-اللغة",
    "href": "chapters/01_intro/introduction.html#أصول-اللغة",
    "title": "1  لغة البرمجة",
    "section": "",
    "text": "False      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\n\n\nجملة بسيطة:\n\nالتعبير: x + y\nالتعيين: x = y\nالتأكيد: assert condition\nالمرور: pass\nالحذف: del x\nالإرجاع: return y\nالإنتاج: yield y\nرفع الاستثناء: raise Exception\nالكسر: break\nالاستمرار: continue\nالاستيراد: import module\nالعالمية: global x\nغير المحلية: nonlocal x\nالنوع: type(x)\n\n\nجملة مركبة:\n\nالشرط: if ...\nالتكرار: while ...\nالحلقة: for ...\nالمحاولة: try ...\nالسياق: with ...\nالمطابقة: match ...\nتعريف الدالة: def ...\nتعريف الفئة: class ...\nالروتينات المتزامنة: async def ...\nقوائم معلمات النوع: [T1[, T2, ...]]\n\n\n\n\n\n\nالمعاملات فهي رموز لعمليات تختلف بحسب السياق (العوامل):\n+       -       *       **      /       //      %      @\n&lt;&lt;      &gt;&gt;      &       |       ^       ~       :=\n&lt;       &gt;       &lt;=      &gt;=      ==      !=\nفمثلاً: معامل الجمع + له أكثر من تفسير في العبارة: x + y:\n\nإذا كان x و y أرقامًا فإن + هو عملية جمع\nإذا كان x و y نصين فإن + هو عملية دمج\n\n\nالمحددات هي رموز تبين أين تبتدئ بعض الجمل أو تنفصل أو تنتهي:\n(       )       [       ]       {       }\n,       :       !       .       ;       @       =\nومن أمثلتها:\n\nفي العبارة: x = (y + z) * (a + b) لتحديد ترتيب العمليات\nفي الإجراء المستدعى: print(x, y, z) لتحديد العوامل\nفي تعريف صف: xs = (10, 20, 30) لتحديد العناصر\n\n\n\n\n\n\nقطع برمجية\nفي كل قطعة جمل برمجية بسيطة أو مركبة\nفي كل جملة مفردات وتعبيرات وعوامل ومحددات",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#القطعة-البرمجية",
    "href": "chapters/01_intro/introduction.html#القطعة-البرمجية",
    "title": "1  لغة البرمجة",
    "section": "1.2 القطعة البرمجية",
    "text": "1.2 القطعة البرمجية\nفي لغة إجرائية كبايثون فإن تنفيذ الأسطر البرمجية يكون حسب ترتيب كتابتها من الأعلى إلى الأسفل.\n\nالمثال الأول: جمل التعيين والشرط\n\ndistance = 200\nspeed =  100\ntime_to_arrive = distance / speed\n\nif time_to_arrive &gt; 1:\n    print('we are going to be late!')\nelse:\n    print('on time')\n\nwe are going to be late!\n\n\nفي هذه القطعة مجموعة جُمل\n\nتعريف المتغيرات عن طريق جمل التعيين: distance = 200 و speed = 100\nتعيين ناتج حساب قسمة المسافة على السرعة: time_to_arrive = distance / speed\nجملة شرطية: if\n\nالجزء الأول (الشرط): time_to_arrive &gt; 1\n\nالجزء الثاني المضمن داخل القطعة: هي جمل برمجية متعلقة بنفوذ الشرط\n\nالجزء الثالث (في حالة انتفاء الشرط): else\n\nالجزء الرابع (المضمن داخل القطعة): هي جمل برمجية متعلقة بانتفاء ذلك الشرط\n\n\n\nوقد تتضح أكثر حين نرسمها:\n\n\n\n\n\nflowchart TD\n    B[distance = 200] --&gt; C[speed = 100] --&gt; D[time_to_arrive = distance / speed] --&gt; IF1{{time_to_arrive &gt; 1 ?}}\n    IF1 --&gt;|False| X[\"on time\"]\n    IF1 --&gt;|True| Y[\"we are going to be late!\"]\n\n\n\n\n\n\n\n\nالمثال الثاني: القوائم وحلقات التكرار\nهذا المثال أكثر تعقيدًا نسبيًّا:\n\nنعرف سعر كل ثمرة في قائمة أسعار: fruit_prices\n\n\nfruit_prices = {\n    'apple': 0.5,\n    'banana': 0.25,\n    'orange': 0.75\n}\n\n\nنضع بعض المشتريات في السلة: basket\n\n\nbasket = ['apple', 'apple', 'apple', 'banana']\n\n\nنحسب سعر السلة كلها بحسب قائمة الأسعار: total_price\nنحتاج لاستعمال جملة الحلقة: for للمرور على كل عنصر في السلة\nنستعمل جملة الزيادة: += لزيادة الحاصل\nأخيرًا جملة استدعاء لإجراء الطباعة: print\n\n\ntotal_price = 0\n\nfor fruit in basket:\n    total_price += fruit_prices[fruit]\n\nprint(total_price)\n\n1.75",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#المزيدات",
    "href": "chapters/01_intro/introduction.html#المزيدات",
    "title": "1  لغة البرمجة",
    "section": "1.3 المزيدات",
    "text": "1.3 المزيدات\nمن خواص لغة البرمجة: إنشاء مركبات لغوية جديدة. وذلك بثلاثة أمور:\n\nتعريف الدوال / الإجراءات\nتعريف الأصناف / الأنواع\nتعريف الوحدات المتضمنة للأمرين السابقين\n\nفأضاف مطوروا بايثون أنفسهم إلى اللغة ما يسمى بالمكتبة الأساسية وهي على قسمين:\n\nمضمَّنات أساسية، وفيها:\n\nإجراءات مضمَّنة مثل: print, sum, max, min, len\nأصناف مضمَّنة مثل: str, int, list\n\nوحدات أساسية، مثل:\n\nوحدة math التي تضم مجموعة إجراءات تعنى بالعمليات الرياضية على الأعداد\nوحدة datetime التي تضم مجموعة أصناف وإجراءات تعنى بالوقت والتاريخ\n\n\nوكونها مكتبة أساسية فهي تنزل وتثبت مع حزمة لغة بايثون نفسها.\n\nمثال الإجراءات المضمَّنة\n\nmy_list = [20, 10, 30, 40, 50, 20, 10, 20,\n           30, 40, 50, 60, 30, 20, 30, 40]\n\nفلمجموعة الأرقام عدد من الإجراءات المضمَّنة في لغة بايثون مثل:\n\nالجمع: sum\nالقيمة العليا: max\nالقيمة الدنيا: min\nعد العناصر: len\n\nنستعرضها هنا:\n\nprint('sum is:', sum(my_list))\nprint('max is:', max(my_list))\nprint('min is:', min(my_list))\n\navg = sum(my_list) / len(my_list)\nprint('average is:', avg)\n\nsum is: 500\nmax is: 60\nmin is: 10\naverage is: 31.25\n\n\nوغيرها كثير.\n\n\nمثال وحدة الرياضيات الأساسية\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nتعمل هذه القطعة كالتالي:\n\nجملة استيراد المكتبة الرياضية: import math\nتعريف النقطتين: x1, y1 = 0, 0 و x2, y2 = 3, 4\nحساب المسافة: distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) وفيه:\n\nx2 - x1 هو الفرق بين الإحداثيات السينية\ny2 - y1 هو الفرق بين الإحداثيات الصادية\n** هي عملية تربيع العدد\nmath.sqrt هي دالة حساب الجذر التربيعي\n\nطباعة النتيجة: print(distance) وفيه:\n\ndistance هو الناتج النهائي لحساب المسافة\nprint هي دالة تطبع الناتج على الشاشة\n\n\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\nويمكن كتابة قطع برمجية مخزَّنة بحدود يتم تعيينا لاحقها كما هو حال الدوال الرياضية التي تتغير نتيجتها بتغير مدخلاتها. كما في هذا المثال:\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\nprint(distance(x1=0, y1=0, x2=3, y2=4))\nprint(distance(x1=1, y1=1, x2=2, y2=2))\n\n5.0\n1.4142135623730951",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#المكتبات-المساهمة",
    "href": "chapters/01_intro/introduction.html#المكتبات-المساهمة",
    "title": "1  لغة البرمجة",
    "section": "1.4 المكتبات المساهمة",
    "text": "1.4 المكتبات المساهمة\nفهذه عملية الجذر التربيعي أتينا بها باستيراد الوحدة الأساسية math ثم أشرنا إلى الإجراء sqrt المعرَّف ضمنها عن طريق معامل ..\nأما ما ليس أساسيًّّا (مكتبات مساهمة) فإنه متوفِّر في قواعد بيانات على الشبكة مثل PyPI الذي يضم ما يزيد على ما يزيد على 580,000 مشروع، أو غيره من مواقع استضافة حزم بايثون. ويمكن تنزيلها وتثبيتها باستعمال: pip install package_name ومن ثم استعمال لغتها المزيدة بعد بجملة الاستيراد: import package_name على نحو ما فعلناه مع المكتبة الأساسية math.\nمدير الحزم pip هو أداة لتثبيت الحزم من فهرس حزم بايثون (Python Package Index - PyPI). هنا مثلاً صفحة حزمة numpy. على سبيل المثال، تختص حزمة numpy بالعمليات العددية (Numerical Python) على المصفوفات متعددة الأبعاد. وتعتبر هذه الحزمة أصلاً أساسيًّا لدى حزم كثيرة جدًّا في بايثون. ولنستخدمها نحن، يجب تثبيتها على النحو التالي:\npip install numpy\nبعد ذلك نستطيع استعمالها بعد جملة الاستيراد، لنجرب عملية الضربالنقطي بين مصفوفتين:\n\nimport numpy as np\n\nmat1 = np.array([\n    [1, 2],\n    [3, 4]\n])\n\nmat2 = np.array([\n    [5, 6],\n    [7, 8]\n])\n\nprint(np.dot(mat1, mat2))\n\n[[19 22]\n [43 50]]\n\n\nومن الحزم التي تبني علي numpy حزمة pandas المتخصصة في تفكيك وتركيب الجداول والتحليلات الإحصائية عليها. ونحن إذا أردناها نستوردها ونستعملها:\npip install pandas\n\nimport pandas as pd\n\ndf = pd.read_csv('../../datasets/students.csv')\ndf\n\n\n\n\n\n\n\n\nName\nAge\nGrade\n\n\n\n\n0\nMohammed\n19\n88\n\n\n1\nAbdullah\n20\n95\n\n\n2\nAhmed\n21\n87\n\n\n3\nKhalid\n19\n92\n\n\n4\nSara\n20\n94\n\n\n5\nFatima\n22\n89\n\n\n6\nOmar\n21\n91\n\n\n7\nNorah\n20\n93\n\n\n8\nTurki\n19\n86\n\n\n9\nReem\n21\n90\n\n\n\n\n\n\n\nثم التحليل كالتالي:\n\ndf.describe(include=['number']).T\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\n\n\nAge\n10.0\n20.2\n1.032796\n19.0\n19.25\n20.0\n21.00\n22.0\n\n\nGrade\n10.0\n90.5\n3.027650\n86.0\n88.25\n90.5\n92.75\n95.0\n\n\n\n\n\n\n\nوهي من أشهر المكتبات المساهمة في تحليل البيانات المجدولة.\nوالمثال الأخير هو حزمة geopy المتخصصة في الإحداثيات المكانية على الأرض وما يتعلق بها من حسابات وبيانات. يبدوا استعمالها معقَّدًا؛ لكنك ستراه سهلاً فيما بعد:\npip install geopy\nfrom geopy.distance import geodesic\nfrom geopy.geocoders import Nominatim\n\ngeolocator = Nominatim(user_agent=\"exercise\")\n\ndammam_location = geolocator.geocode(\"Dammam, Saudi Arabia\")\nbahrain_location = geolocator.geocode(\"Bahrain\")\n\ndammam_coords = (dammam_location.latitude, dammam_location.longitude)\nbahrain_coords = (bahrain_location.latitude, bahrain_location.longitude)\n\n# Calculate the distance\ndistance = geodesic(dammam_coords, bahrain_coords).kilometers\nprint(f\"Between Dammam and Bahrain is {distance:.2f} km\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#المجتمع-يطور-اللغة",
    "href": "chapters/01_intro/introduction.html#المجتمع-يطور-اللغة",
    "title": "1  لغة البرمجة",
    "section": "1.5 المجتمع يطور اللغة",
    "text": "1.5 المجتمع يطور اللغة\nفهنا دور المجتمع ليبني باللغة بمفرداتها وجملها ومكتبتها الأساسية والخارجية، ليبني فوق ذلك ما يخدم أغراضه. فاستطاع كل فئة من الناس تركيب حزمة جديدة مكونة من أشياء مركبة وإجراءات مركبة يستفيدون هم في ذلك من حزم أناس آخرين ، ثم يوفرونها لغيرهم. وهكذا تنمو اللغة ، حزمةً تِلو الأخرى بحسب إسهامات كل مجتمع برمجي بما يهتم به.\nومن مكامن القوة في لغة بايثون: أنها متوافقة مع لغتي C/C++ إذْ يُمكن كتابة برمجيات عالية الأداء والكفاءة بهما مستفيدين من الحزم الموجودة فيهما، ثم توفيق ذلك ليكون كمكتبة في لغة بايثون.\nفالمجتمعات البرمجية في بايثون كثيرة ومتعددة في اهتماماتها. منها على سبيل المثال:\n\nتطوير مواقع الشبكة:\n\nDjango - لبناء مواقع متصلة بقواعد بيانات\nFastAPI - حديث وسريع لبناء واجهات برمجية على الشبكة\n\nالذكاء الاصطناعي وتعلم الآلة:\n\nstatsmodels - للنماذج الإحصائية\nscikit-learn - لاكتشاف الأنماط والتنبؤ (تعلم الآلة)\nPyTorch - لبناء نماذج التعلم العميق\n\nتصوير البيانات:\n\nseaborn - تصور البيانات الإحصائية على أساس Matplotlib.\nmatplotlib - مكتبة شاملة لإنشاء تصورات ثابتة ومتحركة وتفاعلية.\n\nالتحليل الرياضي والهندسة:\n\nsympy - للرياضيات الرمزية.\nPySR - الانحدار الرمزي.\nSciPy - للرياضيات والعلوم والهندسة.\n\n\nوتصل عدد المشاريع (تقريبًا عدد الحزم) في قاعدة بيانات (PyPI) اليوم ما يزيد على 580,000 مشروع. وتجد الكود مشاعًا على أكبر منصة لإدارة الأكواد البرمجية: GitHub.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html",
    "href": "chapters/02_numbers/a_numbers.html",
    "title": "2  الأعداد",
    "section": "",
    "text": "2.1 الحساب والمقارنة\nx = 5\ny = 10\n\nprint(x + y) # الجمع\nprint(x - y) # الطرح\nprint(x * y) # الضرب\nprint(x / y) # القسمة\nprint(x % y) # باقي القسمة\nprint(x ** y) # الأس\n\n15\n-5\n50\n0.5\n5\n9765625\nالمقارنة بين الأعداد:\nx = 5\ny = 10\n\nprint(x == y) # التطابق\nprint(x != y) # الاختلاف\nprint(x &gt; y) # أكبر\nprint(x &lt; y) # أصغر\nprint(x &lt;= y) # أصغر أو يساوي\nprint(x &gt;= y) # أكبر أو يساوي\n\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "href": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "title": "2  الأعداد",
    "section": "2.2 ترتيب العمليات",
    "text": "2.2 ترتيب العمليات\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\nإليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه. ولاحظ أننا نستعمل جملة التوكيد (assert) التي تسكُت إن كان الشيء الذي أمامها جملة منطقية صحيحة؛ وإلا فهي تظهر رسالة خطأ. وسترى أننا نستعملها بكثرة لتقرير لوازم ما نبينه في الدرس:\n\nassert 3 + 2 * 5 == 13\nassert (3 + 2) * 5 == 25\n\n\nassert 8 - 4 / 2 == 6\nassert (8 - 4) / 2 == 2\n\n\nassert 2 ** 3 * 4 == 32\nassert (2 ** 3) * 4 == 32",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "href": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "title": "2  الأعداد",
    "section": "2.3 التعيين النسبي",
    "text": "2.3 التعيين النسبي\nيراجع: التعيين النسبي.\nلأن التعيين النسبي يستعمل بكثرة، فوجب علينا التعرف عليه، وأحيانًا نحتاج لاستعماله. فجمل التعيين التالية متكافئة:\n\ni = i + 1 تعادل i += 1\ni = i - 1 تعادل i -= 1\ni = i * 2 تعادل i *= 2\ni = i / 2 تعادل i /= 2\n\nجرب الكود أدناه لترى النتيجة:\n\ni = 0\ni = i + 1\ni += 1\nprint(i)\n\n2\n\n\nلاحظ أن i++ تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:\n\ni++\nprint(i)\n\n\n  Cell In[7], line 1\n    i++\n       ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات",
    "href": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات",
    "title": "2  الأعداد",
    "section": "2.4 وحدة الرياضيات",
    "text": "2.4 وحدة الرياضيات\n\nimport math\n\nx = 5.4\n\nكل هذه الطرق الثلاث يتم فيها حساب الأس:\n\nالأولى pow دالة مدمجة\nالثانية math.pow دالة من الوحدة الرياضيات\nالثالثة x ** 2 عن طريق المعامل **\n\n\\[\nx^2 = x \\times x\n\\]\n\nassert(\n    pow(x, 2) ==\n    math.pow(x, 2) ==\n    x ** 2 ==\n    x * x\n)\n\nوكذلك الجذر التربيعي:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\n\nالأولى math.sqrt دالة من الوحدة الرياضيات\nالثانية x ** 0.5 عن طريق المعامل **\n\n\nassert (\n    math.sqrt(x) ==\n    x ** 0.5\n)\n\nتقريب لأقرب عدد صحيح أصغر:\n\\[\n\\text{floor}(x) = \\lfloor x \\rfloor\n\\]\n\nmath.floor(x)\n\n5\n\n\nتقريب لأقرب عدد صحيح أكبر:\n\\[\n\\text{ceil}(x) = \\lceil x \\rceil\n\\]\n\nmath.ceil(x)\n\n6\n\n\nحذف ما بعد الفاصلة:\n\nmath.trunc(x)\n\n5\n\n\nتقريب إلى رقمين بعد الفاصلة:\n\nround(x, 2)\n\n5.4\n\n\nملاحظة: الدالة الأخيرة round ليست مستوردة من math وإنما هي مُضمَّنة في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "href": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "title": "2  الأعداد",
    "section": "2.5 مجموعة الأعداد",
    "text": "2.5 مجموعة الأعداد\nأما التعامل مع المجموعات (كمجموعة الأعداد) فسيأتي في باب المجموعات المرتبة. لكننا نعرض لمثال بسيط للتعامل مع المجموعات العددية:\n\nxs = [10, 20, 30, 40, 50]\n\nتوفر بايثون الدوال التالية للمجموعة العددية:\n\nالطول (عدد العناصر): len (من كلمة length)\nمجموع العناصر: sum\nالعنصر الأكبر: max\nالعنصر الأصغر: min\n\n\nprint('length:', len(xs))\nprint('total:', sum(xs))\nprint('average:', sum(xs) / len(xs))\nprint('maximum:', max(xs))\nprint('minimum:', min(xs))\n\nlength: 5\ntotal: 150\naverage: 30.0\nmaximum: 50\nminimum: 10\n\n\n\nالإحصاء\nونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:\n\nالمتوسط الحسابي: statistics.mean\nالوسيط: statistics.median\nالمنوال: statistics.mode\nالانحراف المعياري: statistics.stdev\n\n\nimport statistics\n\nxs = [\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20,\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20\n]\n\nprint('mean:', statistics.mean(xs))\nprint('median:', statistics.median(xs))\nprint('mode:', statistics.mode(xs))\nprint('standard deviation:', statistics.stdev(xs))\n\nmean: 20.785714285714285\nmedian: 20.5\nmode: 20\nstandard deviation: 1.8126539343499315",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "href": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "title": "2  الأعداد",
    "section": "2.6 أنواع العدد في بايثون",
    "text": "2.6 أنواع العدد في بايثون\n\nالعدد الصحيح (int)\nالقيمة المنطقية (bool)\nالعدد العشري (float)\nالعدد المركب (complex)\n\nصفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالأمر فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.\nفالتمثيل الداخلي للأعداد له أثر:\n\nفي مساحة التخزين\nدقة العدد؛ وبالتالي صحة الحساب\nسرعة الحساب\n\nلكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.\n\nالعدد الصحيح\nالوظيفة: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك\n\nage = 20\nlevel = 3\nindex = -2\nstart, end = -5, 10\nleft, middle, right = 3, 5, 7\n\nنستعمل الدالة type للتحقق من نوع المتغير:\n\nassert int == type(age) \nassert int == type(level) \nassert int == type(index) \nassert int == type(start) == type(end)\nassert int == type(left) == type(middle) == type(right)\n\nالمجال: يختلف مجال العدد الصحيح باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:\n\nيعبر الرمز \\(\\mathbb{Z}\\) عن مجموعة العدد الصحيح\n8-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^7 \\leq x &lt; 2^7\\} = \\{-128, \\ldots, 127\\}\\)\n16-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{15} \\leq x &lt; 2^{15}\\} = \\{-32768, \\ldots, 32767\\}\\)\n32-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{31} \\leq x &lt; 2^{31}\\} = \\{-2147483648, \\ldots, 2147483647\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{63} \\leq x &lt; 2^{63}\\} = \\{-9223372036854775808, \\ldots, 9223372036854775807\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{127} \\leq x &lt; 2^{127}\\} = \\{-170141183460469231731687303715884105728, \\ldots, 170141183460469231731687303715884105727\\}\\)\n\n\n\n\n\n\n\nملاحظة\n\n\n\n\n\nلاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)\n\n\n\n\n\nالقيمة المنطقية\nوهي كناية عن مجموعة مشتملة هي العددان: \\(\\{0, 1\\}\\) الذيان يمثل لهما بالكلمتين: True و False وذلك لتبيين وظيفتهما المنطقية.\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nالوظيفة: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.\nنلجئ الكلام عنها إلى باب الشرط والتكرار.\n\n\nالعدد العشري\nالوظيفة: تمثيل الكميات مثل المال، المسافة، والوقت\n\ndistance = 100.0\nprice = 10.5\ntime = 1.5\ntemperature = 36.6\ndifference = 0.001\n\nنستعمل الدالة type للتحقق من نوع المتغير:\n\nassert float == type(distance)\nassert float == type(price)\nassert float == type(time)\nassert float == type(temperature)\nassert float == type(difference)\n\nالمجال: يختلف مجال العدد العشري باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:\n\nيعبر الرمز \\(\\mathbb{R}\\) عن مجموعة العدد العشري\n32-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{31} \\leq x &lt; 2^{31}\\} = \\{-3.4 \\times 10^9, \\ldots, 3.4 \\times 10^9\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{63} \\leq x &lt; 2^{63}\\} = \\{-1.8 \\times 10^{19}, \\ldots, 1.8 \\times 10^{19}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{127} \\leq x &lt; 2^{127}\\} = \\{-1.2 \\times 10^{38}, \\ldots, 1.2 \\times 10^{38}\\}\\)",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "href": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "title": "2  الأعداد",
    "section": "2.7 اختلاف نوع العدد",
    "text": "2.7 اختلاف نوع العدد\nإذا اختلف النوع فإن بايثون ترقي النوع المشتمل إلى النوع الأشمل، وذلك بحسب ناتج العملية:\n\nجمع صحيح وعشري = عشري: int + float = float\nقسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): int / int = float\nالقسمة الصحيحة بين صحيح وصحيح = صحيح: int // int = int\n\nالمثال الأول: جمع عدد صحيح وعدد عشري:\n\na = 1 + 1.0\nprint(a)\nassert type(a) == float\n\n2.0\n\n\nالمثال الثاني: قسمة عدد صحيح على عدد عشري:\n\nc = 1 / 2\nprint(c)\nassert type(c) == float\n\n0.5\n\n\nالمثال الثالث: استعمال القسمة الصحيحة //:\n\nb = 1 // 2\nprint(b)\nassert type(b) == int\n\n0",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "2  الأعداد",
    "section": "2.8 الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "2.8 الفرق بين النوع العددي والنوع النصي للعدد\nتأمل المتغيرين\n\na = 50\nb = '50'\n\n\nالأول: عدد صحيح (int)\nالثاني: حرفان (str)\n\nنستعمل جمل التوكيد لبيان ذلك:\n\nassert not (a == b)\nassert type(a) != type(b)\nassert type(a) == int\nassert type(b) == str\n\nومقتضى ذلك: امتناع عملية الجمع: a + b\n\n'5' + 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 '5' + 5\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nبل يجب التحويل أولاً باستعمال الدالة int التي تفسر الأحرف كعدد صحيح:\n\na = 5\nb = '5'\n\nb = int(b)\n\nassert a + b == 10",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "href": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "title": "2  الأعداد",
    "section": "2.9 كتابة القيَم العددية",
    "text": "2.9 كتابة القيَم العددية\nالحروفيَّة هي رموز للقيم لبعض الأنواع المدمجة. مثال: 42 هو حرفيُّ عدد صحيح و 3.14 هو حرفيُّ عدد عشري.\nوتخصيص الحرفيّ True للعدد 1 و False للعدد 0 ليس من قبيل الضرورة في اللغة وإنما من قبيل التسهيل (وفوق ذلك فإن بايثون تجعل له نوعًا خاصًّا وعمليات مصاحبة).\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nكذلك خصصت بايثون e أو E للترميز العلمي (وجاء الحرف e من كلمة: Exponent) المخصص للأعداد العشرية الكبيرة والصغيرة.\n\nassert 1e2 == 100\nassert 1e9 == 1E9\nassert 1e-4 == 0.0001\n\nويجوز استعمال الشرطة السفلية _ لفاصلة الألوف:\n\nassert 1_000_000 == 1000000\n\nوأما إن كنت تهتم بالتمثيل الثنائي أو الثماني أو الست عشري فذلك أيضًا له تعبيرات مخصصة:\n\n0b أو 0B للأرقام الثنائية\n0o أو 0O للأرقام الثمانية\n0x أو 0X للأرقام الست عشرية\n\nوإليك تطبيق ذلك:\n\nassert 0b1010 == 10\nassert 0o10 == 8\nassert 0x10 == 16\n\nوأخيرًا يمكن استعمال j أو J للأعداد المركبة:\n\nassert 1 + 2j == 2j + 1",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#خلاصة",
    "href": "chapters/02_numbers/a_numbers.html#خلاصة",
    "title": "2  الأعداد",
    "section": "2.10 خلاصة",
    "text": "2.10 خلاصة\nعرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.\nننتقل الآن لباب الشرط والتكرار حيث الجمل الشرطية والتعيين المشروط.",
    "crumbs": [
      "باب الأعداد",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/b_context.html",
    "href": "chapters/02_numbers/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "نتائج الجبر بتعيين المتغيرات في المعادلات الرياضية\nلا يلزمنا اشتقاق هذه المعادلات؛ لكن نستعمل النتائج التي خرج بها أهل الرياضيات فنعوض هذه المتغيرات بالقيم التي نريد لنتحصل على الناتج.",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/b_context.html#نتائج-الجبر-بتعيين-المتغيرات-في-المعادلات-الرياضية",
    "href": "chapters/02_numbers/b_context.html#نتائج-الجبر-بتعيين-المتغيرات-في-المعادلات-الرياضية",
    "title": "تطبيقات",
    "section": "",
    "text": "معادلة تحويل وحدة إلى وحدة أخرى\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n\nc = 32\nf = (9 / 5) * c + 32\n\nprint('Celsius:', c)\nprint('Fahrenheit:', f)\n\nCelsius: 32\nFahrenheit: 89.6\n\n\n\n\nمعادلة مساحة المكعب\nاكتب برنامجًا يحسب مساحة المكعب وفق المعادلة:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\n\nwidth = 3\nlength = 4\nheight = 5\n\narea = width * length * height\nprint(area)\n\n60\n\n\n\n\nمعادلة مساحة الدائرة\nاكتب برنامجًا لحساب مساحة الدائرة وفق المعادلة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nimport math\n\nradius = 5\narea = math.pi * radius**2\nprint(area)\n\n78.53981633974483\n\n\nملاحظة:\n\nتم استعمال radius ** 2 بدلاً من دالة القوة math.pow(radius, 2) لتربيع العدد.\nكذلك يجوز استعمال x ** 0.5 بدلاً من math.sqrt(x) لحساب الجذر التربيعي.\n\n\n\nمعادلة طول الخط المستقيم بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0",
    "crumbs": [
      "باب الأعداد",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/c_problems.html",
    "href": "chapters/02_numbers/c_problems.html",
    "title": "تمارين",
    "section": "",
    "text": "كم سيكون عمرك عند حصول حدث مستقبلي معيَّن؟",
    "crumbs": [
      "باب الأعداد",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/c_problems.html#كم-سيكون-عمرك-عند-حصول-حدث-مستقبلي-معين",
    "href": "chapters/02_numbers/c_problems.html#كم-سيكون-عمرك-عند-حصول-حدث-مستقبلي-معين",
    "title": "تمارين",
    "section": "",
    "text": "عرف تاريخ الحدث المستقبلي بالسنوات: future_date\nعرف تاريخ اليوم: today\nعرف المتغير: age\nاحسب عمرك عند حصول الحدث: age_then\nاطبع النتيجة: print(age_then)",
    "crumbs": [
      "باب الأعداد",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/c_problems.html#حساب-الأجر",
    "href": "chapters/02_numbers/c_problems.html#حساب-الأجر",
    "title": "تمارين",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nعدد ساعات العمل: hours\nمعدل الأجر لكل ساعة: per_hour_rate\nاحسب الأجر الذي تستحقه بناءً على عدد الساعات ومعدل الأجر: gross_pay\nاطبع النتيجة: print(gross_pay)",
    "crumbs": [
      "باب الأعداد",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/c_problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/c_problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "تمارين",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nسرعة السيارة: speed\nالمسافة: distance\nاحسب الزمن المستغرق للوصول إلى المكان المعيَّن بناءً على السرعة والمسافة: time\nاطبع النتيجة: print(time)",
    "crumbs": [
      "باب الأعداد",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/c_problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/c_problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "تمارين",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\n\n\nمثلث\n\n\nباستخدام معادلة هيرون:\n\\[\n\\text{area} = \\sqrt{s (s - a) (s - b) (s - c)}  \n\\]\nحيث:\n\n\\(a\\), \\(b\\), \\(c\\) هي أطوال أضلاع المثلث\nنصف المحيط:\n\n\\[\ns = \\frac{a + b + c}{2}\n\\]\n\na = 3\nb = 4\nc = 5",
    "crumbs": [
      "باب الأعداد",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/02_numbers/d_solutions.html",
    "href": "chapters/02_numbers/d_solutions.html",
    "title": "حلول",
    "section": "",
    "text": "كم سيكون عمرك عند حصول حدث مستقبلي معيَّن؟\nfuture_date = 2050\ntoday = 2024\nage = 20\nage_then = age + (future_date - today)\nprint('you will be', age_then, 'years old in', future_date)\n\nyou will be 46 years old in 2050",
    "crumbs": [
      "باب الأعداد",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/d_solutions.html#حساب-الأجر",
    "href": "chapters/02_numbers/d_solutions.html#حساب-الأجر",
    "title": "حلول",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nhours = 40\nper_hour_rate = 10\ngross_pay = hours * per_hour_rate\nprint('you deserve:', gross_pay, 'SAR')\n\nyou deserve: 400 SAR",
    "crumbs": [
      "باب الأعداد",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/d_solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/d_solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "حلول",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nspeed = 100\ndistance = 200\ntime = distance / speed\nprint('it will take you', time, 'hours to reach the destination')\n\nit will take you 2.0 hours to reach the destination",
    "crumbs": [
      "باب الأعداد",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/02_numbers/d_solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/d_solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "حلول",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\nimport math\n\na = 3\nb = 4\nc = 5\n\ns = (a + b + c) / 2\narea = math.sqrt(s * (s - a) * (s - b) * (s - c))\nh = 2 * area / c\nprint('the height of the triangle is', h)\n\nthe height of the triangle is 2.4",
    "crumbs": [
      "باب الأعداد",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html",
    "href": "chapters/03_control_flow/a_control_flow.html",
    "title": "3  الشرط والتكرار",
    "section": "",
    "text": "3.1 الجملة الشرطية\nيسير تنفيذ الجمل البرمجية في اللغات الإجرائية -مثل بايثون- من الأعلى للأسفل. فإذا كتبنا الكود التالي:\nفإن جملة التعيين التالية تكتُب قيمة 2 في نفس المحلّ الذي كتبت عليه جملة التعيين الأولى 1. لذا ظهرت النتيجة: 2.\nكثيرًا ما نحتاج للتحكم فيما يُنفَّذ وما يُهمل أو ما يتكرر من الجمل البرمجية. فمن الحالات التي يتغير فيها الترتيب:\nالجملة الشرطية هي جملة مركَّبة من كلمة if وتعبير منطقي ثم الجمل التي يتعلق تنفيذها بناءً على هذا الشرط (وتكون داخل المحاذاة):",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "title": "3  الشرط والتكرار",
    "section": "",
    "text": "flowchart TD\n    IF{{if cond}} -- False --&gt; X[\"Outside\"]\n    IF -- True --&gt; Y[\"Inside\"]\n\n  style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ncond = True\nif cond:\n    print('Inside')\nprint('Outside')\n\nInside\nOutside\n\n\n\n\n\nتنبيه: المحاذاة العمودية\nلاحظ أن المحاذاة العمودية (Indentation) (المسافات البيضاء أسفل كلمة if) في الكود أعلاه ليست لمجرد تسهيل قراءة الكود، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال الكود.\nلاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في الكود:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    Y[\"Inside\"] --&gt; X[\"Outside\"]\n    style IF fill:#fc0000, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[3], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل الكود بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n    \n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\n\n\nيؤدي الكود السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في كتابة كود بايثون!",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التعبيرات-المنطقية",
    "href": "chapters/03_control_flow/a_control_flow.html#التعبيرات-المنطقية",
    "title": "3  الشرط والتكرار",
    "section": "3.2 التعبيرات المنطقية",
    "text": "3.2 التعبيرات المنطقية\nأما الشروط فتستند إلى المنطق الرقمي الثنائي الذي نجد له في بايثون كلمتين من أصل اللغة هما:\n\nكلمة True (وتساوي الرقم 1) وتعبِّر عن تحقق الأمر\nكلمة False (وتساوي الرقم 0) وتعبِّر عن عدم التحقق الأمر\n\nوكلاهُما يندرج تحت نوع خاصّ من صنف الأرقام وهو النوع الثنائي (bool).\nأما الجملة الشرطية أو التعيين الشرطي ونحوه، فيتعلَّق بتحقق عبارة منطقية. فمن العبارات المنطقية: عبارة المقارنة:\n\n\n\nالعلامة\nالوصف\n\n\n\n\na == b\nيساوي\n\n\na != b\nلا يساوي\n\n\na &gt; b\nأكبر من\n\n\na &lt; b\nأصغر من\n\n\na &gt;= b\nأكبر من أو يساوي\n\n\na &lt;= b\nأصغر من أو يساوي\n\n\n\nهنا نستكشف عبارات تؤول إلى قيَم منطقية. العبارة الأولى: خمسة أكبر من تسعة؟\n\nb1 = 5 &gt; 9\nprint(type(b1))\nprint(b1)\n\n&lt;class 'bool'&gt;\nFalse\n\n\nالعبارة الثانية: هل طول كذا أكبر من طول كذا؟\n\nb2 = len('12345') &gt; len('123456789')\nprint(b2)\n\nFalse\n\n\n\nتركيب الشروط\nيجوز دمج عدة شروط بعمليات الجمع والتخيير والحصر والعكس، فناتجها منطقي:\n\n\n\nA\nB\nAND\nOR\nXOR\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n\n\nالجمع: AND (و): تخرج 1 فقط إذا كان كلا المدخلين 1.\nالتخيير: OR (أو): تخرج 1 إذا كان أحد المدخلين على الأقل 1.\nالحصر: XOR (أو الحصرية): تخرج 1 إذا كان المدخلان مختلفين.\nالعكس: NOT (ليس): تخرج عكس المدخل (1 يصبح 0، و0 يصبح 1).\n\nعلى سبيل المثال:\n\nage = 20\nweight = 50\n\nif age &gt; 18 and weight &gt; 45:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nتستعمل الأقواس لتجميع الشروط لإيقاع الترتيب المنطقي المراد:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\nيُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون True أو False ولا بأس بتجزئته حينما يسهل بذلك الفهم:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\n\nif is_minor or (is_cold and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\n\nتسلسل المقارنات\nتفهم بايثون المقارنات المتسلسلة. فعبارة x &lt; y &lt;= z تكافئ x &lt; y and y &lt;= z:\n\nlow = 10\nhigh = 20\nx = 15\n\nassert (low &lt; x &lt; high) == (low &lt; x and x &lt; high)\n\nكذلك تراها تستعمل في المساواة:\n\nassert 3 == len('123') == len([10, 20, 30]) == len('abc')",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "title": "3  الشرط والتكرار",
    "section": "3.3 الجملة الشرطية المتكاملة",
    "text": "3.3 الجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if condition_1}}\n    IF -- False --&gt; ELIF{{elif condition_2}}\n    IF -- True --&gt; code_1\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; code_2\n    ELSE --&gt; code_3\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\n\nكلمة if (إذا) تبدأ الجملة المركبة الشرطية\nقد توجد else (وإلا) مرة. وهي تعمل عند تخلُّف العبارة المنطقية السابقة لها سواءً كانت السابقة لها if أو elif.\nوقد توجد elif بينهما مرة أو أكثر (وهي اختصار لكلمة else if وتعني: وإلا فإن)، فتعمل مثل else معلَّقة بعبارة منطقية مثل if.\n\n\nجرب\nاستكشف المنطق التالي بتغيير قيمة x كل مرة للتبع ما يحصل في كل مرة:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSet to zero\nAlways: 0\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if x &lt; 0}}\n    IF -- False --&gt; ELIF{{elif x == 0}}\n    IF -- True --&gt; S1[x = 0] --&gt; S2[\"Set to zero\"]\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; S3[x = 1] --&gt; S4[\"Single\"]\n    ELSE --&gt; S5[\"More\"]\n\n    Always[Always: x]\n    S2 --&gt; Always\n    S4 --&gt; Always\n    S5 --&gt; Always\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,3 color:red;\n\n\n\n\n\n\nوهذا تصوير لسير الأوامر لنفس الكود. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الفعلية:\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "title": "3  الشرط والتكرار",
    "section": "3.4 جملة التعيين المشروط",
    "text": "3.4 جملة التعيين المشروط\nتستطيع في بايثون أن تجعل جملة التعيين تأخذ قيمتها بحسب شرطٍ معين. مثلاً:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if age &gt; 14}}\n    IF -- False --&gt; S2[\"status = 'child'\"]\n    IF -- True --&gt; S1[\"status = 'adult'\"]\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0 color:red;\n\n\n\n\n\n\n\n\nage = 18\nstatus = 'adult' if age &gt; 14 else 'child'\n\nprint(status)\n\nadult\n\n\n\n\nوهي مكافئة للكود التالي:\n\nage = 18\n\nif age &gt; 14:\n  status = 'adult'\nelse:\n  status = 'child'\n\nprint(status)\n\nadult\n\n\nويحصل تسلسل التعيين المشروط بالصيغة التالية:\n\n\n\n\n\n\n\nflowchart TD\n  S1[\"score = 75\"] --&gt; IF1\n  IF1{{if score &gt;= 90}} -- True --&gt; A[\"grade = 'A'\"]\n  IF1 -- False --&gt; IF2{{if score &gt;= 80}} -- True --&gt; B[\"grade = 'B'\"]\n  IF2 -- False --&gt; C[\"grade = 'C'\"]\n  \n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 2,4 color:red;\n\n\n\n\n\n\n\n\nscore = 75\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\"\nprint(grade)\n\nC",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "title": "3  الشرط والتكرار",
    "section": "3.5 تضمين الجمل الشرطية",
    "text": "3.5 تضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\n\n\n\n\n\n\n\nflowchart TD\n  IF1{{if condition_1}}\n  IF1 -- False --&gt; ELSE1\n  IF1 -- True --&gt; IF2{{if condition_2}}\n  IF2 -- False --&gt; code_2\n  IF2 -- True --&gt; code_1\n  ELSE1[code_3]\n\n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\nننبه مرة أخرى أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\nمثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+\n\n\nوهذا تصوير له:",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "href": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "title": "3  الشرط والتكرار",
    "section": "3.6 التكرار",
    "text": "3.6 التكرار\nحلقة التكرار: هي الرجوع بالتنفيذ لجملة سابقة (غالبًا تكون سطرًا سابقًا) وذلك يحصل عددًا من المرات أو معلَّقًا بشرط.\nفللتكرار طريقتان:\n\nالتكرار بمتوالية (for)؛ إذ يتوقف عدد مرات التكرار على عدد العناصر الناتجة من المتوالية التي يجري عليها التكرار.\nالتكرار بشرط (while)؛ إذ يستمر التكرار مادام الشرط متحققًا.\n\n\nالتكرار بشرط\nنبدأ بالتكرار بالطريقة غير المحددة، وهي جُملة تبدأ بالكلمة while على النحو التالي. كأنها if متكررة إلى حين تخلُّف الشرط (أن يصبح False). وإن لم يتحقق الشرط أصلاً فلا ينفذ الكود المضمَّن أصلا:\n\n\n\n\n\n\n\nflowchart TD\n  WHILE{{while condition}}\n  WHILE -- False --&gt; END\n  WHILE -- True --&gt; S1[code] --&gt; WHILE\n  \n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\nwhile &lt;boolean expression&gt;:\n    &lt;code&gt;\n\n\nمثال:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; S3[\"Done\"]\n  WHILE -- True --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n3\n4\nDone\n\n\n\n\nلنقم بتتبع الخطوات عندما تكون i = 0:\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\nوهذا تصوير لسير الأوامر لنفس الكود. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الفعلية:\n\n\nلاحظ أن نسيان جملة الزيادة (i += 1) يجعل الشرط دائمًا صحيحًا، فيدور البرنامج في حقلة لا نهيائة ولا يخرج أبدًا. ويعتبر هذا خطأ برمجيًّا يتعذر على الكود التعامل معه بنفسه؛ بل يجب على المبرمج أن يكتشفه.\n\n\nالخروج من الحلقة\n\nتستخدم كلمة break لإيقاف عملية التكرار كلها.\nتستخدم كلمة continue للانتقال إلى الكرة التالية متخطيةً بقية الخطوات في الكرة الحالية.\n\nأولاً نمثل لاستعمال جملة break على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- break --&gt; Done\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,4 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\n\n\n\n\nوهذا مثال لاستخدام عبارة continue للتخطي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- continue --&gt;  WHILE\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,4 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\n\n\n\n\nأما جملة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط، ولا يتوقف الخارجي. وهذا مثال:\n\n\n\n\n\n\n\nflowchart TD\n  INIT1[\"i = 0\"] --&gt; WHILE1\n  WHILE1{{\"while i &lt; 3\"}}\n    S3[\"i += 1\"] --&gt; WHILE1\n    WHILE1 -- True --&gt; INIT2[\"j = 0\"] --&gt; WHILE2\n    WHILE2{{\"while j &lt; 3\"}}\n      WHILE2 -- True --&gt; IF1{{\"if i == 1\"}} -- break --&gt; WHILE1\n      IF1 -- False --&gt; S1[\"print(i, j)\"] --&gt; S2[\"j += 1\"] --&gt; WHILE2\n    WHILE2 -- False --&gt; S3\n\n  style WHILE1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style WHILE2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 5,8 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone",
    "crumbs": [
      "باب الشرط والتكرار",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/b_context.html",
    "href": "chapters/03_control_flow/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "حساب مجموع الأعداد المدخلة",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/b_context.html#حساب-مجموع-الأعداد-المدخلة",
    "href": "chapters/03_control_flow/b_context.html#حساب-مجموع-الأعداد-المدخلة",
    "title": "تطبيقات",
    "section": "",
    "text": "استخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nأضف العدد إلى المجموع الكلي: total\nاستمر في الدوران إلى أن يدخل المستخدم العدد 0 .. عندها قم بإنهاء الحلقة بالكلمة break\n\ntotal = 0\n\nwhile True:\n  number_in = input(\"Enter a number: \")\n  number = int(number_in)\n  total += number\n  if number == 0:\n    break\nprint(total)",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/b_context.html#حجرة-ورقة-مقص",
    "href": "chapters/03_control_flow/b_context.html#حجرة-ورقة-مقص",
    "title": "تطبيقات",
    "section": "حجرة ورقة مقص",
    "text": "حجرة ورقة مقص\nفي هذا المثال بعض الجمل التي لم نتعرف عليها بعد، ولكن لعل السياق يوضح معناها:\n\nuser_move not in [\"rock\", \"paper\", \"scissors\"] تغنينا عن جملة شرطية من ثلاثة مقارنات:\n\nif user_move != \"rock\" and user_move != \"paper\" and user_move != \"scissors\"\n\nrandom.choice([\"rock\", \"paper\", \"scissors\"]) تختار عشوائيًا عنصرًا من القائمة وتضعه في المتغير computer_move\nmatch هي جملة تحل محل if وelif وelse\n\nimport random\n\nprompt = \"Enter your move (rock, paper, scissors): \"\n\nuser_move = input(prompt)\n\nwhile user_move not in [\"rock\", \"paper\", \"scissors\"]:\n  print(f\"Sorry, I can't understand what \\\"{user_move}\\\" is. Check the spelling please.\")\n  user_move = input(prompt)\n\ncomputer_move = random.choice([\"rock\", \"paper\", \"scissors\"])\n\nprint(\"Computer move:\", computer_move)\n\nif user_move == computer_move:\n  print(\"It's a tie!\")\nelse:\n  match (user_move, computer_move):\n    case (\"rock\", \"scissors\") | (\"paper\", \"rock\") | (\"scissors\", \"paper\"):\n      print(\"You win!\")\n    case _:\n      print(\"You lose!\")\nيتبين ما تختصره علينا جملة match مقارنة بالشرطية المكافئة التالية (لاحظ وجود علامة \\ لإعلام المترجم أن الجملة تمتد للسطر الذي يليه):\nif user_move == \"rock\" and computer_move == \"scissors\" \\\n  or user_move == \"paper\" and computer_move == \"rock\" \\\n  or user_move == \"scissors\" and computer_move == \"paper\":\n  print(\"You win!\")\nelse:\n  print(\"You lose!\")\nولك أن تختصرها هي كذلك كالتالي:\nif (user_move, computer_move) in [(\"rock\", \"scissors\"), (\"paper\", \"rock\"), (\"scissors\", \"paper\")]:\n  print(\"You win!\")\nelse:\n  print(\"You lose!\")",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/b_context.html#حساب-مضروب-العدد",
    "href": "chapters/03_control_flow/b_context.html#حساب-مضروب-العدد",
    "title": "تطبيقات",
    "section": "حساب مضروب العدد",
    "text": "حساب مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots 1\n\\]\n\ni = 5\nj = i\nwhile j &gt; 1:\n  j -= 1\n  i *= j\nprint(i)\n\n120\n\n\nشرح للخطوات التنفيذية التفصيلية:\n\nأولاً، قم بتعيين المتغير i إلى العدد 5\nثانياً، قم بتعيين المتغير j إلى العدد 5\nثالثاً، استمر في الدوران إلى أن يصل j إلى القيمة 1\n\nفي كل دوران، قم بطرح 1 من j\nثم قم بضرب i بالقيمة الجديدة لـ j: المتحصل هو أن `i = i * (i - 1)\n\nأخيراً، قم بطباعة القيمة النهائية لـ i",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/b_context.html#تسجيل-الدخول",
    "href": "chapters/03_control_flow/b_context.html#تسجيل-الدخول",
    "title": "تطبيقات",
    "section": "تسجيل الدخول",
    "text": "تسجيل الدخول\n\nاستخدم دالة input() لطلب اسم المستخدم (username) و كلمة المرور (password) من المستخدم وخزن كل منهما في متغير مناسب\nإذا كان اسم المستخدم هو \"admin\" وكلمة المرور هي \"abc123\"، اطبع: \"Welcome admin\"\nأو إذا كان اسم المستخدم هو \"backdoor\" وكلمة المرور هي \"let me in\"، اطبع: \"Nobody knows!\"\nخلاف ذلك، اطبع: \"Access denied!\"\n\nimport getpass\n\nusername = input(\"Enter your username: \")\npassword = getpass.getpass(\"Enter your password: \")\n\nmax_tries = 3\ntries = 0\n\nwhile tries &lt; max_tries:\n  if username == \"admin\" and password == \"abc123\":\n    print(\"Welcome admin\")\n    break\n  elif username == \"backdoor\" and password == \"let me in\":\n    print(\"Nobody knows!\")\n    break\n  else:\n    print(\"Access denied!\")\n    tries += 1\nلاحظ:\n\nوجود حلقة while لإعادة المحاولة ثلاث مرات فقط\nوجود جملة break لإنهاء الحلقة إذا تم التسجيل بنجاح\n\nلا توجد break في جزئية else الأخيرة وذلك لأن عدد المحاولات يزيد في كل مرة ليؤول الأمر إلى انتفاء شرط الدوران",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/b_context.html#برنامج-تفاعلي",
    "href": "chapters/03_control_flow/b_context.html#برنامج-تفاعلي",
    "title": "تطبيقات",
    "section": "برنامج تفاعلي",
    "text": "برنامج تفاعلي\ninventory = 100\n\nwhile True:\n  print(\"Store Menu:\")\n  print(\"1. Buy Apples\")\n  print(\"2. Restock Apples\")\n  print(\"3. Exit\")\n\n  choice = input(\"Enter your choice: \")\n\n  match choice:\n    case \"1\":\n      quantity = int(input(\"Enter the quantity of apples to buy: \"))\n      if quantity &lt;= inventory:\n        inventory -= quantity\n        print(\"You bought\", quantity, \"apples. Remaining inventory:\", inventory)\n      else:\n        print(\"Insufficient stock. Please try again later.\")\n    case \"2\":\n      quantity = int(input(\"Enter the quantity of apples to restock: \"))\n      inventory += quantity\n      print(\"Restocked\", quantity, \"apples. New inventory:\", inventory)\n    case \"3\":\n      print(\"Exiting the store...\")\n      break\n    case _:\n      print(\"Invalid choice. Please try again.\")\nقد يبدو الأمر بلا معنى؛ لكن هكذا تعمل برامج الخوادم التي تستقبل الطلبات بشكل مستمر. فإنها تدخل حلقة لانهائية تأخذ فيها الطلبات من المستخدمين ليتم معالجتها والرد عليهم.",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/b_context.html#برنامج-تفاعلي-ذو-صفحات-متعددة",
    "href": "chapters/03_control_flow/b_context.html#برنامج-تفاعلي-ذو-صفحات-متعددة",
    "title": "تطبيقات",
    "section": "برنامج تفاعلي ذو صفحات متعددة",
    "text": "برنامج تفاعلي ذو صفحات متعددة\npage = \"main\"\n\nADMIN_USERNAME = \"admin\"\nADMIN_PASSWORD = \"abc123\"\n\nwhile True:\n  match page:\n    case \"main\":\n      print(\"*** Main menu ***\")\n      print(\"1. Login\")\n      print(\"2. Register\")\n      print(\"3. Exit\")\n      choice = input(\"Where do you want to go?: \")\n      match choice:\n        case \"1\":\n          page = \"login\"\n        case \"2\":\n          page = \"register\"\n        case _:\n          break\n    \n    case \"login\":\n      print(\"*** Login menu ***\")\n      username = input(\"Please enter the username: \")\n      password = getpass.getpass(\"Please enter the password: \")\n      if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:\n        print(\"Login successful!\")\n        page = \"admin_panel\" # not matched, so it will match \"_\" and break the loop\n      else:\n        print(\"Login failed!\")\n        page = \"main\"\n    \n    case \"register\":\n      print(\"*** Register menu ***\")\n      username = input(\"Please enter the username: \")\n      password = getpass.getpass(\"Please enter the password: \")\n      print(\"Register successful!\")\n      page = \"main\"\n    \n    case _:\n      break",
    "crumbs": [
      "باب الشرط والتكرار",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/c_problems.html",
    "href": "chapters/03_control_flow/c_problems.html",
    "title": "تمارين",
    "section": "",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\nالمطلوب:",
    "crumbs": [
      "باب الشرط والتكرار",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/c_problems.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/c_problems.html#الوزن-الطبيعي",
    "title": "تمارين",
    "section": "",
    "text": "التصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\n\n\n\n\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\n\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/c_problems.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/c_problems.html#مجموع-الأرقام-إلى-س",
    "title": "تمارين",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/c_problems.html#متحدث-آلي",
    "href": "chapters/03_control_flow/c_problems.html#متحدث-آلي",
    "title": "تمارين",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”",
    "crumbs": [
      "باب الشرط والتكرار",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/d_solutions.html",
    "href": "chapters/03_control_flow/d_solutions.html",
    "title": "حلول",
    "section": "",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\nالمطلوب:\nheight = 1.70\nweight = 95\nbmi = weight / height**2\n\nif bmi &lt; 16:\n    print('severe_thinness')\nelif bmi &lt; 17:\n    print('moderate_thinness')\nelif bmi &lt; 18.5:\n    print('mild_thinness')\nelif bmi &lt; 25:\n    print('normal')\nelif bmi &lt; 30:\n    print('overweight')\nelif bmi &lt; 35:\n    print('obese_class_1')\nelif bmi &lt; 40:\n    print('obese_class_2')\nelse:\n    print('obese_class_3')\n\nobese_class_1",
    "crumbs": [
      "باب الشرط والتكرار",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/d_solutions.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/d_solutions.html#الوزن-الطبيعي",
    "title": "حلول",
    "section": "",
    "text": "التصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\n\n\n\n\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\n\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/d_solutions.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/d_solutions.html#مجموع-الأرقام-إلى-س",
    "title": "حلول",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الإجراء input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة\n\nuser_input = input(\"Enter a number: \")\nn = int(user_input)\n\ntotal = 0\ni = 1\nwhile i &lt;= n:\n    total += i\n    i += 1\n\nprint('sum is:', total)",
    "crumbs": [
      "باب الشرط والتكرار",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/d_solutions.html#متحدث-آلي",
    "href": "chapters/03_control_flow/d_solutions.html#متحدث-آلي",
    "title": "حلول",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”\n\nprint(\"\"\"مرحبا بك في خدمة التبرع\nفضلا أريد منك تزويدي ببعض المعلومات ..\n\"\"\")\n\nprint('أتشرف باسمك، مثلا: محمد أحمد')\nname = input()\n\nprint('زودنا برقم جوالك، يبدأ بـ966')\nphone = input()\n\nprint('ممكن تحدد مدينتك؟')\ncity = input()\n\nprint('الرجاء قم بكتابة اسم الحي')\nneighborhood = input()\n\nprint('name:', name)\nprint('phone:', phone)\nprint('city:', city)\nprint('neighborhood:', neighborhood)\n\nwhile True:\n    print('هل تود تأكيد طلب التبرع؟')\n    print('1. تأكيد الطلب')\n    print('2. تعديل الطلب')\n    print('3. إلغاء الطلب')\n    user_confirmation = input()\n\n    if user_confirmation == '1':\n        print('تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً')\n        break\n    elif user_confirmation == '2':\n        print('ما الشيء الذي تريد تعديله؟')\n        print('1. الاسم')\n        print('2. رقم الهاتف')\n        print('3. المدينة')\n        print('4. اسم الحي')\n        user_modification = input()\n        match user_modification:\n            case '1':\n                print('اسم الزبون')\n                name = input()\n            case '2':\n                print('رقم الهاتف')\n                phone = input()\n            case '3':\n                print('المدينة')\n                city = input()\n            case '4':\n                print('اسم الحي')\n                neighborhood = input()\n            case _:\n                print('إختيار غير موجود')\n\n    elif user_confirmation == '3':\n        print('تم إلغاء طلب التبرع')\n        break",
    "crumbs": [
      "باب الشرط والتكرار",
      "حلول"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html",
    "href": "chapters/04_functions/a_functions.html",
    "title": "4  الإجراءات",
    "section": "",
    "text": "4.1 التعريف والاستدعاء\nالإجراء (أو الدالة) هو قطعة كود مخزَّنة لها اسم يمكن استدعاؤها بمتغيرات مغايرة.\nعند الاستدعاء: يتم تنفيذ نسخة معيَّنة من قطعة الكود (ليس فيها متغيرات؛ وإنما هي قيَم تم تعيينها) فيما يسمى إطار التنفيذ الذي يحتفظ بذاكرة محليَّة خاصة به إلى نهاية آخر جملة من القطعة. ثم تخلَّى الذاكرة المحليَّة وترجع لموضع الاستدعاء المباشر لها.\nتأمل تعريف الإجراء التالي الذي يحسب العلامة بناءً على الدرجة:\ndef calculate_grade(score):\n    if score &gt;= 90:\n        return \"A\"\n    elif score &gt;= 80:\n        return \"B\"\n    elif score &gt;= 70:\n        return \"C\"\n    elif score &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\nيجوز الآن استدعاء الإجراء باسمه. وجملة الاستدعاء تتكون من اسم الإجراء متبوعًا بقوسين فيهما تعيين العوامل، ونتيجتها هي ما يرجع به الإجراء (عند جملة return بحسب حاله):\nprint(calculate_grade(95))\nprint(calculate_grade(85))\n\nA\nB\nولا تقتصر على عاملٍ واحد. بل تتعدد العوامل:\ndef weather_condition(temperature, humidity, wind_speed):\n    if temperature &gt;= 30 and humidity &gt;= 60 and wind_speed &gt;= 10:\n        return \"Rainy\"\n    elif temperature &gt;= 20 and humidity &gt;= 50 and wind_speed &gt;= 5:\n        return \"Cloudy\"\n    elif temperature &gt;= 10 and humidity &gt;= 30 and wind_speed &gt;= 0:\n        return \"Sunny\"\n    return \"Normal\"\nولتعيين العوامل طريقتان، وقد تستعملان معًا:\ncond = weather_condition(temperature=30, humidity=60, wind_speed=10)\n\nif cond == \"Rainy\":\n    print(\"Don't forget your umbrella!\")\n\nDon't forget your umbrella!\nويجوز المزج بينهما بشرط تقدُّم التعيين بالموضع على التعيين بالاسم. ولاحظ في هذا المثال جواز عدم التقيُّد بالترتيب عند التعيين بالاسم (إذ قدَّمنا wind_speed على humidity بينما هي في التعريف بعدها).\nprint(weather_condition(20, wind_speed=5, humidity=50))\n\nCloudy",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#التعريف-والاستدعاء",
    "href": "chapters/04_functions/a_functions.html#التعريف-والاستدعاء",
    "title": "4  الإجراءات",
    "section": "",
    "text": "فإن جملة تعريف الإجراء تبتدئ بكلمة def مبتوعة باسم الإجراء (calculate_grade)\nبين الأقواس تحدد المتغيرات / العوامل (score) التي يُمكن تعيينها لاحقًا\nأما المُخرجات فإنَّها تخرُج بجملة الرجوع return.\n\n\n\n\n\n\n\n\nتعيين بالموضع: weather_condition(30, 60, 10)\nتعيين بالاسم weather_condition(temperature=30, humidity=60, wind_speed=10) ولا يُشترط الترتيب فيه.",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#التعيين-الاختياري",
    "href": "chapters/04_functions/a_functions.html#التعيين-الاختياري",
    "title": "4  الإجراءات",
    "section": "4.2 التعيين الاختياري",
    "text": "4.2 التعيين الاختياري\nنريد تعريف إجراء يتصرف بالشكل التالي:\n# assert convert_temperature(celsius=32) == 89.6\n# assert convert_temperature(fahrenheit=89.6) == 32\nفكيف نكتب هذا الإجراء؟\nتذكر أن معادلة التحويل هي:\n\\[\nF = \\frac{9}{5} C + 32\n\\]\n\nلجعل العامل اختياريًّا تُعيَّنُ له القيمة الافتراضية None أو تعيَّنُ له أي قيمة افتراضيَّة أخرى فيأخذها حين لا يُعيَّن عند الاستدعاء.\nولاحظ استعمال is not None للتحقق من عدم تعيين العامل وليس بالمقارنة المنطقية == None فهي مقارنة هوية وليست مقارنة قيمة.\n\n\ndef convert_temperature(celsius = None, fahrenheit = None):\n    if celsius is not None:\n        fahrenheit = (9 / 5) * celsius + 32\n        return fahrenheit\n    elif fahrenheit is not None:\n        celsius = (fahrenheit - 32) * (5 / 9)\n        return celsius\n    raise ValueError('Either celsius or fahrenheit must be provided')\n\nلاحظ في السطر الأخير وجود: raise ValueError وهي جملة ترفع خطأ؛ وموضعها يجعلها ترفع في حال لم يتم تعيين أي من العوامل عند الاستدعاء. وسيأتي الكلام في باب الخطِأ عنها بتفصيل إن شاء الله.\nالاختبارات:\n\nassert convert_temperature(celsius=32) == 89.6\nassert convert_temperature(fahrenheit=89.6) == 32\n\nنجحنا! فجمل التوكيد لم تظهر أية مشاكل.\nولك أن تضفي على الإجراء تنويهًا بأنواع مدخلاته ومخرجاته لتقليل الخطأ وزيادة الوضوح على النحو التالي:\ndef convert_temperature(celsius: float = None, fahrenheit: float = None) -&gt; float:\n    # ...\n\nفعبارة: celsius: float = None تتكون من ثلاثة أجزاء:\n\nاسم العامل: celsius\nنوعه: float\nالقيمة الافتراضية: None (أي: إذا لم يتم تعيينه فسيكون له القيمة None)\n\nوكذلك fahrenheit: float = None مثلها.\nثم الجزء الأخير بعد الأقواس: -&gt; float وهو يشير لنوع القيمة التي يرجعها الإجراء.\n\nوقد تلاحظ أننا سابقًا لم نعرف لا أنواع المدخلات ولا أنواع المخرجات. فهي في بايثون اختيارية: تزيده وضوحًا وذلك يقلل من مساحة الخطأ عند استعماله.",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#نطاق-التسمية",
    "href": "chapters/04_functions/a_functions.html#نطاق-التسمية",
    "title": "4  الإجراءات",
    "section": "4.3 نطاق التسمية",
    "text": "4.3 نطاق التسمية\nومن مميزات الإجراء المعرَّف أنَّ له نطاقًا خاصًّا؛ فما يُعرَّفُ داخله يبقى في نطاقه ولا يُعرَف خارجه. ويسمى هذا نطاق التسمية:\n\ndef calculate_bmi(weight: float, height: float) -&gt; float:\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\n\nفنتوقع وقوع خطأ هنا لأن bmi غير معرفة إلا في نطاق الإجراء:\n\nprint(bmi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 print(bmi)\n\nNameError: name 'bmi' is not defined\n\n\n\nلكن نطاق التسمية الذي داخل الإجراء، هو نفسه داخل نطاقٍ أشمل منه. ففي هذا المثال نجد استعمال len الذي هو إجراء تم تعريفه في نطاق أشمل (ضمن الإجراءات الأساسية في اللغة)، وكذلك الأمر في المتغير MAX_LEN إلا أنه دونه في الشمول:\n\nMAX_LEN = 8\n\ndef check_password_strength(password: str) -&gt; str:\n    if len(password) &gt; MAX_LEN:\n        return \"strong\"\n    elif len(password) &gt; MAX_LEN // 2:\n        return \"medium\"\n    return \"weak\"\n\nأما استعمالنا للأحرف الكبيرة، فهو عُرفٌ يقضي بأنَّنا سنلتزم بعدم تغييره. وكثيرًا ما يستعمل ذلك فيما هو من الإعدادات العامَّة التي تضبط سلوك البرنامج.\n\n\n\nمستويات نطاق التسمية",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#الإجمال-ثم-التفصيل",
    "href": "chapters/04_functions/a_functions.html#الإجمال-ثم-التفصيل",
    "title": "4  الإجراءات",
    "section": "4.4 الإجمال ثم التفصيل",
    "text": "4.4 الإجمال ثم التفصيل\nننصح بطريقة الإجمال ثم التفصيل في كتابة الكود، وهي:\n\nتصميم القطعة بتحديد ما تُنتج بناءً على ما تأخذ، بغض النظر عن كيفية وقوع ذلك على وجه التفصيل.\n\nيتضمن ذلك كتابة العوامل وأنواعها، والنتائج وأنواعها\nيتضمن ذلك كتابة وصف الإجراء باللغة الإنجليزية، لتوثيق ما لا يمكن تبيينه بمجرد أسماء العوامل والأنواع واسم الإجراء\n\nبعد ذلك نكتب الاختبارات التي تصف سلوك الإجراء (مدخلات -&gt; مخرجات)\nوبعد ذلك نأتي لكتابة التفاصيل: التي هي قطعة الكود داخل الإجراء.\nوأثناء كتابة التفاصيل نشغل الاختبارات كي توجِّهنا لما هو غير مطابق للوصف.\n\nفي المثال التالي لاحظ هذه الأمور:\n\nتعريف الإجراء باسم وعوامل وأنواعها.\nالوصف المُجمَل باللغة الإنجليزية، ويسمى docstring؛ وهو النص الذي يترأس الإجراء (في سطره الأول). والقاعدة العامة فيه: ألا يصف إلا ما يفيد المستفيد من الإجراء. أما التفاصيل التي تفيد مطوِّر الإجراء فإنها تكون تعليقات بعلامة # في ثناياه.\nكلمة pass التي تُستعمل لإرضاء مترجم اللغة. لأننا سنكتب الاختبارات قبل أن نكتب تفاصيله، ولا نريد لمترجم بايثون أن يظهر خطأ بسبب عدم وجود قطعة كود داخل الإجراء.\n\n\ndef min_max(numbers: list[float]) -&gt; tuple[float, float]:\n    \"\"\"Return the minimum and maximum values in the list.\"\"\"\n    pass\n\nوهذا الذي يظهر حين تريد المساعدة عن طريق الإجراء المدمج help، هكذا:\n\nhelp(min_max)\n\nHelp on function min_max in module __main__:\n\nmin_max(numbers: list[float]) -&gt; tuple[float, float]\n    Return the minimum and maximum values in the list.\n\n\n\nثم نكتب اختبارات تصف السلوك الذي نريده منه:\n# assert min_max([10, 20, 30, 40, 50]) == (10, 50)\n# assert min_max([50, 40, 30, 20, 10]) == (10, 50)\n# assert min_max([10, 10, -900, 10, 10]) == (-900, 10)\nثم الآن نعدل الإجراء الذي كتبناه في الأعلى، ولاحظ استعمال التعليقات # لتوضيح التسلسل التنفيذي:\n\ndef min_max(numbers: list[float]) -&gt; tuple[float, float]:\n    \"\"\"Return the minimum and maximum values in the list.\"\"\"\n\n    if len(numbers) == 0:\n        return None, None\n    \n    # Assign the first element to minimum and maximum\n    minimum = numbers[0]\n    maximum = numbers[0]\n    \n    for num in numbers:\n        if num &lt; minimum:\n            minimum = num\n        # elif is used because maximum will never be less than minimum\n        elif num &gt; maximum:\n            maximum = num\n    return minimum, maximum\n\nونشغل الاختبارات:\n\nassert min_max([10, 20, 30, 40, 50]) == (10, 50)\nassert min_max([50, 40, 30, 20, 10]) == (10, 50)\nassert min_max([10, 10, -900, 10, 10]) == (-900, 10)\nassert min_max([]) == (None, None)",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#إطلاق-عدد-العوامل",
    "href": "chapters/04_functions/a_functions.html#إطلاق-عدد-العوامل",
    "title": "4  الإجراءات",
    "section": "4.5 إطلاق عدد العوامل",
    "text": "4.5 إطلاق عدد العوامل\nقد تتساءل كيف تعمل print وهي تأخذ عددًا لا محدودًا من العوامل؟ حتى نجيب عن ذلك ننظر في عملية فك الأقواس وهي علامة النجمة * قبل المتغيِّر المشير لمجموعة، على النحو التالي:\n\nt = (10, 20, 30)\nprint(t)\nprint(*t)\n\n(10, 20, 30)\n10 20 30\n\n\nلاحظ الفرق بين الاستدعاء الأول والثاني:\n\nالأوَّل يطبع المتغير t ككل، أي: كصف\nيُمرر واحدًا تلوَ الآخر للإجراء print بعد فك الأقواس كأنك كتبت: print(10, 20, 30)\n\nوحين تسعمل علامة النجمة التعريف عوامل الإجراء، فإن أي عامل موضعي زائد عن العدد، يكونُ فيه كصفّ. وبالمثال يتضح (وقد اصطلح على تسميته args جوازًا لا وجوبًا وهي اختصار كلمة arguments):\n\ndef show(a, *args):\n    print(a)\n    print(type(args), args)\n    print('print:', *args)\n\nshow(1, 2, 3, 4, 5)\n\n1\n&lt;class 'tuple'&gt; (2, 3, 4, 5)\nprint: 2 3 4 5\n\n\nوكذلك العوامل المعيَّنة بالاسم، لكن بالنجمتين ** ومعنى الكلمة kwargs هو: Keyword Arguments:\n\ndef show(a, **kwargs):\n    print(a)\n    print(type(kwargs), kwargs)\n    print('print:', *kwargs)\n\nshow(a=1, b=2, c=3, d=4, e=5)\n\n1\n&lt;class 'dict'&gt; {'b': 2, 'c': 3, 'd': 4, 'e': 5}\nprint: b c d e\n\n\nوقد يجتمعان في نفس الإجراء *args و **kwargs نحو:\n\ndef show(x, y, *args, **kwargs):\n    print(x, y)\n    print(type(args), args)\n    print(type(kwargs), kwargs)\n\nshow(1, 2, 3, 4, 5, a=1, b=2, c=3)\n\n1 2\n&lt;class 'tuple'&gt; (3, 4, 5)\n&lt;class 'dict'&gt; {'a': 1, 'b': 2, 'c': 3}\n\n\nولا بد من تقديم الموضعية قبل الاسمية.\nللمزيد راجع العوامل الخاصة في التوثيق.",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#الإجراء-النقي",
    "href": "chapters/04_functions/a_functions.html#الإجراء-النقي",
    "title": "4  الإجراءات",
    "section": "4.6 الإجراء النقي",
    "text": "4.6 الإجراء النقي\nحتى يستفاد من الإجراء، لا بد أن يكون له مخرجات؛ وتكون بأحد أمرين:\n\nالرجوع لموضع الاستدعاء بالنتيجة (جملة الرجوع return) فينتقل أثر هذا الإجراء للعالم عن طريقها\nالتأثير في العالم بغير الرجوع لموضع الاستدعاء بالنتيجة\n\nالإجراء النقي (pure) لا أثر على مخرجاته إلا بالنظر لمدخلاته فقط؛ ولا يؤثر هو إلا بإرجاع مخرجاته. أما غير النقي فهو الذي:\n\nيؤثر في غير مخرجاته المباشرة (مثلاً يكتب في ملف أو على سطر الأوامر أو يعدِّل على مدخلاته) أو\nيتأثر بغير مدخلاته المباشرة (مثلاً: يعتمد على متغيرات معرَّفة خارج الإجراء).\n\nوهذا مثال لإجراء لا يُنتج في موضع الاستدعاء (لا يُرجع قيمة باستعمال جملة الرجوع return) لكنَّه يُنتج بطباعة حروف على سطر الأوامر. فنقول: هو يؤثر بطريقة غير مباشرة؛ لذا هو غير نقي.\n\ndef print_decorated(message: str) -&gt; None:\n    print(\"*\" * 50)\n    print(message)\n    print(\"*\" * 50)\n\nprint_decorated(\"Hello, world!\")\n\n**************************************************\nHello, world!\n**************************************************\n\n\nوكذلك يُقال أن مثل هذا الإجراء ذو أعراض جانبية (side effects)؛ وذلك إشارةً إلى التغيير الذي يحصل بسببه بطريقة غير مباشرة (ليس عن طريق الرجوع بنتيجة).\nكذلك هو من جنس الإجراء العقيم (void) وهو الذي لا يرجع بقيمة لموضع الاستدعاء (فلا تجد جملة الرجوع return في ثناياه). وإنما تكون مخرجاته في غير موضع الاستدعاء. وأي إجراءٍ لا يجد فيه مترجم بايثون كلمة return فإنه يُدرجها في آخره بالرجوع بلا شيء: return None.\nفكلما كان الإجراء نقيًّا كان عزله وضبطه وإتقانه واختباره أسهل. لكنّ الإجراءات النقية تعيش في عالم مثالي لا يتأثر بالواقع ولا يؤثر فيه (I/O)؛ بل بالمعالجات التي بينها فقط. ولنرى التأثير في الواقع يجب أن نخرج إلى ما هو مُنتجٌ فيه: وهو غير نقي.\nوالذي نميل إليه: تغليب النقاوة، واستعمال الأعراض الجانبية عند أطراف المعالجة ونهاياتها.\nفتحصل لنا بذلك هذه الأنواع:\n\nإجراء نقي: لا يؤثر في العالم بغير الرجوع بالنتيجة. ونتيجته مرتبطة فقط بمدخلاته المباشرة.\nوغير النقي: يؤثر في العالم بغير الرجوع بالنتيجة. وفيه قسمان:\n\nقد يرجع بنتيجة وكذلك له تأثير جانبي.\nإجراء عقيم: لا يرجع بنتيجة.",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#الإجراء-المتسلسل",
    "href": "chapters/04_functions/a_functions.html#الإجراء-المتسلسل",
    "title": "4  الإجراءات",
    "section": "4.7 الإجراء المتسلسل",
    "text": "4.7 الإجراء المتسلسل\nالإجراء المتسلسل: يحتوي على جملة يستدعي فيها نفسه. ويجب أن تؤول سلسلة الاستدعاءات هذه إلى جملة تنهي التسلسل.\nفمثلا: تعرف الرياضيات مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots(1)\n\\]\nفهي عملية ضرب لكل عدد مع الذي قبله حتى ينتهي للواحد. ومن أمثلته:\n\\[\n!5 = (5)(4)(3)(2)(1)\n\\]\nولك أن تصف نفس العملية بالشكل التالي:\n\\[\n!n = n !(n-1)\n\\]\nأي أن مضروب العدد هو ضربُ هذا العدد في مضروب العدد الذي يقبله. وذلك يتسلسل على النحو التالي:\n\\[\n!5 = (5)!(4) = (5)(4!(3)) = (5)(4(3!(2))) = (5)(4(3(2!(1)))) = (5)(4(3(2(1)))) = (5)(4)(3)(2)(1)\n\\]\nإذا نخلص بالمعادلة التالية:\n\\[\n!n = n(n-1)(n-2)\\cdots(1) = n!(n-1)\n\\]\nوهكذا يكون تعريفها في بايثون:\n\ndef factorial(n: int) -&gt; int:\n    # Recursive case\n    if n &gt; 0:\n        recursive_result = factorial(n - 1)\n        return n * recursive_result\n    # Terminal case\n    return 1\n\nfactorial(5)\n\n120\n\n\nحيث لدينا حالتان:\n\nعندما تكون n &gt; 0 يتم الاستدعاء الذاتي : recursive_result = factorial(n - 1) إذْ هي جملة متسلسلة تكدِّس استدعاءات فوق استدعاءات؛ لكنها تؤول في النهاية إلى الجملة التي تُنهي التسلسل\nreturn 1 هي الجملة التي تنهي التسلسل\n\nوهنا قطعة كود نستعملها لتصور تسلسل الاستدعاءات:\n\n\nالكود\ndef factorial(n: int, depth: int = 0) -&gt; int:\n\n    # Recursive case\n    print(f\"{'  ' * depth}Call factorial({n})\")\n    if n &gt; 0:\n        result = n * factorial(n - 1, depth + 1)\n        print(f\"{'  ' * depth}Return {result} from factorial({n})\")\n        return result\n    \n    # Terminal case\n    print(f\"{'  ' * depth}Return 1 from factorial({n})\")\n    return 1\n\nfactorial(5)\n\n\nCall factorial(5)\n  Call factorial(4)\n    Call factorial(3)\n      Call factorial(2)\n        Call factorial(1)\n          Call factorial(0)\n          Return 1 from factorial(0)\n        Return 1 from factorial(1)\n      Return 2 from factorial(2)\n    Return 6 from factorial(3)\n  Return 24 from factorial(4)\nReturn 120 from factorial(5)\n\n\n120\n\n\n\nفكل استدعاء يُنشأ له إطار تنفيذ جديد تكون بالنسبة له قيمة n هي المعيَّنة له وقت النداء.\nوهكذا يتم تكديس الاستدعاءات حتى ينتهي التسلسل عند الاستدعاء factorial(0) الذي يؤول لنتيجة مباشرة: return 1 فيخلَّى هذا الإطار من الذاكرة وتعود نتيجته إلى الإطار المباشر الذي استدعاه وهو إطار factorial(1).\nفتتعين القيمة recursive_result = 1 وينتقل إلى الجملة التي بعدها وهي جملة الرجوع بنتيجة return n * recursive_result وهُما معيَّنان، أي تكون الجملة في واقع إطار التنفيذ: return 1 * 1.\nوهذه النتيجة تعود للإطار الذي استدعاه وهو factorial(2) … إلخ.\n\nاستدعاء الإجراء المتسلسل يؤدي إلى إطارات تنفيذ متداخلة تؤول إلى إطار واحد في النهاية.\nيستعمل الإجراء المتسلسل وكذلك هياكل البيانات المتسلسلة بشكل كبير في الخوارزميات الفعالة.\nيسهل كتابة بعض الخوارزميات باستعمال الإجراء المتسلسل. لكن قد تكون (أحياًنا) أقل أداءً من استعمال الحلقات.",
    "crumbs": [
      "باب الإجراءات",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/b_context.html",
    "href": "chapters/04_functions/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "طول الخط المستقيم بين نقطتين\nتعريف الإجراء أمر مساعد للبرمجة وليس هو تنفيذيًّا بذاته. لذا ستكون تطبيقات هذا الجزء عبارة عن قولَبة التطبيقات السابقة بتعريفها في إجراءات:\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nوتذكر أن:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\ndef euclidean_distance(x1: float, y1: float, x2: float, y2: float) -&gt; float:\n    return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5\n\nassert euclidean_distance(x1=0, y1=0, x2=3, y2=4) == 5.0",
    "crumbs": [
      "باب الإجراءات",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/04_functions/b_context.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/04_functions/b_context.html#مجموع-الأرقام-إلى-س",
    "title": "تطبيقات",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i = \\frac{n(n + 1)}{2}\n\\]\n\ndef sum_of_numbers(n: int) -&gt; int:\n    return n * (n + 1) // 2\n\nassert sum_of_numbers(n=5) == 1+2+3+4+5 == 15\nassert sum_of_numbers(n=10) == 1+2+3+4+5+6+7+8+9+10 == 55",
    "crumbs": [
      "باب الإجراءات",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/04_functions/b_context.html#فصل-البيانات",
    "href": "chapters/04_functions/b_context.html#فصل-البيانات",
    "title": "تطبيقات",
    "section": "فصل البيانات",
    "text": "فصل البيانات\nهذا الإجراء يقسم سلسلة إلى جزئين بناءً على نسبة معينة:\n\ndef split_data(seq, ratio):\n    idx = int(len(seq) * ratio)\n    return seq[:idx], seq[idx:]\n\nنختبر الإجراء ونلاحظ أن الناتج من نوع صف (tuple). فنستعمل التعيين المتعدد لاستخراج القيم من الصف:\n\nmy_data = list(range(1, 10 + 1))\nt = split_data(my_data, 0.80)\n\nprint(type(t))\na, b = t\nprint(a, b)\n\nassert a == [1, 2, 3, 4, 5, 6, 7, 8]\nassert b == [9, 10]\n\n&lt;class 'tuple'&gt;\n[1, 2, 3, 4, 5, 6, 7, 8] [9, 10]",
    "crumbs": [
      "باب الإجراءات",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html",
    "href": "chapters/05_sequences/a_sequences.html",
    "title": "5  المجموعة المرتبة",
    "section": "",
    "text": "5.1 التسلسل\nكثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، …إلخ من العمليات التي تعمل على جميع عناصر المجموعة.\nوكل ما هو من جنس المجموعة (Collection) فإنه يقبل الأفعال التالية:\nانظر Collection في خريطة المجموعات: شكل 1.\nالتسلسل (Sequence) هو أي مجموعة مرتبة من الأشياء.\nوسوف نرمز للمفرد بـx ولما يدل على التسلسل بـs.\nوالأنواع الأربعة التي من جنس التسلسل هي:\nفهذه الأربعة تقبل الأفعال التالية:\nوتقبل من أفعال الإنشاء:\nومن هذه الأنواع المتغير، ومنها ما لا يقبل التغير وهو الجامد؛ وسيأتي بيانه في موضعه -إن شاء الله-.",
    "crumbs": [
      "باب المجموعة المرتبة",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#التسلسل",
    "href": "chapters/05_sequences/a_sequences.html#التسلسل",
    "title": "5  المجموعة المرتبة",
    "section": "",
    "text": "قولنا (مجموعة) يعني قبوله الأفعال الثلاثة السابق ذكرها.\nقولنا (مرتبة) يعني أن لكل عنصر موضعًا فيها، وله ما قبله وما بعده.\n\n\n\n\nالقائمة (list) ويُعبَّرُ عنه بالقوسين المربعين [].\nالصف (tuple) ويُعبَّرُ عنه بالقوسين المنحنيين ().\nالمجال (range) ويُعبَّرُ عنه بالإجراء المنشئ range().\nالنص (str) ويُعبَّرُ عنه بالتنصيص المفرد '' أو المزدوج \"\".\n\n\n\nالإشارة:\n\nبالموضع: s[i]\nبالقطعة: s[i:j]\nبالقطعة مع خطوة: s[i:j:k]\n\nمعرفة موضع شيء (إن وجد): s.index(x)\nعد تكرارات شيء: s.count(x)\nالبحث عن الأصغر والأكبر: min(s) و max(s)\n\n\n\nالدمج: s1 + s2\nالتكرار: s * n\n\n\n\nالإنشاء\n\nينشأ الصف بوضع العناصر بين القوسين المنحنيين () أو باستعمال الإجراء المنشئ tuple()\nتنشأ القائمة بوضع العناصر بين القوسين المربعين [] أو باستعمال الإجراء المنشئ list()\n\n\ns = (10, 20, 30) + (40, 50)\ns = s * 2\nprint(s)\n\n(10, 20, 30, 40, 50, 10, 20, 30, 40, 50)\n\n\nويقبل إنشاء مجموعة من العناصر مختلفة النوع، بما في ذلك القائمة والصف كعنصر:\n\ns = (10, 'A', 2.0, True, ['B', 30])\nprint(s)\n\n(10, 'A', 2.0, True, ['B', 30])\n\n\nنستعرض هنا العضوية والعد والتكرار\n\ns = [100, 200, 300]\n\nassert 100 in s\nassert 400 not in s\nassert len(s) == 3\n\nfor x in s:\n    print(x)\n\n100\n200\n300\n\n\n\n\nالإشارة\nتستعمل الإشارة الموضعية لقراءة عنصر من التسلسل. ويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل على النحو التالي:\n\ns = [10, 20, 30, 40, 50]\nassert s[0] == 10\nassert s[-1] == 50\nassert s[len(s) // 2] == 30\n\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\nشكل الإشارة بالقطعة على نحو: s[start : end : step]. والقيم الافتراضية عند الإغفال هي: s[0:len(s):1].\n\ns = [10, 20, 30, 40, 50]\nassert s[1:3] == [20, 30]\nassert s[::2] == [10, 30, 50]\nassert s[::-1] == [50, 40, 30, 20, 10]\nassert s[1:4:2] == [20, 40] == s[-4:-1:2]\nassert s[1:4:2] == s[slice(1,4,2)] == [20, 40]\n\nلاحظت استعمال الإجراء المنشئ slice() في الإشارة بالقطعة، وقد جعلت بايثون علامة : بديلاً عنه.\nوجاز للعنصر الواحد أن يكون مجموعة؛ ومثاله المصفوفة (صفٌّ من صفوف):\n\nmatrix = (\n    (10, 20, 30),\n    (40, 50, 60),\n    (70, 80, 90)\n)\n\nassert matrix[0] == (10, 20, 30)\nassert matrix[-1] == (70, 80, 90)\nassert matrix[1][1] == 50\n\n 0              1              2               \n +--------------+--------------+--------------+\n | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |\n +--------------+--------------+--------------+\n-3             -2             -1\nالإشارة لعناصر الصف الواحد:\n 0    1    2            \n +----+----+----+\n | 10 | 20 | 30 |\n +----+----+----+\n-3   -2   -1\n 0    1    2            \n +----+----+----+\n | 40 | 50 | 60 |\n +----+----+----+\n-3   -2   -1\n 0    1    2            \n +----+----+----+\n | 70 | 80 | 90 |\n +----+----+----+\n-3   -2   -1\nعناصر نصوص:\n\nss = [\"Apple\", \"Banana\", \"Orange\", \"Lemon\"]\nassert ss[1] == \"Banana\"\nassert ss[-1][0] == \"L\"\n\n 0       1        2        3       4\n +-------+--------+--------+-------+\n | Apple | Banana | Orange | Lemon |\n +-------+--------+--------+-------+\n-4      -3       -2       -1\nالإشارة لصف الأحرف في النص الواحد:\n 0   1   2   3   4\n +---+---+---+---+---+\n | L | e | m | o | n |\n +---+---+---+---+---+\n-5  -4  -3  -2  -1\nوسيأتي التفصيل في باب النص.\n\n\nالبحث\n\ns = ('A', 'B', 'A')\nassert s.index('B') == 1\nassert s.count('A') == 2\n\n\ns = (30, 20, 40, 10, 50)\nassert min(s) == 10\nassert max(s) == 50",
    "crumbs": [
      "باب المجموعة المرتبة",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#القائمة",
    "href": "chapters/05_sequences/a_sequences.html#القائمة",
    "title": "5  المجموعة المرتبة",
    "section": "5.2 القائمة",
    "text": "5.2 القائمة\nالقائمة (list) تسلسل متغير. وهذا يعني:\n\nقولنا (متغيرة) يعني أنها تقبل الإضافة والحذف والتعديل على عناصرها\nقولنا (مرتبة) يعني أن لكل عنصر موضعًا فيها، وله ما قبله وما بعده.\n\nويترتب عليه قبولها الإشارة بالموضع i أو بالقطعة [i:j] أو بالقطعة بالخطوة [i:j:k]\n\n\nانظر MutableSequence في خريطة المجموعات: شكل 1.\n\nالتغير\nالتغير هي الخاصية التي تختلف فيها القائمة عن قسيماتها التسلسلية. ومعناه قبولها الأفعال التالية (نستعمل في المثال حرف l للقائمة):\n\nالاستبدال:\n\nلموضع: l[i] = x\nلقطعة: l[i:j] = t\nلقطعة بخطوة: l[i:j:k] = t\n\nالحذف:\n\nلموضع: del l[i]\nلقطعة: del l[i:j]\nلقطعة بخطوة: del l[i:j:k]\n\nالإزالة: l.remove(x) لحذف أول ورود للعنصر\nالنزع: l.pop([i]) حذف العنصر من الموضع وإرجاعه\n\nإن لم يحدد الموضع: نزع الأخير. إذ القوسان [i] هنا في التعريف يعبران عن عامل اختياري وهو الموضع i\n\nالإدراج: l.insert(i, x) لإضافة عنصر في موضع محدد\nالإلحاق: l.append(x) لإضافة عنصر في النهاية\nالترتيب: l.sort() أو بالإجراء المدمج sorted(l)\nالعكس: l.reverse() أو بالإجراء المدمج reversed(l)\n\nلاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين المنحنيين ():\n\nt = (10, 20, 30, 40, 50)\nt[0] = 100\nprint(t)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 2\n      1 t = (10, 20, 30, 40, 50)\n----&gt; 2 t[0] = 100\n      3 print(t)\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nلكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين []:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nprint(l)\n\n[100, 20, 30, 40, 50]\n\n\nالاستبدال بالموضع والحذف منه:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nassert l == [100, 20, 30, 40, 50]\n\ndel l[0]\nassert 100 not in l\n\nالاستبدال بالقطعة والحذف منها\n\nl = [10, 20, 30, 40, 50]\nl[1:3] = [200, 300]\nassert l == [10, 200, 300, 40, 50]\n\ndel l[1:3]\nassert l == [10, 40, 50]\n\nالإدراج:\n\nl = [10, 20, 30, 40, 50]\nl.insert(1, 100)\nassert l == [10, 100, 20, 30, 40, 50]\n\nالإزالة:\n\nl = [10, 20, 30, 40, 50]\nl.remove(20)\nassert l == [10, 30, 40, 50]\n\nالإلحاق:\n\nl = [10, 20, 30, 40, 50]\nl.append(60)\nassert l == [10, 20, 30, 40, 50, 60]\n\nالترتيب والعكس:\n\nl = [30, 40, 10, 20, 50]\nl.sort()\nassert l == [10, 20, 30, 40, 50]\n\nl.reverse()\nassert l == [50, 40, 30, 20, 10]\n\nنزع العنصر الأخير وإرجاعه:\n\nl = [10, 20, 30, 40, 50]\nx = l.pop()\nassert x == 50\nassert 50 not in l",
    "crumbs": [
      "باب المجموعة المرتبة",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#التسلسلات-المرتبطة",
    "href": "chapters/05_sequences/a_sequences.html#التسلسلات-المرتبطة",
    "title": "5  المجموعة المرتبة",
    "section": "5.3 التسلسلات المرتبطة",
    "text": "5.3 التسلسلات المرتبطة\nهذان تسلسلان مرتبطان:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = [90, 80, 75, 85, 95]\n\nassert len(students) == len(marks)\n\nلو أردنا أن نمر على التسلسلين في نفس الوقت نستعمل الإجراء المدمج zip() الذي يظل يولد صفًا عناصره من كل تسلسل:\n\nfor x, y in zip(students, marks):\n    print(x, y)\n\nAhmad 90\nBelal 80\nCamal 75\nDawud 85\nEmad 95",
    "crumbs": [
      "باب المجموعة المرتبة",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#النطاق",
    "href": "chapters/05_sequences/a_sequences.html#النطاق",
    "title": "5  المجموعة المرتبة",
    "section": "5.4 النطاق",
    "text": "5.4 النطاق\nيمثل النطاق (range) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فهي ثلاثة عوامل تحدده:\n\nالبداية (start): مشمول ، وقيمته الافتراضية 0.\nالنهاية (stop): غير مشمول ، وتم تعريف النطاق بحيث لا يُمكن إهمال النهاية.\nالخطوة (step): مقدار الزيادة أو النقص للعدد التالي ، وقيمته الافتراضية 1 (أي: الزيادة بواحد).\n\nدعونا الآن نلقي نظرة على التعريف كما هو موجود في وثائق بايثون، وذلك لنتعلم كيف نقرؤ التعريف. ادخل الرابط وتأمل معي ..\n\nclass range(stop)\nclass range(start, stop[, step])\n\nأولاً: نلاحظ كلمة class في الابتداء وهذا يعني أنه صِنف وليس إجراءً.\nثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما تعمل به بايثون؟\nنجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو stop وتأخذ البداية والخطوة فيمتهما الافتراضية: start=0 و step=1 حسب ما كُتب:\n\nIf the step argument is omitted, it defaults to 1.\nIf the start argument is omitted, it defaults to 0\n\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nأما التعريف الثاني فيجب تفكيكه لنفهمه: class range(start, stop[, step]).\nوجود الأقواس المربعة [ ] يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو start, stop؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الافتراضية step=1.\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\nالتكرار والإشارة\nيستعمل النطاق في التكرار على متواليات هكذا:\n\nxs = [10, 20, 30, 40, 50]\nfor i in range(len(xs)):\n    print(xs[i])\n\n10\n20\n30\n40\n50\n\n\nففي كل مرة يشير i للموضع التالي في المتوالية، ويستعمل في معامل الإشارة xs[i] لقراءة العنصر.\n\n\nتأجيل النتيجة\nويجدر بالذكر أن النطاق لا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وهو كالصف لا يقبل التعديل.\nنستعمل إجراء الإنشاء range() لإنشاء نطاق:\n\nr = range(0, 20, 2)\nr\n\nrange(0, 20, 2)\n\n\nفحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:\n\nprint(11 in r)\nprint(10 in r)\n\nFalse\nTrue\n\n\nكذلك الأمر عند البحث عن موضع رقمٍ ما:\n\nprint(r.index(10))\n\n5\n\n\nوالإشارة لموضع ما أو قطعة كذلك:\n\nprint(r[5])\nprint(r[:5])\nprint(r[-1])\n\n10\nrange(0, 10, 2)\n18\n\n\n\n\nتحويل النطاق\nبمجرد تحويل النطاق إلى نوعٍ متحقق (كالقائمة أو الصف) ؛ يتم توليد جميع الأرقام التي في النطاق حالًا. نستعمل التركيب: list(range()) للإنشاء والتحويل:\n\nevens = list(range(0, 10, 2))\nodds = list(range(1, 10, 2))\nprint(evens)\nprint(odds)\n\n[0, 2, 4, 6, 8]\n[1, 3, 5, 7, 9]",
    "crumbs": [
      "باب المجموعة المرتبة",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "href": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "title": "5  المجموعة المرتبة",
    "section": "5.5 الإنشاء المختصر: الجملة الثلاثية",
    "text": "5.5 الإنشاء المختصر: الجملة الثلاثية\nمما تميزت به لغة بايثون عن غيرها: مختصرة الإنشاء (Comprehension)؛ وهي جملة تُنشئ مجموعة مستمَدَّة من متوالية في ثلاث جُمَل في سطرٍ واحدٍ (غالبًا). فالمتوالية قد تكون قائمة أو مجموعة فريدة أو مجموعة روابط. ومن استخداماتها:\n\nتحويل عناصر من المتوالية\nترشيح عناصر من متوالية\n\nوليسَت زيادتها في اللغة من باب الضرورة وإنما من باب التحسين. إذْ فيها قوة في التعبير عن جمل كثيرة في مساحة صغيرة. فهي جملة مركَّبة من ثلاث جمل: تعبير وتكرار وشرط (والشرطُ ليسَ بشرطٍ). وبحسب ما يُراد إنشاؤه تختلف الأقواس: القائمة، ومجموعة الفرائدة والقاموس والمولِّد:\n\n[expression for item in iterable if condition] List\n{expression for item in iterable if condition} Set\n{expression: expression for item in iterable if condition} Dict\n(expression for item in iterable if condition) Generator\n\nافترض أننا نريد حساب مربع كل عدد في قائمة، نستطيع كتابة ذلك المنطق بالشكل التالي:\n\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nإذا أردنا تفكيك ذلك فنقول: المُدخل قائمة، والمخرج قائمة. إذًا يمكن كتابة ذلك باختصار في سطرٍ واحد على النحو: قوس مربع متبوعًا بعبارة ناتجة متبوعًا بقطعة for وقد يكون متبوعًا بمرة أو أكثر من قطع for (للتكرار أكثر) أو if (للترشيح). وهذا مثال:\n\nsquares = [x ** 2 for x in range(10)]\n\nلو أردنا ترشيح الأعداد الزوجية من القائمة، نستطيع استعمال قطعة if في الاختصار على النحو التالي:\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nevens = [x for x in numbers if x % 2 == 0]\n\nندمج القطعتين (عبارة الناتج من التكرار مع قطعة التشريح if) لنحصل على مربع الأعداد الزوجية فقط:\n\nsquared_evens = [x ** 2 for x in numbers if x % 2 == 0]\n\nفهذه ثلاثة جمل:\n\nجملة الناتج: x ** 2\nجملة التكرار: for x in numbers\nجملة الترشيح: if x % 2 == 0",
    "crumbs": [
      "باب المجموعة المرتبة",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html",
    "href": "chapters/05_sequences/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "ترشيح الأرقام\nتصور أن لدينا قائمة من الأرقام الموجبة والسالبة في مجموعة واحدة، ونريد فصلها لمجموعتين:\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = []\nnegatives = []\n\nfor x in numbers:\n    if x &gt; 0:\n        positives.append(x)\n    else:\n        negatives.append(x)\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]\nأو باستعمال الإنشاء المختصر:\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = [x for x in numbers if x &gt; 0]\nnegatives = [x for x in numbers if x &lt; 0]\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html#التكرار-على-قائمتين",
    "href": "chapters/05_sequences/b_context.html#التكرار-على-قائمتين",
    "title": "تطبيقات",
    "section": "التكرار على قائمتين",
    "text": "التكرار على قائمتين\n\ntotal_sales = [52000.00, 51000.00, 48000.00]\nprod_cost   = [46800.00, 45900.00, 43200.00]\nfor sales, costs in zip(total_sales, prod_cost):\n    profit = sales - costs\n    print(f'Total profit: {profit}')\n\nTotal profit: 5200.0\nTotal profit: 5100.0\nTotal profit: 4800.0",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html#التكرار-على-العناصر-الصفوف",
    "href": "chapters/05_sequences/b_context.html#التكرار-على-العناصر-الصفوف",
    "title": "تطبيقات",
    "section": "التكرار على العناصر الصفوف",
    "text": "التكرار على العناصر الصفوف\nلاحظ أن كل عنصر في القائمة هو صف من ثلاثة عناصر:\n\nmy_words = [\n  (\"ذهب\", \"يذهب\", \"ذاهب\"),\n  (\"ضرب\", \"يضرب\", \"ضارب\"),\n  (\"جلس\", \"يجلس\", \"جالس\")\n]\n\nfor (verb_past, verb_present, subject) in my_words:\n  print(verb_past, verb_present, \"وهو\", subject)\n  print('-' * 50)\n\nذهب يذهب وهو ذاهب\n--------------------------------------------------\nضرب يضرب وهو ضارب\n--------------------------------------------------\nجلس يجلس وهو جالس\n--------------------------------------------------",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html#استعمال-الإحصاء-في-معرفة-معدل-التحسن",
    "href": "chapters/05_sequences/b_context.html#استعمال-الإحصاء-في-معرفة-معدل-التحسن",
    "title": "تطبيقات",
    "section": "استعمال الإحصاء في معرفة معدل التحسن",
    "text": "استعمال الإحصاء في معرفة معدل التحسن\nتصور أن لديك مجموعة بيانات تمثل عدد صفحات القراءة اليومية لشخص ما خلال شهرين:\n\nfirst_month = [\n    20, 21, 22, 23, 20, 22, 20, 18, 24, 18, 21, 23, 19, 20,\n    20, 21, 22, 23, 20, 22, 20, 18, 24, 18, 21, 23, 19, 20\n]\n\nsecond_month = [\n    30, 31, 32, 33, 30, 32, 30, 28, 34, 28, 31, 23, 29, 30,\n    30, 31, 32, 33, 30, 32, 30, 28, 34, 28, 31, 23, 29, 30\n]\n\n\nimport statistics\n\n\nمتوسط عدد صفحات القراءة في الشهر الأول\nمتوسط عدد صفحات القراءة في الشهر الثاني\nمتوسط عدد صفحات القراءة للشهرين معًا\n\n\navg1 = statistics.mean(first_month)\navg2 = statistics.mean(second_month)\navg_of_two = statistics.mean(first_month + second_month)\n\nprint('first month average reading:', round(avg1, 1))\nprint('second month average reading:', round(avg2, 1))\nprint('average reading for the two months:', round(avg_of_two, 1))\n\nfirst month average reading: 20.8\nsecond month average reading: 30.1\naverage reading for the two months: 25.4\n\n\n\nإذا كانت عدد صفحات القراءة تتزايد أم تتناقص\n\n\nif avg2 &gt; avg1:\n    print('number of pages is increasing by', round(avg2 - avg1, 1))\nelse:\n    print('number of pages is decreasing by', round(avg1 - avg2, 1))\n\nnumber of pages is increasing by 9.3\n\n\n\nأكثر ما تمت قراءته في يوم\nوأقل ما تمت قراءته في يوم\n\n\nprint('-' * 50)\nprint('first month:')\nprint('minimum number of pages:', min(first_month))\nprint('maximum number of pages:', max(first_month))\n\nprint('-' * 50)\nprint('second month:')\nprint('minimum number of pages:', min(second_month))\nprint('maximum number of pages:', max(second_month))\n\nboth_months = first_month + second_month\n\nmaximum = max(both_months)\nminimum = min(both_months)\n\nprint('-' * 50)\nprint('both months:')\nprint('maximum number of pages:', maximum)\nprint('minimum number of pages:', minimum)\n\n--------------------------------------------------\nfirst month:\nminimum number of pages: 18\nmaximum number of pages: 24\n--------------------------------------------------\nsecond month:\nminimum number of pages: 23\nmaximum number of pages: 34\n--------------------------------------------------\nboth months:\nmaximum number of pages: 34\nminimum number of pages: 18",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html#حساب-مجموع-المسافات-بين-التنبؤ-والحقيقة",
    "href": "chapters/05_sequences/b_context.html#حساب-مجموع-المسافات-بين-التنبؤ-والحقيقة",
    "title": "تطبيقات",
    "section": "حساب مجموع المسافات بين التنبؤ والحقيقة",
    "text": "حساب مجموع المسافات بين التنبؤ والحقيقة\nتستعمل معادلة مجموع القيم المطلقة للفروق بين التنبؤ والحقيقة في الانحدار الخطي الذي يستعمل في تعلم الآلة:\n\\[\n\\text{MAE} = \\sum_{i=1}^{n} |y^{(i)}_\\text{predicted} - y^{(i)}_\\text{actual}|\n\\]\nفلدينا قائمتان من الأعداد، ما تم التنبؤ به من قبل النموذج، وما هو حقيقي ضمن البيانات، ونريد أن نجد مجموع الفروق المطلقة بينهما.\n\npredictions = [ 1, 2, 3, 4, 5]\nactuals =     [-2, 3, 4, 5, 6]\nerrors =      [ 0, 0, 0, 0, 0]\n\nfor i in range(len(predictions)):\n  errors[i] = abs(predictions[i] - actuals[i])\n\nprint('errors:', errors)\nprint('total error:', sum(errors))\n\nerrors: [3, 1, 1, 1, 1]\ntotal error: 7",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html#معرفة-النقاط-المجاورة",
    "href": "chapters/05_sequences/b_context.html#معرفة-النقاط-المجاورة",
    "title": "تطبيقات",
    "section": "معرفة النقاط المجاورة",
    "text": "معرفة النقاط المجاورة\nتذكر قانون المسافة الإقليدية بين نقطتين:\n\\[\nd = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nنريد استعماله لقائمة من النقاط لمعرفة النقاط المجاورة.\n\npoints = [(1, 2), (3, 4), (5, 6), (7, 8)]\nnew_point = (2, 3)\n\ndistances = []\nnew_x, new_y = new_point\n\nfor point in points:\n  x, y = point\n  distance = ((x - new_x) ** 2 + (y - new_y) ** 2) ** 0.5\n  distances.append(distance)\n\npoints_sorted_by_distance = [point for _, point in sorted(zip(distances, points))]\nprint('nearest points:', points_sorted_by_distance)\n\nnearest points: [(1, 2), (3, 4), (5, 6), (7, 8)]",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html#القائمة-كمكدس",
    "href": "chapters/05_sequences/b_context.html#القائمة-كمكدس",
    "title": "تطبيقات",
    "section": "القائمة كمكدس",
    "text": "القائمة كمكدس\nالمكدس هو عبارة عن مجموعة مرتبة تتراكم عناصرها فوق بعض، بحيث ما يدخل أخيرا هو ما يخرج أولاً.\nيتحصل المكدس بفعلين من القائمة:\n\nالإلحاق (إضافة العنصر في النهاية): l.append(x)\nالنزع (إزالة الأخير وإرجاعه): l.pop()\n\nومن تطبيقات المكدس السهلة، استعماله في التحقق من توازن الأقواس:\n\ndef is_balanced(text: str) -&gt; bool:\n    \"\"\"Check if the text has balanced parentheses.\"\"\"\n    stack = []\n    for character in text:\n        if character == '(':\n            stack.append(character)\n        elif character == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()    \n    return len(stack) == 0\n\nassert is_balanced('()')\nassert is_balanced('(())')\nassert not is_balanced('(()')\nassert not is_balanced('((()')\nassert not is_balanced('())))')",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/b_context.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "href": "chapters/05_sequences/b_context.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "أمثلة إضافية على الإنشاء المختصر",
    "text": "أمثلة إضافية على الإنشاء المختصر\nوإليك بعض الأمثلة الإضافية:\n\nvec = [-4, -2, 0, 2, 4]\n\nترشيح الأعداد الموجبة (لاحظ أن عبارة الناتج تأخذ المكرر مثل ما هو: x ولا تعدل عليه):\n\n[x for x in vec if x &gt;= 0]\n\n[0, 2, 4]\n\n\nهنا عبارة الناتج تستعمل الإجراء abs(x) لأخذ القيمة المطلقة (بحيث تحول السالب إلى رديفه الموجب):\n\n[abs(x) for x in vec]\n\n[4, 2, 0, 2, 4]\n\n\nوفي هذا المثال استعمال الإجراء المتعلق بكل ناتج نصي من التكرار على قائمة من النصوص:\n\nfreshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n[f.strip() for f in freshfruit]\n\n['banana', 'loganberry', 'passion fruit']\n\n\nقطعة الناتج هنا هي صفّ مكوَّن من الرقم ومربعه ، وذلك من تكرارٍ على range(6) والذي يبدأ من 0 وينتهي عند 5 كما نعرف:\n\n[(x, x ** 2) for x in range(6)]\n\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n\n\nلاحظ أن العبارة مبهمة إذا لم تحدد القوسين لتحديد الصف في العبارة الناتجة:\n\n[x, x ** 2 for x in range(6)]\n\n\n  Cell In[18], line 1\n    [x, x ** 2 for x in range(6)]\n     ^\nSyntaxError: did you forget parentheses around the comprehension target?\n\n\n\n\nيمكن استعمال اختصار من اختصار على النحو التالي. في هذا المثال نفرد قائمة مكونة من قوائم عددية، فنحوِّلها لتكون قائمة واحدة مكوَّنة من جميع هذه الأرقام:\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nإذا كتبناها من غير اختصار فشكلها كالتالي (لاحظ استعملنا متغير flat لتجميع القيَم المفردة):\n\nflat = []\nfor elem in vec:\n    for num in elem:\n        flat.append(num)\nflat\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nوهذا مثال لحاصل الضرب الديكارتي بين مجموعتين رياضيتين:\n\ncolors = ['red', 'green']\nshapes = ['circle', 'square']\ncartesian_product = [(color, shape) for color in colors for shape in shapes]\ncartesian_product\n\n[('red', 'circle'),\n ('red', 'square'),\n ('green', 'circle'),\n ('green', 'square')]",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/c_problems.html",
    "href": "chapters/05_sequences/c_problems.html",
    "title": "تمارين",
    "section": "",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها.\nولديك سلة مشتريات تريد أن تحسب مجموعها.\nاكتب إجراء يحسب مجموع السلة:",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/05_sequences/c_problems.html#سلة-مشتريات",
    "href": "chapters/05_sequences/c_problems.html#سلة-مشتريات",
    "title": "تمارين",
    "section": "",
    "text": "fruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\n\ndef calculate_total_price(shopping_list):\n    pass\nassert calculate_total_price([\"apple\", \"apple\", \"apple\"]) == 4.5\nassert calculate_total_price([\"banana\", \"apple\"]) == 3.5\nassert calculate_total_price([]) == 0.0",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/05_sequences/c_problems.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/c_problems.html#متوسط-المبيعات-اليومية",
    "title": "تمارين",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\nاحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الدالة len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الدالة sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الدالة statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/05_sequences/c_problems.html#ضرب-متجهين",
    "href": "chapters/05_sequences/c_problems.html#ضرب-متجهين",
    "title": "تمارين",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\ndef dot_product(v, u):\n    pass\nللاختبار سنستعمل ما هو موجود في مكتبة numpy:\nimport numpy as np\n\nassert dot_product([1, 2, 3], [4, 5, 6]) == np.dot([1, 2, 3], [4, 5, 6])\nassert dot_product([1, 2, 3], [1, 2, 3]) == np.dot([1, 2, 3], [1, 2, 3])",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/05_sequences/c_problems.html#توزيع-الفرق",
    "href": "chapters/05_sequences/c_problems.html#توزيع-الفرق",
    "title": "تمارين",
    "section": "توزيع الفرق",
    "text": "توزيع الفرق\nلديك قائمة من الأسماء وتريد توزيعها إلى مجموعات:\n\nالحالة الأولى: يتم تعيين حجم المجموعة الواحدة\nالحالة الثانية: يتم تعيين عدد المجموعات\n\ndef make_groups1(items: list[str], num_groups: int = None, group_size: int = None) -&gt; list[list[str]]:\n    pass\nويجب أن يكون الترتيب عشوائيًّا. انظر توثيق مكتبة بايثون عن مكتبة العشواء هذه: random.choice(), random.shuffle(), random.sample().\nافترض أن هذه القائمة التي لديك:\nAhmad\nMohannad\nMohammed\nSalem\nAli\nSamir\nالاختبارات\ng1 = make_groups1([\"Ahmad\", \"Mohannad\", \"Mohammed\", \"Salem\", \"Ali\", \"Samir\"], num_groups=2)\nassert len(g1) == 2\nassert len(g1[0]) == 3\nassert len(g1[1]) == 3\n\ng2 = make_groups1([\"Ahmad\", \"Mohannad\", \"Mohammed\", \"Salem\", \"Ali\", \"Samir\"], group_size=2)\nassert len(g2) == 3\nassert len(g2[0]) == 2\nassert len(g2[1]) == 2\nassert len(g2[2]) == 2\n\nضم الأقران\nتريد الآن أن تزيد شرطًا وهو أن يكون فارق العمر بينهم أقل ما يمكن. وهذه أعمارهم:\nAhmad: 24\nMohannad: 17\nMohammed: 16\nSalem: 32\nAli: 26\nSamir: 31\nالاختبارات\ngroups = make_groups2([\"Ahmad\", \"Mohannad\", \"Mohammed\", \"Salem\", \"Ali\", \"Samir\"], group_size=2)\nfor g in groups:\n    if \"Ahmad\" in g:\n        assert \"Ali\" in g\n    if \"Mohannad\" in g:\n        assert \"Mohammed\" in g\n    if \"Salem\" in g:\n        assert \"Samir\" in g",
    "crumbs": [
      "باب المجموعة المرتبة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a_mapping.html",
    "href": "chapters/06_mapping/a_mapping.html",
    "title": "6  المجموعة المرقومة",
    "section": "",
    "text": "6.1 مجموعة الفرائد\nبعد أن رأينا التلسلسل الذي هو نوع مجموعة مرتبة. ننتقل في درسنا هذا للبحث في نوعين آخرين يندرجان تحت المجموعة المرقومة:\nمجموعة الفرائد (set) هي مجموعة متغيرة تحوي أشياء مرقومة فريدة بلا ترتيب.\nانظر MutableSet في خريطة المجموعات: شكل 1.\nتنشأ المجموعة الفريدة بالإجراء المنشئ set(). ويفضل استعمال القوسين المتعرجين { } بدلاً منه:\ns1 = set([10, 20, 30])\ns2 = {10, 20, 30}\nassert s1 == s2\nتقبل مجموعة الفرائد لكونها مجموعة (Collection) العمليات التالية:\nوباعتبارها مجموعة متغيرة (MutableSet)، فإنها تقبل الأفعال التالية:\nذكرنا أن شرط عضوية العنصر أن يكون مرقومًا؛ وهذا يجعل عملية البحث فيها قفزة واحدة (O(1))؛ إذْ يتم حساب الرقم بالإجراء hash() الذي يشير لعنوان القيمة في الذاكرة.\nالمرقوم (Hashable): هو ما يقبل الفعل hash() الذي يحول الشيء إلى رقم فريد. ومنه:\nأما القائمة مثلاً، فليست معدودة ضمن المرقومات، وذلك لأنها متغيرة (تقبل زيادة أو حذف أو تعديل عنصر) وذلك يغير الرقم؛ والشرط في المرقوم ألا يتغير رقمه أبدًا؛ لذا تجد الصف معدودًا ضمن المرقومات وليست القائمة كذلك:\ns = {10, 'AAA', True, (22, 'BB')}\n\nassert len(s) == 4\nassert 22 not in s\nassert (22, 'BB') in s\n\nfor x in s:\n    print(x)\n\n(22, 'BB')\nTrue\n10\nAAA\nباعتبارها مجموعة غير مرتبة، فإنها لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تقبل الإشارة (xs[i]) أو التقطيع (xs[i:j]) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:\nxs = {10, 20, 30}\nxs[0]\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 2\n      1 xs = {10, 20, 30}\n----&gt; 2 xs[0]\n\nTypeError: 'set' object is not subscriptable\nوتقبل المجموعة الفريدة ما تقبله المجموعة في الرياضيات من عمليات:\nوهذا الكود مثال لجميع هذه العمليات الرياضية:\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}\n\nunion = set1 | set2\nassert union == {1, 2, 3, 4, 5, 6, 7, 8}\n\nintersection = set1 & set2\nassert intersection == {4, 5}\n\ndiff1 = set1 - set2\nassert diff1 == {1, 2, 3}\n\ndiff2 = set2 - set1\nassert diff2 == {6, 7, 8}\n\nsymmetric_difference = set1 ^ set2\nassert symmetric_difference == {1, 2, 3, 6, 7, 8}\nنصيحة: من الأفضل استعمال اسم الإجراء بدلاً من العلامة التي تقابله حيث أنها تقبل أي نوع من المتكررات (Iterables) ولا تقتصر على مجموعة الفرائد فقط (set).\nوكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:\nوهذا مثال لاستعمالها:\nset1 = {'A', 'B', 'C'}\nset2 = {'A', 'B', 'C', 'D', 'E'}\nset3 = {'سين', 'جيم', 'قاف'}\n\nassert (set1 &lt;= set2) == set1.issubset(set2)\nassert (set2 &gt;= set1) == set2.issuperset(set1)\nassert (\n    set3.isdisjoint(set1 | set2) ==\n    (len(set3 & (set1 | set2)) == 0)\n)\nوهنا بحثٌ سريع جدًا باستعمال جملة التحقق من العضوية (بالتأكيد لا يظهر أثر السرعة في مجموعة صغيرة):\nlanguages = {\"Arabic\", \"English\"}\nif 'Python' not in languages:\n    print('you need to add Python to your languages!')\n\nyou need to add Python to your languages!\nوتستعمل كذلك لإزالة العناصر المتكررة في أي مجموعة، نحو الكود التالي. فإننا نحول القائمة إلى مجموعة فرائد فتزول تلك العناصر تلقائيًّا، ثم نعيدها كما كانت:\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nunique_numbers = list(set(numbers))\nprint(unique_numbers)\n\n[1, 2, 3, 4, 5]\nوكذلك من الصف:\nt = (1, 2, 2, 3, 4, 4, 5)\nunique_t = tuple(set(t))\nprint(unique_t)\n\n(1, 2, 3, 4, 5)",
    "crumbs": [
      "باب المجموعة الرابطة",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرقومة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a_mapping.html#مجموعة-الفرائد",
    "href": "chapters/06_mapping/a_mapping.html#مجموعة-الفرائد",
    "title": "6  المجموعة المرقومة",
    "section": "",
    "text": "قولنا (متغيرة) يعني أنها تقبل الإضافة والحذف والتعديل على عناصرها\nقولنا (فريدة) يعني أن العنصر لا يتكرر فيها\nقولنا (مرقومة) يعني أن عناصرها يجب أن تكون قابلة للرقم (hash)\nقولنا (بلا ترتيب) يعني أن العنصر ليس له موقع محدد فيها فليس له ما قبله وليس له ما بعده\n\n\n\n\n\n\nالعد: len(s)\nالتكرار: for x in s\nالعضوية: x not in s\n\n\n\nالإضافة: add\nالحذف: discard\nنزع عنصر عشوائي: pop\nالمحو: clear\n\n\n\n\nالنص (str) له خوارزمية معيَّنة لرقْمه\nالرقم (int) رقْمه هو نفسه\nالصف (tuple) رقْمه هو رقم عناصره (فيجب أن تكون جميع عناصره مرقومة)\n\n\n\n\n\n\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل).\n\n\n\n\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nالاتحاد\nset1 | set2\nset1.union(set2)\n\n\nالتقاطع\nset1 & set2\nset1.intersection(set2)\n\n\nالفرق\nset1 - set2\nset1.difference(set2)\n\n\nالفرق التماثلي\nset1 ^ set2\nset1.symmetric_difference(set2)\n\n\n\n\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nتحقق الجزئية\nset1 &lt;= set2\nset1.issubset(set2)\n\n\nتحقق الشمول\nset1 &gt;= set2\nset1.issuperset(set2)\n\n\nتحقق الانفصال\nlen(set1 & set2) == 0\nset1.isdisjoint(set2)",
    "crumbs": [
      "باب المجموعة الرابطة",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرقومة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a_mapping.html#القاموس",
    "href": "chapters/06_mapping/a_mapping.html#القاموس",
    "title": "6  المجموعة المرقومة",
    "section": "6.2 القاموس",
    "text": "6.2 القاموس\nالقاموس (dict) هو مجموعة مرتبة من المرقومات الفريدة الدالة على قيم.\nانظر MutableMapping في خريطة المجموعات: شكل 1.\nتنشأ المجموعة الرابطة بالإجراء المنشئ dict() ويفضل استعمال القوسين المتعرجين { } بدلاً منه:\n\nd1 = dict(key1='value1', key2='value2')\nd2 = {'key1': 'value1', 'key2': 'value2'}\nassert d1 == d2\n\nاصطلاحات: نسمي key1 المرقوم ونسمي value1 القيمة؛ وهما معًا نسميهما رابطًا.\nومن حيث كون القاموس مجموعة (Collection)، فإنه يقبل الأفعال ثلاثة:\n\nالعضوية: x not in d\nالعد: len(d)\nالتكرار: for x in d\n\nويقبل القاموس لكونه دالة (Mapping) الأفعال التالية:\n\nالإشارة بمرقوم: dict[key]\nالإشارة بمرقوم أو إرجاع قيمة افتراضية: dict.get(key[, default])\n\nويجوز التكرار بثلاثة طرق:\n\nكر الروابط: for key, value in d.items()\nكر المرقومات: for key in d.keys()\nكر القيم: for value in d.values()\n\nولكونه دالة متغيرة (MutableMapping)، فإنه يقبل الأفعال التالية:\n\nالتعديل بمرقوم: dict[key] = value\nالحذف بمرقوم: del dict[key]\nنزع بمرقوم وإرجاع القيمة: x = dict.pop(key)\nالتحديث بدالَّة أو بمكرر روابط: dict.update(mapping)\n\nملاحظة: منذ بايثون 3.7 أصبح القاموس مرتبًا. أي أن الروابط لها ما قبلها ولها ما بعدها بحسب ترتيب إدراجها.\nلاحظ أننا نستعمل مرقومات مختلفة وأيضًا نستعمل قيم مختلفة:\n\ndata = {\n    'key1': 100,\n    20: 'value2',\n    'c': [10, 20, 30, True],\n    (1, 2): 'value3',\n    ('a', 'b', 'c'): 'value4',\n}\n\nassert len(data) == 5\ndel data['key1']\nassert 'key1' not in data\n\nونحصل عليها بالإشارة بمرقوم:\n\nprint(data[20])\nprint(data['c'])\nprint(data[(1, 2)])\nprint(data[('a', 'b', 'c')])\n\nvalue2\n[10, 20, 30, True]\nvalue3\nvalue4\n\n\n\nإنشاء قاموس من سلسلتين\nويتحصل القاموس من سلسلتين باستعمال الإجراء zip()، كما يلي:\n\nstudents = ['Ahmad', 'Belal', 'Careem', 'David']\nmarks = [90, 80, 75, 85]\ndata = dict(zip(students, marks, strict=True))\ndata\n\n{'Ahmad': 90, 'Belal': 80, 'Careem': 75, 'David': 85}",
    "crumbs": [
      "باب المجموعة الرابطة",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرقومة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html",
    "href": "chapters/06_mapping/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "الكلمة ومعناها\nالقاموس بالمعنى الذي يشير إليه اللفظ. نفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:\nenglish_to_arabic = {\n    'apple': 'تفاحة',\n    'banana': 'موزة',\n    'orange': 'برتقالة',\n}",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#ربط-الأسماء-بالأرقام",
    "href": "chapters/06_mapping/b_context.html#ربط-الأسماء-بالأرقام",
    "title": "تطبيقات",
    "section": "ربط الأسماء بالأرقام",
    "text": "ربط الأسماء بالأرقام\nمثلاً: دليل أرقام الهواتف هو قاموس:\n\nname_to_phone = {\n    'Adam': '966xxxxxxxxx',\n    'Mohammed': '966xxxxxxxxx',\n}\n\nوكذلك دليل أسماء النطاق (DNS: Domain Name System) على شبكة الانرتنت هو قاموس:\n\ndomain_to_ip = {\n    'google.com': '172.217.14.206',\n    'wikipedia.org': '103.86.96.10',\n}",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#اختصار-الروابط-الطويلة",
    "href": "chapters/06_mapping/b_context.html#اختصار-الروابط-الطويلة",
    "title": "تطبيقات",
    "section": "اختصار الروابط الطويلة",
    "text": "اختصار الروابط الطويلة\nمن استعمالات القاموس: اختصار الروابط الطويلة في روابط قصيرة.\n\nshort_to_full = {\n    'google': 'https://www.google.com',\n    'python': 'https://www.python.org',\n    'wiki': 'https://www.wikipedia.org',\n}",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#الاختصارات",
    "href": "chapters/06_mapping/b_context.html#الاختصارات",
    "title": "تطبيقات",
    "section": "الاختصارات",
    "text": "الاختصارات\nأو الاختصارات إلى الكلمة التامة:\n\nabb_to_full = {\n    'ASAP': 'As Soon As Possible',\n    'BRB': 'Be Right Back',\n    'DIY': 'Do It Yourself',\n    'EDA': 'Exploratory Data Analysis',\n    'FYI': 'For Your Information',\n    'SAR': 'Saudi Riyal',\n}\n\nويمكن عكس القاموس بالطريقة التالية:\n\nfull_to_abb = {}\n\nfor key, value in abb_to_full.items():\n    full_to_abb[value] = key\n\nprint(full_to_abb)\n\n{'As Soon As Possible': 'ASAP', 'Be Right Back': 'BRB', 'Do It Yourself': 'DIY', 'Exploratory Data Analysis': 'EDA', 'For Your Information': 'FYI', 'Saudi Riyal': 'SAR'}",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#سلة-المشتريات",
    "href": "chapters/06_mapping/b_context.html#سلة-المشتريات",
    "title": "تطبيقات",
    "section": "سلة المشتريات",
    "text": "سلة المشتريات\nنفترض أن لدينا سلة تحتوي على مشتريات العميل (basket)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس prices بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).\n\nprices = {\n    'apple': 15.25,\n    'banana': 10.50,\n    'orange': 5.75,\n    'cantaloupe': 40.00\n}\n\nيجوز تحديث الأسعار هكذا:\n\nprices['banana'] = 12\n\nأو بالمجموع هكذا:\n\nprices.update({'banana': 12, 'orange': 15})\n\nوالآن نفترض أن لدينا قائمة بالفواكه التي يريدها العميل:\n\nbasket = ['apple', 'apple', 'banana', 'orange', 'banana']\n\nنحسب سعر كل فاكهة في السلة بناءً على الأسعار الموجودة في القاموس:\n\ntotal = 0\n\nfor fruit in basket:\n    total += prices[fruit]\n\nprint(total)\n\n69.5",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#تسجيل-تفضيلات-المستخدم",
    "href": "chapters/06_mapping/b_context.html#تسجيل-تفضيلات-المستخدم",
    "title": "تطبيقات",
    "section": "تسجيل تفضيلات المستخدم",
    "text": "تسجيل تفضيلات المستخدم\nيجوز أن تكون قيمة المرقوم قاموسًا؛ وهذا يعني أن القاموس قد يتضمن قاموسًا.\nهذا المثال يوضح استعمالًا شائعًا لذلك، وهو ترتيب معلومات أو تفضيلات المستخدم.\n\nuser = {\n    'name': 'Adam',\n    'language': 'Arabic',\n    'phone': '966xxxxxxxxx',\n    'last_updated': '2021-09-01',\n    'age': 25,\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\nوللوصول إلى قيمة مضمَّنة، نستعمل الإشارة مرتين، هكذا:\n\nuser['notifications']['sms']\n\nFalse\n\n\nأما حفظها فسيأتي الكلام عن حفظ البيانات في باب كتابة الملفات وقراءتها إن شاء الله.",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#الذاكرة-القريبة",
    "href": "chapters/06_mapping/b_context.html#الذاكرة-القريبة",
    "title": "تطبيقات",
    "section": "الذاكرة القريبة",
    "text": "الذاكرة القريبة\nيجوز أن تسجل نتيجة استدعاء إجراء بمدخلات معيَّنة. حتى إذا ما تكرر الاستدعاء نفس المدخلات؛ توفِّر تكلفة استدعائه بإرجاع النتيجة المحفوظة. وهذا يفيد في أمرين:\n\nالاقتصاد في موارد المعالجة، خصوصًا عند تعقد العمليات.\nتقليل وقت الاستجابة.\n\nويشترط أن يكون الإجراء نقيًّا. (انظر قسم الإجراء النقي في باب الإجراء).\n\nfactorial_table = {\n    0: 1,\n    1: 1,\n    2: 2,\n    3: 6,\n}\n\ndef factorial(n):\n    if n not in factorial_table:\n        factorial_table[n] = n * factorial(n - 1)\n    return factorial_table[n]\n\nبل إن بايثون توفر هذه الخاصية للدوال عن طريق المزيِّن (decorator) @functools.lru_cache، هكذا:\n\nimport functools\n\n@functools.lru_cache\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nلاحظ عدم الحاجة لتعريف القاموس factorial_table، بل يقوم المزيِّن هو بذلك تلقائيًّا.",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#استعمال-الإنشاء-المختصر",
    "href": "chapters/06_mapping/b_context.html#استعمال-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "استعمال الإنشاء المختصر",
    "text": "استعمال الإنشاء المختصر\nتقدم معنا الكلام عن الإنشاء المختصر. وسنستعرضه الآن مع القاموس.\nعكس قاموس بحيث تصبح الدلائل هي القيم والقيم هي الدلائل:\n\nidx2label = {\n    0: 'cat',\n    1: 'dog',\n    2: 'bird',\n}\n\nlabel2idx = {label: idx for idx, label in idx2label.items()}\nlabel2idx\n\n{'cat': 0, 'dog': 1, 'bird': 2}\n\n\nهنا مثال لقاموس من الفواكه، نريد ترشيح ما قيمته أقل من 20:\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nfiltered_menu = {key: value for key, value in menu.items() if value &lt; 20}\nfiltered_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5}\n\n\nوهذا مثال أكثر تعقيدًا. نطبق خصم 20% فقط على العناصر التي يكون سعرها أعلى من المتوسط، مع الحفاظ على بقية الأسعار كما هي. لاحظ أن التعبير هنا هو تعيين شرطي: value * (1 - discount) if value &gt; avg_price else value وليس هو قطعة الترشيح (if)؛ إذ تلك تأتي في نهاية الجملة، بعد قطعة التكرار (for).\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\navg_price = sum(menu.values()) / len(menu)\ndiscount = 0.20\n\ndiscounted_menu = {\n    key: value * (1 - discount) if value &gt; avg_price else value\n    for key, value in menu.items()\n}\ndiscounted_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5, 'cantaloupe': 32.0}",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html",
    "href": "chapters/06_mapping/c_problems.html",
    "title": "تمارين",
    "section": "",
    "text": "قاموس داخل قاموس\nإذا كان لديك قاموس متداخل كالتالي:\nmy_dict = {\n    \"class\": {\n        \"president\": {\n            \"name\": \"Malik\",\n            \"marks\": {\n                \"physics\": 70,\n                \"history\": 80\n            }\n        }\n    }\n}\nالمطلوب: اطبع قيمة المفتاح \"history\" بالتدريج من القاموس المتداخل.",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#تقريب-الاختلاف-بين-الكلمات",
    "href": "chapters/06_mapping/c_problems.html#تقريب-الاختلاف-بين-الكلمات",
    "title": "تمارين",
    "section": "تقريب الاختلاف بين الكلمات",
    "text": "تقريب الاختلاف بين الكلمات\nفي هذا المثال، تعود هذه النصوص كلها إلى نفس المعنى.\n\n(‘medina’, ‘madinah’, ‘madina’, ‘al madinah’, ‘al madina’, ‘medina’, ‘madinah’, ‘madina’, ‘المدينة’, ‘مدينة’),\n(‘mecca’, ‘makkah’, ‘makka’, ‘makkah’, ‘makkah’, ‘مكة’, ‘مكه’),\n\ndef normalize_city_name(city_name: str) -&gt; str:\n    pass\nassert (\n    'medina' ==\n    normalize_city_name('medinah') ==\n    normalize_city_name('al madina') ==\n    normalize_city_name('المدينة') ==\n    normalize_city_name('المدينه')\n)\nassert (\n    'mecca' ==\n    normalize_city_name('makkah') ==\n    normalize_city_name('makka') ==\n    normalize_city_name('مكة') ==\n    normalize_city_name('مكه')\n)",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#تصحيح-الإملاء",
    "href": "chapters/06_mapping/c_problems.html#تصحيح-الإملاء",
    "title": "تمارين",
    "section": "تصحيح الإملاء",
    "text": "تصحيح الإملاء\nاكتب إجراءً يصحح الإخطاء الشائعة في الإملاء العربي.\n\nإبدال التاء المربوطة بالهاء: مكتبه، لعبه، روايه\nإبدال الظاء بالضاد والعكس: ظابط، قرظ، ضهر\nزيادة الياء: أحسنتي، رأيتكي\n\ndef correct_spelling(word: str) -&gt; str:\n    pass\nassert correct_spelling('المكتبه فيها الروايه التي أبحث عنها') == 'المكتبة فيها الرواية التي أبحث عنها'\nassert correct_spelling('أعطاك الظابط القرظ بعد الضهر') == 'أعطاك الضابط القرض بعد الظهر'\nassert correct_spelling('رأيتكي أحسنتي') == 'رأيتك أحسنت",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#حساب-الجمل",
    "href": "chapters/06_mapping/c_problems.html#حساب-الجمل",
    "title": "تمارين",
    "section": "حساب الجُمَّل",
    "text": "حساب الجُمَّل\nحِسَاب الجُمَّل هي طريقة لتسجيل صور الأرقام والتواريخ باستخدام الحروف الأبجدية، إذ يُعطى كل حرف رقما معينا يدل عليه.\nفكانوا من تشكيلة هذه الحروف ومجموعها يصلون إلى ما تعنيه من تاريخ مقصود وبالعكس كانوا يستخدمون الأرقام للوصول إلى النصوص.\n\n\n\nحساب الجمَّل\n\n\n\n\n\n\n\n\n\n\n\nا\n1\nي\n10\nق\n100\nغ\n1000\n\n\nب\n2\nك\n20\nر\n200\nبغ\n2000\n\n\nجـ\n3\nل\n30\nش\n300\nجغ\n3000\n\n\nد\n4\nم\n40\nت\n400\nدغ\n4000\n\n\nهـ\n5\nن\n50\nث\n500\nهغ\n5000\n\n\nو\n6\nس\n60\nخ\n600\nوغ\n6000\n\n\nز\n7\nع\n70\nذ\n700\nزغ\n7000\n\n\nح\n8\nف\n80\nض\n800\nحغ\n8000\n\n\nط\n9\nص\n90\nظ\n900\nطغ\n9000\n\n\n\nاكتب تفاصيل الإجراء الذي يحسب الجمَّل لكلمة معينة.\ndef gematria(word: str) -&gt; int:\n    pass\nassert gematria('غرم') == 1240\nassert gematria('رب') == 202\nassert gematria('ريح') == 218\nassert gematria('شعب') == 372\nوكذلك في العبارات:\nassert gematria('في المشمش') == 801 == 80+10+1+30+40+300+40+300\nassert gematria('مات الشعر بعده') == 1123 == 40+1+400+1+30+300+70+200+2+70+4+5",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#التوفيق-بين-مجموعتين",
    "href": "chapters/06_mapping/c_problems.html#التوفيق-بين-مجموعتين",
    "title": "تمارين",
    "section": "التوفيق بين مجموعتين",
    "text": "التوفيق بين مجموعتين\nمسألة التوفيق بين مجموعتين تجدها في سياقات كثيرة.\nنريد في هذا التمرين التوفيق بين أشخاص وما لديهم من مهارات وبين شركات وما تطلبها من هذه المهارات.\nيمكن أن تبدأ بهذا الشكل لإيجاد كمية التوافق:\nperson_skills = {\"Python\", \"SQL\"}\nneeded_skills = {\"Python\", \"R\", \"Ninja\", \"Gymnastics\", \"Art of War\"}\nلكن في الواقع تأتي البيانات لمجموعة من الأشخاص مع مجموعة من الشركات هكذا:\npeople = [\n    {\"name\": \"Ahmad\", \"skills\": [\"Python\", \"Go\", \"JavaScript\", \"Machine Learning\", \"Statistics\"]},\n    {\"name\": \"Jawad\", \"skills\": [\"Management\", \"Business\", \"Marketing\"]},\n    {\"name\": \"Belal\", \"skills\": [\"Python\", \"Statistics\", \"R\", \"Management\"]},\n]\n\ncompanies = [\n    {\"name\": \"X\", \"skills_needed\": [\"Python\", \"Machine Learning\", \"Statistics\"]},\n    {\"name\": \"Y\", \"skills_needed\": [\"Sales\", \"Marketing\", \"Leadership\", \"Management\"]},\n    {\"name\": \"Z\", \"skills_needed\": [\"Statistics\", \"R\", \"Management\"]},\n]\nاكتب برنامج للتوفيق بين المجموعتين بحيث ترتب على بما يناسب الشركات مرة، وبما يناسب الأشخاص مرة.\nX: Ahmad, ...\nY: Jawad, ...\nZ: Belal, ...\n\nAhmad: X, ...\nJawad: Y, ...\nBelal: Z, ...",
    "crumbs": [
      "باب المجموعة الرابطة",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html",
    "href": "chapters/07_strings/a1_strings.html",
    "title": "7  النص",
    "section": "",
    "text": "7.1 النص الطبيعي\nالنص (str) صف من الأحرف. وهو تسلسل ثابت من أرقام يونيكود (Unicode) التي هي رموز تتبع ترميزًا عالميًا يحوي جميع أحرف اللغات بالإضافة إلى علامات الترقيم والرسوم (مثل: 💡🔍📐) ونحوها.\nالنص الطبيعي (الحر أو البشري) هو ما لا يتبع هيكلاً أو قالبًا يحكم طريقة كتابته؛ وهو يطول ويقصر من الحرف الواحد إلى مجموعة الأحرف إلى الكلمة إلى الجملة وإلى أكبر من ذلك نحو:\nوأوجه معالجة النصوص الحرة كثيرة منها: الفهرسة والبحث والاستبدال والعد والتصنيف والترتيب والقولبة …إلخ.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "href": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "title": "7  النص",
    "section": "",
    "text": "محادثات وسائل التواصل الاجتماعي\nرسائل البريد الإلكتروني\nمقالات\nكتب\nموسوعات\nصفحات الشبكة\nمواقع الشبكة",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "href": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "title": "7  النص",
    "section": "7.2 النص المُقَوْلَب",
    "text": "7.2 النص المُقَوْلَب\nالنص المقولَب الذي يأخذ شكلاً محددًا؛ وله صيغ متعددة يُنشئ الناس منها قوالب للنص لتمثل مجموعات أو ارتباطات من البيانات، كالجداول ونحوها.\nوصيغ القولبة كثيرة من أشهرها: XML, YAML, JSON, CSV\n\n\nمثال لقالب بصيغة YAML:\n---\nName: Adam\nAge: 25\nCity: Riyadh\n\nمثال لقالب بصيغة JSON:\n{\n  \"Name\": \"Adam\",\n  \"Age\": 25,\n  \"City\": \"Riyadh\"\n}\n\n\nوهذا مثال لقالب بصيغة XML:\n&lt;person&gt;\n  &lt;name&gt;Adam&lt;/name&gt;\n  &lt;age&gt;25&lt;/age&gt;\n  &lt;city&gt;Riyadh&lt;/city&gt;\n&lt;/person&gt;\nوالصيغة التي تستعمل كثيرًا لتمثيل الجداول (صفوف) هي صيغة CSV. فكل سطرٍ هو صفٌّ في الجدول، وأوَّلُ سطرٍ هو رأس الجدول عادةً. وذلك على النحو التالي:\nName,Age,City\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\nجرب أن تُنشئ ملفًّا نصيًّا وتكتب فيه ذلك وتحفظه بصيغة csv ثم سترى أنه يمكنك فتحه بمحرر جداول (:مثل إكسل - Excel).",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "href": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "title": "7  النص",
    "section": "7.3 إنشاء النص",
    "text": "7.3 إنشاء النص\nجملة إنشاء النص في بايثون تكون كالتالي:\n\nبعلامة اقتباس مفردة: 'السلام عليكم!'\nأو بعلامة اقتباس مزدوجة: \"السلام عليكم!\" وليس بينهما فرق.\nأو بعلامة اقتاس مكررة ثلاثة مرات: \"\"\"السلام عليكم!\"\"\" للنص الجاري على أكثر من سطر.\n\nعلى سبيل المثال:\n\nname = 'Adam'\naddress = \"Makkah, Saudi Arabia\"\n\nتأمل إنشاء هذا النص الذي يبتدئ في السطر الأول ويتمد لأربعة أسطر:\n\nmessage = \"\"\"السلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\"\"\"\nprint(message)\n\nالسلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\n\n\n\nقراءة الملفات النصية\nوكثيرًا ما يكون وجود النص في البرنامج ناتجًا عن قراءة ملف نصي بالإجراء open() وذلك بإضافة الحرف r ميشرًا إلى أن غرض الفتح القراءة:\nfile = open('my_file.txt', 'r')\nmessage = file.read()\nfile.close()\nprint(message)\nوسيأتي تفصيل كيفية التعامل مع الملفات في باب الملفات.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "href": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "title": "7  النص",
    "section": "7.4 الإشارة لجزء من النص",
    "text": "7.4 الإشارة لجزء من النص\nولكون النص تسلسلاً ثابتًا فإنه يقبل جميع عمليات التسلسل السابق ذكرها (انظر باب المجموعة المرتبة).\n\ns = 'Arabian'\n\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\n 0   1   2   3   4   5   6   7\n +---+---+---+---+---+---+---+\n | A | r | a | b | i | a | n |\n +---+---+---+---+---+---+---+\n-7  -6  -5  -4  -3  -2  -1\n\nجرب\n\ns[1:5]\ns[1:5:2]\ns[::2]\ns[::-1]\n\nلاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:\n\ns = ('A', 'r', 'a', 'b', 'i', 'a', 'n')\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\nلكن الفرق أن النص صنفٌ له أفعال / عمليات خاصة تتعلق بالنصوص.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "href": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "title": "7  النص",
    "section": "7.5 النص ثابت لا يقبل التغير",
    "text": "7.5 النص ثابت لا يقبل التغير\nفالنص تسلسل يشبه الصف في كوْنه ثابتًا (أي لا يقبل تعديل عنصر أو إضافته أو حذفه). فلو حاولت تغيير موضعٍ s[i] في النص أو قطعة s[i:j] فإنك ستواجه خطأ:\n\ns = 'Arabian'\ns[0] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 s = 'Arabian'\n----&gt; 2 s[0] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nلكننا لتعديل النص في الواقع نعيِّنُ إلى نفس المتغير نصًّا جديدًا منه:\n\ns = 'Arabian'\ns = 'a' + s[1:]\nprint(s)\n\narabian\n\n\nلاحظ أننا أسندنا النص الجديد إلى المتغير s، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "href": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "title": "7  النص",
    "section": "7.6 العمليات الخاصة بالنصوص",
    "text": "7.6 العمليات الخاصة بالنصوص\n\nالاستبدال\nلاستبدال جزء من النص، نستخدم إجراء .replace():\n\ns = 'Arabian'\ns = s.replace('ian', 'y')\nprint(s)\n\nAraby\n\n\n\n\nإزالة المسافات\nكما لدينا علميات .strip() لإزالة المسافات البيضاء من بداية ونهاية النص.\n\nassert '  Arabian  '.strip() == 'Arabian'\n\n\n\nالبحث والمطابقة\nوكذلك لدينا عمليات البحث:\n\nالتحقق من البدء والنهاية وما بينهما: .startswith(prefix) و .endswith(suffix) أو sub in string وهي أعم.\nلمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص .find()\n\n\ns = 'Arabian'\nassert s.startswith('A')\nassert not s.startswith('a')\nassert s.endswith('n')\nassert 'rabia' in s\nassert s.find('a') == 2\n\n\n\nالفصل والوصل\n\nفصل النص لقائمة بناءً على جزء فاصل: list.split(seperator)\nوصل عناصر القائمة في نص مفصول بجزء فاصل: seperator.join(list)\n\nأولاً: الفصل: مثاله قراءة سطر في ملف csv إذْ القيم مفصولة بعلامة الفاصلة ,:\n\ncsv = \"Adam,25,Riyadh\"\nassert csv.split(',') == ['Adam', '25', 'Riyadh']\n\nولقراءة الملف كاملاً نكرر:\n\nالقيم في السطر الواحد مفصولة بعلامة الفاصلة ,\nوالصفوف مفصولة بعلامة السطر الجديد \\n\n\nلذلك سنستعمل الاثنين هنا:\n\ncsv = \"\"\"name,age,city\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\"\"\"\n\ndata = []\nfor line in csv.split(sep='\\n'):\n  row = line.split(sep=',')\n  data.append(row)\nprint(data)\n\n[['name', 'age', 'city'], ['Adam', '25', 'Riyadh'], ['Belal', '30', 'Jeddah'], ['Camal', '35', 'Dammam']]\n\n\nثانيًا: الوَصل: مثاله أننا نحول القائمة إلى نص مفصول بعلامة الفاصلة , وذلك ليكون سطرًا في ملف csv:\n\ndata = ['Adam', '25', 'Riyadh']\nseperator = ','\ncsv = seperator.join(data)\nassert csv == 'Adam,25,Riyadh'\n\n\n\nعمليات إنجليزية\nوهنا عمليات خاصة بالنصوص الإنجليزية:\n\nupper() نسخة ذات حروف كبيرة.\nlower() نسخة ذات حروف صغيرة.\ncapitalize() نسخة ذات حرف أول كبير من كل كلمة.\ntitle() نسخة ذات حالة عنوان.\n\n\nname = 'Adam ibraheeM'\nprint(name.upper())\nprint(name.lower())\nprint(name.capitalize())\nprint(name.title())\n\nADAM IBRAHEEM\nadam ibraheem\nAdam ibraheem\nAdam Ibraheem\n\n\nوانظر مستندات النصوص لمعرفة كافة الإجراءات الممكنة على النصوص.\n\n\nتفسير الأرقام\nتفسير الأرقام المكتوبة نصًّا تكثر الحاجة إليه خصوصًا عند قراءة ملفات أو التعامل مع بيانات من المستخدم، إذ يكون الإدخال نصيًّا:\n\nint(x) لتحويل نص إلى عدد صحيح.\nfloat(x) لتحويل نص إلى عدد عشري.\n\nلاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:\n\nx = '20'\ny = '40'\nprint(x + y)\n\n2040\n\n\nالواجب تحويلهما إلى أعداد أولاًً:\n\nx2 = float(x)\ny2 = float(y)\nprint(x2 + y2)\n\n60.0",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "href": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "title": "7  النص",
    "section": "7.7 إخراج النص",
    "text": "7.7 إخراج النص\nنستعرض ثلاث طرق لدمج النصوص في بايثون:\n\nالأولى: تحويل الشيء إلى نص قبل دمجه مع النص، باستعمال str(x)\nالثانية: استعمال فراغات بالقوسين المعكوفين {} مع الإجراء .format() لاستبدالها.\nالثالثة: استعمال f-string بأن تضع الحرف f قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل الأقواس المعكوفة {}. وهي الطريقة التي نفضلها.\n\n\nname = \"John\"\nlvl = 300\n\ns1 = \"I am \" + name + \" and I want to reach level \" + str(lvl) # + operator\ns2 = \"I am {} and I want to reach level {}\".format(name, lvl)  # .format() method\ns3 = f\"I am {name} and I want to reach level {lvl}\"            # f-strings\nassert s1 == s2 == s3\nprint(s1)\n\nI am John and I want to reach level 300\n\n\nيقبل النص التكرار بعلامة *:\n\nprint('-' * 10)\nprint('*' * 10)\nprint('=' * 10)\n\n----------\n**********\n==========",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "href": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "title": "7  النص",
    "section": "7.8 المحاذاة والحشو",
    "text": "7.8 المحاذاة والحشو\n\nname = 'Adam'\nprint(name.ljust(15)) \nprint(name.center(15))\n\nAdam           \n      Adam     \n\n\nطريقة ممتعة لتزيين سلسلة نصية باستخدام دالة center:\n\nprint('*' * 20)\nprint('Adam'.center(20, \"*\"))\nprint('*' * 20)\n\n********************\n********Adam********\n********************",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "href": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "title": "7  النص",
    "section": "7.9 تنسيق الأرقام",
    "text": "7.9 تنسيق الأرقام\n\nمحاذاة الأرقام\n\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\n       100\n      1000\n     10000\n\n\nيمكننا أيضًا جعل كل من العدد n والتعبئة p متغيرات:\n\nn = 100\np = 5\nprint(f'{n:{p}}')\n\n  100\n\n\nبشكل افتراضي، يتم محاذاة الرقم إلى اليمين. يمكننا محاذاته إلى اليسار بإضافة &lt;. لاحظ الفرق بين التعبيرين أدناه:\n\nprint(f'{n:&gt;{p}}')\nprint(f'{n:&lt;{p}}')\n\n  100\n100  \n\n\n\n\nفاصل الآلاف\n\nbig_num = 10000\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n10000\n10,000\n\n\n\n\nالترميز العلمي\n\nsmall_num = 0.00001\nprint(f\"{small_num:.2e}\")\n\n1.00e-05\n\n\n\n\nالأعداد العشرية\n\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\nمثال: تنسيق الكم المالي\nهنا نستخدم مكونين داخل الأقواس المعقوفة وعلامة $ في البداية: - يتم إضافة علامة $ قبل الرقم (ليست جزءًا من الرقم المنسق على الإطلاق) - , تضيف فاصل الآلاف - .2f يقوم بتقريب الرقم إلى منزلتين عشريتين\n\nprice_dollars = 2978.95\nprice_riyals = price_dollars * 3.75\nprint(f\"${price_dollars:,.2f} = {price_riyals:,.2f} SAR\")\n\n$2,978.95 = 11,171.06 SAR",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html",
    "href": "chapters/07_strings/a2_unicode.html",
    "title": "8  تمثيل النص",
    "section": "",
    "text": "8.1 ترميز Unicode\nترميز الحروف هي عملية تعيين أرقام للأحرف الرسومية مما يسمح بتخزينها ونقلها وتحويلها باستخدام الحواسيب الرقمية.\nرموز ASCII تحتوي على 128 حرف للغة الإنجليزية وبعض علامات الترقيم. منها 95 فقط هي أحرف قابلة للطباعة أما البقية فتسمى أحرف تحكُّم (مثل حرف السطر الجديد \\n ، وحرف الرجوع لبداية السطر \\r).\nثم امتدت عن طريق رموز ANSII لتغطي أحرف إضافية (من 128 إلى 255) وهي الأحرف الاتينية للغات الأخرى.\nلنستكشف السلاسل عن طريق حزمة من المكتبة الأساسية string. الآتي الأحرف اللاتينية الكبيرة والصغيرة، وعلامات الترقيم:\nواليوم رموز Unicode تحتوي على أكثر من مليون حرف لتغطية لغات العالم كافة: اللاتينية، اليونانية، السيريلية، الأرمنية، العبرية، العربية، السريانية، الثانا، الديفاناغارية، البنغالية، الجورموخية، الأورية، التاميلية، التيلوغوية، الكانادية، المالايالامية، السنهالية، التايلاندية، اللاوية، التبتية، الميانمارية، الجورجية، الهانغول، الإثيوبية، الشيروكية، الرموز الكندية الأصلية، الخميرية، المنغولية، الهان (الأيدوغراف الياباني، الصيني، الكوري)، الهيراغانا، الكاتاكانا، واليي. المصدر. وما يزال أول 128 حرف منها متطابق مع رموز ASCII.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "href": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "title": "8  تمثيل النص",
    "section": "",
    "text": "مثال\nماذا يحصل لو كتبنا حروف عربية ثم حاولنا حفظ الملف بترميز ASCII ولم نحفظه بترميز Unicode؟\n\n\n\nبرنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات\n\n\nالخطأ يقول: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "href": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "title": "8  تمثيل النص",
    "section": "8.2 كيف يتم تمثيل النصوص في بايثون؟",
    "text": "8.2 كيف يتم تمثيل النصوص في بايثون؟\nتمثيل النصوص في بايثون يكون عن طريق النوع str؛ يُعرَّف بكتابة سلسلة من الأحرف لكن في الواقع تتحول إلى سلسلة من رموز Unicode (أي: أرقام). هذا يعني أنها قد تكون سلسلة رموز لاتينية أو عربية أو صينية أو غير ذلك مما تحويه رموز Unicode.\nالدالة المدمجة ord() تقوم بتحويل الحرف إلى رقم الرمز. بينما chr() تعكس ذلك (من الرمز إلى الحرف).\nعلى النقيض من سي وجافا؛ لا يوجد نوع خاص بالحرف الواحد (char) في بايثون.\n\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nماذا عن الحروف العربية؟ أين تقع في أرقام ترميز Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nلمعرفة أرقام الحروف في نصٍّ ما؛ نستعمل التكرار هكذا:\n\ndef get_unicode_points(s):\n    codes = []\n    for c in s:\n        codes.append(ord(c))\n    return codes\n\nprint(get_unicode_points('Arabian'))\nprint(get_unicode_points('السَّلَامُ عَلَيْكُمْ'))\n\n[65, 114, 97, 98, 105, 97, 110]\n[1575, 1604, 1587, 1614, 1617, 1604, 1614, 1575, 1605, 1615, 32, 1593, 1614, 1604, 1614, 1610, 1618, 1603, 1615, 1605, 1618]\n\n\nفهذه هي الحروف في الواقع، إلا أننا نتعامل مع شيء مجرَّد في لغات البرمجة العالية غالبًا ما يسمى str.\nراجع ويكيبيديا: النص العربي في Unicode لمزيد من التفاصيل.\n\nالأحرف البيضاء\nالأحرف في الأجهزة الرقمية على نوعين:\n\nأحرف طباعة: مثلاً: الأحرف اللاتينية والأرقام وعلامات الترقيم\nأحرف تحكم: مخفيَّة؛ والغرض منها التحكم بمعالج هذا النص\n\nلعرض الأحرف القابلة للطباعة في محارف آسكي (ASCII)، لدينا المتغير printable من مكتبة string:\n\nimport string\nstring.printable\n\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n\n\nكانت أحرف التحكُّم تستخدم لرن جرس الآلة الطابعة ، والتحكم بها ، لكن اليوم الذي يُستخدم منها غالبًا هو الأحرف البيضاء (Whitespace Characters) ويشمل ذلك الأحرف التالية:\n\nspace: \\s ويمثل المسافة التي بين الكلمات\ntab: \\t ويمثل المسافة التي بين أعمدة الجداول\nlinefeed: \\n تعليمة سطر جديد\nreturn: \\r تعليمة العودة لبداية السطر الجديد\nformfeed: \\f تعليمة الصفحة الجديدة\nvertical tab: \\v تعليمة العمود الجديد\nbackspace: \\b تعليمة عودة المؤشر بمقدار حرف واحد للكتابة فوق الحرف السابق\n\nأما الثلاثة الأخيرة فقد كانت تستخدم فيما مضى، لكن اليوم المستخدم هو الأربعة الأولى فقط. ويجدر بالذكر أن ملفات نصوص نظام ويندوز تستعمل \\r\\n للانتقال لسطر جديد بينما تستعمل الأنظمة الأخرى \\n فقط.\nتذكر أن بايثون تعتمد على space و tab للمسافة البادئة للسطر (indentation)، لتحديد نطاقات الكود بحسب المحاذاة العمودية.\n\nimport string\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\nيهمنا هنا الأحرف البيضاء لأنها تظهر في النصوص وقد تكون مزعجة عند معالجتها. لنلقي نظرة على ثلاثة من الأحرف البيضاء: المسافة (space)، التبويب (tab)، وتعليمة السطر الجديد (linefeed).\n\n# Tab character: \"\\t\"\nprint('A\\tB')\n\nA   B\n\n\n\n# Space character: \" \"\nprint('   A            B   ')\n\n   A            B   \n\n\n\n# Newline character: '\\n'\nprint('A\\nB')\n\nA\nB\n\n\nلاحظ أن طول السلسلة النصية هو عدد الأحرف في السلسلة، سواء كانت قابلة للطباعة (printable) أو أحرف بيضاء (whitespace).\n\nassert len('A B') == 3\nassert len('A\\tB') == 3\nassert len('A\\nB') == 3\n\n\n\nالأطراف الزائدة\nلاحظ أن هذه الدالة ستزيل الأحرف البيضاء من بداية ونهاية السلسلة النصية، ولكن ليس الأحرف البيضاء في منتصف السلسلة\nقبل:\n\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\nبعد:\n\nprint(text.strip())\n\nhello    world\n\n\n\n\nتجزئة النص\nانظر: Splitlines\n\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\nإذا تركنا الكود كما هو في السطر من غير print فإن ذلك يعرض السلسلة النصية كما هي (بما في ذلك أحرف المسافات البيضاء)\n\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\nأما إذا وضعنا print فإنه يطبع الأحرف المرئية ، وينسِّقُ المظهر بناءً على أحرف التحكُّم المخفية:\n\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\nإذا لم نحدد محدد الفاصل فإن الفاصل الافتراضي هو المسافة.\n\nprint(\"Hello, world\".split())\n\n['Hello,', 'world']\n\n\nهنا نحدد الفاصل أنه الحرف \"l\":\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\nلإزالة الأحرف البيضاء جميعها؛ نستعمل التكرار هكذا:\n\ntext = '\\t hello    world \\n\\n\\n'\nsp = text.split()\nprint('split:', sp)\nclean = ' '.join(sp)\nprint('clean:', clean)\n\nsplit: ['hello', 'world']\nclean: hello world\n\n\nالفصل في الداخل ينتج قائمة من النصوص، بعضها فارغ لوجود الأحرف البيضاء المتتالية، فلا تتضمن في القائمة الناتجة.",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#الطباعة",
    "href": "chapters/07_strings/a2_unicode.html#الطباعة",
    "title": "8  تمثيل النص",
    "section": "8.3 الطباعة",
    "text": "8.3 الطباعة\n\nحروف التحكم بآلة الطباعة\nيسمّى الحرف \\r بالعودة للبداية لأنه يعني أمر يقوم بإرجاع المؤشر إلى بداية السطر.\nكانت آلة الطباعة قديمًا يتحرك رأس الطباعة فيها بعد طباعة كل حرف. ثم عندما ينتهي السطر، يجب على الشخص أن يقوم بعمليتين:\n\nالضغط على المفتاح الذي يرفع الورقة بمقدار سطر (ويرمز له بالحرف \\r)\nالضغط على المفتاح الذي يرجع رأس الطباعة لبداية السطر (ويرمز له بالحرف \\n)\n\nوهما مستخدمان اليوم فيما يُعرض على الشاشة.\nفإجراء print في الحقيقة يضع سطرًا جديدًا (حرف \\n) في الوضع الافتراضي. فإن أردنا ألا يضعه، فنحدد العامل end الذي فيه على النحو التالي:\n\nprint('Hello', end='')\nprint('World', end='')\n\nHelloWorld\n\n\nلاحظ أننا جعلنا (end='') أي: لا نريده أن يضع حرفًا بعد طباعة النص. ولذلك ظهرت الكلمتان في نفس السطر.\nولو أردت أن تعيد الكتابة على نفس السطر، يمكنك أن تضع الحرف (\\r) الذي يأمر رأس الطباعة بالرجوع لبداية السطر:\n\nprint('123', end='\\r')\nprint('45')\n\n12345\n\n\nلاحظ أن النتيجة هي طباعة الحرفين 45 فوق الحرفين 12 مع بقاء الحرف الأخير 3 في الأخير. وذلك لرجوع رأس الطباعة.\nتستعمل هذه اللطيفة في تحديث العداد حتى يظهر على الشاشة وكأنه يزيد شيئًا فشيئًا. وذلك على النحو التالي (لاحظ أننا نستعمل time.sleep(t) حتى نمثِّل وجود عمليَّة تأخذ وقتًا طويلاً فحسب):\nimport time\n\nfor x in range(10 + 1):\n    time.sleep(0.20)\n    print(f'[{x}/10] ' + '===' * x + '&gt;', end='\\r')",
    "crumbs": [
      "باب النص",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html",
    "href": "chapters/07_strings/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "الكلمة المتناظرة\nفي هذا المثال نوضح استعمال مؤشرين على نفس النص لمعرفة ما إذا كانت الكلمة متناظرة:\ndef is_palindrome(word):\n    \"\"\"\n    A palindrome word is one that can be read the same way from both ends.\n    \"\"\"\n\n    # Remove the difference of capitalization\n    word = word.lower()\n    \n    # Remove the spaces (to match things like: \"Race car\")\n    word = word.replace(\" \", \"\")\n\n    # Check if the word is a palindrome\n    for i in range(len(word) // 2):\n        j = len(word) - i - 1\n        if word[i] != word[j]:\n            return False\n    return True\n\n# Test examples\nassert is_palindrome(\"radar\")\nassert is_palindrome(\"level\") \nassert is_palindrome(\"madam\")\nassert is_palindrome(\"توت\")\nassert is_palindrome(\"خوخ\")\nassert is_palindrome(\"Race car\")\nassert is_palindrome(\"حصان ناصح\")\nassert not is_palindrome(\"python\")\nبدل الحلقة، وكان لنا أن نكتب باختصار: word == word[::-1] وهي تعني أن النص متناظر إذا كان مساوياً لنفسه بالمقلوب.\ndef is_palindrome(word):\n    word = word.lower()\n    word = word.replace(\" \", \"\")\n    return word == word[::-1]",
    "crumbs": [
      "باب النص",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#الكلمة-المتناظرة",
    "href": "chapters/07_strings/b_context.html#الكلمة-المتناظرة",
    "title": "تطبيقات",
    "section": "",
    "text": "المؤئر الأول بإصبعك الأيمن: i يبدأ من أول حرف وينتهي عند المنتصف\nالمؤئر الثاني بإصبعك الأيسر: j يبدأ من آخر حرف وينتهي عند المنتصف",
    "crumbs": [
      "باب النص",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#عد-الكلمات",
    "href": "chapters/07_strings/b_context.html#عد-الكلمات",
    "title": "تطبيقات",
    "section": "عد الكلمات",
    "text": "عد الكلمات\nهذا مثال لاستخراج الكلمات (من غير تكرار) من قاموس من العبارات (ثلاثة عبارات). هذه العملية تستعمل كثيرًا في تحليل النصوص إذ نريد أن نعرف جميع الكلمات الواردة في مجموعة من النصوص، ولا نريد الكلمات المعهودة جدًّا (هنا نسميها stop_words)، كما أننا نستعمل .lower() في التعبير الناتج حتى لا يفرق بين الحروف في حالتيها الإنجليزية:\n\nstop_words = {'is', 'and', 'the', 'be', 'not'}\n\ndocuments = {\n    'Python':     \"python is great and Python is easy\",\n    'Java':       \"Java is verbose and java is popular\",\n    'JavaScript': \"JavaScript is for the web and javascript is everywhere\"\n}\n\nword_counts = dict()\n\nfor doc in documents.values():\n    doc = doc.lower()\n    words = doc.split()\n    for w in words:\n        if w not in stop_words:\n            word_counts[w] = word_counts.get(w, 0) + 1\n\nfor w, count in word_counts.items():\n    print(f\"{w}: {count}\")\n\npython: 2\ngreat: 1\neasy: 1\njava: 2\nverbose: 1\npopular: 1\njavascript: 2\nfor: 1\nweb: 1\neverywhere: 1",
    "crumbs": [
      "باب النص",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#ترجمة-أوامر",
    "href": "chapters/07_strings/b_context.html#ترجمة-أوامر",
    "title": "تطبيقات",
    "section": "ترجمة أوامر",
    "text": "ترجمة أوامر\nنكتب برنامج يقرأ سطرًا يأمره بعملية حسابية على عوامل محددة. فهو كلغة برمجة بسيطة.\n\ndef parse_command(cmd):\n    \"\"\"\n    Parse a command and return the result of the operation.\n\n    Example:\n    &gt;&gt;&gt; parse_command(\"+ 5 10 2\")\n    17\n    &gt;&gt;&gt; parse_command(\"* 5 10 2\")\n    100\n    &gt;&gt;&gt; parse_command(\"max 5 10 2\")\n    10\n    \"\"\"\n\n    operator, *operands = cmd.split(\" \")\n\n    match operator:\n        case \"+\":\n            total = 0\n            for item in operands:\n                total += float(item)\n            return total\n\n        case \"*\":\n            total = 1\n            for item in operands:\n                total *= float(item)\n            return total\n\n        case \"max\":\n            max_value = float(operands[0])\n            for item in operands[1:]:\n                f = float(item)\n                if f &gt; max_value:\n                    max_value = f\n            return max_value\n\n        case _:\n            raise ValueError(f\"Unknown operator: {operator}\")\n\nassert parse_command(\"+ 5 10 2\") == 17\nassert parse_command(\"* 5 10 2\") == 100\nassert parse_command(\"max 5 10 2\") == 10\n\nتطبيقات النصوص كثيرة جدًّا في الواقع، لكن نكتفي بهذا هنا، ولعلك تراجع مصادر مختصة بالتحليل النصي لتعلم المزيد.",
    "crumbs": [
      "باب النص",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#تلوين-الخارج",
    "href": "chapters/07_strings/b_context.html#تلوين-الخارج",
    "title": "تطبيقات",
    "section": "تلوين الخارج",
    "text": "تلوين الخارج\nfrom colorama import Fore, Back, Style\n\n# Print different color text with different background\nprint(f\"{Fore.RED}This text is red!{Style.RESET_ALL}\")\nprint(f\"{Back.GREEN}This has a green background{Style.RESET_ALL}\")\nprint(f\"{Fore.YELLOW}{Back.BLUE}This is yellow text on a blue background{Style.RESET_ALL}\")\n\n# Print with bold and italic styles\nprint(f\"{Style.BRIGHT}This is bright text{Style.RESET_ALL}\")\nprint(f\"{Style.DIM}This is dimmed text{Style.RESET_ALL}\")\n\n# Reset all styles at the end\nprint(f\"{Style.RESET_ALL}This is back to default style\")",
    "crumbs": [
      "باب النص",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html",
    "href": "chapters/08_files_and_directories/a1_serialization.html",
    "title": "9  الملف",
    "section": "",
    "text": "9.1 قراءة وكتابة الملفات\nفيه ثلاثة خطوات:\nوذلك على النحو التالي:\nf = open(file='../../datasets/example_root/a/a.txt', mode='r')\ncontent = f.read()\nf.close()\n\nprint(content)\n\nlorem ipsum dolfet\nweilfur badem zelfur\nأما المسار فله شكلان\nوقد تستعمل علامة ./ للإشارة للدليل الحالي. أما علامة ../ فتشير إلى الدليل الأب.\nوهكذا نكتب في الملف باستعمال file.write()، بعد فتح الملف بوضع الكتابة 'w' في open(mode='w'):\ncontent = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\n\nf = open(file='../../datasets/example_root/a/zzz.txt', mode='w')\nf.write(content)\nf.close()\n\nprint(content)\n\nSalam everyone,\nI hope you are enjoying the course,\n\nThank you.\nانظر توثيق قراءة وكتابة الملفات.\nولأن الإغلاق ضروري بعد كل فتح؛ فقد وفرت بايثون لذلك مركبًا لغويًّا يُعرف بإدارة السياق. فالملف صنفٌ يعتبر مدير سياق (Context Manager) فيجوز استعمال with وتضمين قطعة الكود في سياقها الذي يتكفل بإغلاق الملف تلقائيّا عند نهاية آخر جملة في قطعة الكود داخلها. وذلك على النحو التالي:\ncontents = ''\nwith open(file='../../datasets/example_root/a/a.txt', mode='r') as f:\n    contents = f.read()\nprint(contents)\n\nlorem ipsum dolfet\nweilfur badem zelfur",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#قراءة-وكتابة-الملفات",
    "href": "chapters/08_files_and_directories/a1_serialization.html#قراءة-وكتابة-الملفات",
    "title": "9  الملف",
    "section": "",
    "text": "نفتح الملف open(): وهذا طلبٌ من نظام التشغيل الإذنَ (بحسب mode الإذن بالقراءة r أو الإذن بالكتابة w أو الإذن بالقراءة والكتابة rw)؛ ونحصل في النتيجة على مؤشر يشير إليه.\n. نقرأ الملفfile.read() فيتم نسخ محتواه من التخزين إلى الذاكرة\nولا بُد من تسريحه بعد الفراغ منه باستعمال file.close()\n\n\n\n\n\n\n\n\n\n\n\n\nنوع المسار\nالشرح\nمثال\n\n\n\n\nالمسار المطلق (Absolute Path)\nيحدد المسار بشكل كامل بدءًا من الجذر، ولا يعتمد على الموقع الحالي.\n/home/user/Downloads\n\n\nالمسار النسبي (Relative Path)\nيحدد المسار بالنسبة لموقع الملف الحالي.\n../../datasets/example_root/a/a.txt",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#صياغة-البيانات",
    "href": "chapters/08_files_and_directories/a1_serialization.html#صياغة-البيانات",
    "title": "9  الملف",
    "section": "9.2 صياغة البيانات",
    "text": "9.2 صياغة البيانات\nسَلْسَلة البيانات (Data Serialization) تشير لعملية تحويل البيانات في ذاكرة بايثون (مثل القائمة [] والقاموس {}) من صيغتها الثنائية الخاص باللغة إلى تمثيلٍ ليس خاصًّا بلغةٍ معيَّنة؛ بل يتبع صيغةً متفقًا عليها؛ فإما أن يكون:\n\nتمثيلاً نصيًّا (Plain Text Serialization) متفقًا عليه مثل: xml أو json أو csv ونحوها (وقد تقدَّم عرضُها في باب النص).\nأو تمثيلاً ثنائيًّا (Binary Serialization) متفقًا عليه كذلك مثل: pickle أو protobuf أو parquet.\n\nفالتمثيل النصي يتميز بأنه مباشر وواضح بالنسبة للبشر. لكنه أبطأ في المعالجة (سواءً في الكتابة أو في القراءة) وأكبرُ حجمًا في التخزين غالبًا. أما التمثيل الثانئي فهو بعكسه: أقرب للآلة وأصعب في التدقيق عند حدوث الخطأ إلا مع وجود أدوات تساعد في ذلك. لكنه أسرع في المعالجة وأقل حجمًا للتخزين.\nوعملية تحويل البيانات المُسَلسَلة (أي المكتوبة بإحدى هذه الصيغ) وقراءَتها في برنامجٍ ما تسمى فك التسلسل (Deserialization). فالتحويل يكون مثلاً من النصي إلى الثنائي في الذاكرة. أو من الثنائي المسلسل إلى الثنائي في الذاكرة.\nفالسلسلة وفكها ما هي إلا صياغة لا تغير المكنون بل شكله.\nويختلف شكل البيانات من ثلاثة أوجه:\n\nالصف: [1, 2, 3, 4, 5]\nالربط: {key1: value1, key2: value2}\nالتضمين: فيكون العنصر نفسه سلسلة أو ارتباطًا\n\nفالصفوف تتميز بكون كل صفٍّ فيها تدوينًا لمجموعة خصائص تشترك في العمود كله. أما الارتباط ففيه مرونة؛ فمجموعة الارتباطات لا تُلزِم كل ارتباط أن يكون له ذات خصائص الارتباط الذي قبله. والتقسيمات تُنتج التضمين.",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#الارتباط-والتضمين",
    "href": "chapters/08_files_and_directories/a1_serialization.html#الارتباط-والتضمين",
    "title": "9  الملف",
    "section": "9.3 الارتباط والتضمين",
    "text": "9.3 الارتباط والتضمين\nسنمثل باستعمال الوحدة المدمجة json ذات وظائف القراءة والكتابة لملفات مصاغة على شكل json. فإن كنت تتعامل مع صيغ أخرى انظر في الوثائق:\n\nالوحدة المدمجة xml لصيغة xml.\nأو مكتبة pyyaml لصيغة yaml.\n\n\nimport json\n\nلنفترض أن لدينا user_preferences محفوظًا في القاموس، ونريد حفظه في ملف json:\n\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\nلنكتبها في الملف نستعمال json.dump على النحو التالي:\n\nwith open('../../datasets/user_preferences.json', mode='w') as file:\n    json.dump(user_preferences, file)\n\nفإذا أردنا قراءتها استعمال json.load على النحو التالي:\n\nwith open('../../datasets/user_preferences.json') as file:\n    data = json.load(file)\nprint(data)\n\n{'theme': 'dark', 'language': 'Arabic', 'notifications': {'email': True, 'sms': False, 'push': True}, 'last_updated': '2021-09-01', 'emails': ['example1@domain.com', 'example2@domain.com']}",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#الصف",
    "href": "chapters/08_files_and_directories/a1_serialization.html#الصف",
    "title": "9  الملف",
    "section": "9.4 الصف",
    "text": "9.4 الصف\nتأتي البيانات الجدولية في صيغ متعددة، مثل: - CSV وهي صيغة يكون فيها الصف في سطر، وتكون عناصره مفصولة بعلامة الفاصلة \",\" - TSV وهي مثل CSV إلا أن الفاصلة علامة \"\\t\"\nوغيرها كثير.\nفي هذا القسم، سنركز على ملفات (Comma Separated Values) CSV؛ وتعني حرفيًّا: القيَم المفصولة بالفاصلة.\nتوجد في بايثون وحدة csv فيها إجراءات للقراءة والكتابة على طريقة csv. فلدينا:\n\nكائن reader لعمليات القراءة\nوكائن آخر منفصل اسمه writer يحوي عمليات الكتابة\n\n\nimport csv\n\nلنكتب قائمة من الطلاب إلى ملف CSV. لاحظ، لدينا قائمة من قوائم، حيث تمثل كل قائمة داخلية صفًا لوحدها:\n\nheader = ['Name', 'Age', 'Grade']\nrows = [\n    ['Adam', 22, 90],\n    ['Belal', 23, 92],\n    ['Camal', 24, 91],\n]\n\nنكتبها على النحو التالي:\n\nwith open('../../datasets/students.csv', mode='w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(header)\n    writer.writerows(rows)\n\nملاحظة، يمكنك محاولة فتح الملف مباشرة من مستكشف الملفات. حاول فتحه باستخدام Excel أو Google Sheet أو أي برنامج جداول بيانات آخر. إذا فتحته باستخدام محرر نصوص، سترى البيانات كملف CSV؛ حرفيًا قيم مفصولة بفواصل.\nالآن، دعنا نقرأه كهيكل بيانات في بايثون: كقائمة من القوائم.\n\nwith open('../../datasets/students.csv') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)\n\n['Name', 'Age', 'Grade']\n['Adam', '22', '90']\n['Belal', '23', '92']\n['Camal', '24', '91']\n\n\nلنحاول حساب متوسط درجات الطلاب.\n\nstudents = []\nwith open('../../datasets/students.csv') as file:\n    reader = csv.reader(file)\n    next(reader) # skip the header\n    for row in reader:\n        students.append(row)\n\nالآن بعد أن حفظناها في القائمة students، دعونا نقوم ببعض العمليات الحسابية.\n\ngrades = [s[2] for s in students]\navg = sum(grades) / len(grades)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 2\n      1 grades = [s[2] for s in students]\n----&gt; 2 avg = sum(grades) / len(grades)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nهذا الخطأ متوقع عند قراءة الملفات لأنها دائمًا تعتبر من نوع str، ولذلك نضطر لتحويل القيَم العددية إلى int لإجراء عمليات رياضية:\n\ngrades = [int(s[2]) for s in students]\navg = sum(grades) / len(grades)\navg\n\n91.0\n\n\nيمكنك أيضًا قراءة وكتابة البيانات في شكل قاموس باستخدام الكائنات DictReader وDictWriter.\n\nwith open('../../datasets/students.csv') as file:\n    reader = csv.DictReader(file)\n    for row in reader:\n        print(row)\n\n{'Name': 'Adam', 'Age': '22', 'Grade': '90'}\n{'Name': 'Belal', 'Age': '23', 'Grade': '92'}\n{'Name': 'Camal', 'Age': '24', 'Grade': '91'}\n\n\nوالطريقة الموصى بها للتعامل مع البيانات الجدولية (مثل ملفات CSV) هي استخدام مكتبة مثل pandas. توفر هذه المكتبة هيكل بيانات سريع ومرن لمعالجة البيانات وتحليلها. ولا بأس أن تطلع على دليل البداية في مكتبة pandas.\n\nإذا كنت تريد قراءة الملفات وكتابتها بشكل بسيط انظر: open().\nوإذا كنت تريد التعامل مع الملفات المؤقتة فانظر: tempfile.\nوكثير من عمليات التعامل مع الملفات والأدلة تجدها في: shutil.",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a2_directories.html",
    "href": "chapters/08_files_and_directories/a2_directories.html",
    "title": "10  الدليل",
    "section": "",
    "text": "الدليل\nأحيانًا نريد التعامل مع مجلَّد يحوي مجموعة ملفات، بنقلها أو نسخها أو حذفها ونحو ذلك.\nوجب علينا أولاً أن نُدرك أن ثمة نوعان من الملفات في النظام:\nوالملف المبتدأُ بالنقطة مثل: .git يكون مخفيًّا.\nوالطريق هو الموصل لملفٍّ ما أو دليلٍ ما نحو: datasets/example_root/a/a.txt. وسبق أن بينا أنه على نوعين: مُطلَق ونسبي. وسنعتمد على وحدة pathlib لنرى عمليات تركيب المسار والبحث فيه والاستعلام عن مدلوله ونحو ذلك. وسنبدأ بها.\nلاستعراض عمليات المكتبة، أنشأنا مُسبقًا شجرة تبدأ من دليل example_root تجده داخل datasets في مستودع مشروع الكتاب على النحو التالي:\nالشيء الأساسي الذي نتعامل معه هو المسار (Path):\nيُنشأ المسار من نص أو مجموعة نصوص بينها علامة / (وهي في الأصل علامة قسمة إذا وُضعت بين الأرقام) التي تعني ضم النص إلى المسار.\nلاحظ استعمال النص الخام r'' لكون الحرف \\ له معنىً خاص في نصوص بايثون، فهو يستعمل مثلا \\n للانتقال لسطر جديد. لكن حين نستعمل r'' فإن الحرف \\ لا يعني شيئًا خاصًا.\nملاحظة، عند نسخ المسارات في نظام ويندوز (Windows)، يجب عليك إما استبدال الشرطات المائلة العكسية \\ بالشرطات المائلة الأمامية / أو استخدام السلاسل النصية الخام r'' لتجنب المشاكل (كما فعلنا أعلاه).\nوهكذا نستطيع استعمال الكائن Path في إجراء open(file=path) للتعامل مع الملفات:\nولأن الملف يعتبر مدير سياق (Context Manager) فيستحسن الإتيان بجملة السياق with إذ تتكفل بإغلاق الملف تلقائيّا عند نهايتها. وذلك على النحو التالي:\nبدلاً من قراءة الملف جملة واحدة .read() نستطيع القراءة سطرًا بسطر عن طريق الإجراء .readline() على النحو التالي:\nتستعمل .rstrip() لإزالة حرف انتقال السطر \\n .\nانظر قراءة الأدلة.\nلعرض قائمة الدليل، نستعمل المكرر الناتج من إجراء .iterdir() ونكرر عليه، وهو بدورِه يُنتج في كل كرةٍ مساراً (x). وهذا المسار يُمكن التحقق من أنه يشير إلى دليل أو لا (x.is_dir()) على النحو التالي:\np = Path('../../datasets/example_root/')\ndirs = [x for x in p.iterdir() if x.is_dir()]\ndirs\n\n[PosixPath('../../datasets/example_root/a'),\n PosixPath('../../datasets/example_root/b'),\n PosixPath('../../datasets/example_root/c')]",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a2_directories.html#تصنيف-عمليات-pathlib-في-بايثون",
    "href": "chapters/08_files_and_directories/a2_directories.html#تصنيف-عمليات-pathlib-في-بايثون",
    "title": "10  الدليل",
    "section": "10.1 تصنيف عمليات pathlib في بايثون",
    "text": "10.1 تصنيف عمليات pathlib في بايثون\nوإليك تصنيف لعمليات مكتبة pathlib:\n\nعمليات المسار\n\nإنشاء وتعديل المسارات:\n\n.joinpath: دمج مكونات مسار.\n.parent: استخراج الدليل الأب.\n.name: استخراج الاسم الأساسي للملف.\n.stem: استخراج اسم الملف بدون الامتداد.\n.suffix: استخراج امتداد الملف.\n.with_name: إنشاء مسار جديد باسم مختلف.\n.with_suffix: إنشاء مسار جديد بامتداد مختلف.\nrelative_to: إنشاء مسار نسبي.\n\n\n\n\nعمليات على نظام الملفات\n\nاستعلام:\n\nis_absolute: هل هو مطلق؟.\nsamefile: هل مساران يشيران إلى نفس الملف؟.\nexists: هل هو مسار موجود؟.\nis_file: هل هو مسار ملف؟.\nis_dir: هل هو مسار دليل؟.\nis_symlink: هل هو ارتباط رمزي؟.\nstat: سرد إحصائيات نظام الملفات.\nlstat: سرد إحصائيات نظام الملفات دون متابعة الارتباطات الرمزية.\n\nعمليات تغيير:\n\nopen: فتح ملف للقراءة أو الكتابة أو الإضافة.\nmkdir: إنشاء دليل.\nrmdir: حذف دليل فارغ.\nunlink: حذف ملف.\nrename: تعديل اسم ملف.\nreplace: تعديل اسم ملف مع الكتابة فوقه إذا لزم الأمر.\nchmod: تغيير أذونات الملف.\nlchmod: تغيير أذونات الملف دون متابعة الارتباطات الرمزية.\ntouch: تحديث الطابع الزمني للملف.\n\n\n\n\nالارتباطات الرمزية والصلبة\n\nsymlink_to: إنشاء ارتباط رمزي.\nhardlink_to: إنشاء ارتباط صلب.\nreadlink: قراءة الهدف من ارتباط رمزي.\n\n\n\nالتكرار والبحث\n\niterdir: تكرار على قائمة الدليل.\nglob: البحث عن الملفات المطابقة لنمط.\nrglob: البحث بشكل متكرر عن الملفات المطابقة لنمط.\nwalk: التنقل بشكل متكرر في شجرة الأدلة.",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a2_directories.html#النسخ-والحذف-والنقل-shutil",
    "href": "chapters/08_files_and_directories/a2_directories.html#النسخ-والحذف-والنقل-shutil",
    "title": "10  الدليل",
    "section": "10.2 النسخ والحذف والنقل (shutil)",
    "text": "10.2 النسخ والحذف والنقل (shutil)\n\nshutil.copy2: نسخ ملف.\nshutil.copytree: نسخ شجرة أدلة.\nshutil.rmtree: حذف شجرة أدلة.\nshutil.move: نقل ملف أو دليل.",
    "crumbs": [
      "باب الملفات",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/b_context.html",
    "href": "chapters/08_files_and_directories/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "تصنيف التغريدات\nلدينا ثلاثة ملفات:\nنريد تصنيف التغريدات بناءً على عدد الكلمات الإيجابية والسلبية فيها.\nfrom pathlib import Path\n\ndata_dir = Path('../../datasets/tweets')\nبعد النظر في شكل الملفات. يتبين لنا أن السطر الواحد يحتوي على “شيء” واحد. وبالتالي سنقسم البيانات على كل سطر.\nونلاحظ أيضًا وجود أسطر خاوية، يجب التخلص منها.\ndef read_lines(file_path: Path) -&gt; list[str]:\n    \"\"\"skips empty lines and converts to lowercase\"\"\"\n    result = []\n    with open(file_path, 'r') as file:\n        for line in file:\n            x = line.strip()\n            if len(x) &gt; 0:\n                x = x.lower()\n                result.append(x)\n    return result\nنستدعي الدالة لقراءة الملفات الثلاث:\ntweets = read_lines(data_dir / 'tweets.txt')\npositive_words = read_lines(data_dir / 'words_positive.txt')\nnegative_words = read_lines(data_dir / 'words_negative.txt')\nfor i, tweet in enumerate(tweets):\n    print(i, tweet)\n\n0 grateful for the amazing people in my life who make it so wonderful\n1 the beautiful flowers were in full bloom and the sweet scent filled the air. the birds were singing merrily and the sun was shining brightly. it was a perfect day\n2 the kind and generous old man was always willing to help others. he was a role model for the entire community and he was loved by everyone\n3 the intelligent and talented young woman had a bright future ahead of her. she was passionate about her work and she was determined to make a difference in the world\n4 sending out good vibes to everyone today! have a beautiful day!\n5 i've been feeling so anxious and stressed lately with everything going on. really need a break from it all.\n6 traffic was the worst it's ever been today. the long commute just made me feel grumpy and drained.\n7 had an awful morning - overslept and missed my first meeting. feeling uneasy about how my boss will react.\n8 all the noise from the construction outside is driving me nuts. it's making working from home dreadful.\n9 went out with some friends last night but didn't have as much fun as i thought. felt a bit lonely and left early feeling uneasy.\nfor p in positive_words:\n    print(p)\n\ngrateful\namazing\nwonderful\nbeautiful\nsweet\nperfect\nkind\ngenerous\nhelp\nloved\nintelligent\ntalented\nyoung\nbright\npassionate\ndetermined\ngood\nbeautiful\nfriends\nfun\nhappy\nfor n in negative_words:\n    print(n)\n\nanxious\nstressed\nworst\ngrumpy\ndrained\nawful\noverslept\nmissed\nuneasy\nboss\nnoise\ndreadful\nlonely\nsad\nالآن نقوم بتصنيف التغريدات:\ndef classify(text: str) -&gt; (int, int):\n    \"\"\"Returns the number of positive and negative words in the text\"\"\"\n    \n    positive_count = 0\n    for word in positive_words:\n        if word in text:\n            positive_count += 1\n    \n    negative_count = 0\n    for word in negative_words:\n        if word in text:\n            negative_count += 1\n    \n    return positive_count, negative_count\n\nassert classify('i am happy') == (1, 0)\nassert classify('i am sad') == (0, 1)\nassert classify('i am happy and sad') == (1, 1)\nassert classify('i shall walk to the store') == (0, 0)\nنستدعي الدالة على التغريدات، ونفرز النتائج في ثلاثة قوائم:\npositive_tweets = []\nnegative_tweets = []\nneutral_tweets = []\nfor tweet in tweets:\n    pos, neg = classify(tweet)\n    score = pos - neg\n    print(f'-{neg} +{pos} = {score:+}')\n    if score &gt; 0:\n        positive_tweets.append((tweet, score))\n    elif score &lt; 0:\n        negative_tweets.append((tweet, score))\n    else:\n        neutral_tweets.append((tweet, score))\n\n-0 +3 = +3\n-0 +5 = +5\n-0 +4 = +4\n-0 +6 = +6\n-0 +3 = +3\n-2 +0 = -2\n-3 +0 = -3\n-5 +0 = -5\n-2 +0 = -2\n-2 +2 = +0\nنعرض التغريدات بحسب التصنيف مرتبة بقوة التصنيف من الأعلى إلى الأسفل:\nprint('positive_tweets:')\nfor tweet, score in sorted(positive_tweets, key=lambda x: x[1], reverse=True):\n    print(f'{score:+} {tweet}')\n\npositive_tweets:\n+6 the intelligent and talented young woman had a bright future ahead of her. she was passionate about her work and she was determined to make a difference in the world\n+5 the beautiful flowers were in full bloom and the sweet scent filled the air. the birds were singing merrily and the sun was shining brightly. it was a perfect day\n+4 the kind and generous old man was always willing to help others. he was a role model for the entire community and he was loved by everyone\n+3 grateful for the amazing people in my life who make it so wonderful\n+3 sending out good vibes to everyone today! have a beautiful day!\nprint('negative_tweets:')\nfor tweet, score in sorted(negative_tweets, key=lambda x: x[1]):\n    print(f'{score:+} {tweet}')\n\nnegative_tweets:\n-5 had an awful morning - overslept and missed my first meeting. feeling uneasy about how my boss will react.\n-3 traffic was the worst it's ever been today. the long commute just made me feel grumpy and drained.\n-2 i've been feeling so anxious and stressed lately with everything going on. really need a break from it all.\n-2 all the noise from the construction outside is driving me nuts. it's making working from home dreadful.\nprint('neutral_tweets:')\nfor tweet, score in neutral_tweets:\n    print(f'{score} {tweet}')\n\nneutral_tweets:\n0 went out with some friends last night but didn't have as much fun as i thought. felt a bit lonely and left early feeling uneasy.",
    "crumbs": [
      "باب الملفات",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/b_context.html#تصنيف-التغريدات",
    "href": "chapters/08_files_and_directories/b_context.html#تصنيف-التغريدات",
    "title": "تطبيقات",
    "section": "",
    "text": "الأول يحوي تغريدات\nالثاني يحوي كلمات إيجابية\nالثالث يحوي كلمات سلبية",
    "crumbs": [
      "باب الملفات",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html",
    "href": "chapters/09_oop/a1_classes.html",
    "title": "11  الأصناف",
    "section": "",
    "text": "11.1 تعريف الصنف\nتتخذ بايثون نموذجًا في البرمجة يسمى البرمجة الشيئية؛ فالمتغيرات تحمل أشياء: فالرقم شيء، والنص شيء، والقائمة شيء، والمصفوفة شيء، وهلم جرا.\nوالشيء يختصُّ بما أُسنِدَ إليه:\nيُعرَّف الإجراء بالكلمة class ويُبتدأُ غالبًا بتعريف إجراء الإنشاء __init__ ليتم تعيين الصفات فيه بالإسناد للاسم self الذي يشير إلى الشيء المعين الذي يتم إنشاؤه الآن.\nأما تعريف الأفعال فكالإجراءات مثل def move بزيادة self في الابتداء.\nتأمل المثال:\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\nوالآن نستطيع إنشاء معيَّنات من هذا الصنف ونمرر القيم x, y بحسب ما هو موجود في الإجراء المخصص للإنشاء: __init__ على النحو التالي:\np1 = Point(3, 4)\np2 = Point(7, 1)\nنستعمل حرف النقطة . بعد اسم المعيَّن للإشارة لصفةٍ أو فعل، نحو: p1.x:\nx_diff = abs(p1.x - p2.x)\ny_diff = abs(p1.y - p2.y)\nprint(f'X difference is {x_diff} and Y difference is {y_diff}.')\n\nX difference is 4 and Y difference is 3.\nوهذا مثال لاستدعاء الفعل: p1.move()\np1.move(4, 4)\nprint(p1.x, p1.y)\n\n7 8\nلو أردنا طباعة النقطة، كيف تظهر؟\nprint(p1)\n\n&lt;__main__.Point object at 0x71b7d15a92b0&gt;\nلتخصيص طريقة عرض الشيء، بحيث لو طبعناه أو ذكرناه في آخر السطر يظهر البشكل الذي نريده، يمكن تغيير الإجراء المخصص __repr__ أي: التمثيل .. هكذا:\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\nوالآن إن عرفنا نقطة جديدة، ووضعناها على السطر لوحدها ، ستظهر لنا الإحداثيات، لا عنوانها الذاكري:\np = Point(3, 4)\np.move(7, 6)\np\n\nPoint(10, 10)\nالإجراء الثابت هو ما يُسنَدُ للصنف نفسه لا للأعيان. ويتم تثبيت الإجراء بعلامة المزيِّن @staticmethod. لاحظ عدم وجود self في الإجراء الجديد distance لأنه ثابت:\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n                \n    @staticmethod\n    def distance(p1, p2):\n        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\nويتم استدعاؤه بذكر اسم الصنف والنقطة .:\na = Point(0, 1)\nb = Point(1, 0)\n\nPoint.distance(a, b)\n\n1.4142135623730951\nكذلك يُجعل المتغير من النوع الثابت بتعيينه بمحاذاة غيره من الإجراءات نحو ما فعلنا هنا بالمتغير distance_type. ولاحظ استعماله في الإجراء distance في جملة if-else من غير استعمال self لأننا لا نشير إلى معيَّن:\nclass Point:\n    distance_type = 'euclidean'\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2):\n        if Point.distance_type == 'euclidean':\n            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n        elif Point.distance_type == 'manhattan':\n            return abs(p1.x - p2.x) + abs(p1.y - p2.y)",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الأصناف</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#التغليف-encapsulation",
    "href": "chapters/09_oop/a1_classes.html#التغليف-encapsulation",
    "title": "11  الأصناف",
    "section": "11.2 التغليف (Encapsulation)",
    "text": "11.2 التغليف (Encapsulation)\nفكرة التغليف في البرمجة الشيئية هي إبعاد التفاصيل عن المستفيد.\nفي المثال التالي لا نريد للمستفيد أن يعدِّل على الرصيد balance إلا عن طريق الفعل deposit الذي يضمن أن الزيادة تكون موجبة.\nولاحظ أن استعمال __balance عرفٌ بين المبرمجين في بايثون لنقول أن الصفة مخفيَّة عن المستفيد، وأنه يجب أن لا يغيرها مباشرةً.\nأما المزيِّن @property في الإجراء balance فإنه يرجع بقيمة الصفة لا بالصفة نفسها. وذلك ليمنع التعديل عليها.\n\nclass Account:\n    def __init__(self, name, balance):\n        self.name = name\n        self.__balance = balance\n\n    def deposit(self, amount):\n        if amount &lt;= 0:\n            raise ValueError(\"must be positive\")\n        self.__balance += amount\n        print('time of deposit:', '2027-07-07')\n\n    @property\n    def balance(self):\n        return self.__balance\n\n\na1 = Account('Adam', 100)\na1.balance\n\n100\n\n\n\na1.deposit(100)\na1.balance\n\ntime of deposit: 2027-07-07\n\n\n200\n\n\nولو حاولت التغيير مباشرة فلن تستطيع (من غير الشرطتين السفليتين):\n\na1.balance = 1000\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[104], line 1\n----&gt; 1 a1.balance = 1000\n\nAttributeError: property 'balance' of 'Account' object has no setter",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الأصناف</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#الوراثة-inheritance",
    "href": "chapters/09_oop/a1_classes.html#الوراثة-inheritance",
    "title": "11  الأصناف",
    "section": "11.3 الوراثة (Inheritance)",
    "text": "11.3 الوراثة (Inheritance)\nوالوراثة: أن يستمد الشيء صفات وإجراءات شيءٍ آخر مباشرةً. كأن تقول: إن المربع والمثلث شكلٌ.\nوسنوضح ذلك بأمثلة مصطنعة.\nالمثال الأول: المربع مستطيل:\n\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n    \n    def area(self):\n        return self.width * self.height\n    \nclass Square(Rectangle):\n    def __init__(self, side):\n        super().__init__(side, side)\n\nوتشير كلمة super() في الوارث إلى الصنف المورث. فدالة الإنشاء في الأصل تستدعي دالة الإنشاء في الأصل.\nالمثال الثاني:\n\nالأشكال لها محيط\nالمثلث شكل\nالمستطيل شكل وله مساحة أيضًا\n\n\nclass Shape:\n    def __init__(self, sides):\n        self.sides = sides\n\n    def perimeter(self):\n        result = 0\n        for s in self.sides:\n            result += s\n        return result\n\nclass Triangle(Shape):\n    def __init__(self, s1, s2, s3):\n        super().__init__([s1, s2, s3])\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        super().__init__([width, height, width, height])\n\n    def area(self):\n        return self.sides[0] * self.sides[1]\n\nفهو يستمد منه ويزيد عليه.\n\ntri1 = Triangle(10, 10, 10)\nprint(\"Triangle:\")\nprint(\"Perimeter:\", tri1.perimeter())\n\nTriangle:\nPerimeter: 30\n\n\n\nrect1 = Rectangle(10, 20)\nprint(\"Rectangle:\")\nprint(\"Perimeter:\", rect1.perimeter())\nprint(\"Area:\", rect1.area())\n\nRectangle:\nPerimeter: 60\nArea: 200\n\n\nفائدة: يفضل كثير من الممارسين الانتماء على الوراثة في أغلب الأحيان. فهي أكثر قبولاً للنمو، بينما الوراثة جامدة وغير مرنة عند التغيير. وكثيرٌ مما ينظَّرُ له في الوراثة يمكن تحقيقه بجملة if-elif-else أو جملة match-case وتنتهي القصة.",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الأصناف</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#التركيب-composition",
    "href": "chapters/09_oop/a1_classes.html#التركيب-composition",
    "title": "11  الأصناف",
    "section": "11.4 التركيب (Composition)",
    "text": "11.4 التركيب (Composition)\nوالتركيب: أن يدخُلَ الشيءُ تحت صنفٍ ما لا لأنَّه أنشئَ منه ولكن لمطابقته خصائصه.\nويكثر فيه المجرَّداتُ ذات الفعل الواحد أو الفعلين. لأننا نريد أشياء كثيرة تنتمي بحسب ما يكون فيها من أفعال.\nفمثلاً: أيُّ شيءٍ يعرِّفُ الإجراء len(sized)__ -&gt; int__ فإنه ينتمي لصنف ذوات الحجم (Sized).\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __len__(self):\n        return 2\n\nv1 = Vector(10, 20)\nlen(v1)\n\n2\n\n\nفالمتجه صار ذا حجمٍ باعتبار وجود الإجراء المخصص __len__. ووجوده يجعل الإجراء len يقبله كعامل له.\nأو أكثر بحسب الاعتبار. فنقول إن المتسلسلة (Sequence) نوع من المجموعة (Collection) باعتبارات ثلاث (انظر: خريطة المجموعات شكل 1):\n\nكونها تقبل العضويَّة: x in s وفعلها هو: __contains__\nكونها تقبل التكرار: for x in s وفعلها هو: __iter__\nكونها تقبل العد: len(s) وفعلها هو: __len__\n\nومن وجهٍ آخر فهي (أعني المتسلسلة) من صنف القابل للعكس (Reversible) لكونها تقبل الإجراء reversed الذي فعله: __reversed__.",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الأصناف</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#المعاملات-operators",
    "href": "chapters/09_oop/a1_classes.html#المعاملات-operators",
    "title": "11  الأصناف",
    "section": "11.5 المعاملات (Operators)",
    "text": "11.5 المعاملات (Operators)\nتأمل التالي وتوقَّع النتيجة وعلل إجابتك. ما هي نتيجة:\nالأول:\n[1, 2, 3] + [4, 5, 6]\nالثاني:\n[1, 2, 3] * [4, 5, 6]\nالثالث:\n[1, 2, 3] * 5\nالرابع:\n[1, 2, 3] - 3\nكل الذي سبق، قد تم تعريفه في بايثون لهذه الأصناف التي تراها بالتحديد عن طريق إجراءات مخصصة. وإليك هذا الجدول للمعاملات المخصصة:\n\n\n\nالمعامل\nالإجراء\n\n\n\n\nself + other\n__add__\n\n\nself - other\n__sub__\n\n\nself * other\n__mul__\n\n\nself / other\n__truediv__\n\n\nself // other\n__floordiv__\n\n\nself % other\n__mod__\n\n\nself ** other\n__pow__\n\n\n\n(وانظر توثيق بايثون لمحاكاة العمليات الرقمية).\nفنستطيع تعريف نوع متجَّه على النحو التالي.\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, other):\n        return Vector(self.x * other.x, self.y * other.y)\n\nوالآن يمكننا إنشاء متجهين وإجراء العمليات المخصصة:\n\nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\n\nv1 + v2\n\nVector(4, 6)\n\n\n\nv1 - v2\n\nVector(-2, -2)\n\n\n\nv1 * v2\n\nVector(3, 8)\n\n\nماذا لو أردنا إضافة عمليات بين المتجه والعدد، نحو: v1 + 3? يتطلب ذلك إضافة شرط لفحص النوع:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x + other.x, self.y + other.y)\n        else:\n            return Vector(self.x + other, self.y + other)\n    \n    def __sub__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x - other.x, self.y - other.y)\n        else:\n            return Vector(self.x - other, self.y - other)\n    \n    def __mul__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x * other.x, self.y * other.y)\n        else:\n            return Vector(self.x * other, self.y * other)\n\nوالآن يمكننا إجراء العمليات المخصصة:\n\nv1 = Vector(1, 2)\nv1 + 3\n\nVector(4, 5)\n\n\nلكن لاحظ أنك لو وضعت العدد أولاً فسيظهر خطأ:\n\n3 + v1\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[116], line 1\n----&gt; 1 3 + v1\n\nTypeError: unsupported operand type(s) for +: 'int' and 'Vector'\n\n\n\nهذا لأن عملية الجمع الآن لا تنظر في نوع العدد (int) ولا تجد فيه قبولاً للمتجه (فقد عرفناه للتو). ولحل هذه المشكلة توفر بايثون لكل إجراء مخصص مقابل يبدأ بحرف r على النحو التالي:\n\n\n\nالمعامل\nالإجراء\n\n\n\n\nother + self\n__radd__\n\n\nother - self\n__rsub__\n\n\nother * self\n__rmul__\n\n\n\nنعدل الإجراء بحيث نضيف إليه المقابل:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x + other.x, self.y + other.y)\n        else:\n            return Vector(self.x + other, self.y + other)\n\n    def __radd__(self, other):\n        return self + other\n\nوالآن كلاهما يعمل بشكل صحيح:\n\nv1 = Vector(1, 2)\n3 + v1\n\nVector(4, 5)\n\n\n\nv1 + 3\n\nVector(4, 5)",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الأصناف</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html",
    "href": "chapters/09_oop/a2_classes.html",
    "title": "12  التجريد",
    "section": "",
    "text": "12.1 التعميم\nومن الخصائص الممتعة في بناء البرمجيات: العلاقات بين المجردات في المستويات المختلفة من التجريد. وسنمثل لذلك بـ:\nنريد أن نعمم صنف المتجه بحيث لا يتقيد بعنصرين x,y بل يقبل أن يكون أكثر من ذلك:\nclass Vector:\n    def __init__(self, *args):\n        self.elements = args\n    \n    def __repr__(self):\n        str_elements = [str(e) for e in self.elements]\n        return f\"Vector({', '.join(str_elements)})\"\n    \n    def __add__(self, other):\n        result = []\n        if isinstance(other, Vector):\n            if len(self.elements) != len(other.elements):\n                raise ValueError(\"Vectors must have the same length\")\n            for a, b in zip(self.elements, other.elements):\n                result.append(a + b)\n        else:\n            for a in self.elements:\n                result.append(a + other)        \n        return Vector(*result)\n    \n    def __radd__(self, other):\n        return self + other\nأما السطر الأخير: return Vector(*result) فعلامة النجمة تفك القائمة بحيث تمرر عناصرها كمعيَّنات منفصلة لإجراء الإنشاء.\nv1 = Vector(10, 20, 30)\nv2 = Vector(60, 50, 40)\n\nv1 + v2\n\nVector(70, 70, 70)\nv1 + 10\n\nVector(20, 30, 40)\n10 + v1\n\nVector(20, 30, 40)",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html#التركيب",
    "href": "chapters/09_oop/a2_classes.html#التركيب",
    "title": "12  التجريد",
    "section": "12.2 التركيب",
    "text": "12.2 التركيب\nلو كان عندنا تعريف صنف نقطة ..\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2):\n        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n\nيمكننا تركيب شيء مكون من النقاط، وهو المضلَّع، على النحو التالي:\n\nيأخذ إجراء الإنشاء __init__ سلسلة من النقاط ويعيِّنُها لمتغير اسمه points\nيعرض إجراء التمثيل __repr__ كلمة Polygon وداخل أقواسها يضع تمثيل النقاط\nلاحظ أن إجراء perimeter يُنتج قُطر المضلَّع؛ وهو مجموع المسافات بين النقاط المتوالية\n\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def __repr__(self):\n        return f\"Polygon({self.points})\"\n\n    def perimeter(self):\n        n = len(self.points)\n        s = 0\n        for i in range(n):\n            s += Point.distance(self.points[i], self.points[(i+1)%n])\n        return s\n\nلاحظ أن إنشاء المضلَّع يتطلَّب إنشاء نقاط. ولاحظ أننا جعلنا كل نقطة في سطر، لكنها في الحقيقة كلها عناصر لقائمة، وهو واضحٌ بملاحظة القوسين المربعين [ ]:\n\npoly = Polygon([\n    Point(0, 0),\n    Point(5, 0),\n    Point(5, 5),\n    Point(0, 5),\n])\npoly\n\nPolygon([Point(0, 0), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nوالآن يمكن استعمال إجراء حساب المحيط:\n\npoly.perimeter()\n\n20.0\n\n\nولأن هذا المركَّب مكوَّن من أفراد، فنريده أن يُشابه الأنواع الحاوية، التي لها أفعال معيَّنة. وذلك ممكنٌ باستعمال الأفعال المخصصة:\n\nالعد: len(s) يُسمَّى فعله: __len__\nالإشارة: s[i] يُسمَّى فعله: __getitem__\nالتعيين: s[i] = p يُسمَّى فعله: __setitem__\nالحذف: del s[i] يُسمَّى فعله: __delitem__\n\nانظر التوثيق الرسمي لبايثون حول محاكاة أنواع الحاويات لمزيد من المعلومات.\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def __repr__(self):\n        return f\"Polygon({self.points})\"\n\n    def __len__(self):\n        return len(self.points)\n    \n    def __getitem__(self, i):\n        return self.points[i]\n\n    def __setitem__(self, i, p):\n        self.points[i] = p\n\n    def __delitem__(self, i):\n        del self.points[i]\n    \n    def perimeter(self):\n        n = len(self.points)\n        s = 0\n        for i in range(n):\n            s += Point.distance(self.points[i], self.points[(i+1)%n])\n        return s\n\n\npoly = Polygon([\n    Point(0, 0),\n    Point(5, 0),\n    Point(5, 5),\n    Point(0, 5),\n])\npoly\n\nPolygon([Point(0, 0), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nوالآن نستطيع عدَّ النقاط بالإجراء المعروف len الذي بدوْره يستدعي الإجراء المتعلق بالشيء __len__ (فُهما سواء):\n\nassert len(poly) == poly.__len__()\nlen(poly)\n\n4\n\n\nبتعريفنا لإجراء معرفة الطول، انسجم هذا الصنف مع المجموعات مثل القائمة ومجموعة الفرائد والروابط والسلسلة النصية وغيرها.\nوقد تتساءل: هل أي كلمة أكتبها بين الشرطتين السفليتين استطيع استعماله مثل len؟ والجواب: للأسف لا؛ وإنما هي أسماء مخصوصة.\nأما قبول الإجراء len لأصناف مغايرة عن بعضها فهي خاصيَّة تعدد الأشكال (Polymorphism): أي أن الإجراء الواحد يقبل أصناف متعددة في الحقيقة لكنَّها في تُظهر نفس السلوك الخارجي. بعبارة أخرى نقول:\n\nالظاهر: المدخلات والمخرجات واحدة\nالحقيقة: الخوارزمية قد تختلف اختلافًا جذريًّا !\n\nوهذا كثيرٌ في البرمجيات.\nثم الإشارة برقم أو بشريحة:\n\nprint(poly[0])\nprint(poly[-1])\nprint(poly[1:3])\nprint(poly[::-1])\n\nPoint(0, 0)\nPoint(0, 5)\n[Point(5, 0), Point(5, 5)]\n[Point(0, 5), Point(5, 5), Point(5, 0), Point(0, 0)]\n\n\nثم التعيين:\n\npoly[0] = Point(10, 10)\npoly\n\nPolygon([Point(10, 10), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nوأخيرًا الحذف:\n\ndel poly[0]\npoly\n\nPolygon([Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nتبين بهذا محاكاة بعض إجراءات الحاويات الأساسية مثل list وset وtuple وstr وdict. وقد تقدَّم معنا أن النقطة تستطيع محاكاة الأنواع العددية باستعمال الفعل المخصص للجمع + الذي هو __add__.",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html#التخصيص",
    "href": "chapters/09_oop/a2_classes.html#التخصيص",
    "title": "12  التجريد",
    "section": "12.3 التخصيص",
    "text": "12.3 التخصيص\nيكثر استعمال الطابور كهيكل بيانات لحل مجموعة من المسائل بطريقة سهلة. نستعرض في هذا المثال كيفية تخصيص القائمة (list) ذات الإجراءات الكثيرة من الحذف والإضافة والتعديل، لصنف له إجراءات مختلفة لكنها مبنية عليها.\nالطابور يُعرَّف بأمرين أساسيين:\n\nالإدخال من جهة\nالإخراج من الجهة المقابلة (بحيث يكون ما دخل أولاً هو الذي يخرج أولاً)\n\nفهو بهذا أخص من القائمة التي تزيد عليه: الإشارة لعنصر برقمٍ وإمكان تعديله أو حذفه أو الإضافة في الوسط، وغيرها.\n\n\n\nتوضيح الطابور\n\n\nفهذا مثال لكتابة صنف الطابور:\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the end of the queue\"\"\"\n        self.items.append(item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the front of the queue\"\"\"\n        if not self.is_empty():\n            return self.items.pop(0)\n        return None\n\n    def peek(self):\n        \"\"\"Return the item at the front without removing it\"\"\"\n        if not self.is_empty():\n            return self.items[0]\n        return None\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return len(self.items) == 0\n    \n    def __len__(self):\n        return len(self.items)\n\n    def __repr__(self):\n        \"\"\"Return the underlying list representation\"\"\"\n        return repr(self.items)\n\n\nلاحظ أن إجراء الإنشاء __init__ يعيِّن قائمة فارغة للشيء self\nثم الإجراء enqueue يتم بواسطة إجراء القائمة append\nوالإجراء dequeue يتم بواسطة إجراء القائمة pop\nوكذلك peek باستعمال الإشارة بالرقم للعنصر في الموضع 0\nثم is_empty بالنظر لطول القائمة بالإجراء len\n\nنختبر ذلك الآن:\n\nq = Queue()\n\nq.enqueue(1)\nq.enqueue(2)\nq.enqueue(3)\n\nprint(q)\n\n[1, 2, 3]\n\n\nنزيل عُنصرًا:\n\nq.dequeue()\nprint(q)\n\n[2, 3]\n\n\nهل يمكننا معرفة عدد العناصر؟:\n\nlen(q)\n\n2\n\n\nصحيح أن القائمة أكثر قدرة (إذْ تتضمن عمليات أكثر)، إلا أن الطابور مخصص لخدمة وظيفة محددة. وليس يهمنا ما ينطوي خلفه (قائمة أم صف أم غير ذلك)؛ بل يهمنا إجراءاته الظاهرة لنا. أما طريقة عمله فقد تجرَّدنا عنها.",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html#التسلسل",
    "href": "chapters/09_oop/a2_classes.html#التسلسل",
    "title": "12  التجريد",
    "section": "12.4 التسلسل",
    "text": "12.4 التسلسل\nومن الأنواع ما يتسليل مثل الشجرة، حيث فروعها قد تكون أصولاً لفروع أخرى. وهكذا يتسلسل الأمر حتى نصل إلى الأوراق / الثمار (القيم الأخيرة).\nومثل هذا له استعمالات كثيرة في هيكلة البيانات بأمثل بنية تكون فيها أسرع في البحث والإدراج والحذف ونحو ذلك. لكننا نكتفي بمثال نعرف فيه الشجرة الثنائية:\n\nclass BinaryTreeNode:\n    def __init__(self,\n        value,\n        left: 'BinaryTreeNode' = None,\n        right: 'BinaryTreeNode' = None):\n        self.value = value\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        if self.left is None and self.right is None:\n            return f\"{self.value}\"\n        return f\"({self.left}) &lt;-- [{self.value}] --&gt; ({self.right})\"\n\n\ntree = BinaryTreeNode(10)\ntree.left = BinaryTreeNode(5)\ntree.right = BinaryTreeNode(15)\n\ntree\n\n(5) &lt;-- [10] --&gt; (15)\n\n\n\ntree.left.left = BinaryTreeNode(3)\ntree.left.right = BinaryTreeNode(7)\ntree.right.left = BinaryTreeNode(13)\ntree.right.right = BinaryTreeNode(17)\n\ntree\n\n((3) &lt;-- [5] --&gt; (7)) &lt;-- [10] --&gt; ((13) &lt;-- [15] --&gt; (17))",
    "crumbs": [
      "باب الأصناف",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html",
    "href": "chapters/10_time/a_time.html",
    "title": "13  الوقت",
    "section": "",
    "text": "13.1 مقدمة",
    "crumbs": [
      "باب الوقت",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#مقدمة",
    "href": "chapters/10_time/a_time.html#مقدمة",
    "title": "13  الوقت",
    "section": "",
    "text": "الساعات والأيام\nتذكر بعض المصادر أن الأولين كانوا يقسمون الوقت على 12 ساعة ليلية (تبدأ بعد غروب الشمس) تتلوها 12 ساعة نهارية (تبدأ بعد شروق الشمس). وهي ساعات متغيرة؛ ففي الصيف تزيد طول ساعة النهار (فوق 60 دقيقة معتدلة) بينما تقصر ساعة الليل (دون 60 دقيقة معتدلة)، ويحصل العكس في الشتاء (فيكون الليل أطول والنهار أقصر). أما عند اعتدال الشمس في أشهر معيَّنة في خط الاستواء فإن ساعات الليل والنهار 60 دقيقة (وهو مقياس الاعتدال). والمرجع في ذلك الساعة الشمسية (المزوَّلة). ولحساب الفترة الزمنية كانوا يستعملون ما يُحرَق كالشمع، أو ثقب في وعاء مدرَّج من ماء أو رمل.\nانظر كتاب فقه اللغة للثعالبي:\n\nالفصل السابع عشر “في تَعْدِيدِ سَاعَاتِ النَّهارِ واللَّيل على أربع وعشرين لفظة”.\nعن حمزة بن الحسن وعليه عهدتها:\nسَاعَاتُ النَّهارِ: الشُرُوقُ. ثُمَّ البكورُ. ثُمَّ الغُدْوَةُ. ثُمَّ الضُّحَى. ثُمَّ الهاجِرَةُ. ثُمَّ الظَهِيرَةُ. ثُمَّ الرَّوَاحُ. ثُمَّ العَصْرُ. ثُمَّ القَصْرُ. ثُمَّ الأصِيلُ. ثُمَّ العَشِيُّ. ثُمَّ الغُروبُ. سَاعَاتُ اللَّيلِ: الشَّفَقُ. ثُمَّ الغَسَقُ. ثُمَّ العَتَمَةُ. ثُمَّ السُّدْفَة. ثُمَّ الفَحْمَةُ. ثُمَّ الزُّلَّةُ. ثُمَّ الزُّلْفةُ. ثُمَّ البُهْرَةُ. ثُمَّ السَّحَرُ. ثُمَّ الفَجْرُ. ثُمَّ الصُّبْحُ. ثُمَّ الصَّباحُ\n\nثم جاءت الساعات الميكانيكية الثابتة التي تعمل وكأن جميع الساعات 60 دقيقة (وكأنها على خط الاستواء وفي وقت اعتدال الشمس عليه)؛ ولا تعتبر شتاءً ولا صيْفًا، ولا نهارًا ولا ليلاً .. لكنها أصبحت هي المتداولة. وقد مرَّ ضبط الساعة (حتى لا تحيد) بمستويات متطورة من الدقة، فبدأت من الساعة المتأرجحة (1657) إلى الكرونومتر (1762) إلى مذبذب الكوارتز (1927) إلى الساعة الذرية (1949) إلى ساعة شعاع السيزيوم (1955) إلى ساعة نافورة السيزيوم (1993) إلى الساعة الضوئية (Optical Clock: 2006) والتي تحيد بمقدار ثانية بعد كل 30 مليار سنة.\n\n\nالتوقيت العالمي والمناطق الزمنية\nظهر نظام التوقيت العالمي المنسق (UTC: Coordinated Universal Time) حوالي سنة 1967، لتسهيل التعامل بين الدول والتواصل عبر القارات. فهو نظام للوقت يعتمد على خطوط الطول الأرضية، تقسَّم فيه الجغرافيا لمناطق زمنية بحسب بعدها عن خط طول جرينيتش الذي كان هو نقطة الصفر (UTC+00:00) أي: المرجِع: فما يكون شرقيها يكون الفارق فيه بالموجب، وما يكون غربيَّها يكون الفارق فيه بالسالب.\nوكل منطقة زمنية لها توقيت محلي تعتمده في معاملاتها اليومية فيما يتعلق بالوقت من تواصل وتنسيق ومواعيد ونحو ذلك. في الخريطة أدناه نرى تقسيم المناطق الزمنية:\n\n\n\nخريطة تظهر تقسيم المناطق الزمنية\n\n\nلاحظ أولاً أن الخطوط ليست طوليَّة بالفعل، انظر إلى الألوان فليست هي مستطيلات بل تتعرَّج بحسب حدود الدُّول في الغالب. فالأمر ليس بالبساطة التي قد نعتقدها: فليس الوقت المحلي هو فقط زيادة أو نقص من الوقت العالمي .. بل هناك عدة اعتبارات للتحويل بينها:\n\nمناطق عريضة جغرافيًّا: كالصين التي تمتد لتغطي مجموعة خطوط طول إلا أنها تعتمد توقيتًا موحَّدًا.\nالتوقيت الصيفي: بعض المناطق الزمنية تقدِّم الوقت ساعة عند الربيع (أو نهاية الشتاء) ثُم تعيدُه في الخريف، وذلك لتنظيم جدوَل الناس بحيث يتعرضوا للشمس أكثر.\nقرارات سياسية: قررت بعض الدوَّل أن تغير منطقتها الزمنية في سنة من السنوات؛ فذلك يجب أن يؤخذ في عين الاعتبار عند حساب الأوقات قبل أو بعد هذه السنة لهذه الدُّوَل.\n\nمعلومة جانبية: مصطلح التنسيق في التوقيت العالمي المنسق يشير إلى أنه يضع في الحسبان الاختلاف اليسير بسبب الثواني الكبسية، فتعاد ضبط الأوقات لاعتبارها.\nنخلص من ذلك أن التعامل مع الوقت له اعتبارات كثيرة بسبب ظروف تاريخية وسياسية وليس خاضعًا لقوانين فيزيائية أو أرضية أو فلكية بحتة. ولذلك ظهرت قاعدة بيانات للمناطق الزمنية (بمجهود جماعي) تتضمن معلومات الدول بشكل يتم تحديثه بشكل مستمر لمتابعة التغيرات، تسمَّى: (tz database).",
    "crumbs": [
      "باب الوقت",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#الوقت-في-الحاسب",
    "href": "chapters/10_time/a_time.html#الوقت-في-الحاسب",
    "title": "13  الوقت",
    "section": "13.2 الوقت في الحاسب",
    "text": "13.2 الوقت في الحاسب\nيظهر وقت التقويم (Calendar Time) على هذا النحو:\n\nالتاريخ: 2024-11-25\nالساعات: 08:30:25\nالمنطقة الزمنية: GMT+3 (أي: ثلاث ساعات متقدِّمة عن جرينيتش)\n\nلكن تمثيل الزمن في الحاسب هو: عدد صحيح (int) ويمثِّل عدد الثواني من بزوغ فجر نظام يونكس (Unix Epoch) وهو تاريخ ووقت اعتباطي تمَّ وضعه على أن يكون:\n\nتاريخ: 1970-01-01\nالساعة: 00:00:00\nالمنطقة الزمنية: UTC التي هي GMT+0\n\nمثال: لنشير إلى سنة واحدة تمامًا بعد النقطة الصفرية، أي: الساعة 00:00:00 بتاريخ 1 يناير1971 ، فإن السنة الواحدة فيها 31,536,000 ثانية ، وبالتالي يكون هذا الرقم هو الذي يمثل ذلك الوقت.\nولو أردت الترجمة بالعكس، فتقول إن 1,000,000,000 ثانية منذ النقطة الصفرية يوافق 9 سبتمبر 2001 01:46:40 في وقت التقويم على منطقة UTC.\nمشكلة سنة 2038 تحصل في الأنظمة ذات 32-بت؛ إذْ عدد الثواني يصل إلى أقصى مداه عند نقطتين زمنيتين:\n\nففي النزول تستطيع أن تصل إلى: 20:45:52 UTC بتاريخ 1901-12-13 (باختيار عدد سالب)\nوكذلك في الصعود؛ لا يمكن أن تتعدى: 03:14:07 UTC بتاريخ 2038-01-19\n\nوالحل في ذلك بسيط، وهو نقل البرنامج لنظام 64-بت.",
    "crumbs": [
      "باب الوقت",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#الوقت-في-بايثون",
    "href": "chapters/10_time/a_time.html#الوقت-في-بايثون",
    "title": "13  الوقت",
    "section": "13.3 الوقت في بايثون",
    "text": "13.3 الوقت في بايثون\nننتقل الآن إلى الوقت والتاريخ في بايثون، حيث يوجد لدينا المفاهيم التالية:\nأولاً: datetime.date وهو تاريخ مثالي يفترض أن التقويم الغريغوري يمتد إلى ما لا نهاية في المستقبل والماضي (رغم أنه في الحقيقة حل مكان التاريخ الجولياني سنة 1582). سمات هذا الكائن: السنة والشهر واليوم.\nثانيًا: datetime.time هو وقت مثالي يفترض 86,400 ثانية في اليوم (بدون ثوانٍ كبيسة). سمات هذا الكائن: الساعة والدقيقة والثانية والميكروثانية وtzinfo (معلومات المنطقة الزمنية).\nثالثًا: datetime.datetime وهو التاريخ والوقت معًا؛ فلديه سمات كلا الجزئين.\nرابعًا: datetime.timedelta وهو فترة زمنية. ولكننا سنستبدله بـ dateutil.relativedelta إذ هي كذلك فترة زمنية إلا أن نطاقها أوسع (تستوعب السنين والأشهر، وتعتبر السنوات الكبيسة في الحسبان).\nالوقت الصحيح لا بد له من نسبة إلى منطقة زمنيَّة (كأن تقول الساعة 04:00:00 صباحًا بتوقيت UTC+03)؛ فهذا تسميه بايثون وقت واع (Aware)، وأما الوقت الذي لم تحدد منطقته الزمنية (كما لو قُلت في الساعة 04:00:00 صباحًا) فهذا غير منسوب لمنطقة زمنية وبالتالي فهو ساذج (Naive) على تعبيرهم.\nويرشدنا توثيق المكتبة للتوسع في استعمال قاعدة بيانات المناطق الزمنية، والقدرة على تفسير التواريخ والأوقات بمرونة لاستخدام مكتبة dateutil المتوفرة في PyPI.\nلتثبيت المكتبة نستعمل pip على النحو التالي:\npip install python-dateutil\nالآن نستورد المكتبة الأساسية datetime ومكتبة dateutil:\n\nfrom datetime import date, time, datetime, timedelta\nfrom dateutil import tz\n\nنريد الآن معرفة الوقت العالمي والمحلي، وكذلك الوقت في القاهرة، وكذلك الوقت في لندن (هنا قائمة بالأسماء):\n\nprint(datetime.now(tz=tz.tzutc()))\nprint(datetime.now(tz=tz.tzlocal()))\nprint(datetime.now(tz=tz.gettz('Africa/Cairo')))\nprint(datetime.now(tz=tz.gettz('Europe/London')))\n\n2024-12-13 18:09:15.844209+00:00\n2024-12-13 21:09:15.844276+03:00\n2024-12-13 20:09:15.844794+02:00\n2024-12-13 18:09:15.845219+00:00\n\n\nلاحظ أن شكل الوقت كاملاً على النحو التالي:\n    2024-11-19 11:32:35.355104+03:00\n    YYYY-MM-DD HH:MM:SS.ssssss+HH:MM\nنفكك ذلك:\n\nYYYY-MM-DD هو التاريخ (يبدأ بالسنة ثم الشهر ثم اليوم)\nHH:MM:SS.ssssss هو الوقت (بالساعات والدقائق والثواني والميكروثواني)\n+HH:MM هو الفرق بين الوقت المحلي لتلك المنطقة الزمنية والوقت العالمي المنسق (UTC).\n\n\nالتفسير: تحويل النص إلى تاريخ ووقت\nوقراءة التواريخ أفضل بكثير في مكتبة dateutil بدلاً من استعمال المكتبة الأساسية datetime. وتكثر الحاجة لذلك عند استقبال معلومات من الشبكة أو من ملفات أو من المستخدمين:\n\nfrom dateutil.parser import parse\n\nهنا نحدد وقتًا افتراضيًّا عند القراءة، بحيث لو لم توجد المعلومة عند القراءة فإنها تستعمل القيم الافتراضية:\n\nDEFAULT = datetime(2003, 9, 25)\nparse(\"Thu Sep 25 10:36:28\", default=DEFAULT)\n\ndatetime.datetime(2003, 9, 25, 10, 36, 28)\n\n\nونرى كيف أن المفسر يحاول معرفة المعلومات ولو كانت ناقصة:\n\nدون السنة\nدون الشهر\nدون الثواني\nدون اليوم\n\n\nprint(parse(\"Thu Sep 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36\", default=DEFAULT))\nprint(parse(\"10:36\", default=DEFAULT))\n\n2003-09-25 10:36:28\n2003-09-25 10:36:28\n2003-09-25 10:36:00\n2003-09-25 10:36:00\n\n\n\n\nالحسابات الزمنية\n\nfrom dateutil.relativedelta import relativedelta\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nحساب الزمن المنقضي\n\ntoday = datetime.now(tz=tz.tzlocal())\nbirthday = datetime(1970, 1, 1, tzinfo=tz.tzlocal())\nage = relativedelta(today, birthday)\nprint(f'You are {age.years} years and {age.months} months old')\n\nYou are 54 years and 11 months old\n\n\n\n\nحساب الزمن لموعد\n\ntoday = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2025, 1, 15, tzinfo=tz.tzlocal())\ndiff = relativedelta(exam_date, today)\nprint(f'There are {diff.days} days and {diff.hours} hours remaining')\n\nThere are 1 days and 2 hours remaining\n\n\n\n\nمقارنة الوقت\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=9, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif now &gt; exam_date:\n    print('The exam has passed')\nelif now &lt; exam_date:\n    print('The exam is coming')\n\nThe exam has passed\n\n\n\n\nمقارنة الفترة\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=15, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif relativedelta(now, exam_date).hours &lt; 1:\n    print('Hurry up!')\nelif relativedelta(now, exam_date).hours &lt; 4:\n    print(f'Remember you have an exam today at {exam_date:%H:%M}')\nelse:\n    print(f'You have plenty of time to prepare for the exam')\n\nYou have plenty of time to prepare for the exam\n\n\n\n\nالجمعة القادمة\n\ntoday = datetime.now(tz=tz.tzlocal())\nnext_friday = today + relativedelta(days=+1, weekday=FR)\nprint(f'The next Friday is {next_friday:%Y-%m-%d}')\n\nThe next Friday is 2024-12-20\n\n\n\n\nالجمعة الفائتة\n\nlast_friday = today - relativedelta(days=+1, weekday=FR(-1))\nprint(f'The last Friday is {last_friday:%Y-%m-%d}')\n\nThe last Friday is 2024-12-06\n\n\n\n\nحساب الوقت باعتبار منطقتين زمنيتين\nلديك اجتماع في وقت محدد بتوقيت لندن، وتريد معرفة وقت الوصول بالطائرة إن كانت الرحلة تستغرق 4 ساعات والإقلاع من القاهرة في الساعة 01:00:00 صباحًا والوجهة لندن:\n\ndeparture_tz = tz.gettz('Africa/Cairo')\narrival_tz = tz.gettz('Europe/London')\n\ndeparture_time = datetime(2024, 11, 19, hour=1, tzinfo=departure_tz)\n\narrival_time = departure_time + relativedelta(hours=4)\n\nprint(f'You leave at {departure_time.astimezone(departure_tz)} in Cairo time')\nprint(f'You arrive at {arrival_time.astimezone(arrival_tz)} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz)} in Cairo time')\n\nYou leave at 2024-11-19 01:00:00+02:00 in Cairo time\nYou arrive at 2024-11-19 03:00:00+00:00 in London time\nwhich corresponds to 2024-11-19 05:00:00+02:00 in Cairo time\n\n\n\n\n\nتنسيق التاريخ والوقت\nوانظر الجدول لتنسيق مظهر التاريخ والوقت:\n\nprint(f'Departure time: {departure_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\nprint(f'Arrival time: {arrival_time.astimezone(arrival_tz):%d %b, %X %Z} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\n\nDeparture time: 19 Nov, 01:00:00 EET in Cairo time\nArrival time: 19 Nov, 03:00:00 GMT in London time\nwhich corresponds to 19 Nov, 05:00:00 EET in Cairo time\n\n\n\n\nالتكرار\nتكرار التواريخ يتم في هذه المكتبة باستعمال rrule ويحدد على النحو التالي:\n\nfrom dateutil.rrule import rrule\nfrom dateutil.rrule import DAILY, WEEKLY, MONTHLY, YEARLY, HOURLY, MINUTELY, SECONDLY\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nيوم ويوم\nتكرار أوقات بأخذ يوم وترك يوم، ابتداءً من وقت معين في الساعة العاشرة صباحًا:\n\nlist(\n    rrule(DAILY, interval=2, count=10, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 21, 10, 0),\n datetime.datetime(2024, 11, 23, 10, 0),\n datetime.datetime(2024, 11, 25, 10, 0),\n datetime.datetime(2024, 11, 27, 10, 0),\n datetime.datetime(2024, 11, 29, 10, 0),\n datetime.datetime(2024, 12, 1, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 5, 10, 0),\n datetime.datetime(2024, 12, 7, 10, 0)]\n\n\n\n\nأسبوعي\n\nlist(\n    rrule(WEEKLY, interval=1, count=4, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 26, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 10, 10, 0)]\n\n\n\n\nشهريًّا إلى وقت محدد\n\nlist(\n    rrule(MONTHLY, interval=1,\n        dtstart=datetime(2024, 8, 1),\n        until=datetime(2025, 4, 1),\n    )\n)\n\n[datetime.datetime(2024, 8, 1, 0, 0),\n datetime.datetime(2024, 9, 1, 0, 0),\n datetime.datetime(2024, 10, 1, 0, 0),\n datetime.datetime(2024, 11, 1, 0, 0),\n datetime.datetime(2024, 12, 1, 0, 0),\n datetime.datetime(2025, 1, 1, 0, 0),\n datetime.datetime(2025, 2, 1, 0, 0),\n datetime.datetime(2025, 3, 1, 0, 0),\n datetime.datetime(2025, 4, 1, 0, 0)]\n\n\n\n\nكل 15 دقيقة لمدة 6 مرات\n\nlist(\n    rrule(MINUTELY, interval=15, count=6, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 19, 10, 15),\n datetime.datetime(2024, 11, 19, 10, 30),\n datetime.datetime(2024, 11, 19, 10, 45),\n datetime.datetime(2024, 11, 19, 11, 0),\n datetime.datetime(2024, 11, 19, 11, 15)]\n\n\nوندعوك للاطلاع على المزيد من الأمثلة على مكتبة dateutil.",
    "crumbs": [
      "باب الوقت",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#التاريخ-الهجري-في-بايثون",
    "href": "chapters/10_time/a_time.html#التاريخ-الهجري-في-بايثون",
    "title": "13  الوقت",
    "section": "13.4 التاريخ الهجري في بايثون",
    "text": "13.4 التاريخ الهجري في بايثون\nتوفر مكتبة hijridate التعامل مع التاريخ الهجري والتحويل بينه وبين الجريجوري (الميلادي):\nfrom hijridate import Hijri, Gregorian\n\ng = Hijri(1446, 5, 17).to_gregorian()\nh = Gregorian(2024, 11, 19).to_hijri()\n\nprint(g)\nprint(h)",
    "crumbs": [
      "باب الوقت",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html",
    "href": "chapters/11_errors/a1_errors.html",
    "title": "14  الخطأ",
    "section": "",
    "text": "14.1 الخطأ النحوي: الخطأ في المبنى\nينقسم الخطأ لثلاثة أنواع:\nفي هذا الفصل، نناقش كل نوع من الأخطاء وكيفية التعامل معها.\nالأخطاء النحوية تتعلق بتركيب اللغة لا أكثر ولا أقل. إليك ثلاثة أمثلة.",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html#الخطأ-النحوي-الخطأ-في-المبنى",
    "href": "chapters/11_errors/a1_errors.html#الخطأ-النحوي-الخطأ-في-المبنى",
    "title": "14  الخطأ",
    "section": "",
    "text": "فقدان النقطتين :\n\nif (x &gt; 5)\n    print(\"x\")\n\n\n  Cell In[1], line 1\n    if (x &gt; 5)\n              ^\nSyntaxError: expected ':'\n\n\n\n\n\n\nعلامات اقتباس غير متوازنة\n\nprint(\"x\n\n\n  Cell In[2], line 1\n    print(\"x\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\nاسم متغير غير صالح\n\nmy-variable = 10\n\n\n  Cell In[3], line 1\n    my-variable = 10\n    ^\nSyntaxError: cannot assign to expression here. Maybe you meant '==' instead of '='?\n\n\n\n\n\n\nأخطاء المحاذاة\nمن الأخطاء النحوية الشائعة في بايثون: أخطاء المحاذاة (Indentation Error).\nوذلك أن بايثون تقبل نوعين من المسافات البادئة للسطر؛ إما بحرف المسافة التي بين الكلمات \\s أو بحرف المسافة بين الأعمدة \\t. وقد يستعمل بعض الناس هذه وبعضهم ذلك، ثم تأخذ كودًا من هنا وكودًا من هناك، فترى الكود عنك لا يعمل، والسبب هو الخلط بينهما في نفس الكود. وبايثون لا تقبل ذلك. فيجب توحيد النوع. إما هذه أو هذه. لذلك يضبط VS Code ومحررات الأكواد الأخرى تحويل البادئة تلقائيًا إلى مسافة أو العكس.\nإليك بعض الأمثلة لما يحصل من أخطاء في المحاذاة:\nعدم وجود مسافة بادئة، عندما تكون متوقعة:\n\nif True:\nprint(\"x\")\n\n\n  Cell In[4], line 2\n    print(\"x\")\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\nعدم تطابق المحاذاة:\n\nif True:\n    print(\"x\")\n     print('y')\n\n\n  Cell In[5], line 3\n    print('y')\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\nتجويد العبارة\nمن تجويد العبارة تسمية المتغيرات بما يدل على وظيفتها، مثل:\n\nrate = 50\nhours_per_day = 6\ndays = 5\npay = rate * hours_per_day * days\nprint(pay)\n\n1500\n\n\nوإن كان ليس من الخطأ النحوي كتابتها بطريقة مختلفة وبأسماء غير معبِّرة، إلا أنه أمرٌ غير مستحسن:\n\nr, hpd, d = 50, 6, 5\np = r * hpd * d\nprint(p)\n\n1500\n\n\nوفي هذا نصائح كثيرة، يراجع فيها دليل أسلوب الكتابة في بايثون.",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html#الخطأ-المنطقي-الخطأ-في-المعنى",
    "href": "chapters/11_errors/a1_errors.html#الخطأ-المنطقي-الخطأ-في-المعنى",
    "title": "14  الخطأ",
    "section": "14.2 الخطأ المنطقي: الخطأ في المعنى",
    "text": "14.2 الخطأ المنطقي: الخطأ في المعنى\nوهي التي نقصدها حين نقول: Bug، ولذلك قيل للبرنامج الذي يساعد في إصلاحها: Debugger، وعملية البحث عنها وإصلاحها: Debugging.\nالأخطاء المنطقية صامتة. إذ لا يكتشفها المترجم، وتتسبب في تصرف البرنامج بشكل غير صحيح. الأخطاء المنطقية هي الأصعب في التتبع والإصلاح لأنها ليست واضحة. يمكن أن تكون ناجمة عن:\n\nافتراضات غير صحيحة\nتطبيق غير صحيح للخوارزمية أو\nتحضير غير صحيح للبيانات\n\nاقرأ المزيد عن أنواع الأخطاء وإليك بعض الأمثلة.\n\nاستعمال الإجراء الخاطئ\n\nimport math\n\nsquare = math.sqrt(4) # should use math.pow(4, 2) instead\n\n\n\nاستعمال العامل الخاطئ\n\nx = 16\nif (x == \"16\"):\n    print('equal')\n\n\n\nمستوى محاذاة خاطئ\nهنا كانت النية تقتضي أن تكون print(j) داخل الحلقة الداخلية:\n\nfor i in range(2):\n    for j in range(3):\n        print(i)  \n    print(j)\n\n0\n0\n0\n2\n1\n1\n1\n2\n\n\n\n\nخطأ الحافَّة\nيكاد يكون أشهر الأخطاء في البرمجة: خطأ الحافَّة. ويسمى (Off-by-one error).\nنشرحه بمثال: النية هنا هي طباعة الأرقام من 5 إلى 0 بما في ذلك 0، ولكن الحلقة تتوقف عند 1.\n\nfor i in range(5, 0, -1):\n    print(i)\n\n5\n4\n3\n2\n1",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html#كشف-الأخطاء-المنطقية",
    "href": "chapters/11_errors/a1_errors.html#كشف-الأخطاء-المنطقية",
    "title": "14  الخطأ",
    "section": "14.3 كشف الأخطاء المنطقية",
    "text": "14.3 كشف الأخطاء المنطقية\nلكونها جملاً صحيحة في ذاتها؛ لا يستطيع البرنامج كشف هذه الأخطاء لوحده. بل يجب على من يُدركُ حقيقة المطلوب من البرنامج أن يتكفل بذلك. وهنا تكون الحاجة ماسَّة لجمل التوكيد: assert وقد رأيناها كثيرًا.\nوالتدقيق؛ إذْ أفضل طريقة لحل الأخطاء المنطقية هي تنفيذ الكود والنظر في الناتج، وتتبع المنطق مرة أخرى إلى الكود سطرًا بسطر. يمكنك استخدام عبارات الطباعة print لتصحيح الأخطاء وفهم تدفق البرنامج. وقد يكون الأفضل من ذلك استعمال المدقق (Debugger).\nمراجعة الأقران: بحيث يطلع على الكود شخص آخر، فإنه قد يرى منه ما تعذر عليك رؤيته. وقد يتم تنظيمه بين أعضاء الفريق الواحد بأحد برمجيات التعاون مثل: GitHub وGitLab وBitbucket وغيرها. لكن ليس شرطًا أن يكون بطريقة منظَّمة حتى تستفيد منه.",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html",
    "href": "chapters/11_errors/a2_exceptions.html",
    "title": "15  الخطأ الواقعي: الاستثناء",
    "section": "",
    "text": "15.1 الفرق بين الوقاية والتدارك\nالاستثناء (Exception) هو خروج البرنامج عن المسار المثالي. ويسمى خطأً (Error).\nمثل أن يؤمَر بقراءة ملف .. والواقع أن هذا الملف غير موجود! أو أن يطلب من المستخدم رقمًا فيعطيه كلاماً! أو أن يطلب من الشبكة شيئًا .. فتنقطع الشبكة! فكل هذه تعتبر مسارات غير مثالية لكنها تحصل في ظروف واقعيَّة. فيجب كتابة قطع في البرنامج تتعامل معها. ولذا فإن بعض الممارسين لا يفضلون استعمال كلمة استثناء لأنَّ مثل ذلك يحصل كثيرًا فهو ليس خارجًا عن العادة؛ بل من الطبيعي أن يحصل ذلك في الواقع.\nتصوَّر أن البرنامج سلسلة من الإجراءات بحيث يختص كل إجراء بمهمة معيَّنة (بناءً على مدخلاته يُعطي مخرجاته) فإننا نتعمَّد أن يكون وعيُه محدودًا بمدخلاته حتى نقلل من تشابك قطع الكود حتى نيسِّر على أنفسنا التحقق من صحَّة المنطق. وهذه فكرة إطار التنفيذ التي سبق الحديث عنها في باب الإجراء.\nفللخطأ حالتان -لا غير- في علاقتها مع من يتعامل معه:\nومنشؤ الخطأ أحد أمرين:\nوللتعامل مع الخطأ حين يستوعبه السياق طريقتان:\nهذا الإجراء مسؤول عن تهيئة البرنامج، ومن خطواته أنه يقرأ ملف الضبط المخصص custom_config.json. وفي هذه الحالة قد يحصل خطأ. إذْ قد لا يكون الملف موجودًا أصلا!\nهذا الإجراء مسؤول عن تهيئة البرنامج، ومن خطواته أنه يقرأ ملف الضبط المخصص custom_config.json. وفي هذه الحالة قد يحصل خطأ. إذْ قد لا يكون الملف موجودًا أصلا!\nففي هذه الحالة يحصل استثناء من نوع FileNotFoundError.\nفإذا اخترنا طريق الوقاية فإننا أولاً نلتمس وجوده قبل فتحه. ونتعامل مع حالة الخطأ هذه (أي: عدمه)، بأن -مثلاً- نقرأ ملف الضبط الافتراضي default.json بدلاً من الملف المطلوب. والفرق بين هذا الملف والذي قبله أننا موقنون بوجوده، والأوَّل وجوده مظنون إذْ الذي يضعه هو المستخدم.\nوقد تقول، حسنًا ماذا يكون لو عُدم ملف default.json أيضًا؟ فنقول: لا بأس أن يحصل خطأ يوقف البرنامج. إذْ ذاك يعتبر خطأ منطقيًّا يجب إصلاحه بإضافة الملف، وليس ثمة مجال لأن يصلحه الكود بنفسه.\nأما التدارك فيكون بجملة try-except على النحو التالي:\nأما استعمال الوقاية ففيه شك بوجود فجوة زمنية بين عملية التحقق من وجود الملف وبين قراءته. فالحاسب تتوارد عليه البرمجيات، ولا يستأثر به برنامج واحد. فإذا تغيَّر الحال في هذه الفجوة الزمنية وعاد بالنقض على التحقق بعد حصوله انتفت الفائدة منه. لذا فالتدارك أضمن.",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#الفرق-بين-الوقاية-والتدارك",
    "href": "chapters/11_errors/a2_exceptions.html#الفرق-بين-الوقاية-والتدارك",
    "title": "15  الخطأ الواقعي: الاستثناء",
    "section": "",
    "text": "file = open('custom_config.json')\n\ndef initialize_program():\n    # ... code before\n    file = open('custom_config.json')\n    # ... code after\n\n\ndef initialize_program():\n    # ... code before\n    if os.path.exists('custom_config.json'):\n        file = open('custom_config.json')\n    else:\n        file = open('default.json')\n    # ... code after\n\n\ndef initialize_program():\n    # ... code before\n    try:\n        file = open('custom_config.json')\n    except FileNotFoundError:\n        file = open('default.json')\n    # ... code after\n\n\nالحالة الأولى: خطأ جديد يستوعبه السياق\nمثاله ما لو لم تكن أحد الصفات محددة، فيمكن تعيينها بقيمة افتراضية، ولا يلزمنا تصعيد الخطأ:\ndef save_user(user: dict):\n    if 'language' not in user:\n        user['language'] = 'ar'\n    # ... rest of the code\n    save_to_database(user)\n\n\nالحالة الثانية: خطأ مرفوع يستوعبه السياق\nوقد مثلنا له بفتح الملف، ونمثل له بمثال آخر:\n\ndef get_user_guess() -&gt; int:\n    print('Please enter a number')\n    guess = input()\n    try:\n        guess = int(guess)\n    except ValueError:\n        print(f'The value \"{guess}\" is not a number')\n        guess = get_user_guess() # recursive call\n    return guess\n\n\n\nالحالة الثالثة: خطأ جديد لا يستوعبه السياق\nفي هذا المثال يجب أن تكون الوحدة إحدى القيم المسموحة: C أو F. وإلا فلا حيلة للإجراء أن يتم وظيفته. لذا نرفع خطأ جديدًا بجملة raise.\ndef convert_temperature(value: float, unit: str) -&gt; float:\n    if unit not in {'C', 'F'}:\n        raise ValueError(f\"Invalid unit: {unit}\")\n    \n    if unit == 'C':\n        return value * 9/5 + 32\n    elif unit == 'F':\n        return (value - 32) * 5/9\n\n\nالحالة الرابعة: خطأ مرفوع لا يستوعبه السياق\nففي هذا المثال عملية قسمة قد يحصل فيها قسمة على صفر في (a / b)، فيرتفع خطأ اسمه ZeroDivisionError من تلك العملية. والحقيقة أننا في هذا السياق ليس لنا أن نعدِّل الرقم، بل نريد لمن استدعى الإجراء أن يعلم بالخطأ، ولسنا نريد إضافة معلومة أخرى فوق ذلك. لذا نسكت عنه (أي: لا نضع try-except) وهذا يجعله ينتقل مباشرة للإجراء المستدعي.\ndef divide_lists(list1: list, list2: list) -&gt; list:\n    result = []\n    for a, b in zip(list1, list2):\n        result.append(a / b)\n    return result\nفإن من الأخطاء ما يتعذر على البرنامج معالجته بنفسه:\n\nإذا كانت المشكلة بامتلاء الذاكرة في الجهاز؛ فإن البرنامج ليس له إلا أن يخرج برسالة للمستخدم أو المسؤول عن الجهاز .. وليس للبرنامج أن يمسح بيانات المستخدم!\nأما إذا كانت المشكلة في تأخر الإجابة من الخادم مثلاً، فقد نعيد المحاول مرة أخرى بعد ثوانٍ، ونعيدها لعددٍ محدد من المرات، أملاً في الحصول على إجابة. ثم بعد ذلك لا يمكن إلا أن نظهر رسالة خطأ إن نفدت جميع المحاولات.",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#إلتقاط-جميع-الأخطاء",
    "href": "chapters/11_errors/a2_exceptions.html#إلتقاط-جميع-الأخطاء",
    "title": "15  الخطأ الواقعي: الاستثناء",
    "section": "15.2 إلتقاط جميع الأخطاء",
    "text": "15.2 إلتقاط جميع الأخطاء\nمن الخطأ في المنطق البرمجي إلتقاط جميع الأخطاء في الإجراءات باستعمال except Exception وهو النوع الشامل لجميع الأخطاء. فهذه الطريقة لا تخبرنا بنوع الخطأ وبالتالي لا نتعامل معه بحسبه، وإنما غاية ما تحقق هو منع تصعيد الخطأ لأعلى طبقة، إذْ حين يحصل ذلك توقف بايثون البرنامج (وعندها تظهر سلسلة الاستدعاءات).\nلكن يجوز ذلك في قطع الكود التي يُراد لها الاستمرار، وإن فشلَ شيئٌ فيها. مثلاً: لا تريد للخادم أن يتوقف تمامًا بمجرد حصول خطأ واحد في أحد خيوط التنفيذ الخاصة بخدمة أحد الطلبات. ففي مثل ذلك يسوغ استخدام except Exception الشاملة. انظر مثلاً قطعة الكود في إطار الويب فلاسك المسؤول عن استقبال الطلبات.",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#أنواع-الاستثناء-في-بايثون",
    "href": "chapters/11_errors/a2_exceptions.html#أنواع-الاستثناء-في-بايثون",
    "title": "15  الخطأ الواقعي: الاستثناء",
    "section": "15.3 أنواع الاستثناء في بايثون",
    "text": "15.3 أنواع الاستثناء في بايثون\nوقد تم تعريف أصناف من الأخطاء في بايثون بحسب الحالة، وتم تقسيمها بالشكل التالي:\n\nSyntaxError\nالسبب: خطأ نحوي في صياغة اللغة:\n\nكلمة غير صحيحة: خطأ في الإملاء\nفي وضع كلمة صحيحة في غير سياقها\nمحاذاة غير متسقة (IndentationError)\n\nالحل: اقرأ رسالة الخطأ وستدلُّك على السبب والموضع الذي حصل فيه الخطأ.\n\n\nTypeError\nالسبب:\n\nاستدعاء إجراء بعدد أكثر أو أقل من العوامل الواجبة (مثل: len(1, 2))\nاستدعاء إجراء بعوامل لا تطابق النوع المحدد في تعريفه (مثل: math.sqrt('nine') أو 5 + '5')\n\nالحل: الوقاية بـ type() أو isinstance() أو بالتأكد من تحويل النوع مسبقًا.\na = 5\nb = input('Enter a number: ')\nresult = a + int(b)\n\n\nValueError\nالسبب: أن يكون النوع صحيحًا (فلا يحصُل TypeError) لكن القيمة غير مقبولة.\n\nمثلاً: استدعاء إجراء بقيمة نوعها عددي لكنَّها سالبة وهو لا يقبل إلا الموجبة. نحو: math.sqrt(-16) فالجذر التربيعي لا يقبل السالب.\n\nالحل: الوقاية بفحص مدى القيمة ، نحو: if x &gt;=0: math.sqrt(x)\n\n\nIndexError & KeyError\nالسبب: الرقم الذي استعمل في عملية الإشارة [index]list (قائمة) أو dict[key] (قاموس) يشير لما هو خارج المجموعة.\nنحو:\n\nmy_list = [10, 20, 30]\nidx = 3\nvalue = my_list[idx]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[18], line 3\n      1 my_list = [10, 20, 30]\n      2 idx = 3\n----&gt; 3 value = my_list[idx]\n\nIndexError: list index out of range\n\n\n\nالحل بالوقاية:\nif idx &lt; len(my_list):\n    value = my_list[idx]\nelse:\n    # do something else\nأو بالتدارك:\ntry:\n    value = my_list[idx]\nexcept IndexError:\n    # do something else\nوكذلك في القاموس، نحو:\n\nmy_dict = {'A': 10, 'B': 20, 'C': 30}\nkey = 'Z'\nvalue = my_dict[key]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[19], line 3\n      1 my_dict = {'A': 10, 'B': 20, 'C': 30}\n      2 key = 'Z'\n----&gt; 3 value = my_dict[key]\n\nKeyError: 'Z'\n\n\n\nالحل بالوقاية\nif key in my_dict:\n    value = my_dict[key]\nelse:\n    # do something else\nأو هكذا (تعيين قيمة افتراضية):\nvalue = my_dict.get(key, 0)\nأو بالتدارك:\ntry:\n    value = my_dict[key]\nexcept KeyError:\n    # do something else\n\n\nAttributeError & NameError\nالسبب: استعمال متغير أو إجراء قبل تعريفه.\n\nفإن أسنِد إلى كائن؛ وقع AttributeError\nوإلا وقع NameError\n\n\na = 10\na + X\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[20], line 2\n      1 a = 10\n----&gt; 2 a + X\n\nNameError: name 'X' is not defined\n\n\n\n\nsome_function(55)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 some_function(55)\n\nNameError: name 'some_function' is not defined\n\n\n\n\nclass A:\n    pass\n\na = A()\na.x\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[22], line 5\n      2     pass\n      4 a = A()\n----&gt; 5 a.x\n\nAttributeError: 'A' object has no attribute 'x'\n\n\n\n\na.do_something()\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 a.do_something()\n\nAttributeError: 'A' object has no attribute 'do_something'\n\n\n\n\n\nModuleNotFoundError\nالسبب: فشل جُملة الاستيراد import numpy\nالحل:\n\nتأكد من صحة الإملاء\nتأكد من تثبيت الوحدة في البيئة التي يعمل فيها البرنامج: pip install numpy",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#تعريف-أخطاء-جديدة",
    "href": "chapters/11_errors/a2_exceptions.html#تعريف-أخطاء-جديدة",
    "title": "15  الخطأ الواقعي: الاستثناء",
    "section": "15.4 تعريف أخطاء جديدة",
    "text": "15.4 تعريف أخطاء جديدة\nتعريف الخطأ يكون بتعريف صنف جديد يرث من الصنف Exception، وهذا ما يحققه السطر الأول بين القوسين. وتستطيع أن ترث ممن يرث، فتتكون لديك فروع من هذا الخطأ:\n\nclass ParentError(Exception):\n    pass\n\nclass XError(ParentError):\n    pass\n\nclass YError(ParentError):\n    pass\n\n\n\n\n\n\nflowchart TD\n    A[ParentError] --&gt; B[XError]\n    A --&gt; C[YError]\n\n\n\n\n\n\nوهذا الإجراء يحصل فيه الخطأ بطريقة مصطنعة لكنها توضح ما نريد، وهو الخطأ الفرعي XError الذي يرث من الخطأ الأصلي ParentError:\n\ndef do_something():\n    raise XError('Something went wrong')\n\nثم حين نفحص، تسطيع أن نطابق بالأصل أو الفرع:\n\ntry:\n    do_something()\nexcept ParentError as e:\n    print(\"caught you:\", e)\n\ncaught you: Something went wrong",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#منظور-آخر-للخطأ",
    "href": "chapters/11_errors/a2_exceptions.html#منظور-آخر-للخطأ",
    "title": "15  الخطأ الواقعي: الاستثناء",
    "section": "15.5 منظور آخر للخطأ",
    "text": "15.5 منظور آخر للخطأ\nفائدة: لدينا طريقتان في التعامل مع الخطأ الواقعي، واختارت بايثون طريقة الاستثناء:\nالأولى: رفع قيمة الخطأ بالاسثناء: لغات مثل C++ (1979)، Java (1998)، Python (1991) و JavaScript (1995) ترمي/ترفع الاستثناءات باستعمال عبارة مثلة raise أو عبارة throw على حسب اللغة. وتكون معالجة الخطأ بجملة try-catch أو try-except.\nالثانية: الرجوع بقيمة الخطأ: اللغات الحديثة مثل Go (2009) و Rust (2015) ببساطة تعيد الخطأ كشيء (قيمة) عند حدوثه باستعمال جملة return التي في الإجراء. وتكون معالجة الخطأ بجملة شرطية عاديَّة نحو: if error == error_type\nوبعض اللغات مثل: C (1978) وكذلك C++ (1985) تخلط بين النوعين!\n\nالمراجع:\n\nPython Tutorial: Exceptions\nMiguel Grinberg: The Ultimate Guide to Error Handling in Python",
    "crumbs": [
      "باب الخطأ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html",
    "href": "appendix_collections.html",
    "title": "خريطة المجموعات",
    "section": "",
    "text": "classDiagram\n    class Container {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n    }\n\n    class Iterable {\n        &lt;&lt;abstract&gt;&gt;\n        +__iter__()\n    }\n\n    class Iterator {\n        &lt;&lt;abstract&gt;&gt;\n        +__next__()\n        +__iter__()\n    }\n\n    class Reversible {\n        &lt;&lt;abstract&gt;&gt;\n        +__reversed__()\n    }\n\n    class Sized {\n        &lt;&lt;abstract&gt;&gt;\n        +__len__()\n    }\n\n    class Collection {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n    }\n\n    class Sequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__len__()\n        +__contains__()\n        +__iter__()\n        +__reversed__()\n        +index()\n        +count()\n    }\n\n    class MutableSequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__len__()\n        +insert()\n        +append()\n        +clear()\n        +reverse()\n        +extend()\n        +pop()\n        +remove()\n        +__iadd__()\n    }\n\n    class Set {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +__le__()\n        +__lt__()\n        +__eq__()\n        +__ne__()\n        +__gt__()\n        +__ge__()\n        +__and__()\n        +__or__()\n        +__sub__()\n        +__xor__()\n        +isdisjoint()\n    }\n\n    class MutableSet {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +add()\n        +discard()\n        +clear()\n        +pop()\n        +remove()\n        +__ior__()\n        +__iand__()\n        +__ixor__()\n        +__isub__()\n    }\n\n    class Mapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__iter__()\n        +__len__()\n        +__contains__()\n        +keys()\n        +items()\n        +values()\n        +get()\n        +__eq__()\n        +__ne__()\n    }\n\n    class MutableMapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__iter__()\n        +__len__()\n        +pop()\n        +popitem()\n        +clear()\n        +update()\n        +setdefault()\n    }\n\n    Iterable &lt;|-- Iterator\n    Iterable &lt;|-- Reversible\n    Sized &lt;|-- Collection\n    Iterable &lt;|-- Collection\n    Container &lt;|-- Collection\n    Reversible &lt;|-- Sequence\n    Collection &lt;|-- Sequence\n    Sequence &lt;|-- MutableSequence\n    Collection &lt;|-- Set\n    Set &lt;|-- MutableSet\n    Collection &lt;|-- Mapping\n    Mapping &lt;|-- MutableMapping\n\n\n\n\nشكل 1: الأنواع المجردة حول المجموعة (Collection)",
    "crumbs": [
      "الملحقات",
      "خريطة المجموعات"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "قاموس المصطلحات",
    "section": "",
    "text": "Tuple",
    "crumbs": [
      "الملحقات",
      "قاموس المصطلحات"
    ]
  },
  {
    "objectID": "glossary.html#tuple",
    "href": "glossary.html#tuple",
    "title": "قاموس المصطلحات",
    "section": "",
    "text": "Etymology. The term originated as an abstraction of the sequence: single, couple/double, triple, quadruple, quintuple, sextuple, septuple, octuple, …, n‑tuple, …, where the prefixes are taken from the Latin names of the numerals. The unique 0-tuple is called the null tuple or empty tuple. Wikipedia",
    "crumbs": [
      "الملحقات",
      "قاموس المصطلحات"
    ]
  },
  {
    "objectID": "glossary.html#parameter",
    "href": "glossary.html#parameter",
    "title": "قاموس المصطلحات",
    "section": "Parameter",
    "text": "Parameter\n\nA parameter (from Ancient Greek παρά (pará) ‘beside, subsidiary’ and μέτρον (métron) ‘measure’), generally, is any characteristic that can help in defining or classifying a particular system (meaning an event, project, object, situation, etc.). Wikipedia",
    "crumbs": [
      "الملحقات",
      "قاموس المصطلحات"
    ]
  }
]