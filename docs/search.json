[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "مقدمة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nثم أدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة التخزين.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة ويشغِّل هذه الإلكترونيات المجهرية لتحقيق مقصوده منها.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#سبب-تأليف-الكتاب",
    "href": "index.html#سبب-تأليف-الكتاب",
    "title": "البايثونية",
    "section": "سبب تأليف الكتاب",
    "text": "سبب تأليف الكتاب\nلمستُ حاجة المبتدئين لفهم أدقَّ للغة بايثون -وعلى صعيد أكبر- المعاني البرمجية بالعموم. وغلبةً على من تعلَّم بلغة غيره أن يعظِّمه فيقلد حتى متناقضات مقالاته ولا يميِّز بين صحيحها وسقيمها. وعجزَه عن الإضافة المفيدة لما تعلَّمه ولمن علمه؛ فعسيرٌ عليه أنْ يعرف المنطلقات حتى يتتبع أصل الحكم الذي هو متمسِّك به اليوم.\nورأيتُ أنَّ وصف المفاهيم باللغة الأم أمكن في الذهن وأوعى، وأوسع في الاختراع والإبداع، ومنسجمٌ مع من استمدَّ من وعيِه الثقافي آلة لتكوين وعيِه العلمي في علمٍ من العلوم والصناعة. ورجائي بذلك أن يكون صعودُك في درج هذا العلم قفزًا.\nوتمنيتُ أن أُسْهِمَ في تعليم من هم على أبواب البرمجة ينظرون وليس عندهم دليل يرشدهم في طُرُقاتها. فهم مع ما عندهم من العلوم، لم يدرسوا دراسةً منهجيَّة في علوم الحاسب أو فروعه المهتمَّة بالبرمجة: كأصحاب التخصصات الإنسانية واللغوية والتجريبية والمنطقية والشرعية، ممن يجد في نفسه ميلاً إلى التحليل الرياضي والصبر على التدقيق المنطقي. وأرى تيسيرها باللغة العربية لهم أنفعُ في علومهم وأعمالهم.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#عناصر-الكتاب",
    "href": "index.html#عناصر-الكتاب",
    "title": "البايثونية",
    "section": "عناصر الكتاب",
    "text": "عناصر الكتاب\nقُسِّمَ الكتاب على النحو التالي:\n\nالنظرية فيه المفاهيم والأقسام والقواعد .. وليست فيه أمثلة وتطبيق.\nالتطبيق: نرى فيه كيف نضع ما تعلمنا في سياقات مختلفة\nالتمرين: يأتي دوْر المتعلم ليرسخ المفاهيم بالممارسة\nالحل: للتحقق من صحَّة حلك للتمرين",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "index.html#لماذا-لغة-بايثون-بالتحديد",
    "href": "index.html#لماذا-لغة-بايثون-بالتحديد",
    "title": "البايثونية",
    "section": "لماذا لغة بايثون بالتحديد؟",
    "text": "لماذا لغة بايثون بالتحديد؟\nتعتبر المؤسسات لغات البرمجة منتجاتٍ لها. وهذا المنتج -الذي هو لغة البرمجة- كالمطرقة والمنشار بل وصندوق الأدواة كاملاً؛ وسيلة للإنتاج. والتنافُس يشكل تداخلاً في الوظائف التي تخدمها كل لغة، فبعضها يستعمل لأنظمة التشغيل (مستوى دوني من البرمجة) وبعضها يستعمل لتطبيقات الشبكة (مستوى عالي من البرمجة).\nويقع الاختيار على لغة بايثون كثيرًا لأمور:\n\nالسهولة نسبةً إلى أخواتها؛ حيث يجد فيها المبتدئ قُربًا إلى اللغة الإنجليزية\nالعموم (عدم اختصاصها بمجال ضيق) وذلك يتمثل في تنوع تطبيقاتها\nالقبول فالجهود متظافرة على خدمة مكتباتها من المجتمعات التي تتمحور حول نوع ما من التطبيقات. وهذا التراكم يعني أن كثيرًا من الأوامِِر يعبَّر عنه بأسطر قليلة\n\nومن تطبيقاتها:\n\nتطوير مواقع الشبكة\nتطبيقات تعلم الآلة والذكاء الاصطناعي\nتحليل البيانات وتصويرها\n\nوأكثر التطبيقات من أنظمة المعلومات: التي تختص بجمع المعلومات وحفظها وفهرستها وترتيبها وتقسيمها وعرضها وتسهيل الحصول عليها بالسؤال المباشر وغير المباشر، والتحقق منها وتوفيرها والاستفادة منها وترجمتها ونحو ذلك:\n\nمثل: محرك بحث قوقل (يعمل على ترتيب شبكة الإنترنت)\nونظام الدفع عبر البطاقة\nوالبرمجيات المكتيبة (تقارير ، محاسبة ، تخطيط، …إلخ) ، ونحو ذلك\n\nوليست بايثون مقصودة لذاتها فمن بساطة البرمجة أن تعلُّمَك للغة الثانية أسهل بمراحل من الأولى؛ إذْ كان عليك أن تتعلم مفاهيم جديدة في أوَّل مرة؛ وهي الآن تتكرر بتنسيق مختلف قليلاً وبألفاظ وتراكيب جديدة. إلا إنْ انتقلت في مستوى التطبيق من لغة عالية (مثل Python و Go) إلى لغة دانية (مثل C أو Rust). والواقع أن ليسَ ثمة لغة واحدة تحقق كل ما تريد؛ بل يغلب على المشاريع البرمجية تعدد اللغات فيها.",
    "crumbs": [
      "مقدمة"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "إعداد بيئة التطوير",
    "section": "",
    "text": "نبدأ بالتعرف على بيئة التطوير ، وتثبيتها في جهازك؛ وذلك أنني أؤمن بضرورة إكساب الفرد أعلى قدر من التحكم في أدواته حتى يتمكن منها ومن تطويعها لعمل ما يريد بالشكل الأمثل.\nبيئة التطوير هي الأدوات البرمجية الأساسية والمساعدة لعمليات كتابة الكود وتنفيذه واختباره ونحو ذلك.\nأما محرر الكود فسنختار محرر (Visual Studio Code) وهو فرعٌ عن مشروع مفتوح المصدر بنت عليه شركة مايكروسوفت. ويستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024 لأن الشركة أسسته ثم فتحت للمجتمع البرمجي أكواده. وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن. وتعني الشركة بدعمه وصيانته باستمرار وتطويره، كما أتيح بفتح أكواده سهولة كشف الأخطاء فيه، وأتيح بفضل تصميمه لأن يُخصص وتمتد إمكانياته بإضافات برمجيَّة قابلة للتثبيت يقوم بتزويدها لبعضهم البعض المجتمع البرمجي على مختلف لغاته واستعمالاته.\nوأما تنظيم المشروعات والمكتبات فسنختار uv من Astral إذْ يجمع بين الترتيب (فصل كل مشروع عن الآخر)، والسرعة (لأنه كُتِبَ بلغة Rust)، وكذلك السهولة.\nتابع المقطع الذي فيه تفصيل ذلك كله:\n\n\nبعد ذلك تكون جاهزًا للبدء في البرمجة.",
    "crumbs": [
      "إعداد بيئة التطوير"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html",
    "href": "chapters/01_intro/introduction.html",
    "title": "1  لغة البرمجة",
    "section": "",
    "text": "1.1 أصول اللغة\nيتألف البرنامج المكتوب بلغة بايثون من قطع برمجية هي عبارة عن سلسلة من الجُمَل البسيطة والمركبة المكونة من مفردات للتعبير عن الأوامِر بطريقة سهلة على المبرمج كتابتها ، وفي نفس الوقت تتبع قواعد نحوية صارمة لا تشتبه عند ترجمتها لتعليمات مفصَّلة ودقيقة بلغة المنطق الرقمي لآلة لتنفذها.\nوقد تكون هذه الجمل البرمجية أصلية في اللغة وقد تكون مزيدة مما أضيف لاحقًا. فأما المفردات الأصلية في لغة بايثون فهي:\nومنها كذلك: match, case, type و _.\nأما الجمل فتنقسم إلى قسمين:\nثم لدينا المعاملات والمحددات.\nتنبيه: ليس المطلوب حفظ ذلك الآن، وإنما هذه نظرة عامَّة لتكوين تصوُّر مجمل.\nإذاً في لغة بايثون:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#أصول-اللغة",
    "href": "chapters/01_intro/introduction.html#أصول-اللغة",
    "title": "1  لغة البرمجة",
    "section": "",
    "text": "False      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n\n\n\n\nجملة بسيطة:\n\nالتعبير: x + y\nالتعيين: x = y\nالتأكيد: assert condition\nالمرور: pass\nالحذف: del x\nالإرجاع: return y\nالإنتاج: yield y\nرفع الاستثناء: raise Exception\nالكسر: break\nالاستمرار: continue\nالاستيراد: import module\nالعالمية: global x\nغير المحلية: nonlocal x\nالنوع: type(x)\n\n\nجملة مركبة:\n\nالشرط: if ...\nالتكرار: while ...\nالحلقة: for ...\nالمحاولة: try ...\nالسياق: with ...\nالمطابقة: match ...\nتعريف الفعل: def ...\nتعريف النوع: class ...\nالروتينات المتزامنة: async def ...\nقوائم معلمات النوع: [T1[, T2, ...]]\n\n\n\n\n\n\nالمعاملات فهي رموز لعمليات تختلف بحسب السياق (العوامل):\n+       -       *       **      /       //      %      @\n&lt;&lt;      &gt;&gt;      &       |       ^       ~       :=\n&lt;       &gt;       &lt;=      &gt;=      ==      !=\nفمثلاً: معامل الجمع + له أكثر من تفسير في العبارة: x + y:\n\nإذا كان x و y أرقامًا فإن + هو عملية جمع\nإذا كان x و y نصين فإن + هو عملية دمج\n\n\nالمحددات هي رموز تبين أين تبتدئ بعض الجمل أو تنفصل أو تنتهي:\n(       )       [       ]       {       }\n,       :       !       .       ;       @       =\nومن أمثلتها:\n\nفي العبارة: x = (y + z) * (a + b) لتحديد ترتيب العمليات\nفي الفعل: print(x, y, z) لتحديد العوامل\nفي تعريف صف: xs = (10, 20, 30) لتحديد العناصر\n\n\n\n\n\n\nقطع برمجية\nفي كل قطعة جمل متتابعة بسيطة أو مركبة\nفي كل جملة مفردات وتعبيرات وعوامل ومحددات",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#القطعة-البرمجية",
    "href": "chapters/01_intro/introduction.html#القطعة-البرمجية",
    "title": "1  لغة البرمجة",
    "section": "1.2 القطعة البرمجية",
    "text": "1.2 القطعة البرمجية\nفي لغة إجرائية كبايثون فإن تنفيذ الأسطر البرمجية يكون حسب ترتيب كتابتها من الأعلى إلى الأسفل.\n\nالمثال الأول: جمل التعيين والشرط\n\ndistance = 200\nspeed =  100\ntime_to_arrive = distance / speed\n\nif time_to_arrive &gt; 1:\n    print('we are going to be late!')\nelse:\n    print('on time')\n\nwe are going to be late!\n\n\nفي هذه القطعة مجموعة جُمل\n\nتعريف المتغيرات عن طريق جمل التعيين: distance = 200 و speed = 100\nتعيين ناتج حساب قسمة المسافة على السرعة: time_to_arrive = distance / speed\nجملة شرطية: if\n\nالجزء الأول (الشرط): time_to_arrive &gt; 1\n\nالجزء الثاني المضمن داخل القطعة: هي جمل برمجية متعلقة بنفوذ الشرط\n\nالجزء الثالث (في حالة انتفاء الشرط): else\n\nالجزء الرابع (المضمن داخل القطعة): هي جمل برمجية متعلقة بانتفاء ذلك الشرط\n\n\n\nوقد تتضح أكثر حين نرسمها:\n\n\n\n\n\nflowchart TD\n    B[distance = 200] --&gt; C[speed = 100] --&gt; D[time_to_arrive = distance / speed] --&gt; IF1{{\"if time_to_arrive &gt; 1\"}}\n    IF1 --&gt;|False| X[\"on time\"]\n    IF1 --&gt;|True| Y[\"we are going to be late!\"]\n\n    style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nالمثال الثاني: القوائم وحلقات التكرار\nهذا المثال أكثر تعقيدًا نسبيًّا:\n\nنعرف سعر كل ثمرة في قائمة أسعار: fruit_prices\n\n\nfruit_prices = {\n    'apple': 0.5,\n    'banana': 0.25,\n    'orange': 0.75\n}\n\n\nنضع بعض المشتريات في السلة: basket\n\n\nbasket = ['apple', 'apple', 'apple', 'banana']\n\n\nنحسب سعر السلة كلها بحسب قائمة الأسعار: total_price\nنحتاج لاستعمال جملة الحلقة: for للمرور على كل عنصر في السلة\nنستعمل جملة الزيادة: += لزيادة الحاصل\nأخيرًا جملة تنفيذ لفعل الطباعة: print\n\n\ntotal_price = 0\n\nfor fruit in basket:\n    total_price += fruit_prices[fruit]\n\nprint(total_price)\n\n1.75",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#المزيدات",
    "href": "chapters/01_intro/introduction.html#المزيدات",
    "title": "1  لغة البرمجة",
    "section": "1.3 المزيدات",
    "text": "1.3 المزيدات\nمن خواص لغة البرمجة: إنشاء مركبات لغوية جديدة. وذلك بشيئين:\n\nتعريف الأفعال\nتعريف الأنواع\n\nفأضاف مطوروا بايثون أنفسهم إلى اللغة ما يسمى بالمكتبة الأساسية وهي على قسمين:\n\nمبنيات أساسية، وفيها:\n\nأفعال مبنية مثل: print, sum, max, min, len\nأنواع مبنية مثل: str, int, list\n\nوحدات أساسية، مثل:\n\nوحدة math التي تضم مجموعة أفعال تعنى بالعمليات الرياضية على الأعداد\nوحدة datetime التي تضم مجموعة أنواع وأفعال تعنى بالوقت والتاريخ\n\n\nوكونها مكتبة أساسية فهي تنزل وتثبت مع حزمة لغة بايثون نفسها.\n\nمثال الأفعال المبنية\n\nmy_list = [20, 10, 30, 40, 50, 20, 10, 20,\n           30, 40, 50, 60, 30, 20, 30, 40]\n\nفلمجموعة الأرقام عدد من الأفعال المبنية في لغة بايثون مثل:\n\nالجمع: sum\nالقيمة العليا: max\nالقيمة الدنيا: min\nعد العناصر: len\n\nنستعرضها هنا:\n\nprint('sum is:', sum(my_list))\nprint('max is:', max(my_list))\nprint('min is:', min(my_list))\n\navg = sum(my_list) / len(my_list)\nprint('average is:', avg)\n\nsum is: 500\nmax is: 60\nmin is: 10\naverage is: 31.25\n\n\nوغيرها كثير.\n\n\nمثال وحدة الرياضيات الأساسية\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nتعمل هذه القطعة كالتالي:\n\nجملة استيراد المكتبة الرياضية: import math\nتعريف النقطتين: x1, y1 = 0, 0 و x2, y2 = 3, 4\nحساب المسافة: distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) وفيه:\n\nx2 - x1 هو الفرق بين الإحداثيات السينية\ny2 - y1 هو الفرق بين الإحداثيات الصادية\n** هي عملية تربيع العدد\nmath.sqrt هي فعل حساب الجذر التربيعي\n\nطباعة النتيجة: print(distance) وفيه:\n\ndistance هو الناتج النهائي لحساب المسافة\nprint هي فعل تطبع الناتج على الشاشة\n\n\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\nويمكن كتابة قطع برمجية مخزَّنة بحدود يتم تعيينا لاحقها كما هو حال الدوال الرياضية التي تتغير نتيجتها بتغير مدخلاتها. كما في هذا المثال:\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\nprint(distance(x1=0, y1=0, x2=3, y2=4))\nprint(distance(x1=1, y1=1, x2=2, y2=2))\n\n5.0\n1.4142135623730951",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#المكتبات-المساهمة",
    "href": "chapters/01_intro/introduction.html#المكتبات-المساهمة",
    "title": "1  لغة البرمجة",
    "section": "1.4 المكتبات المساهمة",
    "text": "1.4 المكتبات المساهمة\nفهذه عملية الجذر التربيعي أتينا بها باستيراد الوحدة الأساسية math ثم أشرنا إلى الفعل sqrt المعرَّف ضمنها بالمعامل . (النقطة).\nوعدا الأساسيةِ؛ المساهمَة: نجدها في قاعدة بيانات PyPI التي تضم أكثر من 580,000 مشروع، أو غيرها من مواقع استضافة حزم بايثون. ويمكن تنزيلها وتثبيتها باستعمال: pip install package_name ومن ثم استعمال لغتها المزيدة بعد بجملة الاستيراد: import package_name على نحو ما فعلناه مع المكتبة الأساسية math.\nمدير الحزم pip هو أداة لتثبيت الحزم من فهرس حزم بايثون (Python Package Index - PyPI). هنا مثلاً صفحة حزمة numpy. على سبيل المثال، تختص حزمة numpy بالعمليات العددية (Numerical Python) على المصفوفات متعددة الأبعاد. وتعتبر هذه الحزمة أصلاً أساسيًّا لدى حزم كثيرة جدًّا في بايثون. ولنستخدمها نحن، يجب تثبيتها على النحو التالي:\npip install numpy\nبعد ذلك نستطيع استعمالها بعد جملة الاستيراد، لنجرب عملية الضربالنقطي بين مصفوفتين:\n\nimport numpy as np\n\nmat1 = np.array([\n    [1, 2],\n    [3, 4]\n])\n\nmat2 = np.array([\n    [5, 6],\n    [7, 8]\n])\n\nprint(np.dot(mat1, mat2))\n\n[[19 22]\n [43 50]]\n\n\nومن الحزم التي تبني على numpy حزمة pandas المتخصصة في تفكيك وتركيب الجداول والتحليلات الإحصائية عليها. ونحن إذا أردناها نستوردها ونستعملها:\npip install pandas\n\nimport pandas as pd\n\ndf = pd.read_csv('../../datasets/students.csv')\ndf\n\n\n\n\n\n\n\n\nName\nAge\nGrade\n\n\n\n\n0\nMohammed\n19\n88\n\n\n1\nAbdullah\n20\n95\n\n\n2\nAhmed\n21\n87\n\n\n3\nKhalid\n19\n92\n\n\n4\nSara\n20\n94\n\n\n5\nFatima\n22\n89\n\n\n6\nOmar\n21\n91\n\n\n7\nNorah\n20\n93\n\n\n8\nTurki\n19\n86\n\n\n9\nReem\n21\n90\n\n\n\n\n\n\n\nثم التحليل كالتالي:\n\ndf.describe(include=['number']).T\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\n\n\nAge\n10.0\n20.2\n1.032796\n19.0\n19.25\n20.0\n21.00\n22.0\n\n\nGrade\n10.0\n90.5\n3.027650\n86.0\n88.25\n90.5\n92.75\n95.0\n\n\n\n\n\n\n\nوهي من أشهر المكتبات المساهمة في تحليل البيانات المجدولة.\nوالمثال الأخير هو حزمة geopy المتخصصة في الإحداثيات المكانية على الأرض وما يتعلق بها من حسابات وبيانات. يبدوا استعمالها معقَّدًا؛ لكنك ستراه سهلاً فيما بعد:\npip install geopy\nfrom geopy.distance import geodesic\nfrom geopy.geocoders import Nominatim\n\ngeolocator = Nominatim(user_agent=\"exercise\")\n\ndammam_location = geolocator.geocode(\"Dammam, Saudi Arabia\")\nbahrain_location = geolocator.geocode(\"Bahrain\")\n\ndammam_coords = (dammam_location.latitude, dammam_location.longitude)\nbahrain_coords = (bahrain_location.latitude, bahrain_location.longitude)\n\n# Calculate the distance\ndistance = geodesic(dammam_coords, bahrain_coords).kilometers\nprint(f\"Between Dammam and Bahrain is {distance:.2f} km\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/01_intro/introduction.html#نمو-اللغة",
    "href": "chapters/01_intro/introduction.html#نمو-اللغة",
    "title": "1  لغة البرمجة",
    "section": "1.5 نمو اللغة",
    "text": "1.5 نمو اللغة\nفهنا دور المجتمع ليبني باللغة بمفرداتها وجملها ومكتبتها الأساسية والخارجية، ليبني فوق ذلك ما يخدم أغراضه. فاستطاع كل فئة من الناس تركيب حزمة جديدة مكونة من أشياء مركبة وأفعال مركبة يستفيدون هم في ذلك من حزم أناس آخرين ، ثم يوفرونها لغيرهم. وهكذا تنمو اللغة ، حزمةً تِلو الأخرى بحسب إسهامات كل مجتمع برمجي بما يهتم به.\nومن مكامن القوة في لغة بايثون: أنها متوافقة مع لغتي C/C++ إذْ يُمكن كتابة برمجيات عالية الأداء والكفاءة بهما مستفيدين من الحزم الموجودة فيهما، ثم توفيق ذلك ليكون كمكتبة في لغة بايثون.\nفالمجتمعات البرمجية في بايثون كثيرة ومتعددة في اهتماماتها. منها على سبيل المثال:\n\nتطوير مواقع الشبكة:\n\nDjango - لبناء مواقع متصلة بقواعد بيانات\nFastAPI - حديث وسريع لبناء واجهات برمجية على الشبكة\n\nالذكاء الاصطناعي وتعلم الآلة:\n\nstatsmodels - للنماذج الإحصائية\nscikit-learn - لاكتشاف الأنماط والتنبؤ (تعلم الآلة)\nPyTorch - لبناء نماذج التعلم العميق\n\nتصوير البيانات:\n\nseaborn - تصور البيانات الإحصائية على أساس Matplotlib.\nmatplotlib - مكتبة شاملة لإنشاء تصورات ثابتة ومتحركة وتفاعلية.\n\nالتحليل الرياضي والهندسة:\n\nsympy - للرياضيات الرمزية.\nPySR - الانحدار الرمزي.\nSciPy - للرياضيات والعلوم والهندسة.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>لغة البرمجة</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html",
    "href": "chapters/02_numbers/a_numbers.html",
    "title": "2  الأعداد",
    "section": "",
    "text": "2.1 الحساب والمقارنة\nx = 5\ny = 10\n\nprint(x + y) # الجمع\nprint(x - y) # الطرح\nprint(x * y) # الضرب\nprint(x / y) # القسمة\nprint(x % y) # باقي القسمة\nprint(x ** y) # الأس\n\n15\n-5\n50\n0.5\n5\n9765625\nالمقارنة بين الأعداد:\nx = 5\ny = 10\n\nprint(x == y) # التطابق\nprint(x != y) # الاختلاف\nprint(x &gt; y) # أكبر\nprint(x &lt; y) # أصغر\nprint(x &lt;= y) # أصغر أو يساوي\nprint(x &gt;= y) # أكبر أو يساوي\n\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "href": "chapters/02_numbers/a_numbers.html#ترتيب-العمليات",
    "title": "2  الأعداد",
    "section": "2.2 ترتيب العمليات",
    "text": "2.2 ترتيب العمليات\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\nإليك ثلاثة أمثلة لترى أثر وضع الأقواس من عدمه. ولاحظ أننا نستعمل جملة التوكيد (assert) التي تسكُت إن كان الشيء الذي أمامها جملة منطقية صحيحة؛ وإلا فهي تظهر رسالة خطأ. وسترى أننا نستعملها بكثرة لتقرير لوازم ما نبينه في الدرس:\n\nassert 3 + 2 * 5 == 13\nassert (3 + 2) * 5 == 25\n\n\nassert 8 - 4 / 2 == 6\nassert (8 - 4) / 2 == 2\n\n\nassert 2 ** 3 * 4 == 32\nassert (2 ** 3) * 4 == 32",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "href": "chapters/02_numbers/a_numbers.html#التعيين-النسبي",
    "title": "2  الأعداد",
    "section": "2.3 التعيين النسبي",
    "text": "2.3 التعيين النسبي\nيراجع: التعيين النسبي.\nلأن التعيين النسبي يستعمل بكثرة، فوجب علينا التعرف عليه، وأحيانًا نحتاج لاستعماله. فجمل التعيين التالية متكافئة:\n\ni = i + 1 تعادل i += 1\ni = i - 1 تعادل i -= 1\ni = i * 2 تعادل i *= 2\ni = i / 2 تعادل i /= 2\n\nجرب الكود أدناه لترى النتيجة:\n\ni = 0\ni = i + 1\ni += 1\nprint(i)\n\n2\n\n\nلاحظ أن i++ تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:\n\ni++\nprint(i)\n\n\n  Cell In[7], line 1\n    i++\n       ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات",
    "href": "chapters/02_numbers/a_numbers.html#وحدة-الرياضيات",
    "title": "2  الأعداد",
    "section": "2.4 وحدة الرياضيات",
    "text": "2.4 وحدة الرياضيات\n\nimport math\n\nx = 5.4\n\nكل هذه الطرق الثلاث يتم فيها حساب الأس:\n\nالأولى pow فعل مبني\nالثانية math.pow فعل من وحدة الرياضيات\nالثالثة x ** 2 عن طريق المعامل **\n\n\\[\nx^2 = x \\times x\n\\]\n\nassert(\n    pow(x, 2) ==\n    math.pow(x, 2) ==\n    x ** 2 ==\n    x * x\n)\n\nوكذلك الجذر التربيعي:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\n\nالأولى math.sqrt فعل من وحدة الرياضيات\nالثانية x ** 0.5 عن طريق المعامل **\n\n\nassert (\n    math.sqrt(x) ==\n    x ** 0.5\n)\n\nتقريب لأقرب عدد صحيح أصغر:\n\\[\n\\text{floor}(x) = \\lfloor x \\rfloor\n\\]\n\nmath.floor(x)\n\n5\n\n\nتقريب لأقرب عدد صحيح أكبر:\n\\[\n\\text{ceil}(x) = \\lceil x \\rceil\n\\]\n\nmath.ceil(x)\n\n6\n\n\nحذف ما بعد الفاصلة:\n\nmath.trunc(x)\n\n5\n\n\nتقريب إلى رقمين بعد الفاصلة:\n\nround(x, 2)\n\n5.4\n\n\nملاحظة: الفعل الأخير round ليس مستوردًا من math وإنما هو مُضمَّن في النطاق العام؛ لذا لا تحتاج لاستيراد شيء. قد تتساءل عن وجود سبب منطقي. لكنني أقول لك: هو سبب واقعي بسبب ظروف تطوير اللغة؛ لا أكثر ولا أقل.",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "href": "chapters/02_numbers/a_numbers.html#مجموعة-الأعداد",
    "title": "2  الأعداد",
    "section": "2.5 مجموعة الأعداد",
    "text": "2.5 مجموعة الأعداد\nأما التعامل مع المجموعات (كمجموعة الأعداد) فسيأتي في باب المجموعات المرتبة. لكننا نعرض لمثال بسيط للتعامل مع المجموعات العددية:\n\nxs = [10, 20, 30, 40, 50]\n\nتوفر بايثون الدوال التالية للمجموعة العددية:\n\nالطول (عدد العناصر): len (من كلمة length)\nمجموع العناصر: sum\nالعنصر الأكبر: max\nالعنصر الأصغر: min\n\n\nprint('length:', len(xs))\nprint('total:', sum(xs))\nprint('average:', sum(xs) / len(xs))\nprint('maximum:', max(xs))\nprint('minimum:', min(xs))\n\nlength: 5\ntotal: 150\naverage: 30.0\nmaximum: 50\nminimum: 10\n\n\n\nالإحصاء\nونستعرض مجموعة من الدوال في مكتبة الإحصاء الأساسية في بايثون، منها:\n\nالمتوسط الحسابي: statistics.mean\nالوسيط: statistics.median\nالمنوال: statistics.mode\nالانحراف المعياري: statistics.stdev\n\n\nimport statistics\n\nxs = [\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20,\n    20, 21, 22, 23, 20, 22, 20,\n    18, 24, 18, 21, 23, 19, 20\n]\n\nprint('mean:', statistics.mean(xs))\nprint('median:', statistics.median(xs))\nprint('mode:', statistics.mode(xs))\nprint('standard deviation:', statistics.stdev(xs))\n\nmean: 20.785714285714285\nmedian: 20.5\nmode: 20\nstandard deviation: 1.8126539343499315",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "href": "chapters/02_numbers/a_numbers.html#أنواع-العدد-في-بايثون",
    "title": "2  الأعداد",
    "section": "2.6 أنواع العدد في بايثون",
    "text": "2.6 أنواع العدد في بايثون\n\nالعدد الصحيح (int)\nالقيمة المنطقية (bool)\nالعدد العشري (float)\nالعدد المركب (complex)\n\nصفة العددية تجوِّز العمليات بينها من جمع وطرح وقسمة ومقارنة. فالفعل فيه تفصيل تتكفل به بايثون عنك إذْ تمثيلها الداخلي في الحقيقة مختلف.\nفالتمثيل الداخلي للأعداد له أثر:\n\nفي مساحة التخزين\nدقة العدد؛ وبالتالي صحة الحساب\nسرعة الحساب\n\nلكننا في هذه المرحلة لن نخوض في هذه التفاصيل. وإنما أردنا بيان وجه الاختلاف بينها وسبب تعدد أنواع العدد في بايثون ولغات البرمجة عمومًا.\n\nالعدد الصحيح\nالوظيفة: الفهرسة والعد والترتيب والزيادة والنقصان والفرق ونحو ذلك\n\nage = 20\nlevel = 3\nindex = -2\nstart, end = -5, 10\nleft, middle, right = 3, 5, 7\n\nيؤتى بالفعل type لمعرفة نوع المتغير:\n\nassert int == type(age) \nassert int == type(level) \nassert int == type(index) \nassert int == type(start) == type(end)\nassert int == type(left) == type(middle) == type(right)\n\nالمجال: يختلف مجال العدد الصحيح باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:\n\nيعبر الرمز \\(\\mathbb{Z}\\) عن مجموعة العدد الصحيح\n8-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^7 \\leq x &lt; 2^7\\} = \\{-128, \\ldots, 127\\}\\)\n16-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{15} \\leq x &lt; 2^{15}\\} = \\{-32768, \\ldots, 32767\\}\\)\n32-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{31} \\leq x &lt; 2^{31}\\} = \\{-2147483648, \\ldots, 2147483647\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{63} \\leq x &lt; 2^{63}\\} = \\{-9223372036854775808, \\ldots, 9223372036854775807\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{Z} \\mid -2^{127} \\leq x &lt; 2^{127}\\} = \\{-170141183460469231731687303715884105728, \\ldots, 170141183460469231731687303715884105727\\}\\)\n\n\n\n\n\n\n\nملاحظة\n\n\n\n\n\nلاحظ أن سبب محدودية ذاكرة الأجهزة القديمة لـ4GB بايت يعود لكون معمارية الجهاز محددة بـ32-بت. ثم لما طورت المعمارية إلى 64-بت أصح حد الذاكرة: 17,179,869,184 GB (16 exabytes)\n\n\n\n\n\nالقيمة المنطقية\nوهي كناية عن مجموعة مشتملة هي العددان: \\(\\{0, 1\\}\\) الذيان يمثل لهما بالكلمتين: True و False وذلك لتبيين وظيفتهما المنطقية.\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nالوظيفة: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء.\nنلجئ الكلام عنها إلى باب الشرط والتكرار.\n\n\nالعدد العشري\nالوظيفة: تمثيل الكميات مثل المال، المسافة، والوقت\n\ndistance = 100.0\nprice = 10.5\ntime = 1.5\ntemperature = 36.6\ndifference = 0.001\n\nنفحص أنواعها:\n\nassert float == type(distance)\nassert float == type(price)\nassert float == type(time)\nassert float == type(temperature)\nassert float == type(difference)\n\nالمجال: يختلف مجال العدد العشري باختلاف البتات التي يتم استعمالها في تمثيله؛ لكن بايثون تستعمل العدد المناسب للبتات من غير علم المستخدم بذلك؛ لكن سنسردها هنا للعلم:\n\nيعبر الرمز \\(\\mathbb{R}\\) عن مجموعة العدد العشري\n32-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{31} \\leq x &lt; 2^{31}\\} = \\{-3.4 \\times 10^9, \\ldots, 3.4 \\times 10^9\\}\\)\n64-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{63} \\leq x &lt; 2^{63}\\} = \\{-1.8 \\times 10^{19}, \\ldots, 1.8 \\times 10^{19}\\}\\)\n128-بت: \\(\\{x \\in \\mathbb{R} \\mid -2^{127} \\leq x &lt; 2^{127}\\} = \\{-1.2 \\times 10^{38}, \\ldots, 1.2 \\times 10^{38}\\}\\)",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "href": "chapters/02_numbers/a_numbers.html#اختلاف-نوع-العدد",
    "title": "2  الأعداد",
    "section": "2.7 اختلاف نوع العدد",
    "text": "2.7 اختلاف نوع العدد\nإذا اختلف النوع تُقدَّرُ الترقيةُ للأشمل، وذلك بحسب ناتج العملية:\n\nجمع صحيح وعشري = عشري: int + float = float\nقسمة صحيح على صحيح = عشري (لأننا نحتاج للفواصل): int / int = float\nالقسمة الصحيحة بين صحيح وصحيح = صحيح: int // int = int\n\nالمثال الأول: جمع عدد صحيح وعدد عشري:\n\na = 1 + 1.0\nprint(a)\nassert type(a) == float\n\n2.0\n\n\nالمثال الثاني: قسمة عدد صحيح على عدد عشري:\n\nc = 1 / 2\nprint(c)\nassert type(c) == float\n\n0.5\n\n\nالمثال الثالث: استعمال القسمة الصحيحة //:\n\nb = 1 // 2\nprint(b)\nassert type(b) == int\n\n0",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "href": "chapters/02_numbers/a_numbers.html#الفرق-بين-النوع-العددي-والنوع-النصي-للعدد",
    "title": "2  الأعداد",
    "section": "2.8 الفرق بين النوع العددي والنوع النصي للعدد",
    "text": "2.8 الفرق بين النوع العددي والنوع النصي للعدد\nتأمل المتغيرين\n\na = 50\nb = '50'\n\n\nالأول: عدد صحيح (int)\nالثاني: حرفان (str)\n\nنستعمل جمل التوكيد لبيان ذلك:\n\nassert not (a == b)\nassert type(a) != type(b)\nassert type(a) == int\nassert type(b) == str\n\nومقتضى ذلك: امتناع عملية الجمع: a + b\n\n'5' + 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 '5' + 5\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nبل يجب التحويل أولاً باستعمال الفعل int الذي يفسر الأحرف كعدد صحيح:\n\na = 5\nb = '5'\n\nb = int(b)\n\nassert a + b == 10",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "href": "chapters/02_numbers/a_numbers.html#كتابة-القيم-العددية",
    "title": "2  الأعداد",
    "section": "2.9 كتابة القيَم العددية",
    "text": "2.9 كتابة القيَم العددية\nالحروفيَّة هي رموز للقيم لبعض الأنواع المدمجة. مثال: 42 هو حرفيُّ عدد صحيح و 3.14 هو حرفيُّ عدد عشري.\nوتخصيص الحرفيّ True للعدد 1 و False للعدد 0 ليس من قبيل الضرورة في اللغة وإنما من قبيل التسهيل (وفوق ذلك فإن بايثون تجعل له نوعًا خاصًّا وعمليات مصاحبة).\n\nassert True  == bool(1) == 1\nassert False == bool(0) == 0\n\nكذلك خصصت بايثون e أو E للترميز العلمي (وجاء الحرف e من كلمة: Exponent) المخصص للأعداد العشرية الكبيرة والصغيرة.\n\nassert 1e2 == 100\nassert 1e9 == 1E9\nassert 1e-4 == 0.0001\n\nويجوز استعمال الشرطة السفلية _ لفاصلة الألوف:\n\nassert 1_000_000 == 1000000\n\nوأما إن كنت تهتم بالتمثيل الثنائي أو الثماني أو الست عشري فذلك أيضًا له تعبيرات مخصصة:\n\n0b أو 0B للأرقام الثنائية\n0o أو 0O للأرقام الثمانية\n0x أو 0X للأرقام الست عشرية\n\nوإليك تطبيق ذلك:\n\nassert 0b1010 == 10\nassert 0o10 == 8\nassert 0x10 == 16\n\nوأخيرًا يمكن استعمال j أو J للأعداد المركبة:\n\nassert 1 + 2j == 2j + 1",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/a_numbers.html#خلاصة",
    "href": "chapters/02_numbers/a_numbers.html#خلاصة",
    "title": "2  الأعداد",
    "section": "2.10 خلاصة",
    "text": "2.10 خلاصة\nعرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ويتعذر حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.\nننتقل الآن لباب الشرط والتكرار حيث الجمل الشرطية والتعيين المشروط.",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html",
    "href": "chapters/02_numbers/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "معادلة مساحة المكعب\nلا يلزمنا اشتقاق هذه المعادلات؛ لكن نستعمل النتائج التي خرج بها أهل الرياضيات فنعوض هذه المتغيرات بالقيم التي نريد لنتحصل على الناتج.\nاكتب برنامجًا يحسب مساحة المكعب وفق المعادلة:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\nwidth = 3\nlength = 4\nheight = 5\n\narea = width * length * height\nprint(area)\n\n60",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "href": "chapters/02_numbers/apps.html#معادلة-تحويل-وحدة-إلى-وحدة-أخرى",
    "title": "تطبيقات",
    "section": "معادلة تحويل وحدة إلى وحدة أخرى",
    "text": "معادلة تحويل وحدة إلى وحدة أخرى\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n\nc = 32\nf = (9 / 5) * c + 32\n\nprint('Celsius:', c)\nprint('Fahrenheit:', f)\n\nCelsius: 32\nFahrenheit: 89.6",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "href": "chapters/02_numbers/apps.html#معادلة-مساحة-الدائرة",
    "title": "تطبيقات",
    "section": "معادلة مساحة الدائرة",
    "text": "معادلة مساحة الدائرة\nاكتب برنامجًا لحساب مساحة الدائرة وفق المعادلة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nimport math\n\nradius = 5\narea = math.pi * radius**2\nprint(area)\n\n78.53981633974483\n\n\nملاحظة:\n\nتم استعمال radius ** 2 بدلاً من الفعل math.pow(radius, 2) لتربيع العدد.\nكذلك يجوز استعمال x ** 0.5 بدلاً من الفعل math.sqrt(x) لحساب الجذر التربيعي.",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "href": "chapters/02_numbers/apps.html#معادلة-طول-الخط-المستقيم-بين-نقطتين",
    "title": "تطبيقات",
    "section": "معادلة طول الخط المستقيم بين نقطتين",
    "text": "معادلة طول الخط المستقيم بين نقطتين\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/apps.html#نسبة-التغير",
    "href": "chapters/02_numbers/apps.html#نسبة-التغير",
    "title": "تطبيقات",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كان معدل قراءتك في الأسبوع الثاني 15 دقيقة، وكان معدل قراءتك في الأسبوع الأول 10 دقائق، فكم نسبة الزيادة في معدل قراءتك؟\n\nweek1 = 10\nweek2 = 15\n\npercentage = (week2 - week1) / week1\nprint(percentage * 100, '%')\n\n50.0 %",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html",
    "href": "chapters/02_numbers/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "كم سيكون عمرك عند حين كذا؟",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-عند-حين-كذا",
    "href": "chapters/02_numbers/problems.html#كم-سيكون-عمرك-عند-حين-كذا",
    "title": "مسائل",
    "section": "",
    "text": "عرف تاريخ الحدث المستقبلي بالسنوات: future_date\nعرف تاريخ اليوم: today\nعرف المتغير: age\nاحسب عمرك عند حصول الحدث: age_then\nاطبع النتيجة: print(age_then)",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الأجر",
    "href": "chapters/02_numbers/problems.html#حساب-الأجر",
    "title": "مسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nعدد ساعات العمل: hours\nمعدل الأجر لكل ساعة: per_hour_rate\nاحسب الأجر الذي تستحقه بناءً على عدد الساعات ومعدل الأجر: gross_pay\nاطبع النتيجة: print(gross_pay)",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/problems.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "مسائل",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nسرعة السيارة: speed\nالمسافة: distance\nاحسب الزمن المستغرق للوصول إلى المكان المعيَّن بناءً على السرعة والمسافة: time\nاطبع النتيجة: print(time)",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/problems.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "مسائل",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\n\n\nمثلث\n\n\nباستخدام معادلة هيرون:\n\\[\n\\text{area} = \\sqrt{s (s - a) (s - b) (s - c)}  \n\\]\nحيث:\n\n\\(a\\), \\(b\\), \\(c\\) هي أطوال أضلاع المثلث\nنصف المحيط:\n\n\\[\ns = \\frac{a + b + c}{2}\n\\]\n\na = 3\nb = 4\nc = 5",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#نسبة-التغير",
    "href": "chapters/02_numbers/problems.html#نسبة-التغير",
    "title": "مسائل",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/problems.html#التغير-النسبي",
    "href": "chapters/02_numbers/problems.html#التغير-النسبي",
    "title": "مسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\nمساعدة: فكك العبارة واجعلها في متغيرات، وضع لكل أسبوعٍ متغيِّرًا يعتمد على الأسبوع الذي قبله.",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html",
    "href": "chapters/02_numbers/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "كم سيكون عمرك عند حين كذا؟\nfuture_date = 2050\ntoday = 2024\nage = 20\nage_then = age + (future_date - today)\nprint('you will be', age_then, 'years old in', future_date)\n\nyou will be 46 years old in 2050",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "href": "chapters/02_numbers/solutions.html#حساب-الأجر",
    "title": "حل المسائل",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\nhours = 40\nper_hour_rate = 10\ngross_pay = hours * per_hour_rate\nprint('you deserve:', gross_pay, 'SAR')\n\nyou deserve: 400 SAR",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "href": "chapters/02_numbers/solutions.html#حساب-الزمن-المستغرق-للوصول-إلى-مكان-معين",
    "title": "حل المسائل",
    "section": "حساب الزمن المستغرق للوصول إلى مكان معيَّن",
    "text": "حساب الزمن المستغرق للوصول إلى مكان معيَّن\n\nspeed = 100\ndistance = 200\ntime = distance / speed\nprint('it will take you', time, 'hours to reach the destination')\n\nit will take you 2.0 hours to reach the destination",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "href": "chapters/02_numbers/solutions.html#حساب-ارتفاع-المثلث-عن-طريق-أطوال-أضلاعه",
    "title": "حل المسائل",
    "section": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه",
    "text": "حساب ارتفاع المثلث عن طريق أطوال أضلاعه\n\nimport math\n\na = 3\nb = 4\nc = 5\n\ns = (a + b + c) / 2\narea = math.sqrt(s * (s - a) * (s - b) * (s - c))\nh = 2 * area / c\nprint('the height of the triangle is', h)\n\nthe height of the triangle is 2.4",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "href": "chapters/02_numbers/solutions.html#نسبة-التغير",
    "title": "حل المسائل",
    "section": "نسبة التغير",
    "text": "نسبة التغير\nإذا كنت تصرف في الشهر 1,000 ريال لقضاء حاجياتك، ثم اتبعت استراتيجية معينة، وأردت أن تحسب نسبة التغير في مصروفك، فكيف تعرف النسبة إذا نزلت إلى 650 ريال؟\n\nold_expense = 1000\nnew_expense = 650\n\npercentage = (new_expense - old_expense) / old_expense\nprint(percentage * 100, '%')\n\n-35.0 %",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "href": "chapters/02_numbers/solutions.html#الزيادة-النسبية",
    "title": "حل المسائل",
    "section": "الزيادة النسبية",
    "text": "الزيادة النسبية\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الرابع؟\n\nincrement = 1.10\n\nw1 = 20\nw2 = w1 * increment\nw3 = w2 * increment\nw4 = w3 * increment\n\nprint(round(w4, 1))\n\n26.6",
    "crumbs": [
      "باب الأعداد (Numbers)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html",
    "href": "chapters/03_control_flow/a_control_flow.html",
    "title": "3  الشرط والتكرار",
    "section": "",
    "text": "3.1 الجملة الشرطية\nيسير تنفيذ الجمل البرمجية في اللغات الإجرائية -مثل بايثون- من الأعلى للأسفل. فإذا كتبنا الكود التالي:\nفإن جملة التعيين التالية تكتُب قيمة 2 في نفس المحلّ الذي كتبت عليه جملة التعيين الأولى 1. لذا ظهرت النتيجة: 2.\nكثيرًا ما نحتاج للتحكم فيما يُنفَّذ وما يُهمل أو ما يتكرر من الجمل البرمجية. فمن الحالات التي يتغير فيها الترتيب:\nالجملة الشرطية هي جملة مركَّبة من كلمة if وتعبير منطقي ثم الجمل التي يتعلق تنفيذها بناءً على هذا الشرط (وتكون داخل المحاذاة):",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية",
    "title": "3  الشرط والتكرار",
    "section": "",
    "text": "flowchart TD\n    IF{{if cond}} -- False --&gt; X[\"Outside\"]\n    IF -- True --&gt; Y[\"Inside\"]\n\n  style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ncond = True\nif cond:\n    print('Inside')\nprint('Outside')\n\nInside\nOutside\n\n\n\n\n\nتنبيه: المحاذاة العمودية\nلاحظ أن المحاذاة العمودية (Indentation) (المسافات البيضاء أسفل كلمة if) في الكود أعلاه ليست لمجرد تسهيل قراءة الكود، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال الكود.\nلاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في الكود:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    Y[\"Inside\"] --&gt; X[\"Outside\"]\n    style IF fill:#fc0000, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[3], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل الكود بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if True}}\n    IF -- True --&gt; Y[\"Inside\"] --&gt; X[\"Outside\"]\n    \n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n\n\n\n\n\n\n\n\nif True:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\n\n\nيؤدي الكود السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في كتابة كود بايثون!",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التعبيرات-المنطقية",
    "href": "chapters/03_control_flow/a_control_flow.html#التعبيرات-المنطقية",
    "title": "3  الشرط والتكرار",
    "section": "3.2 التعبيرات المنطقية",
    "text": "3.2 التعبيرات المنطقية\nأما الشروط فتستند إلى المنطق الرقمي الثنائي الذي نجد له في بايثون كلمتين من أصل اللغة هما:\n\nكلمة True (وتساوي الرقم 1) وتعبِّر عن تحقق الفعل\nكلمة False (وتساوي الرقم 0) وتعبِّر عن عدم التحقق الفعل\n\nوكلاهُما يندرج تحت نوع خاصّ من نوع الأرقام وهو النوع الثنائي (bool).\nأما الجملة الشرطية أو التعيين الشرطي ونحوه، فيتعلَّق بتحقق عبارة منطقية. فمن العبارات المنطقية: عبارة المقارنة:\n\n\n\nالعلامة\nالوصف\n\n\n\n\na == b\nيساوي\n\n\na != b\nلا يساوي\n\n\na &gt; b\nأكبر من\n\n\na &lt; b\nأصغر من\n\n\na &gt;= b\nأكبر من أو يساوي\n\n\na &lt;= b\nأصغر من أو يساوي\n\n\n\nهنا نستكشف عبارات تؤول إلى قيَم منطقية. العبارة الأولى: خمسة أكبر من تسعة؟\n\nb1 = 5 &gt; 9\nprint(type(b1))\nprint(b1)\n\n&lt;class 'bool'&gt;\nFalse\n\n\nالعبارة الثانية: هل طول كذا أكبر من طول كذا؟\n\nb2 = len('12345') &gt; len('123456789')\nprint(b2)\n\nFalse\n\n\n\nتركيب الشروط\nيجوز دمج عدة شروط بعمليات الجمع والتخيير والحصر والعكس، فناتجها منطقي:\n\n\n\nA\nB\nAND\nOR\nXOR\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n\n\nالجمع: AND (و): تخرج 1 فقط إذا كان كلا المدخلين 1.\nالتخيير: OR (أو): تخرج 1 إذا كان أحد المدخلين على الأقل 1.\nالحصر: XOR (أو الحصرية): تخرج 1 إذا كان المدخلان مختلفين.\nالعكس: NOT (ليس): تخرج عكس المدخل (1 يصبح 0، و0 يصبح 1).\n\nعلى سبيل المثال:\n\nage = 20\nweight = 50\n\nif age &gt; 18 and weight &gt; 45:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nتستعمل الأقواس لتجميع الشروط لإيقاع الترتيب المنطقي المراد:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\nيُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون True أو False ولا بأس بتجزئته حينما يسهل بذلك الفهم:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\n\nif is_minor or (is_cold and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\n\nتسلسل المقارنات\nتفهم بايثون المقارنات المتسلسلة. فعبارة x &lt; y &lt;= z تكافئ x &lt; y and y &lt;= z:\n\nlow = 10\nhigh = 20\nx = 15\n\nassert (low &lt; x &lt; high) == (low &lt; x and x &lt; high)\n\nكذلك تراها تستعمل في المساواة:\n\nassert 3 == len('123') == len([10, 20, 30]) == len('abc')",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "href": "chapters/03_control_flow/a_control_flow.html#الجملة-الشرطية-المتكاملة",
    "title": "3  الشرط والتكرار",
    "section": "3.3 الجملة الشرطية المتكاملة",
    "text": "3.3 الجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if condition_1}}\n    IF -- False --&gt; ELIF{{elif condition_2}}\n    IF -- True --&gt; code_1\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; code_2\n    ELSE --&gt; code_3\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\n\nكلمة if (إذا) تبدأ الجملة المركبة الشرطية\nقد توجد else (وإلا) مرة. وهي تعمل عند تخلُّف العبارة المنطقية السابقة لها سواءً كانت السابقة لها if أو elif.\nوقد توجد elif بينهما مرة أو أكثر (وهي اختصار لكلمة else if وتعني: وإلا فإن)، فتعمل مثل else معلَّقة بعبارة منطقية مثل if.\n\n\nجرب\nاستكشف المنطق التالي بتغيير قيمة x كل مرة للتبع ما يحصل في كل مرة:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Set to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nSet to zero\nAlways: 0\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if x &lt; 0}}\n    IF -- False --&gt; ELIF{{elif x == 0}}\n    IF -- True --&gt; S1[x = 0] --&gt; S2[\"Set to zero\"]\n    ELIF -- False --&gt; ELSE{{else}}\n    ELIF -- True --&gt; S3[x = 1] --&gt; S4[\"Single\"]\n    ELSE --&gt; S5[\"More\"]\n\n    Always[Always: x]\n    S2 --&gt; Always\n    S4 --&gt; Always\n    S5 --&gt; Always\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELIF fill:#82aeff, stroke:#333, stroke-width:2px;\n    style ELSE fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0,3 color:red;\n\n\n\n\n\n\nوهذا تصوير لسير الأفعال لنفس الكود. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الفعلية:\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "href": "chapters/03_control_flow/a_control_flow.html#جملة-التعيين-المشروط",
    "title": "3  الشرط والتكرار",
    "section": "3.4 جملة التعيين المشروط",
    "text": "3.4 جملة التعيين المشروط\nتستطيع في بايثون أن تجعل جملة التعيين تأخذ قيمتها بحسب شرطٍ معين. مثلاً:\n\n\n\n\n\n\n\nflowchart TD\n    IF{{if age &gt; 14}}\n    IF -- False --&gt; S2[\"status = 'child'\"]\n    IF -- True --&gt; S1[\"status = 'adult'\"]\n\n    style IF fill:#82aeff, stroke:#333, stroke-width:2px;\n    linkStyle 0 color:red;\n\n\n\n\n\n\n\n\nage = 18\nstatus = 'adult' if age &gt; 14 else 'child'\n\nprint(status)\n\nadult\n\n\n\n\nوهي مكافئة للكود التالي:\n\nage = 18\n\nif age &gt; 14:\n  status = 'adult'\nelse:\n  status = 'child'\n\nprint(status)\n\nadult\n\n\nويحصل تسلسل التعيين المشروط بالصيغة التالية:\n\n\n\n\n\n\n\nflowchart TD\n  S1[\"score = 75\"] --&gt; IF1\n  IF1{{if score &gt;= 90}} -- True --&gt; A[\"grade = 'A'\"]\n  IF1 -- False --&gt; IF2{{if score &gt;= 80}} -- True --&gt; B[\"grade = 'B'\"]\n  IF2 -- False --&gt; C[\"grade = 'C'\"]\n  \n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 2,4 color:red;\n\n\n\n\n\n\n\n\nscore = 75\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\"\nprint(grade)\n\nC",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "href": "chapters/03_control_flow/a_control_flow.html#تضمين-الجمل-الشرطية",
    "title": "3  الشرط والتكرار",
    "section": "3.5 تضمين الجمل الشرطية",
    "text": "3.5 تضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\n\n\n\n\n\n\n\nflowchart TD\n  IF1{{if condition_1}}\n  IF1 -- False --&gt; ELSE1\n  IF1 -- True --&gt; IF2{{if condition_2}}\n  IF2 -- False --&gt; code_2\n  IF2 -- True --&gt; code_1\n  ELSE1[code_3]\n\n  style IF1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style IF2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0,2 color:red;\n\n\n\n\n\n\n\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\n\n\nننبه مرة أخرى أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\nمثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+\n\n\nوهذا تصوير له:",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "href": "chapters/03_control_flow/a_control_flow.html#التكرار",
    "title": "3  الشرط والتكرار",
    "section": "3.6 التكرار",
    "text": "3.6 التكرار\nحلقة التكرار: هي الرجوع بالتنفيذ لجملة سابقة (غالبًا تكون سطرًا سابقًا) وذلك يحصل عددًا من المرات أو معلَّقًا بشرط.\nفللتكرار طريقتان:\n\nسرد متوالية (for): حيث يعيَّن متغير التكرار لكل عنصر في المتوالية، واحدًا تلوَ الآخر. (وسيأتي ذكره في باب المتسلسلات)\nالتكرار بشرط (while): حيث يستمر التكرار مادام الشرط متحققًا. (وهو موضوع هذا القسم)\n\n\nالتكرار بشرط\nنبدأ بالتكرار بالطريقة غير المحددة، وهي جُملة تبدأ بالكلمة while على النحو التالي. كأنها if متكررة إلى حين تخلُّف الشرط (أن يصبح False). وإن لم يتحقق الشرط أصلاً فلا ينفذ الكود المضمَّن أصلا:\n\n\n\n\n\n\n\nflowchart TD\n  WHILE{{while condition}}\n  WHILE -- False --&gt; END\n  WHILE -- True --&gt; S1[code] --&gt; WHILE\n  \n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\nwhile &lt;boolean expression&gt;:\n    &lt;code&gt;\n\n\nمثال:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; S3[\"Done\"]\n  WHILE -- True --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 0 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n3\n4\nDone\n\n\n\n\nلنقم بتتبع الخطوات عندما تكون i = 0:\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\nوهذا تصوير لسير الأفعال لنفس الكود. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الفعلية:\n\n\nلاحظ أن نسيان جملة الزيادة (i += 1) يجعل الشرط دائمًا صحيحًا، فيدور البرنامج في حقلة لا نهيائة ولا يخرج أبدًا. ويعتبر هذا خطأ برمجيًّا يتعذر على الكود التعامل معه بنفسه؛ بل يجب على المبرمج أن يكتشفه.\n\n\nالخروج من الحلقة\n\nتستخدم كلمة break لإيقاف عملية التكرار كلها.\nتستخدم كلمة continue للانتقال إلى الكرة التالية متخطيةً بقية الخطوات في الكرة الحالية.\n\nأولاً نمثل لاستعمال جملة break على النحو التالي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- break --&gt; Done\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,4 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\n\n\n\n\nوهذا مثال لاستخدام عبارة continue للتخطي:\n\n\n\n\n\n\n\nflowchart TD\n  S0[\"i = 0\"] --&gt; WHILE{{\"while i &lt; 5\"}}\n  WHILE -- False --&gt; Done[\"Done\"]\n  WHILE -- True --&gt; IF1{{\"if i == 3\"}}\n  IF1 -- continue --&gt;  WHILE\n  IF1 -- False --&gt; S1[\"print(i)\"] --&gt; S2[\"i += 1\"] --&gt; WHILE\n\n  style WHILE fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 1,4 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\n\n\n\n\nأما جملة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط، ولا يتوقف الخارجي. وهذا مثال:\n\n\n\n\n\n\n\nflowchart TD\n  INIT1[\"i = 0\"] --&gt; WHILE1\n  WHILE1{{\"while i &lt; 3\"}}\n    S3[\"i += 1\"] --&gt; WHILE1\n    WHILE1 -- True --&gt; INIT2[\"j = 0\"] --&gt; WHILE2\n    WHILE2{{\"while j &lt; 3\"}}\n      WHILE2 -- True --&gt; IF1{{\"if i == 1\"}} -- break --&gt; WHILE1\n      IF1 -- False --&gt; S1[\"print(i, j)\"] --&gt; S2[\"j += 1\"] --&gt; WHILE2\n    WHILE2 -- False --&gt; S3\n\n  style WHILE1 fill:#82aeff, stroke:#333, stroke-width:2px;\n  style WHILE2 fill:#82aeff, stroke:#333, stroke-width:2px;\n  linkStyle 5,8 color:red;\n\n\n\n\n\n\n\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الشرط والتكرار</span>"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html",
    "href": "chapters/03_control_flow/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "حساب مجموع الأعداد المدخلة",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "href": "chapters/03_control_flow/apps.html#حساب-مجموع-الأعداد-المدخلة",
    "title": "تطبيقات",
    "section": "",
    "text": "استخدم الفعل input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nأضف العدد إلى المجموع الكلي: total\nاستمر في الدوران إلى أن يدخل المستخدم العدد 0 .. عندها قم بإنهاء الحلقة بالكلمة break\n\ntotal = 0\n\nwhile True:\n  number_in = input(\"Enter a number: \")\n  number = int(number_in)\n  total += number\n  if number == 0:\n    break\nprint(total)",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حجرة-ورقة-مقص",
    "href": "chapters/03_control_flow/apps.html#حجرة-ورقة-مقص",
    "title": "تطبيقات",
    "section": "حجرة ورقة مقص",
    "text": "حجرة ورقة مقص\nفي هذا المثال بعض الجمل التي لم نتعرف عليها بعد، ولكن لعل السياق يوضح معناها:\n\nuser_move not in [\"rock\", \"paper\", \"scissors\"] تغنينا عن جملة شرطية من ثلاثة مقارنات:\n\nif user_move != \"rock\" and user_move != \"paper\" and user_move != \"scissors\"\n\nrandom.choice([\"rock\", \"paper\", \"scissors\"]) تختار عشوائيًا عنصرًا من القائمة وتضعه في المتغير computer_move\nmatch هي جملة تحل محل if وelif وelse\n\nimport random\n\nprompt = \"Enter your move (rock, paper, scissors): \"\n\nuser_move = input(prompt)\n\nwhile user_move not in [\"rock\", \"paper\", \"scissors\"]:\n  print(f\"Sorry, I can't understand what \\\"{user_move}\\\" is. Check the spelling please.\")\n  user_move = input(prompt)\n\ncomputer_move = random.choice([\"rock\", \"paper\", \"scissors\"])\n\nprint(\"Computer move:\", computer_move)\n\nif user_move == computer_move:\n  print(\"It's a tie!\")\nelse:\n  match (user_move, computer_move):\n    case (\"rock\", \"scissors\") | (\"paper\", \"rock\") | (\"scissors\", \"paper\"):\n      print(\"You win!\")\n    case _:\n      print(\"You lose!\")\nيتبين ما تختصره علينا جملة match مقارنة بالشرطية المكافئة التالية (لاحظ وجود علامة \\ لإعلام المترجم أن الجملة تمتد للسطر الذي يليه):\nif user_move == \"rock\" and computer_move == \"scissors\" \\\n  or user_move == \"paper\" and computer_move == \"rock\" \\\n  or user_move == \"scissors\" and computer_move == \"paper\":\n  print(\"You win!\")\nelse:\n  print(\"You lose!\")\nولك أن تختصرها هي كذلك كالتالي:\nif (user_move, computer_move) in [(\"rock\", \"scissors\"), (\"paper\", \"rock\"), (\"scissors\", \"paper\")]:\n  print(\"You win!\")\nelse:\n  print(\"You lose!\")",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "href": "chapters/03_control_flow/apps.html#حساب-مضروب-العدد",
    "title": "تطبيقات",
    "section": "حساب مضروب العدد",
    "text": "حساب مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots 1\n\\]\n\ni = 5\nj = i\nwhile j &gt; 1:\n  j -= 1\n  i *= j\nprint(i)\n\n120\n\n\nشرح للخطوات التنفيذية التفصيلية:\n\nأولاً، قم بتعيين المتغير i إلى العدد 5\nثانياً، قم بتعيين المتغير j إلى العدد 5\nثالثاً، استمر في الدوران إلى أن يصل j إلى القيمة 1\n\nفي كل دوران، قم بطرح 1 من j\nثم قم بضرب i بالقيمة الجديدة لـ j: المتحصل هو أن `i = i * (i - 1)\n\nأخيراً، قم بطباعة القيمة النهائية لـ i",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "href": "chapters/03_control_flow/apps.html#تسجيل-الدخول",
    "title": "تطبيقات",
    "section": "تسجيل الدخول",
    "text": "تسجيل الدخول\n\nاستخدم الفعل input() لطلب اسم المستخدم (username) و كلمة المرور (password) من المستخدم وخزن كل منهما في متغير مناسب\nإذا كان اسم المستخدم هو \"admin\" وكلمة المرور هي \"abc123\"، اطبع: \"Welcome admin\"\nأو إذا كان اسم المستخدم هو \"backdoor\" وكلمة المرور هي \"let me in\"، اطبع: \"Nobody knows!\"\nخلاف ذلك، اطبع: \"Access denied!\"\n\nimport getpass\n\nusername = input(\"Enter your username: \")\npassword = getpass.getpass(\"Enter your password: \")\n\nmax_tries = 3\ntries = 0\n\nwhile tries &lt; max_tries:\n  if username == \"admin\" and password == \"abc123\":\n    print(\"Welcome admin\")\n    break\n  elif username == \"backdoor\" and password == \"let me in\":\n    print(\"Nobody knows!\")\n    break\n  else:\n    print(\"Access denied!\")\n    tries += 1\nلاحظ:\n\nوجود حلقة while لإعادة المحاولة ثلاث مرات فقط\nوجود جملة break لإنهاء الحلقة إذا تم التسجيل بنجاح\n\nلا توجد break في جزئية else الأخيرة وذلك لأن عدد المحاولات يزيد في كل مرة ليؤول الفعل إلى انتفاء شرط الدوران",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "href": "chapters/03_control_flow/apps.html#برنامج-تفاعلي",
    "title": "تطبيقات",
    "section": "برنامج تفاعلي",
    "text": "برنامج تفاعلي\ninventory = 100\n\nwhile True:\n  print(\"Store Menu:\")\n  print(\"1. Buy Apples\")\n  print(\"2. Restock Apples\")\n  print(\"3. Exit\")\n\n  choice = input(\"Enter your choice: \")\n\n  match choice:\n    case \"1\":\n      quantity = int(input(\"Enter the quantity of apples to buy: \"))\n      if quantity &lt;= inventory:\n        inventory -= quantity\n        print(\"You bought\", quantity, \"apples. Remaining inventory:\", inventory)\n      else:\n        print(\"Insufficient stock. Please try again later.\")\n    case \"2\":\n      quantity = int(input(\"Enter the quantity of apples to restock: \"))\n      inventory += quantity\n      print(\"Restocked\", quantity, \"apples. New inventory:\", inventory)\n    case \"3\":\n      print(\"Exiting the store...\")\n      break\n    case _:\n      print(\"Invalid choice. Please try again.\")\nقد يبدو الفعل بلا معنى؛ لكن هكذا تعمل برامج الخوادم التي تستقبل الطلبات بشكل مستمر. فإنها تدخل حلقة لانهائية تأخذ فيها الطلبات من المستخدمين ليتم معالجتها والرد عليهم.",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/apps.html#برنامج-تفاعلي-ذو-صفحات-متعددة",
    "href": "chapters/03_control_flow/apps.html#برنامج-تفاعلي-ذو-صفحات-متعددة",
    "title": "تطبيقات",
    "section": "برنامج تفاعلي ذو صفحات متعددة",
    "text": "برنامج تفاعلي ذو صفحات متعددة\npage = \"main\"\n\nADMIN_USERNAME = \"admin\"\nADMIN_PASSWORD = \"abc123\"\n\nwhile True:\n  match page:\n    case \"main\":\n      print(\"*** Main menu ***\")\n      print(\"1. Login\")\n      print(\"2. Register\")\n      print(\"3. Exit\")\n      choice = input(\"Where do you want to go?: \")\n      match choice:\n        case \"1\":\n          page = \"login\"\n        case \"2\":\n          page = \"register\"\n        case _:\n          break\n    \n    case \"login\":\n      print(\"*** Login menu ***\")\n      username = input(\"Please enter the username: \")\n      password = getpass.getpass(\"Please enter the password: \")\n      if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:\n        print(\"Login successful!\")\n        page = \"admin_panel\" # not matched, so it will match \"_\" and break the loop\n      else:\n        print(\"Login failed!\")\n        page = \"main\"\n    \n    case \"register\":\n      print(\"*** Register menu ***\")\n      username = input(\"Please enter the username: \")\n      password = getpass.getpass(\"Please enter the password: \")\n      print(\"Register successful!\")\n      page = \"main\"\n    \n    case _:\n      break",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html",
    "href": "chapters/03_control_flow/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\nالمطلوب:",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/problems.html#الوزن-الطبيعي",
    "title": "مسائل",
    "section": "",
    "text": "التصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\n\n\n\n\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\n\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/problems.html#مجموع-الأرقام-إلى-س",
    "title": "مسائل",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الفعل input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "href": "chapters/03_control_flow/problems.html#التغير-النسبي",
    "title": "مسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)\nقد مرت علينا هذه المسألة، لكن الآن المطلوب حلها بالتكرار.",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "href": "chapters/03_control_flow/problems.html#متحدث-آلي",
    "title": "مسائل",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html",
    "href": "chapters/03_control_flow/solutions.html",
    "title": "حل المسائل",
    "section": "",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\nحيث:\nالمطلوب:\nheight = 1.70\nweight = 95\nbmi = weight / height**2\n\nif bmi &lt; 16:\n    print('severe_thinness')\nelif bmi &lt; 17:\n    print('moderate_thinness')\nelif bmi &lt; 18.5:\n    print('mild_thinness')\nelif bmi &lt; 25:\n    print('normal')\nelif bmi &lt; 30:\n    print('overweight')\nelif bmi &lt; 35:\n    print('obese_class_1')\nelif bmi &lt; 40:\n    print('obese_class_2')\nelse:\n    print('obese_class_3')\n\nobese_class_1",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "href": "chapters/03_control_flow/solutions.html#الوزن-الطبيعي",
    "title": "حل المسائل",
    "section": "",
    "text": "التصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\n\n\n\n\n\nالوزن بالكيلوغرام: \\(weight\\)\nالطول بالمتر: \\(height\\)\n\n\n\nاحسب بالمعادلة السابقة مؤشر كتلة الجسم لوزنك\nاكتب جملاً شرطية تستعمل الجدول لتصنيف الوزن\nاطبع النتيجة",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/03_control_flow/solutions.html#مجموع-الأرقام-إلى-س",
    "title": "حل المسائل",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو هذه المعادلة: مجموع الأرقام من 1 إلى n:\n\\[\n\\sum_{i=1}^{n} i\n\\]\nتعليمات التطبيق:\n\nاستخدم الفعل input() لطلب إدخال العدد من المستخدم\nالقيمة المدخلة ستكون من النوع النصي وليس العددي؛ لذا:\n\nحول القيمة المدخلة إلى عدد باستخدام int() أو float()\n\nاستعمل حلقة while لجمع الأرقام من 1 إلى العدد الذي أدخله المستخدم\nاطبع النتيجة\n\nuser_input = input(\"Enter a number: \")\nn = int(user_input)\n\ntotal = 0\ni = 1\nwhile i &lt;= n:\n    total += i\n    i += 1\n\nprint('sum is:', total)",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "href": "chapters/03_control_flow/solutions.html#التغير-النسبي",
    "title": "حل المسائل",
    "section": "التغير النسبي",
    "text": "التغير النسبي\nإذا كنت تمارس الرياضة وتزيد في وزن الحمل 10% أسبوعيًّا .. فإذا بدأت بوزن 20 كيلو، فإلى كم كيلوا ستصل في الأسبوع الثاني عشر؟ (بعد ثلاثة أشهر)\nقد مرت علينا هذه المسألة، لكن الآن المطلوب حلها بالتكرار.\n\nweight = 20\nfor week in range(12):\n    weight += weight * 0.1\nprint(weight)\n\n62.768567534419994",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "href": "chapters/03_control_flow/solutions.html#متحدث-آلي",
    "title": "حل المسائل",
    "section": "متحدث آلي",
    "text": "متحدث آلي\nاكتب برنامج يجمع البيانات التالية من المستخدم (الزبون):\n\nاسم الزبون: الرسالة “أتشرف باسمك، مثلا: محمد أحمد”\nرقم الهاتف: الرسالة “زودنا برقم جوالك، يبدأ بـ966”\nالمدينة: الرسالة “ممكن تحدد مدينتك؟”\nاسم الحي: الرسالة “الرجاء قم بكتابة اسم الحي”\n\nبعد ذلك يؤكد الآلي على المستخدم أن المعلومات صحيحة، ويطلب منه التأكيد أو التعديل أو إلغاء الطلب.\n\nفي حال التأكيد: الرسالة “تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً”\nفي حال التعديل، يطلب الآلي من المستخدم تحديد الشيء الذي يريد تعديله ليتم تعديله\nفي حال إلغاء الطلب: الرسالة “تم إلغاء طلب التبرع”\n\nprint(\"\"\"مرحبا بك في خدمة التبرع\nفضلا أريد منك تزويدي ببعض المعلومات ..\n\"\"\")\n\nprint('أتشرف باسمك، مثلا: محمد أحمد')\nname = input()\n\nprint('زودنا برقم جوالك، يبدأ بـ966')\nphone = input()\n\nprint('ممكن تحدد مدينتك؟')\ncity = input()\n\nprint('الرجاء قم بكتابة اسم الحي')\nneighborhood = input()\n\nprint('name:', name)\nprint('phone:', phone)\nprint('city:', city)\nprint('neighborhood:', neighborhood)\n\nwhile True:\n    print('هل تود تأكيد طلب التبرع؟')\n    print('1. تأكيد الطلب')\n    print('2. تعديل الطلب')\n    print('3. إلغاء الطلب')\n    user_confirmation = input()\n\n    if user_confirmation == '1':\n        print('تم تأكيد الطلب برقم 12345 سيتواصل معك ممثل خدمة العملاء في غضون 15 دقيقة علمًا أن ساعات العمل من 9 صباحًا إلى 5 مساءً')\n        break\n    elif user_confirmation == '2':\n        print('ما الشيء الذي تريد تعديله؟')\n        print('1. الاسم')\n        print('2. رقم الهاتف')\n        print('3. المدينة')\n        print('4. اسم الحي')\n        user_modification = input()\n        match user_modification:\n            case '1':\n                print('اسم الزبون')\n                name = input()\n            case '2':\n                print('رقم الهاتف')\n                phone = input()\n            case '3':\n                print('المدينة')\n                city = input()\n            case '4':\n                print('اسم الحي')\n                neighborhood = input()\n            case _:\n                print('إختيار غير موجود')\n\n    elif user_confirmation == '3':\n        print('تم إلغاء طلب التبرع')\n        break",
    "crumbs": [
      "باب الشرط والتكرار (Control Flow)",
      "حل المسائل"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html",
    "href": "chapters/04_functions/a_functions.html",
    "title": "4  الأفعال",
    "section": "",
    "text": "4.1 التعريف والتفاصيل والتنفيذ\nالفعل: قطعة كود مخزَّنة مسمَّاة. عادة ما يكون لها عوامل متغيرة.\nنحو: int(x) لإنشاء العدد الصحيح من النص. مثل: int(\"12\") ينتج: 12.\nوقد يأخذ عاملين نحو: round(x, n) مثل: round(10.259, 2) ينتج: 10.26.\nوقد يأخذ عاملاً واحدًا لكنَّهُ قائمة نحو: sum(numbers) مثل: sum([1, 2, 3, 4, 5]) ينتج: 15.\nوقد يكون عدد عوامله لا محدودًا نحو: print(*values)، (وعلامة النجمة * تشير لقبول عوامل مفكوكة على نحو ما تقدَّم، لا كالقائمة) مثل:\nوقد يكون عامله جائزًا نحو: range(start, stop, step) مثل:\nوقد تقدَّم الحديث عنه في باب التكرار.\nوطلب التنفيذ يكون بالقوسين بعد اسمه ()، وتوضَع العوامل فيهما وهي ضربان:\nوفي كل ما سبق كانت العوامل من نوع الفاعل؛ لأنها كانت تؤثر في النتيجة ولا تتأثر بها.\nأما المفعول فنحو فعل الترتيب من مكتبة القائمة: list.sort(numbers) فإن مفعوله القائمة نفسها، مثل:\nفمع أننا لما نعيِّن النتيجة، فقد تغيَّرت القائمة:\nبعكس الترتيب بالفعل الذي ليس من المكتبة: sorted(numbers) فإنَّ القائمة فيه ليست مفعولاً؛ إذْ يُنتِجُ الفعلُ قائمةً جديدةً ولا يغير القائمة المُدخلة:\nويجتمع الفاعل والمفعول في نحو:\nوقد خصصت لغات البرمجة للمبني للمفعول الواحد كتابةً على النحو: list.sort(numbers) هي نفسها numbers.sort() حيث قدَّم المفعول:\nوحرف النقطة . يصل لما هو مُسنَد إلى الشيء، سواءٌ كان مكتبة نحو list أو معيَّنًا من نوع نحو xs أو ys.\nوتدور حولها فلسفة تسمَّى البرمجة الشيئية: Object-Oriented Programming. ويغلب على ما بين الأقواس إذًا أن يكون فاعلاً. ويأتي الحديث عنها في باب الأصناف إن شاء الله.\nوقد تُعيَّنُ العوامل بأحد طريقتين:\nويجوز استعمال الطريقتين معًا في نحو: list.sort(numbers, reverse=True) ويشترط فيه تقدم التعيين بالموضع ليكون في مكانه، ثم يتبعه التعيين بالاسم حيث لا يشترط الترتيب فيه.\nنذلف الآن لإنشاء أفعال جديدة.\nيعرَّف الفعل بـ def ويتكون من ثلاثة أجزاء:\nأما جملة الرجوع return توقِفُ التنفيذَ عندها وتخرج بالنتيجة لموضع الطلب.\ndef calculate_grade(score):\n    if score &gt;= 90:\n        return \"A\"\n    elif score &gt;= 80:\n        return \"B\"\n    elif score &gt;= 70:\n        return \"C\"\n    elif score &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\nوعند طلب التنفيذ نعين العوامل.\nفينتج لنا بطلب calculate_grade(95) نسخة معيَّنة من تفاصيل الفعل، نسمّيها ظرف التنفيذ ؛ يكون فيه المتغير score=95 كأنه هكذا:\nوبطلب تنفيذ calculate_grade(80) يكون الظرف هكذ:\nلاحظ أن نتيجة السطرين بحسب الظرفين المختلفين:\nprint(calculate_grade(95))\nprint(calculate_grade(80))\n\nA\nB\nوقد نعدد عوامل كثيرة، نحو:\ndef weather_condition(temperature, humidity, wind_speed):\n    if temperature &gt;= 30 and humidity &gt;= 60 and wind_speed &gt;= 10:\n        return \"Rainy\"\n    elif temperature &gt;= 20 and humidity &gt;= 50 and wind_speed &gt;= 5:\n        return \"Cloudy\"\n    elif temperature &gt;= 10 and humidity &gt;= 30 and wind_speed &gt;= 0:\n        return \"Sunny\"\n    return \"Normal\"\nويكون طلبها بالطريقتين كما تقدَّم، بالموضع أو بالاسم:\ncond = weather_condition(30, humidity=60, wind_speed=10)\n\nif cond == \"Rainy\":\n    print(\"Don't forget your umbrella!\")\n\nDon't forget your umbrella!",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الأفعال</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#التعريف-والتفاصيل-والتنفيذ",
    "href": "chapters/04_functions/a_functions.html#التعريف-والتفاصيل-والتنفيذ",
    "title": "4  الأفعال",
    "section": "",
    "text": "اسم الفعل: الذي يُطلَبُ به\nالعوامل: العوامل التي يتم تعيينها لاحقًا\nالتفاصيل: وهي القطعة الكود التي يتم تنفيذها عند الطلب\n\n\n\n\n\nif 95 &gt;= 90:\n    return \"A\"\nelif 95 &gt;= 80:\n    return \"B\"\nelif 95 &gt;= 70:\n    return \"C\"\nelif 95 &gt;= 60:\n    return \"D\"\nelse:\n    return \"F\"\n\nif 80 &gt;= 90:\n    return \"A\"\nelif 80 &gt;= 80:\n    return \"B\"\nelif 80 &gt;= 70:\n    return \"C\"\nelif 80 &gt;= 60:\n    return \"D\"\nelse:\n    return \"F\"",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الأفعال</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#العوامل-الجائزة",
    "href": "chapters/04_functions/a_functions.html#العوامل-الجائزة",
    "title": "4  الأفعال",
    "section": "4.2 العوامل الجائزة",
    "text": "4.2 العوامل الجائزة\nالأصل في العوامل المعرَّفة الوجوب؛ إلا ما عُيِّن عند التعريف، ولو بالقيمة العدميَّة None أو ما يوازيها من القيَم الصفرية. وينسخُ ذلك التعيينَ التعيينُ عند طلب الفعل.\nلو أردنا للفعل أن يتكيَّف بحسب الفاعل المعيَّن، بحيث:\n\nلو عينت السلزيوس فالتحويل لفهرنهايت: convert_temperature(celsius=32)\nلو عينت الفهرنهايت فالتحويل لسلزيوس: convert_temperature(fahrenheit=89.6)\n\nوإليك معادلة التحويل بين نوعيْ درجة الحرارة:\n\\[\nF = \\frac{9}{5} C + 32\n\\]\nفنعرِّفُ العوامل بقيَم عدميَّة، ونفحص وجودها بالشرط is not None لنُعمِلَها أو نهملها:\n\ndef convert_temperature(celsius = None, fahrenheit = None):\n    if celsius is not None:\n        fahrenheit = (9 / 5) * celsius + 32\n        return fahrenheit\n    elif fahrenheit is not None:\n        celsius = (fahrenheit - 32) * (5 / 9)\n        return celsius\n\nنتأكد:\n\nassert convert_temperature(celsius=32) == 89.6\nassert convert_temperature(fahrenheit=89.6) == 32",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الأفعال</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#التصريح-بالنوع",
    "href": "chapters/04_functions/a_functions.html#التصريح-بالنوع",
    "title": "4  الأفعال",
    "section": "4.3 التصريح بالنوع",
    "text": "4.3 التصريح بالنوع\nوجاز في بايثون ذكر أنواع العوامل والنواتج، وليس بلازِم ولا مُلزِم. نحو:\ndef do_something(a: int = 0, b: str = '') -&gt; float:\n    # ...\nفعبارة: a: int = 0 تتكون من ثلاثة أجزاء:\n\nاسم العامل: a\nنوعه: int\nالقيمة الابتدائية: 0\n\nوكذلك b: str = '' مثلها.\nوبعد السهم نوع ناتج الفعل: -&gt; float\nومن الأنواع المبنيَّة في بايثون:\n\nint الأعداد الصحيحة، نحو: 10\nfloat الأعداد العشرية، نحو: 10.5\nstr وهي نوع النص، نحو: \"Salam\"\nlist قائمة وإن شئت تحديد نوع العنصر الواحد فيها؛ فإنك تضعه بين القوسين المربعين، نحو:\n\nlist[int]\nlist[float]\nlist[str]",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الأفعال</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#نطاق-التسمية",
    "href": "chapters/04_functions/a_functions.html#نطاق-التسمية",
    "title": "4  الأفعال",
    "section": "4.4 نطاق التسمية",
    "text": "4.4 نطاق التسمية\nومن خصائص الظرفيَّةِ انعزال المعرَّفات الداخلة عن الخارج. يعني أنها تُنسى بعد إنتهاء الفعل.\n\ndef calculate_bmi(weight: float, height: float) -&gt; float:\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\n\nفنتوقع وقوع خطأ هنا لأن bmi غير معرفة إلا في نطاق الفعل:\n\nprint(bmi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 print(bmi)\n\nNameError: name 'bmi' is not defined\n\n\n\nوعلى العكس فإن المعرَّفات الخارجة معروفة في الداخل؛ فيمكن أن تكون عاملةً في الفعل:\n\nmax_length = 8\n\ndef check_password_strength(password: str) -&gt; str:\n    if len(password) &gt; max_length:\n        return \"strong\"\n    elif len(password) &gt; max_length // 2:\n        return \"medium\"\n    return \"weak\"\n\n\n\n\nمستويات نطاق التسمية",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الأفعال</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#الفعل-المنتج",
    "href": "chapters/04_functions/a_functions.html#الفعل-المنتج",
    "title": "4  الأفعال",
    "section": "4.5 الفعل المنتج",
    "text": "4.5 الفعل المنتج\nتُخرج الأفعال نتائج معالجتها بإحدى طريقتين:\n\nالرجوع: حيث ترجِع النتيجة بجملة return لموضع طلب الفعل، وغالبًا ما يتم تعيينه نحو: y = sqrt(x)\nتغيير مفعول:\n\nمذكور، نحو: list.sort(xs) حيث تعدَّل القيمة التي يشير إليها المتغير xs\nمحذوف، نحو: print(...) حيث قيمة المفعول أصلاً: print(..., file=sys.stdout) فتُكتَب نتيجة المعالجة على الشاشة\n\n\nوالفعل دائمًا يرجع بنهاية آخر جملة فيه، لكن الذي لا يصرَّحُ فيه بكلمة الرجوع return يُقدَّر القيمة العدمية: None ويسمى الفعل حنيها خاويًا (void).\nتأمل المثال التالي الذي يأخذ عوامل ثم لا يرجع بشيء، لكنه يُظهر النتيجة على الشاشة، وقد كتبنا فيه جملة الرجوع return None لكنها مقدَّرة على أية حال، ولا يلزمنا أن نضعها:\n\ndef print_decorated(message: str, n: int) -&gt; None:\n    print(\"=\" * n)\n    print(message)\n    print(\"=\" * n)\n    return None\n\nprint_decorated(\"Salam alykom\", 15)\n\n===============\nSalam alykom\n===============",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الأفعال</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a_functions.html#الإجمال-ثم-التفصيل",
    "href": "chapters/04_functions/a_functions.html#الإجمال-ثم-التفصيل",
    "title": "4  الأفعال",
    "section": "4.6 الإجمال ثم التفصيل",
    "text": "4.6 الإجمال ثم التفصيل\nويُحبَّذُ في الإنشاء الإجمالُ ثم التفصيل. ويتأتى على النحو التالي:\n\ndef min_max(numbers: list[float]) -&gt; tuple[float, float]:\n    \"\"\"Return the minimum and maximum values in the list.\"\"\"\n    pass\n\n\nكتابة اسم معبِّرٍ عن وظيفة الفعل، مع كتابة عوامله وذكر أنواعها\n\nوهي جُملة التعريف: def\n\nكتابة وصف -باللغة الإنجليزية- يحدد سلوكه العام بناءً على عوامله يصف ما يَقبل وما يُنتج (إذْ لغة البرمجة عاجزة عن بيان ذلك)\n\nوهو النص الملحَقُ: docstring (ويكونُ أولَّ شيء فيه قبل أي كود) والقاعدة العامة فيه: ألا يصف إلا ما يفيد المستفيد من الفعل. أما التفاصيل التي تفيد مطوِّر الفعل فإنها تكون تعليقات بعلامة # في ثناياه. فالذي يظهر عند المساعدة help(min_max) هو النص الملحق، لا التعليقات.\n\nبعد ذلك نكتب الاختبارات التي بمجموعها تصف سلوك الفعل من الخارج\n\nونستعمل لها جملة التوكيد: assert\nولن تكون حقيقيةً لأن تفاصيل الفعل لم تُكتب بعد، لذا قد تستعمل كلمة pass لإرضاء المترجم إلى ذلك الحين\n\nوبعد ذلك نأتي لكتابة التفاصيل: التي هي قطعة الكود داخل الفعل.\n\nوهكذا تظهر المساعدة، مثلما لو وضعت المؤشر على اسم الفعل (فإن غالب المحررات تُظهر لك شيئًا):\n\nhelp(min_max)\n\nHelp on function min_max in module __main__:\n\nmin_max(numbers: list[float]) -&gt; tuple[float, float]\n    Return the minimum and maximum values in the list.\n\n\n\nثم نكتب اختبارات تصف السلوك الذي نريده منه:\n# assert min_max([10, 20, 30, 40, 50]) == (10, 50)\n# assert min_max([50, 40, 30, 20, 10]) == (10, 50)\n# assert min_max([10, 10, -900, 10, 10]) == (-900, 10)\nثم الآن نعدل الفعل الذي كتبناه:\n\nتستعمل التعليقات المبتدأة بحرف #لتبيين ما قد يُشكل من التفاصيل\nذكر النوع tuple[float, float] يعني أن الفعل يرجع بزوج، لا بقيمة واحدة (وهذا يسمَّى نوع الصف، وسيأتي الحديث عنه)\n\n\ndef min_max(numbers: list[float]) -&gt; tuple[float, float]:\n    \"\"\"Return the minimum and maximum values in the list.\"\"\"\n\n    if len(numbers) == 0:\n        return None, None\n    \n    # Assign the first element to minimum and maximum\n    minimum = numbers[0]\n    maximum = numbers[0]\n    \n    for num in numbers:\n        if num &lt; minimum:\n            minimum = num\n        # elif is used because maximum will never be less than minimum\n        elif num &gt; maximum:\n            maximum = num\n    return minimum, maximum\n\nونشغل الاختبارات، ونتوقع أن لا يظهر منها خطأ:\n\nassert min_max([10, 20, 30, 40, 50]) == (10, 50)\nassert min_max([50, 40, 30, 20, 10]) == (10, 50)\nassert min_max([10, 10, -900, 10, 10]) == (-900, 10)\nassert min_max([]) == (None, None)\n\nراجع ثوثيق بايثون في العوامل الخاصة للمزيد.",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الأفعال</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a2_recursion.html",
    "href": "chapters/04_functions/a2_recursion.html",
    "title": "5  الفعل المتسلسل",
    "section": "",
    "text": "5.1 مثال: المضروب\nالفعل المتسلسل: يحتوي على جملة يطلب فيها نفسه. ويجب أن تؤول سلسلة الطلبات هذه إلى جملة تنهي التسلسل.\nتنبيه: هذا مبحثٌ شيِّق، وقد يكون فيه شيءٌ من الصعوبة، لكنّ فيه أدوات فعَّالة في استعمال المنطق البرمجي بأقصى مدى.\nفمثلا: تعرف الرياضيات مضروب العدد\n\\[\n!n = n(n-1)(n-2)\\cdots(1)\n\\]\nفهي عملية ضرب لكل عدد مع الذي قبله حتى ينتهي للواحد. ومن أمثلته:\n\\[\n!5 = (5)(4)(3)(2)(1)\n\\]\nولك أن تصف نفس العملية هكذا:\n\\[\n!n = n !(n-1)\n\\]\nأي أن مضروب العدد هو ضربُ هذا العدد في مضروب العدد الذي قبله. وذلك يتسلسل على النحو التالي:\n\\[\n!5 = (5)!(4) = (5)(4!(3)) = (5)(4(3!(2))) = (5)(4(3(2!(1)))) = (5)(4(3(2(1)))) = (5)(4)(3)(2)(1)\n\\]\nإذا نخلص بالمعادلة التالية:\n\\[\n!n = n(n-1)(n-2)\\cdots(1) = n!(n-1)\n\\]\nوهكذا يكون تعريفها في بايثون:\ndef factorial(n: int) -&gt; int:\n    # Recursive case\n    if n &gt; 0:\n        recursive_result = factorial(n - 1)\n        return n * recursive_result\n    # Terminal case\n    return 1\n\nfactorial(5)\n\n120\nحيث لدينا حالتان:\nوهنا قطعة كود نستعملها لتصور تسلسل الطلبات:\nالكود\ndef factorial(n: int, depth: int = 0) -&gt; int:\n\n    # Recursive case\n    print(f\"{'  ' * depth}Call factorial({n})\")\n    if n &gt; 0:\n        result = n * factorial(n - 1, depth + 1)\n        print(f\"{'  ' * depth}Return {result} from factorial({n})\")\n        return result\n    \n    # Terminal case\n    print(f\"{'  ' * depth}Return 1 from factorial({n})\")\n    return 1\n\nfactorial(5)\n\n\nCall factorial(5)\n  Call factorial(4)\n    Call factorial(3)\n      Call factorial(2)\n        Call factorial(1)\n          Call factorial(0)\n          Return 1 from factorial(0)\n        Return 1 from factorial(1)\n      Return 2 from factorial(2)\n    Return 6 from factorial(3)\n  Return 24 from factorial(4)\nReturn 120 from factorial(5)\n\n\n120\nطلب الفعل المتسلسل يؤدي إلى ظروف متداخلة تؤول إلى ظرف واحد في النهاية.\nيستعمل الفعل المتسلسل وكذلك هياكل البيانات المتسلسلة بشكل كبير في الخوارزميات الفعالة.\nيسهل كتابة بعض الخوارزميات باستعمال الفعل المتسلسل. لكن قد تكون (أحياًنا) أقل أداءً من استعمال الحلقات.",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الفعل المتسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/a2_recursion.html#مثال-المضروب",
    "href": "chapters/04_functions/a2_recursion.html#مثال-المضروب",
    "title": "5  الفعل المتسلسل",
    "section": "",
    "text": "عندما تكون n &gt; 0 يتم الطلب الذاتي : recursive_result = factorial(n - 1) إذْ هي جملة متسلسلة تكدِّس طلبات فوق طلبات؛ لكنها تؤول في النهاية إلى الجملة التي تُنهي التسلسل\nreturn 1 هي الجملة التي تنهي التسلسل\n\n\n\n\nفكل طلب يُنشأ له ظرف تنفيذ جديد تكون بالنسبة له قيمة n هي المعيَّنة له وقت النداء.\nوهكذا يتم تكديس الطلبات حتى ينتهي التسلسل عند الطلب factorial(0) الذي يؤول لنتيجة مباشرة: return 1 فيخلَّى هذا الظرف من الذاكرة وتعود نتيجته إلى الظرف المباشر الذي استدعاه وهو ظرف factorial(1).\nفتتعين القيمة recursive_result = 1 وينتقل إلى الجملة التي بعدها وهي جملة الرجوع بنتيجة return n * recursive_result وهُما معيَّنان، أي تكون الجملة في واقع الظرف: return 1 * 1.\nوهذه النتيجة تعود للظرف الذي استدعاه وهو factorial(2) … إلخ.",
    "crumbs": [
      "باب الأفعال (Functions)",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الفعل المتسلسل</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions/apps.html",
    "href": "chapters/04_functions/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "طول الخط المستقيم بين نقطتين\nتعريف الفعل فعل مساعد للبرمجة وليس هو تنفيذيًّا بذاته. لذا ستكون تطبيقات هذا الجزء عبارة عن قولَبة التطبيقات السابقة بتعريفها في أفعال:\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تتبع معادلة فيثاغورس:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nوتذكر أن:\n\\[\n\\sqrt{x} = x^{1/2}\n\\]\ndef euclidean_distance(x1: float, y1: float, x2: float, y2: float) -&gt; float:\n    return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5\n\nassert euclidean_distance(x1=0, y1=0, x2=3, y2=4) == 5.0",
    "crumbs": [
      "باب الأفعال (Functions)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/04_functions/apps.html#كم-سيكون-عمرك-عند-حين-كذا",
    "href": "chapters/04_functions/apps.html#كم-سيكون-عمرك-عند-حين-كذا",
    "title": "تطبيقات",
    "section": "كم سيكون عمرك عند حين كذا؟",
    "text": "كم سيكون عمرك عند حين كذا؟\n\ndef age_at_future_event(age_now: int, current_year: int, future_year: int) -&gt; int:\n    return age_now + (future_year - current_year)\n\nassert age_at_future_event(age_now=0, current_year=2000, future_year=2010) == 10\nassert age_at_future_event(age_now=20, current_year=2000, future_year=2010) == 30",
    "crumbs": [
      "باب الأفعال (Functions)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/04_functions/apps.html#حساب-الأجر",
    "href": "chapters/04_functions/apps.html#حساب-الأجر",
    "title": "تطبيقات",
    "section": "حساب الأجر",
    "text": "حساب الأجر\n\ndef gross_pay(hours: float, per_hour_rate: float) -&gt; float:\n    return hours * per_hour_rate\n\nassert gross_pay(10, 10) == 100\nassert gross_pay(40, 10) == 400",
    "crumbs": [
      "باب الأفعال (Functions)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/04_functions/apps.html#الوزن-الطبيعي",
    "href": "chapters/04_functions/apps.html#الوزن-الطبيعي",
    "title": "تطبيقات",
    "section": "الوزن الطبيعي",
    "text": "الوزن الطبيعي\nهذا هو وزن الجسم الموصى به من قبل منظمة الصحة العالمية (WHO) استنادًا إلى قيم مؤشر كتلة الجسم للبالغين. ويستخدم لكل من الرجال والنساء الذين تبلغ أعمارهم 20 عامًا أو أكثر.\n\n\n\nالتصنيف\nمدى BMI - kg/m2\n\n\n\n\nنحف شديد\n&lt; 16\n\n\nنحف متوسط\n16 - 17\n\n\nنحف خفيف\n17 - 18.5\n\n\nطبيعي\n18.5 - 25\n\n\nزيادة في الوزن\n25 - 30\n\n\nسمنة خفيفة\n30 - 35\n\n\nسمنة ثانية\n35 - 40\n\n\nسمنة ثالثة\n&gt; 40\n\n\n\nالمصدر\nلحساب مؤشر كتلة الجسم (BMI)، نستعمل المعادلة التالية:\n\\[\nBMI = \\frac{weight}{height^2}\n\\]\n\ndef calculate_bmi(weight: float, height: float) -&gt; float:\n    return weight / height**2\n\ndef classify_bmi(bmi: float) -&gt; str:\n    if bmi &lt; 16:\n        return 'severe_thinness'\n    elif bmi &lt; 17:\n        return 'moderate_thinness'\n    elif bmi &lt; 18.5:\n        return 'mild_thinness'\n    elif bmi &lt; 25:\n        return 'normal'\n    elif bmi &lt; 30:\n        return 'overweight'\n    elif bmi &lt; 35:\n        return 'obese_class_1'\n    elif bmi &lt; 40:\n        return 'obese_class_2'\n    else:\n        return 'obese_class_3'\n\nassert classify_bmi(bmi=15) == 'severe_thinness'\nassert classify_bmi(bmi=20) == 'normal'\nassert classify_bmi(bmi=40) == 'obese_class_3'",
    "crumbs": [
      "باب الأفعال (Functions)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/04_functions/apps.html#مجموع-الأرقام-إلى-س",
    "href": "chapters/04_functions/apps.html#مجموع-الأرقام-إلى-س",
    "title": "تطبيقات",
    "section": "مجموع الأرقام إلى س",
    "text": "مجموع الأرقام إلى س\nما نريد صياغته هو مجموع الأرقام من 1 إلى n:\n\ndef sum_of_numbers(n: int) -&gt; int:\n    \"\"\"Sum of numbers from 1 to n\"\"\"\n    pass\n\nحلها بالتكرار باستعمال range لإنشاء تسلسل الأرقام للتكرار عليها، ولاحظ أن النهاية n+1 ليكون الرقم الأخير مشمولاً في التكرار:\n\ndef sum_of_numbers(n: int) -&gt; int:\n    \"\"\"Sum of numbers from 1 to n\"\"\"\n    result = 0\n    for i in range(1, n + 1):\n        result += i\n    return result\n\nassert sum_of_numbers(n=5) == 1+2+3+4+5 == 15\nassert sum_of_numbers(n=10) == 1+2+3+4+5+6+7+8+9+10 == 55\n\nوحلها بالفعل المتسلسل:\n\ndef sum_of_numbers(n: int) -&gt; int:\n    \"\"\"Sum of numbers from 1 to n\"\"\"\n    if n == 1:\n        return 1\n    return n + sum_of_numbers(n - 1)\n\nassert sum_of_numbers(n=5) == 1+2+3+4+5 == 15\nassert sum_of_numbers(n=10) == 1+2+3+4+5+6+7+8+9+10 == 55\n\nوإذا صغناها رياضيًّا وعلمنا المعادلة الرياضية، فلا حاجة للتكرار أصلاً:\n\\[\n\\sum_{i=1}^{n} i = \\frac{n(n + 1)}{2}\n\\]\n\ndef sum_of_numbers(n: int) -&gt; int:\n    \"\"\"Sum of numbers from 1 to n\"\"\"\n    return n * (n + 1) // 2\n\nassert sum_of_numbers(n=5) == 1+2+3+4+5 == 15\nassert sum_of_numbers(n=10) == 1+2+3+4+5+6+7+8+9+10 == 55",
    "crumbs": [
      "باب الأفعال (Functions)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html",
    "href": "chapters/05_sequences/a_sequences.html",
    "title": "6  المجموعة المرتبة",
    "section": "",
    "text": "6.1 التسلسل\nكثيرًا ما نحتاج للتعامل مع الأشياء في مجموعة. وذلك مثلاً لترتيب المجموعة أو عكسها أو ربطها مع مجموعة أخرى، أو البحث فيها، أو تصفيتها، أو تحويلها جميعًا بنفس الطريقة، أو استخلاص قيمة منها، …إلخ من العمليات التي تعمل على جميع عناصر المجموعة.\nوكل ما هو من جنس المجموعة (Collection) فإنه يقبل الأفعال التالية:\nانظر Collection في خريطة المجموعات: شكل 1.\nالتسلسل (Sequence) هو أي مجموعة مرتبة من الأشياء.\nوسوف نرمز للمفرد بـx ولما يدل على التسلسل بـs.\nوالأنواع الأربعة التي من جنس التسلسل هي:\nفهذه الأربعة تقبل الأفعال التالية:\nوتقبل من أفعال الإنشاء:\nأما تخصيص حرف + للدمج (لا للجمع) ، وحرف * للتكرار (لا للضرب)؛ فسيأتي معنا -إن شاء الله- في فصل تعريف الأفعال المخصوصة في باب الأنواع.\nوالأنواع على قسمين من حيث قبول التغير بعد الإنشاء:",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#التسلسل",
    "href": "chapters/05_sequences/a_sequences.html#التسلسل",
    "title": "6  المجموعة المرتبة",
    "section": "",
    "text": "قولنا (مجموعة) يعني قبوله الأفعال الثلاثة السابق ذكرها.\nقولنا (مرتبة) يعني أن لكل عنصر موضعًا فيها، وله ما قبله وما بعده.\n\n\n\n\nالقائمة (list) ويُعبَّرُ عنه بالقوسين المربعين [].\nالصف (tuple) ويُعبَّرُ عنه بالقوسين المنحنيين ().\nالمجال (range) ويُعبَّرُ عنه بالفعل المنشئ range().\nالنص (str) ويُعبَّرُ عنه بالتنصيص المفرد '' أو المزدوج \"\".\n\n\n\nالإشارة:\n\nبالموضع: s[i]\nبالقطعة: s[i:j]\nبالقطعة مع خطوة: s[i:j:k]\n\nمعرفة موضع شيء (إن وجد): s.index(x)\nعد تكرارات شيء: s.count(x)\nالبحث عن الأصغر والأكبر: min(s) و max(s)\n\n\n\nالدمج: s1 + s2\nالتكرار: s * n\n\n\n\n\nمتغير: وهو الذي يقبل أن يكون مفعولاً\nجامد: لا يكون إلا فاعلاً\n\n\nالإنشاء\n\nتنشأ القائمة بوضع العناصر بين القوسين المربعين [] أو باستعمال الفعل المنشئ list()، وهي تسلسل متغير.\nينشأ الصف بوضع العناصر بين القوسين المنحنيين () أو باستعمال الفعل المنشئ tuple()، وهو تسلسل جامد.\n\n\ns = (10, 20, 30) + (40, 50)\ns = s * 2\nprint(s)\n\n(10, 20, 30, 40, 50, 10, 20, 30, 40, 50)\n\n\nويقبل إنشاء مجموعة من العناصر مختلفة النوع، بما في ذلك القائمة والصف كعنصر:\n\ns = (10, 'A', 2.0, True, ['B', 30])\nprint(s)\n\n(10, 'A', 2.0, True, ['B', 30])\n\n\nنستعرض هنا العضوية والعد والتكرار\n\ns = [100, 200, 300]\n\nassert 100 in s\nassert 400 not in s\nassert len(s) == 3\n\nfor x in s:\n    print(x)\n\n100\n200\n300\n\n\n\n\nالإشارة\nتستعمل الإشارة الموضعية لقراءة عنصر من التسلسل. ويجب أن يكون المؤشر رقمًا صحيحًا لا يتجاوز نطاق التسلسل على النحو التالي:\n\ns = [10, 20, 30, 40, 50]\nassert s[0] == 10\nassert s[-1] == 50\nassert s[len(s) // 2] == 30\n\n 0    1    2    3    4    5     \n +----+----+----+----+----+\n | 10 | 20 | 30 | 40 | 50 |\n +----+----+----+----+----+\n-5   -4   -3   -2   -1\nشكل الإشارة بالقطعة على نحو: s[start : end : step]. والقيم الابتدائية عند الإغفال هي: s[0:len(s):1].\n\ns = [10, 20, 30, 40, 50]\nassert s[1:3] == [20, 30]\nassert s[::2] == [10, 30, 50]\nassert s[::-1] == [50, 40, 30, 20, 10]\nassert s[1:4:2] == [20, 40] == s[-4:-1:2]\nassert s[1:4:2] == s[slice(1,4,2)] == [20, 40]\n\nلاحظت استعمال الفعل المنشئ slice() في الإشارة بالقطعة، وقد جعلت بايثون علامة : بديلاً عنه.\nوجاز للعنصر الواحد أن يكون مجموعة؛ ومثاله المصفوفة (صفٌّ من صفوف):\n\nmatrix = (\n    (10, 20, 30),\n    (40, 50, 60),\n    (70, 80, 90)\n)\n\nassert matrix[0] == (10, 20, 30)\nassert matrix[-1] == (70, 80, 90)\nassert matrix[1][1] == 50\n\n 0              1              2               \n +--------------+--------------+--------------+\n | (10, 20, 30) | (40, 50, 60) | (70, 80, 90) |\n +--------------+--------------+--------------+\n-3             -2             -1\nالإشارة لعناصر الصف الواحد:\n 0    1    2            \n +----+----+----+\n | 10 | 20 | 30 |\n +----+----+----+\n-3   -2   -1\n 0    1    2            \n +----+----+----+\n | 40 | 50 | 60 |\n +----+----+----+\n-3   -2   -1\n 0    1    2            \n +----+----+----+\n | 70 | 80 | 90 |\n +----+----+----+\n-3   -2   -1\nعناصر نصوص:\n\nss = [\"Apple\", \"Banana\", \"Orange\", \"Lemon\"]\nassert ss[1] == \"Banana\"\nassert ss[-1][0] == \"L\"\n\n 0       1        2        3       4\n +-------+--------+--------+-------+\n | Apple | Banana | Orange | Lemon |\n +-------+--------+--------+-------+\n-4      -3       -2       -1\nالإشارة لصف الأحرف في النص الواحد:\n 0   1   2   3   4\n +---+---+---+---+---+\n | L | e | m | o | n |\n +---+---+---+---+---+\n-5  -4  -3  -2  -1\nوسيأتي التفصيل في باب النص.\n\n\nالبحث\n\ns = ('A', 'B', 'A')\nassert s.index('B') == 1\nassert s.count('A') == 2\n\n\ns = (30, 20, 40, 10, 50)\nassert min(s) == 10\nassert max(s) == 50",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#القائمة",
    "href": "chapters/05_sequences/a_sequences.html#القائمة",
    "title": "6  المجموعة المرتبة",
    "section": "6.2 القائمة",
    "text": "6.2 القائمة\nالقائمة (list) تسلسل متغير. وهذا يعني:\n\nقولنا (متغيرة) يعني أنها تقبل الإضافة والحذف والتعديل على عناصرها\nقولنا (مرتبة) يعني أن لكل عنصر موضعًا فيها، وله ما قبله وما بعده.\n\nويترتب عليه قبولها الإشارة بالموضع i أو بالقطعة [i:j] أو بالقطعة بالخطوة [i:j:k]\n\n\nانظر MutableSequence في خريطة المجموعات: شكل 1.\n\nالتغير\nالتغير هي الخاصية التي تختلف فيها القائمة عن قسيماتها التسلسلية. ومعناه قبولها الأفعال التالية (نستعمل في المثال حرف l للقائمة):\n\nالاستبدال:\n\nلموضع: l[i] = x\nلقطعة: l[i:j] = t\nلقطعة بخطوة: l[i:j:k] = t\n\nالحذف:\n\nلموضع: del l[i]\nلقطعة: del l[i:j]\nلقطعة بخطوة: del l[i:j:k]\n\nالإزالة: l.remove(x) لحذف أول ورود للعنصر\nالنزع: l.pop([i]) حذف العنصر من الموضع وإرجاعه\n\nإن لم يحدد الموضع: نزع الأخير. إذ القوسان [i] هنا في التعريف يعبران عن عامل اختياري وهو الموضع i\n\nالإدراج: l.insert(i, x) لإضافة عنصر في موضع محدد\nالإلحاق: l.append(x) لإضافة عنصر في النهاية\nالترتيب: l.sort() أو بالفعل المبني sorted(l)\nالعكس: l.reverse() أو بالفعل المبني reversed(l)\n\nلاحظ رسالة الخطأ عند محاولة التعديل على الصف، الذي نعرفه بالقوسين المنحنيين ()، إذْ هو جامد لا يقبل التغير:\n\nt = (10, 20, 30, 40, 50)\nt[0] = 100\nprint(t)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 2\n      1 t = (10, 20, 30, 40, 50)\n----&gt; 2 t[0] = 100\n      3 print(t)\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nلكن هذا مقبول في القائمة، التي نعرفها بالقوسين المربعين []، لأنها متغيرة:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nprint(l)\n\n[100, 20, 30, 40, 50]\n\n\nالاستبدال بالموضع والحذف منه:\n\nl = [10, 20, 30, 40, 50]\nl[0] = 100\nassert l == [100, 20, 30, 40, 50]\n\ndel l[0]\nassert 100 not in l\n\nالاستبدال بالقطعة والحذف منها\n\nl = [10, 20, 30, 40, 50]\nl[1:3] = [200, 300]\nassert l == [10, 200, 300, 40, 50]\n\ndel l[1:3]\nassert l == [10, 40, 50]\n\nالإدراج:\n\nl = [10, 20, 30, 40, 50]\nl.insert(1, 100)\nassert l == [10, 100, 20, 30, 40, 50]\n\nالإزالة:\n\nl = [10, 20, 30, 40, 50]\nl.remove(20)\nassert l == [10, 30, 40, 50]\n\nالإلحاق:\n\nl = [10, 20, 30, 40, 50]\nl.append(60)\nassert l == [10, 20, 30, 40, 50, 60]\n\nالترتيب والعكس:\n\nl = [30, 40, 10, 20, 50]\nl.sort()\nassert l == [10, 20, 30, 40, 50]\n\nl.reverse()\nassert l == [50, 40, 30, 20, 10]\n\nنزع العنصر الأخير وإرجاعه:\n\nl = [10, 20, 30, 40, 50]\nx = l.pop()\nassert x == 50\nassert 50 not in l",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#النطاق",
    "href": "chapters/05_sequences/a_sequences.html#النطاق",
    "title": "6  المجموعة المرتبة",
    "section": "6.3 النطاق",
    "text": "6.3 النطاق\nيمثل النطاق (range) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فثلاثة عوامل تحدده:\n\nالبداية (start=0):\n\nمشمولة\n(إن لم تعيَّن) وهي صفر بالابتداء\n\nالنهاية (stop):\n\nغير مشمولة\nوهي واجبة (إهمالها ممتنع)\n\nالخطوة (step=1):\n\nمقدار الزيادة أو النقص للعدد في كل كرة\n(إن لم تعيَّن) وهي واحد بالابتداء\n\n\nدعونا الآن نلقي نظرة على التعريف كما هو موجود في وثائق بايثون، وذلك لنتعلم كيف نقرؤ التعريف. ادخل الرابط وتأمل معي ..\n\nclass range(stop)\nclass range(start, stop[, step])\n\nأولا: تدل كلمة class على أنها معرَّفة كنوع، فيكون طلب الفعل بنفس الاسم range للإنشاء.\nثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما يكون؟\nنجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو stop وتأخذ البداية والخطوة قيمتهما الابتدائية: start=0 و step=1 حسب ما كُتب:\n\nIf the step argument is omitted, it defaults to 1.\nIf the start argument is omitted, it defaults to 0\n\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nأما التعريف الثاني فيجب تفكيكه لنفهمه: class range(start, stop[, step]).\nوجود الأقواس المربعة [ ] يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو start, stop؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الابتدائية step=1.\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\nالتكرار والإشارة\n\nxs = [10, 20, 30, 40, 50, 60]\n\nوتُسرَد المتسلسلة بكلمة for، نحو:\n\nfor x in xs:\n    print(x)\n\n10\n20\n30\n40\n50\n60\n\n\nأو بسرد نطاقٍ واستعمال الإشارة بالموضع، نحو:\n\nfor i in range(len(xs)):\n    print(xs[i])\n\n10\n20\n30\n40\n50\n60\n\n\nفهذا يفيد في التحكم في السرد، فلو أردنا كل عنصرٍ ثانٍ، نجعل الخطوة 2 ابتداء من العنصر الثاني 1، فنكتبها هكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i])\n\n20\n40\n60\n\n\nأو أردنا قراءة الموضع والذي قبله، فهكذا:\n\nfor i in range(1, len(xs), 2):\n    print(xs[i-1], xs[i])\n\n10 20\n30 40\n50 60\n\n\nفإن جوَّزنا التداخل، جعلنا الخطوة 1، هكذا:\n\nfor i in range(1, len(xs), 1):\n    print(xs[i-1], xs[i])\n\n10 20\n20 30\n30 40\n40 50\n50 60\n\n\nوهلم جرا..\n\n\nتأجيل النتيجة\nويجدر بالذكر أن النطاق لا يولد عناصره التي في النطاق فعليًّا؛ بل يحسبها عند الحاجة إليها. فهو بذلك لا يشغل حيِّزًا في الذاكرة إلا لحدوده الثلاثة والرقم المطلوب حالًا. وهو كالصف لا يقبل التعديل.\nنستعمل فعل الإنشاء range() لإنشاء نطاق:\n\nr = range(0, 20, 2)\nr\n\nrange(0, 20, 2)\n\n\nفحين نسألن عن عضوية عنصر ما في النطاق؛ يتم حساب النطاق بحسبه:\n\nprint(11 in r)\nprint(10 in r)\n\nFalse\nTrue\n\n\nكذلك الفعل عند البحث عن موضع رقمٍ ما:\n\nprint(r.index(10))\n\n5\n\n\nوالإشارة لموضع ما أو قطعة كذلك:\n\nprint(r[5])\nprint(r[:5])\nprint(r[-1])\n\n10\nrange(0, 10, 2)\n18\n\n\n\n\nتحقيق النطاق\nالمولِّد لا تتحقق عناصره إلا عند الحاجة إليها؛ أي: عند قراءتها. فإذا جعلناه فاعلاً في جملة الإنشاء list؛ تولَّدَت جميع عناصره ووُضِعَت في قائمة:\n\nevens = list(range(0, 10, 2))\nodds = list(range(1, 10, 2))\nprint(evens)\nprint(odds)\n\n[0, 2, 4, 6, 8]\n[1, 3, 5, 7, 9]",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#التسلسلات-المرتبطة",
    "href": "chapters/05_sequences/a_sequences.html#التسلسلات-المرتبطة",
    "title": "6  المجموعة المرتبة",
    "section": "6.4 التسلسلات المرتبطة",
    "text": "6.4 التسلسلات المرتبطة\nهذان تسلسلان مرتبطان:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = [90, 80, 75, 85, 95]\n\nassert len(students) == len(marks)\n\nلو أردنا أن نمر على التسلسلين في نفس الوقت نستعمل الفعل المبني zip() الذي يظل يولد صفًا عناصره من كل تسلسل:\n\nlist(zip(students, marks))\n\n[('Ahmad', 90), ('Belal', 80), ('Camal', 75), ('Dawud', 85), ('Emad', 95)]\n\n\nوحاجتنا للفعل المنشئ list() بسبب أن zip مولِّدٌ مثل range لا يحسب العناصر إلا عند قراءتها. والإنشاء يقرأ جميعها لتظهر.\nوعند سياقها في جملة التكرار فإنها تولد زوجًا في كل كرة، إذ هي متوالية (Iterable):\n\nfor x, y in zip(students, marks):\n    print(x, y)\n\nAhmad 90\nBelal 80\nCamal 75\nDawud 85\nEmad 95\n\n\nولو كان لدينا ثلاثة تسلسلات فإنها تولد ثلاثة عناصر في كل كرة:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = range(75, 95+1, 5)\nclasses = ('A-1', 'A-1', 'A-2', 'A-1', 'A-2')\n\nassert list == type(students)\nassert tuple == type(classes)\nassert range == type(marks)\n\nfor x, y, z in zip(students, marks, classes):\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2\n\n\nولاحظ أن نوع students قائمة (list) ونوع marks نطاق (range)، ونوع classes صف (tuple)، لكن الفعل zip يقبل متسلسلات من أي نوع. بل هو في الحقيقة يقبل أي متوالية (Iterable)؛ والتسلسل متوالية (Sequence -&gt; Iterable).\nفتلك الطريقة البايثونية. انظر التوثيق للمزيد عن zip().\nويكون قراءة التسلسلات المرتبطة أيضًا بسرد متوالية النطاق، والإشارة إلى كل عنصر بالموضع:\n\nfor i in range(len(students)):\n    x, y, z = students[i], marks[i], classes[i]\n    print(x, y, z)\n\nAhmad 75 A-1\nBelal 80 A-1\nCamal 85 A-2\nDawud 90 A-1\nEmad 95 A-2",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "href": "chapters/05_sequences/a_sequences.html#الإنشاء-المختصر-الجملة-الثلاثية",
    "title": "6  المجموعة المرتبة",
    "section": "6.5 الإنشاء المختصر: الجملة الثلاثية",
    "text": "6.5 الإنشاء المختصر: الجملة الثلاثية\nمما تميزت به لغة بايثون عن غيرها: مختصرة الإنشاء (Comprehension)؛ وهي جملة تُنشئ مجموعة مستمَدَّة من متوالية في ثلاث جُمَل في سطرٍ واحدٍ -غالبًا- وهدفها: إنشاء مجموعة مستمَدَّة من متوالية.\nوليسَت زيادتها في اللغة من باب الضرورة وإنما من باب التحسين. إذْ فيها قوة في التعبير عن جمل كثيرة في مساحة صغيرة. فهذا المثال يعبر عن إنشاء قائمة كل عنصرٍ فيها مربَّعٌ من المتوالية range(10) في سطرٍ واحد:\n\nsquares = [x ** 2 for x in range(10)]\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nفهي جملة إنشاء مركَّبة من ثلاث جمل:\n\nتعبير (x ** 2) ، الذي يشتمل غالبًا على متغير التكرار (x)\nتكرار: (for x in range(10))\nوشرط: والشرطُ ليسَ بشرط؛ فلم يظهر في هذا المثال\n\nفهي مكافئة للقطعة التالية:\n\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nولو أردنا ترشيح الأعداد الزوجية من قائمة، نستطيع استعمال جملة الشرط في الاختصار على النحو التالي:\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nevens = [x for x in numbers if x % 2 == 0]\nevens\n\n[0, 2, 4, 6, 8]\n\n\n\nالتعبير: (x) فقط\nالتكرار: (for x in numbers)، وتذكر أن القائمة متوالية\nالشرط: (if x % 2 == 0)\n\nوهي مكافئة للقطعة التالية:\n\nevens = []\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\nevens\n\n[0, 2, 4, 6, 8]\n\n\nوأما القوسان المربعان [ ] -في كلا المثالين- فلإنشاء قائمة. وبحسب ما يُراد إنشاؤه تختلف الأقواس:\n\n[expression for item in iterable if condition] للقائمة (list)\n(expression for item in iterable if condition) للمولِّد (Generator)\n{expression for item in iterable if condition} لمجموعة الفرائد (set) وسيأتي الكلام عنها في الباب القادم\n{expression: expression for item in iterable if condition} للقاموس (dict) وسيأتي الكلام عنه في الباب القادم\n\nوقد يكون التعبير غير مشتمل على متغير التكرار، نحو:\n\nnumbers = range(11)\nevens_count = (1 for x in numbers if x % 2 == 0)\n\nفقد أنشأنا بالقوسين الدائريين ( ) مولِّدًا يُنتج 1 لكل عنصر زوجي، بعدد العناصر الزوجية في المتوالية numbers. ثم نحقق وجوده بالقراءة، فنقول مثلاً: sum لجمعها كلها:\n\nsum(evens_count)\n\n6\n\n\nأو نضعها في جملة واحدة:\n\nsum(1 for x in numbers if x % 2 == 0)\n\n6",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html",
    "href": "chapters/05_sequences/apps.html",
    "title": "تطبيقات",
    "section": "",
    "text": "فرز البيانات\nتصور أن لدينا قائمة من الأرقام الموجبة والسالبة في مجموعة واحدة، ونريد فصلها لمجموعتين:\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = []\nnegatives = []\n\nfor x in numbers:\n    if x &gt; 0:\n        positives.append(x)\n    else:\n        negatives.append(x)\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]\nأو باستعمال الإنشاء المختصر:\nnumbers = [-11, -12, 13, 14, -15, 16, 17, -18, -19, 20]\npositives = [x for x in numbers if x &gt; 0]\nnegatives = [x for x in numbers if x &lt; 0]\n\nprint('positives:', positives)\nprint('negatives:', negatives)\n\npositives: [13, 14, 16, 17, 20]\nnegatives: [-11, -12, -15, -18, -19]",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#تجزئة-البيانات",
    "href": "chapters/05_sequences/apps.html#تجزئة-البيانات",
    "title": "تطبيقات",
    "section": "تجزئة البيانات",
    "text": "تجزئة البيانات\nهذا الفعل يقسم قائمة إلى جزئين بنسبة محددة:\n\ndef split(data: list, ratio: float) -&gt; tuple[list, list]:\n    idx = int(len(data) * ratio)\n    return data[:idx], data[idx:]\n\nنختبر الفعل ونلاحظ أن الناتج من نوع صف (tuple). فنستعمل التعيين المتعدد لاستخراج القيم من الصف:\n\nxs = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\na, b = split(xs, 0.80)\n\nassert a == [10, 20, 30, 40, 50, 60, 70, 80]\nassert b == [90, 100]",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#البحث-في-قائمة-صفوف",
    "href": "chapters/05_sequences/apps.html#البحث-في-قائمة-صفوف",
    "title": "تطبيقات",
    "section": "البحث في قائمة صفوف",
    "text": "البحث في قائمة صفوف\nلاحظ أن كل عنصر في القائمة هو صف من ثلاثة عناصر، ولاحظ وجود علامة | في بيان نوع الناتج، وتعني التخيير بين النوعين المذكورين:\n\ndef search_verb(verb: str) -&gt; tuple[str, str, str] | None:\n    dictionary = [\n        (\"ذهب\", \"يذهب\", \"ذاهب\"),\n        (\"ضرب\", \"يضرب\", \"ضارب\"),\n        (\"جلس\", \"يجلس\", \"جالس\")\n    ]\n    for (verb_past, verb_present, subject) in dictionary:\n        if verb_past == verb:\n            return verb_past, verb_present, subject\n    return None\n\nsearch_verb(\"ذهب\")\n\n('ذهب', 'يذهب', 'ذاهب')",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#الحساب-بين-البيانات-المترابطة",
    "href": "chapters/05_sequences/apps.html#الحساب-بين-البيانات-المترابطة",
    "title": "تطبيقات",
    "section": "الحساب بين البيانات المترابطة",
    "text": "الحساب بين البيانات المترابطة\nافترض أن لديك قائمة بالمصروفات والإيرادات لكل رُبع من السنة، وتريد حساب صافي الربح لكل ربع على حدة، ثم جمعها لتحصل على الربح الإجمالي للسنة.\n\nmonthly_income  = [52000, 51000, 48000]\nmonthly_expense = [46800, 45900, 43200]\nmonthly_net = []\nfor inc, exp in zip(monthly_income, monthly_expense):\n    result = inc - exp\n    monthly_net.append(result)\n\nprint(\"monthly net:\", monthly_net)\nprint(\"annual net:\", sum(monthly_net))\n\nmonthly net: [5200, 5100, 4800]\nannual net: 15100\n\n\nأو باستعمال الإنشاء المختصر:\n\nmonthly_income  = [52000, 51000, 48000]\nmonthly_expense = [46800, 45900, 43200]\nmonthly_net = [inc - exp for inc, exp in zip(monthly_income, monthly_expense)]\n\nprint(\"monthly net:\", monthly_net)\nprint(\"annual net:\", sum(monthly_net))\n\nmonthly net: [5200, 5100, 4800]\nannual net: 15100\n\n\nوإن شئت أن تجعلها فعلاً مستقلاً، ولاحظ أن التعريف يُفرق على عدة أسطر إذا طال.\n\ndef calculate_net(\n    monthly_income: list[float],\n    monthly_expense: list[float]\n) -&gt; tuple[list[float], float]:\n    \"\"\"\n    Calculate the net income for each month and the total net income for the year.\n    \"\"\"\n    monthly_net = [inc - exp for inc, exp in zip(monthly_income, monthly_expense)]\n    return monthly_net, sum(monthly_net)\n\nلكن قد لا نحتاج لهذا التفصيل إلا فيما هو معقَّد، وحين يحصل الاشتباه، لكن التعوُّد على مثل هذا خصوصًا في العمل الجماعي، وحين يكبُر المشروع أفضل.",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "href": "chapters/05_sequences/apps.html#معرفة-النقاط-المجاورة",
    "title": "تطبيقات",
    "section": "معرفة النقاط المجاورة",
    "text": "معرفة النقاط المجاورة\nتقول الرياضيات أن المسافة الإقليدية (على سطح مستوي لا متعرج) بين نقطتين تحكمها المعادلة:\n\\[\nd = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\nنريد استعماله لقائمة من النقاط لمعرفة النقاط المجاورة.\n\npoints = [(1, 2), (3, 4), (5, 6), (7, 8)]\nx1, y1 = (2, 4)\n\ndistances = []\n\nfor x2, y2 in points:\n  d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n  distances.append(d)\n  print(f'distance from {x2, y2} to {x1, y1} is {d}')\n\nmin_distance = min(distances)\nmin_distance_index = distances.index(min_distance)\n\nprint('min distance index:', min_distance_index)\n\nnearest_point = points[min_distance_index]\n\nprint(f'nearest point to {x1, y1} is {nearest_point}')\n\ndistance from (1, 2) to (2, 4) is 2.23606797749979\ndistance from (3, 4) to (2, 4) is 1.0\ndistance from (5, 6) to (2, 4) is 3.605551275463989\ndistance from (7, 8) to (2, 4) is 6.4031242374328485\nmin distance index: 1\nnearest point to (2, 4) is (3, 4)\n\n\nفلنجعلها فعلاً، وسنفصِّلُ في الوصف حتى نبيِّنَ وظيفة الفعل لأي مستفيد بما يهمه، فنذكر الماهية ولا نذكر الكيفية التفصيلية:\n\ndef nearest_point(\n    points: list[tuple[float, float]],\n    point: tuple[float, float]\n) -&gt; tuple[float, float]:\n    \"\"\"Find the nearest point to the given point.\n    \n    Args:\n        points: A list of (x,y) coordinate tuples representing points in 2D space.\n                Must contain at least one point.\n        point: A tuple of (x,y) coordinates representing the reference point.\n    \n    Returns:\n        The (x,y) coordinates of the point from the input list that is closest\n        to the reference point, measured by Euclidean distance.\n    \"\"\"\n    x1, y1 = point\n    distances = []\n    for x2, y2 in points:\n        d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n        distances.append(d)\n    min_distance = min(distances)\n    min_distance_index = distances.index(min_distance)\n    return points[min_distance_index]\n\n# Tests\nassert nearest_point(points=[(1, 2)], point=(2, 3)) == (1, 2)\nassert nearest_point(points=[(1, 2), (3, 4), (5, 6), (7, 8)], point=(2, 4)) == (3, 4)",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "href": "chapters/05_sequences/apps.html#أمثلة-إضافية-على-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "أمثلة إضافية على الإنشاء المختصر",
    "text": "أمثلة إضافية على الإنشاء المختصر\nيمكن استعمال اختصار من اختصار على النحو التالي. في هذا المثال نفرد قائمة مكونة من قوائم عددية، فنحوِّلها لتكون قائمة واحدة مكوَّنة من جميع هذه الأرقام:\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nإذا كتبناها من غير اختصار فشكلها كالتالي (لاحظ استعملنا متغير flat لتجميع القيَم المفردة):\n\nflat = []\nfor elem in vec:\n    for num in elem:\n        flat.append(num)\nflat\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nوهذا مثال لحاصل الضرب الديكارتي بين مجموعتين رياضيتين:\n\ncolors = ['red', 'green']\nshapes = ['circle', 'square']\ncartesian_product = [(color, shape) for color in colors for shape in shapes]\ncartesian_product\n\n[('red', 'circle'),\n ('red', 'square'),\n ('green', 'circle'),\n ('green', 'square')]\n\n\nراجع التوثيق لمزيد من الأمثلة.",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html",
    "href": "chapters/05_sequences/problems.html",
    "title": "مسائل",
    "section": "",
    "text": "سلة مشتريات\nلديك قائمة بالفواكه وأسعارها.\nولديك سلة مشتريات تريد أن تحسب مجموعها.\nاكتب فعل يحسب مجموع السلة:",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "href": "chapters/05_sequences/problems.html#سلة-مشتريات",
    "title": "مسائل",
    "section": "",
    "text": "fruits = [\"apple\", \"banana\", \"orange\"]\nprices = [    1.5,      2.0,      1.0]\n\ndef calculate_total_price(shopping_list: list[str]) -&gt; float:\n    \"\"\"Calculate the total price of the shopping list.\"\"\"\n    pass\nassert calculate_total_price([\"apple\", \"apple\", \"apple\"]) == 4.5\nassert calculate_total_price([\"banana\", \"apple\"]) == 3.5\nassert calculate_total_price([]) == 0.0",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "href": "chapters/05_sequences/problems.html#متوسط-المبيعات-اليومية",
    "title": "مسائل",
    "section": "متوسط المبيعات اليومية",
    "text": "متوسط المبيعات اليومية\ndaily_sales = [\n    10, 12, 10, 15, 13, 14, 10,\n    19, 14, 12, 8, 10, 11, 12,\n    14, 15, 14, 14, 10, 5, 13,\n    8, 20, 19, 15, 14, 13, 12,\n]\nاحسب ما يلي:\n\nعدد الأيام\n\nيمكنك استعمال الفعل len()\n\nمجموع المبيعات لكل أسبوع على حدة\n\nيمكنك استعمال الفعل sum() واستعمال الإشارة بقطعة [:7] للأسبوع الأول\n\nمتوسط المبيعات لكل أسبوع على حدة والانحراف المعياري\n\nيمكنك استعمال الفعل statistics.mean() و statistics.stdev()\n\nمتوسط المبيعات خلال الشهر والانحراف المعياري",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "href": "chapters/05_sequences/problems.html#ضرب-متجهين",
    "title": "مسائل",
    "section": "ضرب متجهين",
    "text": "ضرب متجهين\ndef dot_product(v: list[float], u: list[float]) -&gt; float:\n    \"\"\"Calculate the dot product of two vectors.\"\"\"\n    pass\nللاختبار سنستعمل ما هو موجود في مكتبة numpy:\nimport numpy as np\n\nassert dot_product([1, 2, 3], [4, 5, 6]) == np.dot([1, 2, 3], [4, 5, 6])\nassert dot_product([1, 2, 3], [1, 2, 3]) == np.dot([1, 2, 3], [1, 2, 3])",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/05_sequences/problems.html#توزيع-الفرق",
    "href": "chapters/05_sequences/problems.html#توزيع-الفرق",
    "title": "مسائل",
    "section": "توزيع الفرق",
    "text": "توزيع الفرق\nلديك قائمة من الأسماء وتريد توزيعها إلى مجموعات:\n\nالحالة الأولى: يتم تعيين حجم المجموعة الواحدة\nالحالة الثانية: يتم تعيين عدد المجموعات\n\ndef make_groups1(items: list[str], num_groups: int = None, group_size: int = None) -&gt; list[list[str]]:\n    pass\nويجب أن يكون الترتيب عشوائيًّا. انظر توثيق مكتبة بايثون عن مكتبة العشواء هذه: random.choice(), random.shuffle(), random.sample().\nافترض أن هذه القائمة التي لديك:\nAhmad\nMohannad\nMohammed\nSalem\nAli\nSamir\nالاختبارات\ng1 = make_groups1([\"Ahmad\", \"Mohannad\", \"Mohammed\", \"Salem\", \"Ali\", \"Samir\"], num_groups=2)\nassert len(g1) == 2\nassert len(g1[0]) == 3\nassert len(g1[1]) == 3\n\ng2 = make_groups1([\"Ahmad\", \"Mohannad\", \"Mohammed\", \"Salem\", \"Ali\", \"Samir\"], group_size=2)\nassert len(g2) == 3\nassert len(g2[0]) == 2\nassert len(g2[1]) == 2\nassert len(g2[2]) == 2\n\nضم الأقران\nتريد الآن أن تزيد شرطًا وهو أن يكون فارق العمر بينهم أقل ما يمكن. وهذه أعمارهم:\nAhmad: 24\nMohannad: 17\nMohammed: 16\nSalem: 32\nAli: 26\nSamir: 31\nالاختبارات\ngroups = make_groups2([\"Ahmad\", \"Mohannad\", \"Mohammed\", \"Salem\", \"Ali\", \"Samir\"], group_size=2)\nfor g in groups:\n    if \"Ahmad\" in g:\n        assert \"Ali\" in g\n    if \"Mohannad\" in g:\n        assert \"Mohammed\" in g\n    if \"Salem\" in g:\n        assert \"Samir\" in g",
    "crumbs": [
      "باب المجموعة المرتبة (Sequences)",
      "مسائل"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a_mapping.html",
    "href": "chapters/06_mapping/a_mapping.html",
    "title": "7  المجموعة المرقومة",
    "section": "",
    "text": "7.1 مجموعة الفرائد\nبعد أن رأينا التلسلسل الذي هو نوع مجموعة مرتبة. ننتقل في درسنا هذا للبحث في نوعين آخرين يندرجان تحت المجموعة المرقومة:\nمجموعة الفرائد (set) هي مجموعة متغيرة تحوي أشياء مرقومة فريدة بلا ترتيب.\nانظر MutableSet في خريطة المجموعات: شكل 1.\nتنشأ المجموعة الفريدة بالفعل المنشئ set(). ويفضل استعمال القوسين المتعرجين { } بدلاً منه:\ns1 = set([10, 20, 30])\ns2 = {10, 20, 30}\nassert s1 == s2\nتقبل مجموعة الفرائد لكونها مجموعة (Collection) العمليات التالية:\nوباعتبارها مجموعة متغيرة (MutableSet)، فإنها تقبل الأفعال التالية:\nذكرنا أن شرط عضوية العنصر أن يكون مرقومًا؛ وهذا يجعل عملية البحث فيها قفزة واحدة (O(1))؛ إذْ يتم حساب الرقم بالفعل hash() الذي يشير لعنوان القيمة في الذاكرة.\nالمرقوم (Hashable): هو ما يقبل الفعل hash() الذي يحول الشيء إلى رقم فريد. ومنه:\nأما القائمة مثلاً، فليست معدودة ضمن المرقومات، وذلك لأنها متغيرة (تقبل زيادة أو حذف أو تعديل عنصر) وذلك يغير الرقم؛ والشرط في المرقوم ألا يتغير رقمه أبدًا؛ لذا تجد الصف معدودًا ضمن المرقومات وليست القائمة كذلك:\ns = {10, 'AAA', True, (22, 'BB')}\n\nassert len(s) == 4\nassert 22 not in s\nassert (22, 'BB') in s\n\nfor x in s:\n    print(x)\n\n(22, 'BB')\nTrue\n10\nAAA\nباعتبارها مجموعة غير مرتبة، فإنها لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تقبل الإشارة (xs[i]) أو التقطيع (xs[i:j]) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:\nxs = {10, 20, 30}\nxs[0]\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 2\n      1 xs = {10, 20, 30}\n----&gt; 2 xs[0]\n\nTypeError: 'set' object is not subscriptable\nوتقبل المجموعة الفريدة ما تقبله المجموعة في الرياضيات من عمليات:\nوهذا الكود مثال لجميع هذه العمليات الرياضية:\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}\n\nunion = set1 | set2\nassert union == {1, 2, 3, 4, 5, 6, 7, 8}\n\nintersection = set1 & set2\nassert intersection == {4, 5}\n\ndiff1 = set1 - set2\nassert diff1 == {1, 2, 3}\n\ndiff2 = set2 - set1\nassert diff2 == {6, 7, 8}\n\nsymmetric_difference = set1 ^ set2\nassert symmetric_difference == {1, 2, 3, 6, 7, 8}\nنصيحة: من الأفضل استعمال اسم الفعل بدلاً من العلامة التي تقابله حيث أنها تقبل أي نوع من المتكررات (Iterables) ولا تقتصر على مجموعة الفرائد فقط (set).\nوكذلك لدينا أفعال تحقق الجزئية والشمول والانفصال:\nوهذا مثال لاستعمالها:\nset1 = {'A', 'B', 'C'}\nset2 = {'A', 'B', 'C', 'D', 'E'}\nset3 = {'سين', 'جيم', 'قاف'}\n\nassert (set1 &lt;= set2) == set1.issubset(set2)\nassert (set2 &gt;= set1) == set2.issuperset(set1)\nassert (\n    set3.isdisjoint(set1 | set2) ==\n    (len(set3 & (set1 | set2)) == 0)\n)\nوهنا بحثٌ سريع جدًا باستعمال جملة التحقق من العضوية (بالتأكيد لا يظهر أثر السرعة في مجموعة صغيرة):\nlanguages = {\"Arabic\", \"English\"}\nif 'Python' not in languages:\n    print('you need to add Python to your languages!')\n\nyou need to add Python to your languages!\nوتستعمل كذلك لإزالة العناصر المتكررة في أي مجموعة، نحو الكود التالي. فإننا نحول القائمة إلى مجموعة فرائد فتزول تلك العناصر تلقائيًّا، ثم نعيدها كما كانت:\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nunique_numbers = list(set(numbers))\nprint(unique_numbers)\n\n[1, 2, 3, 4, 5]\nوكذلك من الصف:\nt = (1, 2, 2, 3, 4, 4, 5)\nunique_t = tuple(set(t))\nprint(unique_t)\n\n(1, 2, 3, 4, 5)",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرقومة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a_mapping.html#مجموعة-الفرائد",
    "href": "chapters/06_mapping/a_mapping.html#مجموعة-الفرائد",
    "title": "7  المجموعة المرقومة",
    "section": "",
    "text": "قولنا (متغيرة) يعني أنها تقبل الإضافة والحذف والتعديل على عناصرها\nقولنا (فريدة) يعني أن العنصر لا يتكرر فيها\nقولنا (مرقومة) يعني أن عناصرها يجب أن تكون قابلة للرقم (hash)\nقولنا (بلا ترتيب) يعني أن العنصر ليس له موقع محدد فيها فليس له ما قبله وليس له ما بعده\n\n\n\n\n\n\nالعد: len(s)\nالتكرار: for x in s\nالعضوية: x not in s\n\n\n\nالإضافة: add\nالحذف: discard\nنزع عنصر عشوائي: pop\nالمحو: clear\n\n\n\n\nالنص (str) له خوارزمية معيَّنة لرقْمه\nالرقم (int) رقْمه هو نفسه\nالصف (tuple) رقْمه هو رقم عناصره (فيجب أن تكون جميع عناصره مرقومة)\n\n\n\n\n\n\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل).\n\n\n\n\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالفعل المكافئ\n\n\n\n\nالاتحاد\nset1 | set2\nset1.union(set2)\n\n\nالتقاطع\nset1 & set2\nset1.intersection(set2)\n\n\nالفرق\nset1 - set2\nset1.difference(set2)\n\n\nالفرق التماثلي\nset1 ^ set2\nset1.symmetric_difference(set2)\n\n\n\n\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالفعل المكافئ\n\n\n\n\nتحقق الجزئية\nset1 &lt;= set2\nset1.issubset(set2)\n\n\nتحقق الشمول\nset1 &gt;= set2\nset1.issuperset(set2)\n\n\nتحقق الانفصال\nlen(set1 & set2) == 0\nset1.isdisjoint(set2)",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرقومة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/a_mapping.html#القاموس",
    "href": "chapters/06_mapping/a_mapping.html#القاموس",
    "title": "7  المجموعة المرقومة",
    "section": "7.2 القاموس",
    "text": "7.2 القاموس\nالقاموس (dict) هو مجموعة مرتبة من المرقومات الفريدة الدالة على قيم.\nانظر MutableMapping في خريطة المجموعات: شكل 1.\nتنشأ المجموعة الرابطة بالفعل المنشئ dict() ويفضل استعمال القوسين المتعرجين { } بدلاً منه:\n\nd1 = dict(key1='value1', key2='value2')\nd2 = {'key1': 'value1', 'key2': 'value2'}\nassert d1 == d2\n\nاصطلاحات: نسمي key1 المرقوم ونسمي value1 القيمة؛ وهما معًا نسميهما رابطًا.\nومن حيث كون القاموس مجموعة (Collection)، فإنه يقبل الأفعال ثلاثة:\n\nالعضوية: x not in d\nالعد: len(d)\nالتكرار: for x in d\n\nويقبل القاموس لكونه دالة (Mapping) الأفعال التالية:\n\nالإشارة بمرقوم: dict[key]\nالإشارة بمرقوم أو إرجاع قيمة افتراضية: dict.get(key[, default])\n\nويجوز التكرار بثلاثة طرق:\n\nكر الروابط: for key, value in d.items()\nكر المرقومات: for key in d.keys()\nكر القيم: for value in d.values()\n\nولكونه دالة متغيرة (MutableMapping)، فإنه يقبل الأفعال التالية:\n\nالتعديل بمرقوم: dict[key] = value\nالحذف بمرقوم: del dict[key]\nنزع بمرقوم وإرجاع القيمة: x = dict.pop(key)\nالتحديث بدالَّة أو بمكرر روابط: dict.update(mapping)\n\nملاحظة: منذ بايثون 3.7 أصبح القاموس مرتبًا. أي أن الروابط لها ما قبلها ولها ما بعدها بحسب ترتيب إدراجها.\nلاحظ أننا نستعمل مرقومات مختلفة وأيضًا نستعمل قيم مختلفة:\n\ndata = {\n    'key1': 100,\n    20: 'value2',\n    'c': [10, 20, 30, True],\n    (1, 2): 'value3',\n    ('a', 'b', 'c'): 'value4',\n}\n\nassert len(data) == 5\ndel data['key1']\nassert 'key1' not in data\n\nونحصل عليها بالإشارة بمرقوم:\n\nprint(data[20])\nprint(data['c'])\nprint(data[(1, 2)])\nprint(data[('a', 'b', 'c')])\n\nvalue2\n[10, 20, 30, True]\nvalue3\nvalue4\n\n\n\nإنشاء قاموس من سلسلتين\nويتحصل القاموس من سلسلتين باستعمال الفعل zip()، كما يلي:\n\nstudents = ['Ahmad', 'Belal', 'Careem', 'David']\nmarks = [90, 80, 75, 85]\ndata = dict(zip(students, marks, strict=True))\ndata\n\n{'Ahmad': 90, 'Belal': 80, 'Careem': 75, 'David': 85}",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرقومة</span>"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html",
    "href": "chapters/06_mapping/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "الكلمة ومعناها\nالقاموس بالمعنى الذي يشير إليه اللفظ. نفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:\nenglish_to_arabic = {\n    'apple': 'تفاحة',\n    'banana': 'موزة',\n    'orange': 'برتقالة',\n}",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#ربط-الأسماء-بالأرقام",
    "href": "chapters/06_mapping/b_context.html#ربط-الأسماء-بالأرقام",
    "title": "تطبيقات",
    "section": "ربط الأسماء بالأرقام",
    "text": "ربط الأسماء بالأرقام\nمثلاً: دليل أرقام الهواتف هو قاموس:\n\nname_to_phone = {\n    'Adam': '966xxxxxxxxx',\n    'Mohammed': '966xxxxxxxxx',\n}\n\nوكذلك دليل أسماء النطاق (DNS: Domain Name System) على شبكة الانرتنت هو قاموس:\n\ndomain_to_ip = {\n    'google.com': '172.217.14.206',\n    'wikipedia.org': '103.86.96.10',\n}",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#اختصار-الروابط-الطويلة",
    "href": "chapters/06_mapping/b_context.html#اختصار-الروابط-الطويلة",
    "title": "تطبيقات",
    "section": "اختصار الروابط الطويلة",
    "text": "اختصار الروابط الطويلة\nمن استعمالات القاموس: اختصار الروابط الطويلة في روابط قصيرة.\n\nshort_to_full = {\n    'google': 'https://www.google.com',\n    'python': 'https://www.python.org',\n    'wiki': 'https://www.wikipedia.org',\n}",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#الاختصارات",
    "href": "chapters/06_mapping/b_context.html#الاختصارات",
    "title": "تطبيقات",
    "section": "الاختصارات",
    "text": "الاختصارات\nأو الاختصارات إلى الكلمة التامة:\n\nabb_to_full = {\n    'ASAP': 'As Soon As Possible',\n    'BRB': 'Be Right Back',\n    'DIY': 'Do It Yourself',\n    'EDA': 'Exploratory Data Analysis',\n    'FYI': 'For Your Information',\n    'SAR': 'Saudi Riyal',\n}\n\nويمكن عكس القاموس بالطريقة التالية:\n\nfull_to_abb = {}\n\nfor key, value in abb_to_full.items():\n    full_to_abb[value] = key\n\nprint(full_to_abb)\n\n{'As Soon As Possible': 'ASAP', 'Be Right Back': 'BRB', 'Do It Yourself': 'DIY', 'Exploratory Data Analysis': 'EDA', 'For Your Information': 'FYI', 'Saudi Riyal': 'SAR'}",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#سلة-المشتريات",
    "href": "chapters/06_mapping/b_context.html#سلة-المشتريات",
    "title": "تطبيقات",
    "section": "سلة المشتريات",
    "text": "سلة المشتريات\nنفترض أن لدينا سلة تحتوي على مشتريات العميل (basket)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس prices بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).\n\nprices = {\n    'apple': 15.25,\n    'banana': 10.50,\n    'orange': 5.75,\n    'cantaloupe': 40.00\n}\n\nيجوز تحديث الأسعار هكذا:\n\nprices['banana'] = 12\n\nأو بالمجموع هكذا:\n\nprices.update({'banana': 12, 'orange': 15})\n\nوالآن نفترض أن لدينا قائمة بالفواكه التي يريدها العميل:\n\nbasket = ['apple', 'apple', 'banana', 'orange', 'banana']\n\nنحسب سعر كل فاكهة في السلة بناءً على الأسعار الموجودة في القاموس:\n\ntotal = 0\n\nfor fruit in basket:\n    total += prices[fruit]\n\nprint(total)\n\n69.5",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#تسجيل-تفضيلات-المستخدم",
    "href": "chapters/06_mapping/b_context.html#تسجيل-تفضيلات-المستخدم",
    "title": "تطبيقات",
    "section": "تسجيل تفضيلات المستخدم",
    "text": "تسجيل تفضيلات المستخدم\nيجوز أن تكون قيمة المرقوم قاموسًا؛ وهذا يعني أن القاموس قد يتضمن قاموسًا.\nهذا المثال يوضح استعمالًا شائعًا لذلك، وهو ترتيب معلومات أو تفضيلات المستخدم.\n\nuser = {\n    'name': 'Adam',\n    'language': 'Arabic',\n    'phone': '966xxxxxxxxx',\n    'last_updated': '2021-09-01',\n    'age': 25,\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\nوللوصول إلى قيمة مضمَّنة، نستعمل الإشارة مرتين، هكذا:\n\nuser['notifications']['sms']\n\nFalse\n\n\nأما حفظها فسيأتي الكلام عن حفظ البيانات في باب كتابة الملفات وقراءتها إن شاء الله.",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#الذاكرة-القريبة",
    "href": "chapters/06_mapping/b_context.html#الذاكرة-القريبة",
    "title": "تطبيقات",
    "section": "الذاكرة القريبة",
    "text": "الذاكرة القريبة\nيجوز أن تسجل نتيجة طلب فعل بمدخلات معيَّنة. حتى إذا ما تكرر الطلب نفس المدخلات؛ توفِّر تكلفة استدعائه بإرجاع النتيجة المحفوظة. وهذا يفيد في أمرين:\n\nالاقتصاد في موارد المعالجة، خصوصًا عند تعقد العمليات.\nتقليل وقت الاستجابة.\n\nويشترط أن يكون الفعل نقيًّا. (انظر قسم الفعل النقي في باب الفعل).\n\nfactorial_table = {\n    0: 1,\n    1: 1,\n    2: 2,\n    3: 6,\n}\n\ndef factorial(n):\n    if n not in factorial_table:\n        factorial_table[n] = n * factorial(n - 1)\n    return factorial_table[n]\n\nبل إن بايثون توفر هذه الخاصية للدوال عن طريق المزيِّن (decorator) @functools.lru_cache، هكذا:\n\nimport functools\n\n@functools.lru_cache\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nلاحظ عدم الحاجة لتعريف القاموس factorial_table، بل يقوم المزيِّن هو بذلك تلقائيًّا.",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/b_context.html#استعمال-الإنشاء-المختصر",
    "href": "chapters/06_mapping/b_context.html#استعمال-الإنشاء-المختصر",
    "title": "تطبيقات",
    "section": "استعمال الإنشاء المختصر",
    "text": "استعمال الإنشاء المختصر\nتقدم معنا الكلام عن الإنشاء المختصر. وسنستعرضه الآن مع القاموس.\nعكس قاموس بحيث تصبح الدلائل هي القيم والقيم هي الدلائل:\n\nidx2label = {\n    0: 'cat',\n    1: 'dog',\n    2: 'bird',\n}\n\nlabel2idx = {label: idx for idx, label in idx2label.items()}\nlabel2idx\n\n{'cat': 0, 'dog': 1, 'bird': 2}\n\n\nهنا مثال لقاموس من الفواكه، نريد ترشيح ما قيمته أقل من 20:\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nfiltered_menu = {key: value for key, value in menu.items() if value &lt; 20}\nfiltered_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5}\n\n\nوهذا مثال أكثر تعقيدًا. نطبق خصم 20% فقط على العناصر التي يكون سعرها أعلى من المتوسط، مع الحفاظ على بقية الأسعار كما هي. لاحظ أن التعبير هنا هو تعيين شرطي: value * (1 - discount) if value &gt; avg_price else value وليس هو قطعة الترشيح (if)؛ إذ تلك تأتي في نهاية الجملة، بعد قطعة التكرار (for).\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\navg_price = sum(menu.values()) / len(menu)\ndiscount = 0.20\n\ndiscounted_menu = {\n    key: value * (1 - discount) if value &gt; avg_price else value\n    for key, value in menu.items()\n}\ndiscounted_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5, 'cantaloupe': 32.0}",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html",
    "href": "chapters/06_mapping/c_problems.html",
    "title": "تمارين",
    "section": "",
    "text": "قاموس داخل قاموس\nإذا كان لديك قاموس متداخل كالتالي:\nmy_dict = {\n    \"class\": {\n        \"president\": {\n            \"name\": \"Malik\",\n            \"marks\": {\n                \"physics\": 70,\n                \"history\": 80\n            }\n        }\n    }\n}\nالمطلوب: اطبع قيمة المفتاح \"history\" بالتدريج من القاموس المتداخل.",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#توحيد-الصيغة",
    "href": "chapters/06_mapping/c_problems.html#توحيد-الصيغة",
    "title": "تمارين",
    "section": "توحيد الصيغة",
    "text": "توحيد الصيغة\nفي هذا المثال، تعود هذه النصوص كلها إلى نفس المعنى.\n\n(‘medina’, ‘madinah’, ‘madina’, ‘al madinah’, ‘al madina’, ‘medina’, ‘madinah’, ‘madina’, ‘المدينة’, ‘مدينة’),\n(‘mecca’, ‘makkah’, ‘makka’, ‘makkah’, ‘makkah’, ‘مكة’, ‘مكه’),\n\ndef normalize_city_name(city_name: str) -&gt; str:\n    pass\nassert (\n    'medina' ==\n    normalize_city_name('medinah') ==\n    normalize_city_name('al madina') ==\n    normalize_city_name('المدينة') ==\n    normalize_city_name('المدينه')\n)\nassert (\n    'mecca' ==\n    normalize_city_name('makkah') ==\n    normalize_city_name('makka') ==\n    normalize_city_name('مكة') ==\n    normalize_city_name('مكه')\n)",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#تصحيح-الإملاء",
    "href": "chapters/06_mapping/c_problems.html#تصحيح-الإملاء",
    "title": "تمارين",
    "section": "تصحيح الإملاء",
    "text": "تصحيح الإملاء\nاكتب فعلً يصحح الإخطاء الشائعة في الإملاء العربي.\n\nإبدال التاء المربوطة بالهاء: مكتبه، لعبه، روايه\nإبدال الظاء بالضاد والعكس: ظابط، قرظ، ضهر\nزيادة الياء: أحسنتي، رأيتكي\n\ndef correct_spelling(word: str) -&gt; str:\n    pass\nassert correct_spelling('المكتبه فيها الروايه التي أبحث عنها') == 'المكتبة فيها الرواية التي أبحث عنها'\nassert correct_spelling('أعطاك الظابط القرظ بعد الضهر') == 'أعطاك الضابط القرض بعد الظهر'\nassert correct_spelling('رأيتكي أحسنتي') == 'رأيتك أحسنت",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#حساب-الجمل",
    "href": "chapters/06_mapping/c_problems.html#حساب-الجمل",
    "title": "تمارين",
    "section": "حساب الجُمَّل",
    "text": "حساب الجُمَّل\nحِسَاب الجُمَّل هي طريقة لتسجيل صور الأرقام والتواريخ باستخدام الحروف الأبجدية، إذ يُعطى كل حرف رقما معينا يدل عليه.\nفكانوا من تشكيلة هذه الحروف ومجموعها يصلون إلى ما تعنيه من تاريخ مقصود وبالعكس كانوا يستخدمون الأرقام للوصول إلى النصوص.\n\n\n\nحساب الجمَّل\n\n\n\n\n\n\n\n\n\n\n\nا\n1\nي\n10\nق\n100\nغ\n1000\n\n\nب\n2\nك\n20\nر\n200\nبغ\n2000\n\n\nجـ\n3\nل\n30\nش\n300\nجغ\n3000\n\n\nد\n4\nم\n40\nت\n400\nدغ\n4000\n\n\nهـ\n5\nن\n50\nث\n500\nهغ\n5000\n\n\nو\n6\nس\n60\nخ\n600\nوغ\n6000\n\n\nز\n7\nع\n70\nذ\n700\nزغ\n7000\n\n\nح\n8\nف\n80\nض\n800\nحغ\n8000\n\n\nط\n9\nص\n90\nظ\n900\nطغ\n9000\n\n\n\nاكتب تفاصيل الفعل الذي يحسب الجمَّل لكلمة معينة.\ndef gematria(word: str) -&gt; int:\n    pass\nassert gematria('غرم') == 1240\nassert gematria('رب') == 202\nassert gematria('ريح') == 218\nassert gematria('شعب') == 372\nوكذلك في العبارات:\nassert gematria('في المشمش') == 801 == 80+10+1+30+40+300+40+300\nassert gematria('مات الشعر بعده') == 1123 == 40+1+400+1+30+300+70+200+2+70+4+5",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/06_mapping/c_problems.html#التوفيق-بين-مجموعتين",
    "href": "chapters/06_mapping/c_problems.html#التوفيق-بين-مجموعتين",
    "title": "تمارين",
    "section": "التوفيق بين مجموعتين",
    "text": "التوفيق بين مجموعتين\nمسألة التوفيق بين مجموعتين تجدها في سياقات كثيرة.\nنريد في هذا التمرين التوفيق بين أشخاص وما لديهم من مهارات وبين شركات وما تطلبها من هذه المهارات.\nيمكن أن تبدأ بهذا الشكل لإيجاد كمية التوافق:\nperson_skills = {\"Python\", \"SQL\"}\nneeded_skills = {\"Python\", \"R\", \"Ninja\", \"Gymnastics\", \"Art of War\"}\nلكن في الواقع تأتي البيانات لمجموعة من الأشخاص مع مجموعة من الشركات هكذا:\npeople = [\n    {\"name\": \"Ahmad\", \"skills\": [\"Python\", \"Go\", \"JavaScript\", \"Machine Learning\", \"Statistics\"]},\n    {\"name\": \"Jawad\", \"skills\": [\"Management\", \"Business\", \"Marketing\"]},\n    {\"name\": \"Belal\", \"skills\": [\"Python\", \"Statistics\", \"R\", \"Management\"]},\n]\n\ncompanies = [\n    {\"name\": \"X\", \"skills_needed\": [\"Python\", \"Machine Learning\", \"Statistics\"]},\n    {\"name\": \"Y\", \"skills_needed\": [\"Sales\", \"Marketing\", \"Leadership\", \"Management\"]},\n    {\"name\": \"Z\", \"skills_needed\": [\"Statistics\", \"R\", \"Management\"]},\n]\nاكتب برنامج للتوفيق بين المجموعتين بحيث ترتب على بما يناسب الشركات مرة، وبما يناسب الأشخاص مرة.\nX: Ahmad, ...\nY: Jawad, ...\nZ: Belal, ...\n\nAhmad: X, ...\nJawad: Y, ...\nBelal: Z, ...",
    "crumbs": [
      "باب المجموعة الرابطة (Mapping)",
      "تمارين"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html",
    "href": "chapters/07_strings/a1_strings.html",
    "title": "8  النص",
    "section": "",
    "text": "8.1 النص الطبيعي\nالنص (str) صف من الأحرف. وهو تسلسل ثابت من أرقام يونيكود (Unicode) التي هي رموز تتبع ترميزًا عالميًا يحوي جميع أحرف اللغات بالإضافة إلى علامات الترقيم والرسوم (مثل: 💡🔍📐) ونحوها.\nالنص الطبيعي (الحر أو البشري) هو ما لا يتبع هيكلاً أو قالبًا يحكم طريقة كتابته؛ وهو يطول ويقصر من الحرف الواحد إلى مجموعة الأحرف إلى الكلمة إلى الجملة وإلى أكبر من ذلك نحو:\nوأوجه معالجة النصوص الحرة كثيرة منها: الفهرسة والبحث والاستبدال والعد والتصنيف والترتيب والقولبة …إلخ.",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "href": "chapters/07_strings/a1_strings.html#النص-الطبيعي",
    "title": "8  النص",
    "section": "",
    "text": "محادثات وسائل التواصل الاجتماعي\nرسائل البريد الإلكتروني\nمقالات\nكتب\nموسوعات\nصفحات الشبكة\nمواقع الشبكة",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "href": "chapters/07_strings/a1_strings.html#النص-المقولب",
    "title": "8  النص",
    "section": "8.2 النص المُقَوْلَب",
    "text": "8.2 النص المُقَوْلَب\nالنص المقولَب الذي يأخذ شكلاً محددًا؛ وله صيغ متعددة يُنشئ الناس منها قوالب للنص لتمثل مجموعات أو ارتباطات من البيانات، كالجداول ونحوها.\nوصيغ القولبة كثيرة من أشهرها: XML, YAML, JSON, CSV\n\n\nمثال لقالب بصيغة YAML:\n---\nName: Adam\nAge: 25\nCity: Riyadh\n\nمثال لقالب بصيغة JSON:\n{\n  \"Name\": \"Adam\",\n  \"Age\": 25,\n  \"City\": \"Riyadh\"\n}\n\n\nوهذا مثال لقالب بصيغة XML:\n&lt;person&gt;\n  &lt;name&gt;Adam&lt;/name&gt;\n  &lt;age&gt;25&lt;/age&gt;\n  &lt;city&gt;Riyadh&lt;/city&gt;\n&lt;/person&gt;\nوالصيغة التي تستعمل كثيرًا لتمثيل الجداول (صفوف) هي صيغة CSV. فكل سطرٍ هو صفٌّ في الجدول، وأوَّلُ سطرٍ هو رأس الجدول عادةً. وذلك على النحو التالي:\nName,Age,City\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\nجرب أن تُنشئ ملفًّا نصيًّا وتكتب فيه ذلك وتحفظه بصيغة csv ثم سترى أنه يمكنك فتحه بمحرر جداول (:مثل إكسل - Excel).",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "href": "chapters/07_strings/a1_strings.html#إنشاء-النص",
    "title": "8  النص",
    "section": "8.3 إنشاء النص",
    "text": "8.3 إنشاء النص\nجملة إنشاء النص في بايثون تكون كالتالي:\n\nبعلامة اقتباس مفردة: 'السلام عليكم!'\nأو بعلامة اقتباس مزدوجة: \"السلام عليكم!\" وليس بينهما فرق.\nأو بعلامة اقتاس مكررة ثلاثة مرات: \"\"\"السلام عليكم!\"\"\" للنص الجاري على أكثر من سطر.\n\nعلى سبيل المثال:\n\nname = 'Adam'\naddress = \"Makkah, Saudi Arabia\"\n\nتأمل إنشاء هذا النص الذي يبتدئ في السطر الأول ويتمد لأربعة أسطر:\n\nmessage = \"\"\"السلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\"\"\"\nprint(message)\n\nالسلام عليكم ورحمة الله وبركاته,\nأبشركم بأنكم قطعتم نصف المشوار.\n\nشكرًا لكم.\nأخوكم آدم.\n\n\n\n\nقراءة الملفات النصية\nوكثيرًا ما يكون وجود النص في البرنامج ناتجًا عن قراءة ملف نصي بالفعل open() وذلك بإضافة الحرف r ميشرًا إلى أن غرض الفتح القراءة:\nfile = open('my_file.txt', 'r')\nmessage = file.read()\nfile.close()\nprint(message)\nوسيأتي تفصيل كيفية التعامل مع الملفات في باب الملفات.",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "href": "chapters/07_strings/a1_strings.html#الإشارة-لجزء-من-النص",
    "title": "8  النص",
    "section": "8.4 الإشارة لجزء من النص",
    "text": "8.4 الإشارة لجزء من النص\nولكون النص تسلسلاً ثابتًا فإنه يقبل جميع عمليات التسلسل السابق ذكرها (انظر باب المجموعة المرتبة).\n\ns = 'Arabian'\n\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\n 0   1   2   3   4   5   6   7\n +---+---+---+---+---+---+---+\n | A | r | a | b | i | a | n |\n +---+---+---+---+---+---+---+\n-7  -6  -5  -4  -3  -2  -1\n\nجرب\n\ns[1:5]\ns[1:5:2]\ns[::2]\ns[::-1]\n\nلاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:\n\ns = ('A', 'r', 'a', 'b', 'i', 'a', 'n')\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\nلكن الفرق أن النص نوعٌ له أفعال / عمليات خاصة تتعلق بالنصوص.",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "href": "chapters/07_strings/a1_strings.html#النص-ثابت-لا-يقبل-التغير",
    "title": "8  النص",
    "section": "8.5 النص ثابت لا يقبل التغير",
    "text": "8.5 النص ثابت لا يقبل التغير\nفالنص تسلسل يشبه الصف في كوْنه ثابتًا (أي لا يقبل تعديل عنصر أو إضافته أو حذفه). فلو حاولت تغيير موضعٍ s[i] في النص أو قطعة s[i:j] فإنك ستواجه خطأ:\n\ns = 'Arabian'\ns[0] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 s = 'Arabian'\n----&gt; 2 s[0] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nلكننا لتعديل النص في الواقع نعيِّنُ إلى نفس المتغير نصًّا جديدًا منه:\n\ns = 'Arabian'\ns = 'a' + s[1:]\nprint(s)\n\narabian\n\n\nلاحظ أننا أسندنا النص الجديد إلى المتغير s، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "href": "chapters/07_strings/a1_strings.html#العمليات-الخاصة-بالنصوص",
    "title": "8  النص",
    "section": "8.6 العمليات الخاصة بالنصوص",
    "text": "8.6 العمليات الخاصة بالنصوص\n\nالاستبدال\nلاستبدال جزء من النص، نستخدم فعل .replace():\n\ns = 'Arabian'\ns = s.replace('ian', 'y')\nprint(s)\n\nAraby\n\n\n\n\nإزالة المسافات\nكما لدينا علميات .strip() لإزالة المسافات البيضاء من بداية ونهاية النص.\n\nassert '  Arabian  '.strip() == 'Arabian'\n\n\n\nالبحث والمطابقة\nوكذلك لدينا عمليات البحث:\n\nالتحقق من البدء والنهاية وما بينهما: .startswith(prefix) و .endswith(suffix) أو sub in string وهي أعم.\nلمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص .find()\n\n\ns = 'Arabian'\nassert s.startswith('A')\nassert not s.startswith('a')\nassert s.endswith('n')\nassert 'rabia' in s\nassert s.find('a') == 2\n\n\n\nالفصل والوصل\n\nفصل النص لقائمة بناءً على جزء فاصل: list.split(seperator)\nوصل عناصر القائمة في نص مفصول بجزء فاصل: seperator.join(list)\n\nأولاً: الفصل: مثاله قراءة سطر في ملف csv إذْ القيم مفصولة بعلامة الفاصلة ,:\n\ncsv = \"Adam,25,Riyadh\"\nassert csv.split(',') == ['Adam', '25', 'Riyadh']\n\nولقراءة الملف كاملاً نكرر:\n\nالقيم في السطر الواحد مفصولة بعلامة الفاصلة ,\nوالصفوف مفصولة بعلامة السطر الجديد \\n\n\nلذلك سنستعمل الاثنين هنا:\n\ncsv = \"\"\"name,age,city\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\"\"\"\n\ndata = []\nfor line in csv.split(sep='\\n'):\n  row = line.split(sep=',')\n  data.append(row)\nprint(data)\n\n[['name', 'age', 'city'], ['Adam', '25', 'Riyadh'], ['Belal', '30', 'Jeddah'], ['Camal', '35', 'Dammam']]\n\n\nثانيًا: الوَصل: مثاله أننا نحول القائمة إلى نص مفصول بعلامة الفاصلة , وذلك ليكون سطرًا في ملف csv:\n\ndata = ['Adam', '25', 'Riyadh']\nseperator = ','\ncsv = seperator.join(data)\nassert csv == 'Adam,25,Riyadh'\n\n\n\nعمليات إنجليزية\nوهنا عمليات خاصة بالنصوص الإنجليزية:\n\nupper() نسخة ذات حروف كبيرة.\nlower() نسخة ذات حروف صغيرة.\ncapitalize() نسخة ذات حرف أول كبير من كل كلمة.\ntitle() نسخة ذات حالة عنوان.\n\n\nname = 'Adam ibraheeM'\nprint(name.upper())\nprint(name.lower())\nprint(name.capitalize())\nprint(name.title())\n\nADAM IBRAHEEM\nadam ibraheem\nAdam ibraheem\nAdam Ibraheem\n\n\nوانظر مستندات النصوص لمعرفة كافة الأفعال الممكنة على النصوص.\n\n\nتفسير الأرقام\nتفسير الأرقام المكتوبة نصًّا تكثر الحاجة إليه خصوصًا عند قراءة ملفات أو التعامل مع بيانات من المستخدم، إذ يكون الإدخال نصيًّا:\n\nint(x) لتحويل نص إلى عدد صحيح.\nfloat(x) لتحويل نص إلى عدد عشري.\n\nلاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:\n\nx = '20'\ny = '40'\nprint(x + y)\n\n2040\n\n\nالواجب تحويلهما إلى أعداد أولاًً:\n\nx2 = float(x)\ny2 = float(y)\nprint(x2 + y2)\n\n60.0",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "href": "chapters/07_strings/a1_strings.html#إخراج-النص",
    "title": "8  النص",
    "section": "8.7 إخراج النص",
    "text": "8.7 إخراج النص\nنستعرض ثلاث طرق لدمج النصوص في بايثون:\n\nالأولى: تحويل الشيء إلى نص قبل دمجه مع النص، باستعمال str(x)\nالثانية: استعمال فراغات بالقوسين المعكوفين {} مع الفعل .format() لاستبدالها.\nالثالثة: استعمال f-string بأن تضع الحرف f قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل الأقواس المعكوفة {}. وهي الطريقة التي نفضلها.\n\n\nname = \"John\"\nlvl = 300\n\ns1 = \"I am \" + name + \" and I want to reach level \" + str(lvl) # + operator\ns2 = \"I am {} and I want to reach level {}\".format(name, lvl)  # .format() method\ns3 = f\"I am {name} and I want to reach level {lvl}\"            # f-strings\nassert s1 == s2 == s3\nprint(s1)\n\nI am John and I want to reach level 300\n\n\nيقبل النص التكرار بعلامة *:\n\nprint('-' * 10)\nprint('*' * 10)\nprint('=' * 10)\n\n----------\n**********\n==========",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "href": "chapters/07_strings/a1_strings.html#المحاذاة-والحشو",
    "title": "8  النص",
    "section": "8.8 المحاذاة والحشو",
    "text": "8.8 المحاذاة والحشو\n\nname = 'Adam'\nprint(name.ljust(15)) \nprint(name.center(15))\n\nAdam           \n      Adam     \n\n\nطريقة ممتعة لتزيين سلسلة نصية باستخدام الفعل center:\n\nprint('*' * 20)\nprint('Adam'.center(20, \"*\"))\nprint('*' * 20)\n\n********************\n********Adam********\n********************",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "href": "chapters/07_strings/a1_strings.html#تنسيق-الأرقام",
    "title": "8  النص",
    "section": "8.9 تنسيق الأرقام",
    "text": "8.9 تنسيق الأرقام\n\nمحاذاة الأرقام\n\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\n       100\n      1000\n     10000\n\n\nيمكننا أيضًا جعل كل من العدد n والتعبئة p متغيرات:\n\nn = 100\np = 5\nprint(f'{n:{p}}')\n\n  100\n\n\nبشكل افتراضي، يتم محاذاة الرقم إلى اليمين. يمكننا محاذاته إلى اليسار بإضافة &lt;. لاحظ الفرق بين التعبيرين أدناه:\n\nprint(f'{n:&gt;{p}}')\nprint(f'{n:&lt;{p}}')\n\n  100\n100  \n\n\n\n\nفاصل الآلاف\n\nbig_num = 10000\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n10000\n10,000\n\n\n\n\nالترميز العلمي\n\nsmall_num = 0.00001\nprint(f\"{small_num:.2e}\")\n\n1.00e-05\n\n\n\n\nالأعداد العشرية\n\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\nمثال: تنسيق الكم المالي\nهنا نستخدم مكونين داخل الأقواس المعقوفة وعلامة $ في البداية: - يتم إضافة علامة $ قبل الرقم (ليست جزءًا من الرقم المنسق على الإطلاق) - , تضيف فاصل الآلاف - .2f يقوم بتقريب الرقم إلى منزلتين عشريتين\n\nprice_dollars = 2978.95\nprice_riyals = price_dollars * 3.75\nprint(f\"${price_dollars:,.2f} = {price_riyals:,.2f} SAR\")\n\n$2,978.95 = 11,171.06 SAR",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html",
    "href": "chapters/07_strings/a2_unicode.html",
    "title": "9  تمثيل النص",
    "section": "",
    "text": "9.1 ترميز Unicode\nترميز الحروف هي عملية تعيين أرقام للأحرف الرسومية مما يسمح بتخزينها ونقلها وتحويلها باستخدام الحواسيب الرقمية.\nرموز ASCII تحتوي على 128 حرف للغة الإنجليزية وبعض علامات الترقيم. منها 95 فقط هي أحرف قابلة للطباعة أما البقية فتسمى أحرف تحكُّم (مثل حرف السطر الجديد \\n ، وحرف الرجوع لبداية السطر \\r).\nثم امتدت عن طريق رموز ANSII لتغطي أحرف إضافية (من 128 إلى 255) وهي الأحرف الاتينية للغات الأخرى.\nلنستكشف السلاسل عن طريق حزمة من المكتبة الأساسية string. الآتي الأحرف اللاتينية الكبيرة والصغيرة، وعلامات الترقيم:\nواليوم رموز Unicode تحتوي على أكثر من مليون حرف لتغطية لغات العالم كافة: اللاتينية، اليونانية، السيريلية، الأرمنية، العبرية، العربية، السريانية، الثانا، الديفاناغارية، البنغالية، الجورموخية، الأورية، التاميلية، التيلوغوية، الكانادية، المالايالامية، السنهالية، التايلاندية، اللاوية، التبتية، الميانمارية، الجورجية، الهانغول، الإثيوبية، الشيروكية، الرموز الكندية الأصلية، الخميرية، المنغولية، الهان (الأيدوغراف الياباني، الصيني، الكوري)، الهيراغانا، الكاتاكانا، واليي. المصدر. وما يزال أول 128 حرف منها متطابق مع رموز ASCII.",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "href": "chapters/07_strings/a2_unicode.html#ترميز-unicode",
    "title": "9  تمثيل النص",
    "section": "",
    "text": "مثال\nماذا يحصل لو كتبنا حروف عربية ثم حاولنا حفظ الملف بترميز ASCII ولم نحفظه بترميز Unicode؟\n\n\n\nبرنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات\n\n\nالخطأ يقول: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "href": "chapters/07_strings/a2_unicode.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "title": "9  تمثيل النص",
    "section": "9.2 كيف يتم تمثيل النصوص في بايثون؟",
    "text": "9.2 كيف يتم تمثيل النصوص في بايثون؟\nتمثيل النصوص في بايثون يكون عن طريق النوع str؛ يُعرَّف بكتابة سلسلة من الأحرف لكن في الواقع تتحول إلى سلسلة من رموز Unicode (أي: أرقام). هذا يعني أنها قد تكون سلسلة رموز لاتينية أو عربية أو صينية أو غير ذلك مما تحويه رموز Unicode.\nالفعل المبني ord() تقوم بتحويل الحرف إلى رقم الرمز. بينما chr() تعكس ذلك (من الرمز إلى الحرف).\nعلى النقيض من سي وجافا؛ لا يوجد نوع خاص بالحرف الواحد (char) في بايثون.\n\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nماذا عن الحروف العربية؟ أين تقع في أرقام ترميز Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nلمعرفة أرقام الحروف في نصٍّ ما؛ نستعمل التكرار هكذا:\n\ndef get_unicode_points(s):\n    codes = []\n    for c in s:\n        codes.append(ord(c))\n    return codes\n\nprint(get_unicode_points('Arabian'))\nprint(get_unicode_points('السَّلَامُ عَلَيْكُمْ'))\n\n[65, 114, 97, 98, 105, 97, 110]\n[1575, 1604, 1587, 1614, 1617, 1604, 1614, 1575, 1605, 1615, 32, 1593, 1614, 1604, 1614, 1610, 1618, 1603, 1615, 1605, 1618]\n\n\nفهذه هي الحروف في الواقع، إلا أننا نتعامل مع شيء مجرَّد في لغات البرمجة العالية غالبًا ما يسمى str.\nراجع ويكيبيديا: النص العربي في Unicode لمزيد من التفاصيل.\n\nالأحرف البيضاء\nالأحرف في الأجهزة الرقمية على نوعين:\n\nأحرف طباعة: مثلاً: الأحرف اللاتينية والأرقام وعلامات الترقيم\nأحرف تحكم: مخفيَّة؛ والغرض منها التحكم بمعالج هذا النص\n\nلعرض الأحرف القابلة للطباعة في محارف آسكي (ASCII)، لدينا المتغير printable من مكتبة string:\n\nimport string\nstring.printable\n\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n\n\nكانت أحرف التحكُّم تستخدم لرن جرس الآلة الطابعة ، والتحكم بها ، لكن اليوم الذي يُستخدم منها غالبًا هو الأحرف البيضاء (Whitespace Characters) ويشمل ذلك الأحرف التالية:\n\nspace: \\s ويمثل المسافة التي بين الكلمات\ntab: \\t ويمثل المسافة التي بين أعمدة الجداول\nlinefeed: \\n تعليمة سطر جديد\nreturn: \\r تعليمة العودة لبداية السطر الجديد\nformfeed: \\f تعليمة الصفحة الجديدة\nvertical tab: \\v تعليمة العمود الجديد\nbackspace: \\b تعليمة عودة المؤشر بمقدار حرف واحد للكتابة فوق الحرف السابق\n\nأما الثلاثة الأخيرة فقد كانت تستخدم فيما مضى، لكن اليوم المستخدم هو الأربعة الأولى فقط. ويجدر بالذكر أن ملفات نصوص نظام ويندوز تستعمل \\r\\n للانتقال لسطر جديد بينما تستعمل الأنظمة الأخرى \\n فقط.\nتذكر أن بايثون تعتمد على space و tab للمسافة البادئة للسطر (indentation)، لتحديد نطاقات الكود بحسب المحاذاة العمودية.\n\nimport string\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\nيهمنا هنا الأحرف البيضاء لأنها تظهر في النصوص وقد تكون مزعجة عند معالجتها. لنلقي نظرة على ثلاثة من الأحرف البيضاء: المسافة (space)، التبويب (tab)، وتعليمة السطر الجديد (linefeed).\n\n# Tab character: \"\\t\"\nprint('A\\tB')\n\nA   B\n\n\n\n# Space character: \" \"\nprint('   A            B   ')\n\n   A            B   \n\n\n\n# Newline character: '\\n'\nprint('A\\nB')\n\nA\nB\n\n\nلاحظ أن طول السلسلة النصية هو عدد الأحرف في السلسلة، سواء كانت قابلة للطباعة (printable) أو أحرف بيضاء (whitespace).\n\nassert len('A B') == 3\nassert len('A\\tB') == 3\nassert len('A\\nB') == 3\n\n\n\nالأطراف الزائدة\nلاحظ أن هذا الفعل سيزيل الأحرف البيضاء من بداية ونهاية السلسلة النصية، ولكن ليس الأحرف البيضاء في منتصف السلسلة\nقبل:\n\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\nبعد:\n\nprint(text.strip())\n\nhello    world\n\n\n\n\nتجزئة النص\nانظر: Splitlines\n\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\nإذا تركنا الكود كما هو في السطر من غير print فإن ذلك يعرض السلسلة النصية كما هي (بما في ذلك أحرف المسافات البيضاء)\n\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\nأما إذا وضعنا print فإنه يطبع الأحرف المرئية ، وينسِّقُ المظهر بناءً على أحرف التحكُّم المخفية:\n\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\nإذا لم نحدد محدد الفاصل فإن الفاصل الافتراضي هو المسافة.\n\nprint(\"Hello, world\".split())\n\n['Hello,', 'world']\n\n\nهنا نحدد الفاصل أنه الحرف \"l\":\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\nلإزالة الأحرف البيضاء جميعها؛ نستعمل التكرار هكذا:\n\ntext = '\\t hello    world \\n\\n\\n'\nsp = text.split()\nprint('split:', sp)\nclean = ' '.join(sp)\nprint('clean:', clean)\n\nsplit: ['hello', 'world']\nclean: hello world\n\n\nالفصل في الداخل ينتج قائمة من النصوص، بعضها فارغ لوجود الأحرف البيضاء المتتالية، فلا تتضمن في القائمة الناتجة.",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/a2_unicode.html#الطباعة",
    "href": "chapters/07_strings/a2_unicode.html#الطباعة",
    "title": "9  تمثيل النص",
    "section": "9.3 الطباعة",
    "text": "9.3 الطباعة\n\nحروف التحكم بآلة الطباعة\nيسمّى الحرف \\r بالعودة للبداية لأنه يعني فعل يقوم بإرجاع المؤشر إلى بداية السطر.\nكانت آلة الطباعة قديمًا يتحرك رأس الطباعة فيها بعد طباعة كل حرف. ثم عندما ينتهي السطر، يجب على الشخص أن يقوم بعمليتين:\n\nالضغط على المفتاح الذي يرفع الورقة بمقدار سطر (ويرمز له بالحرف \\r)\nالضغط على المفتاح الذي يرجع رأس الطباعة لبداية السطر (ويرمز له بالحرف \\n)\n\nوهما مستخدمان اليوم فيما يُعرض على الشاشة.\nففعل print في الحقيقة يضع سطرًا جديدًا (حرف \\n) في الوضع الافتراضي. فإن أردنا ألا يضعه، فنحدد العامل end الذي فيه على النحو التالي:\n\nprint('Hello', end='')\nprint('World', end='')\n\nHelloWorld\n\n\nلاحظ أننا جعلنا (end='') أي: لا نريده أن يضع حرفًا بعد طباعة النص. ولذلك ظهرت الكلمتان في نفس السطر.\nولو أردت أن تعيد الكتابة على نفس السطر، يمكنك أن تضع الحرف (\\r) الذي يفعل رأس الطباعة بالرجوع لبداية السطر:\n\nprint('123', end='\\r')\nprint('45')\n\n12345\n\n\nلاحظ أن النتيجة هي طباعة الحرفين 45 فوق الحرفين 12 مع بقاء الحرف الأخير 3 في الأخير. وذلك لرجوع رأس الطباعة.\nتستعمل هذه اللطيفة في تحديث العداد حتى يظهر على الشاشة وكأنه يزيد شيئًا فشيئًا. وذلك على النحو التالي (لاحظ أننا نستعمل time.sleep(t) حتى نمثِّل وجود عمليَّة تأخذ وقتًا طويلاً فحسب):\nimport time\n\nfor x in range(10 + 1):\n    time.sleep(0.20)\n    print(f'[{x}/10] ' + '===' * x + '&gt;', end='\\r')",
    "crumbs": [
      "باب النص (Strings)",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>تمثيل النص</span>"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html",
    "href": "chapters/07_strings/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "الكلمة المتناظرة\nفي هذا المثال نوضح استعمال مؤشرين على نفس النص لمعرفة ما إذا كانت الكلمة متناظرة:\ndef is_palindrome(word):\n    \"\"\"\n    A palindrome word is one that can be read the same way from both ends.\n    \"\"\"\n\n    # Remove the difference of capitalization\n    word = word.lower()\n    \n    # Remove the spaces (to match things like: \"Race car\")\n    word = word.replace(\" \", \"\")\n\n    # Check if the word is a palindrome\n    for i in range(len(word) // 2):\n        j = len(word) - i - 1\n        if word[i] != word[j]:\n            return False\n    return True\n\n# Test examples\nassert is_palindrome(\"radar\")\nassert is_palindrome(\"level\") \nassert is_palindrome(\"madam\")\nassert is_palindrome(\"توت\")\nassert is_palindrome(\"خوخ\")\nassert is_palindrome(\"Race car\")\nassert is_palindrome(\"حصان ناصح\")\nassert not is_palindrome(\"python\")\nبدل الحلقة، وكان لنا أن نكتب باختصار: word == word[::-1] وهي تعني أن النص متناظر إذا كان مساوياً لنفسه بالمقلوب.\ndef is_palindrome(word):\n    word = word.lower()\n    word = word.replace(\" \", \"\")\n    return word == word[::-1]",
    "crumbs": [
      "باب النص (Strings)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#الكلمة-المتناظرة",
    "href": "chapters/07_strings/b_context.html#الكلمة-المتناظرة",
    "title": "تطبيقات",
    "section": "",
    "text": "المؤئر الأول بإصبعك الأيمن: i يبدأ من أول حرف وينتهي عند المنتصف\nالمؤئر الثاني بإصبعك الأيسر: j يبدأ من آخر حرف وينتهي عند المنتصف",
    "crumbs": [
      "باب النص (Strings)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#عد-الكلمات",
    "href": "chapters/07_strings/b_context.html#عد-الكلمات",
    "title": "تطبيقات",
    "section": "عد الكلمات",
    "text": "عد الكلمات\nهذا مثال لاستخراج الكلمات (من غير تكرار) من قاموس من العبارات (ثلاثة عبارات). هذه العملية تستعمل كثيرًا في تحليل النصوص إذ نريد أن نعرف جميع الكلمات الواردة في مجموعة من النصوص، ولا نريد الكلمات المعهودة جدًّا (هنا نسميها stop_words)، كما أننا نستعمل .lower() في التعبير الناتج حتى لا يفرق بين الحروف في حالتيها الإنجليزية:\n\nstop_words = {'is', 'and', 'the', 'be', 'not'}\n\ndocuments = {\n    'Python':     \"python is great and Python is easy\",\n    'Java':       \"Java is verbose and java is popular\",\n    'JavaScript': \"JavaScript is for the web and javascript is everywhere\"\n}\n\nword_counts = dict()\n\nfor doc in documents.values():\n    doc = doc.lower()\n    words = doc.split()\n    for w in words:\n        if w not in stop_words:\n            word_counts[w] = word_counts.get(w, 0) + 1\n\nfor w, count in word_counts.items():\n    print(f\"{w}: {count}\")\n\npython: 2\ngreat: 1\neasy: 1\njava: 2\nverbose: 1\npopular: 1\njavascript: 2\nfor: 1\nweb: 1\neverywhere: 1",
    "crumbs": [
      "باب النص (Strings)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#ترجمة-أفعال",
    "href": "chapters/07_strings/b_context.html#ترجمة-أفعال",
    "title": "تطبيقات",
    "section": "ترجمة أفعال",
    "text": "ترجمة أفعال\nنكتب برنامج يقرأ سطرًا يفعله بعملية حسابية على عوامل محددة. فهو كلغة برمجة بسيطة.\n\ndef parse_command(cmd):\n    \"\"\"\n    Parse a command and return the result of the operation.\n\n    Example:\n    &gt;&gt;&gt; parse_command(\"+ 5 10 2\")\n    17\n    &gt;&gt;&gt; parse_command(\"* 5 10 2\")\n    100\n    &gt;&gt;&gt; parse_command(\"max 5 10 2\")\n    10\n    \"\"\"\n\n    operator, *operands = cmd.split(\" \")\n\n    match operator:\n        case \"+\":\n            total = 0\n            for item in operands:\n                total += float(item)\n            return total\n\n        case \"*\":\n            total = 1\n            for item in operands:\n                total *= float(item)\n            return total\n\n        case \"max\":\n            max_value = float(operands[0])\n            for item in operands[1:]:\n                f = float(item)\n                if f &gt; max_value:\n                    max_value = f\n            return max_value\n\n        case _:\n            raise ValueError(f\"Unknown operator: {operator}\")\n\nassert parse_command(\"+ 5 10 2\") == 17\nassert parse_command(\"* 5 10 2\") == 100\nassert parse_command(\"max 5 10 2\") == 10\n\nتطبيقات النصوص كثيرة جدًّا في الواقع، لكن نكتفي بهذا هنا، ولعلك تراجع مصادر مختصة بالتحليل النصي لتعلم المزيد.",
    "crumbs": [
      "باب النص (Strings)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/07_strings/b_context.html#تلوين-الخارج",
    "href": "chapters/07_strings/b_context.html#تلوين-الخارج",
    "title": "تطبيقات",
    "section": "تلوين الخارج",
    "text": "تلوين الخارج\nfrom colorama import Fore, Back, Style\n\n# Print different color text with different background\nprint(f\"{Fore.RED}This text is red!{Style.RESET_ALL}\")\nprint(f\"{Back.GREEN}This has a green background{Style.RESET_ALL}\")\nprint(f\"{Fore.YELLOW}{Back.BLUE}This is yellow text on a blue background{Style.RESET_ALL}\")\n\n# Print with bold and italic styles\nprint(f\"{Style.BRIGHT}This is bright text{Style.RESET_ALL}\")\nprint(f\"{Style.DIM}This is dimmed text{Style.RESET_ALL}\")\n\n# Reset all styles at the end\nprint(f\"{Style.RESET_ALL}This is back to default style\")",
    "crumbs": [
      "باب النص (Strings)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html",
    "href": "chapters/08_files_and_directories/a1_serialization.html",
    "title": "10  الملف",
    "section": "",
    "text": "10.1 قراءة وكتابة الملفات\nفيه ثلاثة خطوات:\nوذلك على النحو التالي:\nf = open(file='../../datasets/example_root/a/a.txt', mode='r')\ncontent = f.read()\nf.close()\n\nprint(content)\n\nlorem ipsum dolfet\nweilfur badem zelfur\nأما المسار فله شكلان\nوقد تستعمل علامة ./ للإشارة للدليل الحالي. أما علامة ../ فتشير إلى الدليل الأب.\nوهكذا نكتب في الملف باستعمال file.write()، بعد فتح الملف بوضع الكتابة 'w' في open(mode='w'):\ncontent = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\n\nf = open(file='../../datasets/example_root/a/zzz.txt', mode='w')\nf.write(content)\nf.close()\n\nprint(content)\n\nSalam everyone,\nI hope you are enjoying the course,\n\nThank you.\nانظر توثيق قراءة وكتابة الملفات.\nولأن الإغلاق ضروري بعد كل فتح؛ فقد وفرت بايثون لذلك مركبًا لغويًّا يُعرف بإدارة السياق. فالملف نوعٌ يعتبر مدير سياق (Context Manager) فيجوز استعمال with وتضمين قطعة الكود في سياقها الذي يتكفل بإغلاق الملف تلقائيّا عند نهاية آخر جملة في قطعة الكود داخلها. وذلك على النحو التالي:\ncontents = ''\nwith open(file='../../datasets/example_root/a/a.txt', mode='r') as f:\n    contents = f.read()\nprint(contents)\n\nlorem ipsum dolfet\nweilfur badem zelfur",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#قراءة-وكتابة-الملفات",
    "href": "chapters/08_files_and_directories/a1_serialization.html#قراءة-وكتابة-الملفات",
    "title": "10  الملف",
    "section": "",
    "text": "نفتح الملف open(): وهذا طلبٌ من نظام التشغيل الإذنَ (بحسب mode الإذن بالقراءة r أو الإذن بالكتابة w أو الإذن بالقراءة والكتابة rw)؛ ونحصل في النتيجة على مؤشر يشير إليه.\n. نقرأ الملفfile.read() فيتم نسخ محتواه من التخزين إلى الذاكرة\nولا بُد من تسريحه بعد الفراغ منه باستعمال file.close()\n\n\n\n\n\n\n\n\n\n\n\n\nنوع المسار\nالشرح\nمثال\n\n\n\n\nالمسار المطلق (Absolute Path)\nيحدد المسار بشكل كامل بدءًا من الجذر، ولا يعتمد على الموقع الحالي.\n/home/user/Downloads\n\n\nالمسار النسبي (Relative Path)\nيحدد المسار بالنسبة لموقع الملف الحالي.\n../../datasets/example_root/a/a.txt",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#صياغة-البيانات",
    "href": "chapters/08_files_and_directories/a1_serialization.html#صياغة-البيانات",
    "title": "10  الملف",
    "section": "10.2 صياغة البيانات",
    "text": "10.2 صياغة البيانات\nسَلْسَلة البيانات (Data Serialization) تشير لعملية تحويل البيانات في ذاكرة بايثون (مثل القائمة [] والقاموس {}) من صيغتها الثنائية الخاص باللغة إلى تمثيلٍ ليس خاصًّا بلغةٍ معيَّنة؛ بل يتبع صيغةً متفقًا عليها؛ فإما أن يكون:\n\nتمثيلاً نصيًّا (Plain Text Serialization) متفقًا عليه مثل: xml أو json أو csv ونحوها (وقد تقدَّم عرضُها في باب النص).\nأو تمثيلاً ثنائيًّا (Binary Serialization) متفقًا عليه كذلك مثل: pickle أو protobuf أو parquet.\n\nفالتمثيل النصي يتميز بأنه مباشر وواضح بالنسبة للبشر. لكنه أبطأ في المعالجة (سواءً في الكتابة أو في القراءة) وأكبرُ حجمًا في التخزين غالبًا. أما التمثيل الثانئي فهو بعكسه: أقرب للآلة وأصعب في التدقيق عند حدوث الخطأ إلا مع وجود أدوات تساعد في ذلك. لكنه أسرع في المعالجة وأقل حجمًا للتخزين.\nوعملية تحويل البيانات المُسَلسَلة (أي المكتوبة بإحدى هذه الصيغ) وقراءَتها في برنامجٍ ما تسمى فك التسلسل (Deserialization). فالتحويل يكون مثلاً من النصي إلى الثنائي في الذاكرة. أو من الثنائي المسلسل إلى الثنائي في الذاكرة.\nفالسلسلة وفكها ما هي إلا صياغة لا تغير المكنون بل شكله.\nويختلف شكل البيانات من ثلاثة أوجه:\n\nالصف: [1, 2, 3, 4, 5]\nالربط: {key1: value1, key2: value2}\nالتضمين: فيكون العنصر نفسه سلسلة أو ارتباطًا\n\nفالصفوف تتميز بكون كل صفٍّ فيها تدوينًا لمجموعة خصائص تشترك في العمود كله. أما الارتباط ففيه مرونة؛ فمجموعة الارتباطات لا تُلزِم كل ارتباط أن يكون له ذات خصائص الارتباط الذي قبله. والتقسيمات تُنتج التضمين.",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#الارتباط-والتضمين",
    "href": "chapters/08_files_and_directories/a1_serialization.html#الارتباط-والتضمين",
    "title": "10  الملف",
    "section": "10.3 الارتباط والتضمين",
    "text": "10.3 الارتباط والتضمين\nسنمثل باستعمال الوحدة المدمجة json ذات وظائف القراءة والكتابة لملفات مصاغة على شكل json. فإن كنت تتعامل مع صيغ أخرى انظر في الوثائق:\n\nالوحدة المدمجة xml لصيغة xml.\nأو مكتبة pyyaml لصيغة yaml.\n\n\nimport json\n\nلنفترض أن لدينا user_preferences محفوظًا في القاموس، ونريد حفظه في ملف json:\n\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\nلنكتبها في الملف نستعمال json.dump على النحو التالي:\n\nwith open('../../datasets/user_preferences.json', mode='w') as file:\n    json.dump(user_preferences, file)\n\nفإذا أردنا قراءتها استعمال json.load على النحو التالي:\n\nwith open('../../datasets/user_preferences.json') as file:\n    data = json.load(file)\nprint(data)\n\n{'theme': 'dark', 'language': 'Arabic', 'notifications': {'email': True, 'sms': False, 'push': True}, 'last_updated': '2021-09-01', 'emails': ['example1@domain.com', 'example2@domain.com']}",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a1_serialization.html#الصف",
    "href": "chapters/08_files_and_directories/a1_serialization.html#الصف",
    "title": "10  الملف",
    "section": "10.4 الصف",
    "text": "10.4 الصف\nتأتي البيانات الجدولية في صيغ متعددة، مثل: - CSV وهي صيغة يكون فيها الصف في سطر، وتكون عناصره مفصولة بعلامة الفاصلة \",\" - TSV وهي مثل CSV إلا أن الفاصلة علامة \"\\t\"\nوغيرها كثير.\nفي هذا القسم، سنركز على ملفات (Comma Separated Values) CSV؛ وتعني حرفيًّا: القيَم المفصولة بالفاصلة.\nتوجد في بايثون وحدة csv فيها أفعال للقراءة والكتابة على طريقة csv. فلدينا:\n\nكائن reader لعمليات القراءة\nوكائن آخر منفصل اسمه writer يحوي عمليات الكتابة\n\n\nimport csv\n\nلنكتب قائمة من الطلاب إلى ملف CSV. لاحظ، لدينا قائمة من قوائم، حيث تمثل كل قائمة داخلية صفًا لوحدها:\n\nheader = ['Name', 'Age', 'Grade']\nrows = [\n    ['Adam', 22, 90],\n    ['Belal', 23, 92],\n    ['Camal', 24, 91],\n]\n\nنكتبها على النحو التالي:\n\nwith open('../../datasets/students.csv', mode='w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(header)\n    writer.writerows(rows)\n\nملاحظة، يمكنك محاولة فتح الملف مباشرة من مستكشف الملفات. حاول فتحه باستخدام Excel أو Google Sheet أو أي برنامج جداول بيانات آخر. إذا فتحته باستخدام محرر نصوص، سترى البيانات كملف CSV؛ حرفيًا قيم مفصولة بفواصل.\nالآن، دعنا نقرأه كهيكل بيانات في بايثون: كقائمة من القوائم.\n\nwith open('../../datasets/students.csv') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)\n\n['Name', 'Age', 'Grade']\n['Adam', '22', '90']\n['Belal', '23', '92']\n['Camal', '24', '91']\n\n\nلنحاول حساب متوسط درجات الطلاب.\n\nstudents = []\nwith open('../../datasets/students.csv') as file:\n    reader = csv.reader(file)\n    next(reader) # skip the header\n    for row in reader:\n        students.append(row)\n\nالآن بعد أن حفظناها في القائمة students، دعونا نقوم ببعض العمليات الحسابية.\n\ngrades = [s[2] for s in students]\navg = sum(grades) / len(grades)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 2\n      1 grades = [s[2] for s in students]\n----&gt; 2 avg = sum(grades) / len(grades)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nهذا الخطأ متوقع عند قراءة الملفات لأنها دائمًا تعتبر من نوع str، ولذلك نضطر لتحويل القيَم العددية إلى int لفعل عمليات رياضية:\n\ngrades = [int(s[2]) for s in students]\navg = sum(grades) / len(grades)\navg\n\n91.0\n\n\nيمكنك أيضًا قراءة وكتابة البيانات في شكل قاموس باستخدام الكائنات DictReader وDictWriter.\n\nwith open('../../datasets/students.csv') as file:\n    reader = csv.DictReader(file)\n    for row in reader:\n        print(row)\n\n{'Name': 'Adam', 'Age': '22', 'Grade': '90'}\n{'Name': 'Belal', 'Age': '23', 'Grade': '92'}\n{'Name': 'Camal', 'Age': '24', 'Grade': '91'}\n\n\nوالطريقة الموصى بها للتعامل مع البيانات الجدولية (مثل ملفات CSV) هي استخدام مكتبة مثل pandas. توفر هذه المكتبة هيكل بيانات سريع ومرن لمعالجة البيانات وتحليلها. ولا بأس أن تطلع على دليل البداية في مكتبة pandas.\n\nإذا كنت تريد قراءة الملفات وكتابتها بشكل بسيط انظر: open().\nوإذا كنت تريد التعامل مع الملفات المؤقتة فانظر: tempfile.\nوكثير من عمليات التعامل مع الملفات والأدلة تجدها في: shutil.",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>الملف</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a2_directories.html",
    "href": "chapters/08_files_and_directories/a2_directories.html",
    "title": "11  الدليل",
    "section": "",
    "text": "الدليل\nأحيانًا نريد التعامل مع مجلَّد يحوي مجموعة ملفات، بنقلها أو نسخها أو حذفها ونحو ذلك.\nوجب علينا أولاً أن نُدرك أن ثمة نوعان من الملفات في النظام:\nوالملف المبتدأُ بالنقطة مثل: .git يكون مخفيًّا.\nوالطريق هو الموصل لملفٍّ ما أو دليلٍ ما نحو: datasets/example_root/a/a.txt. وسبق أن بينا أنه على نوعين: مُطلَق ونسبي. وسنعتمد على وحدة pathlib لنرى عمليات تركيب المسار والبحث فيه والاستعلام عن مدلوله ونحو ذلك. وسنبدأ بها.\nلاستعراض عمليات المكتبة، أنشأنا مُسبقًا شجرة تبدأ من دليل example_root تجده داخل datasets في مستودع مشروع الكتاب على النحو التالي:\nالشيء الأساسي الذي نتعامل معه هو المسار (Path):\nيُنشأ المسار من نص أو مجموعة نصوص بينها علامة / (وهي في الأصل علامة قسمة إذا وُضعت بين الأرقام) التي تعني ضم النص إلى المسار.\nلاحظ استعمال النص الخام r'' لكون الحرف \\ له معنىً خاص في نصوص بايثون، فهو يستعمل مثلا \\n للانتقال لسطر جديد. لكن حين نستعمل r'' فإن الحرف \\ لا يعني شيئًا خاصًا.\nملاحظة، عند نسخ المسارات في نظام ويندوز (Windows)، يجب عليك إما استبدال الشرطات المائلة العكسية \\ بالشرطات المائلة الأمامية / أو استخدام السلاسل النصية الخام r'' لتجنب المشاكل (كما فعلنا أعلاه).\nوهكذا نستطيع استعمال الكائن Path في فعل open(file=path) للتعامل مع الملفات:\nولأن الملف يعتبر مدير سياق (Context Manager) فيستحسن الإتيان بجملة السياق with إذ تتكفل بإغلاق الملف تلقائيّا عند نهايتها. وذلك على النحو التالي:\nبدلاً من قراءة الملف جملة واحدة .read() نستطيع القراءة سطرًا بسطر عن طريق الفعل .readline() على النحو التالي:\nتستعمل .rstrip() لإزالة حرف انتقال السطر \\n .\nانظر قراءة الأدلة.\nلعرض قائمة الدليل، نستعمل المكرر الناتج من فعل .iterdir() ونكرر عليه، وهو بدورِه يُنتج في كل كرةٍ مساراً (x). وهذا المسار يُمكن التحقق من أنه يشير إلى دليل أو لا (x.is_dir()) على النحو التالي:\np = Path('../../datasets/example_root/')\ndirs = [x for x in p.iterdir() if x.is_dir()]\ndirs\n\n[PosixPath('../../datasets/example_root/a'),\n PosixPath('../../datasets/example_root/b'),\n PosixPath('../../datasets/example_root/c')]",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a2_directories.html#تصنيف-عمليات-pathlib-في-بايثون",
    "href": "chapters/08_files_and_directories/a2_directories.html#تصنيف-عمليات-pathlib-في-بايثون",
    "title": "11  الدليل",
    "section": "11.1 تصنيف عمليات pathlib في بايثون",
    "text": "11.1 تصنيف عمليات pathlib في بايثون\nوإليك تصنيف لعمليات مكتبة pathlib:\n\nعمليات المسار\n\nإنشاء وتعديل المسارات:\n\n.joinpath: دمج مكونات مسار.\n.parent: استخراج الدليل الأب.\n.name: استخراج الاسم الأساسي للملف.\n.stem: استخراج اسم الملف بدون الامتداد.\n.suffix: استخراج امتداد الملف.\n.with_name: إنشاء مسار جديد باسم مختلف.\n.with_suffix: إنشاء مسار جديد بامتداد مختلف.\nrelative_to: إنشاء مسار نسبي.\n\n\n\n\nعمليات على نظام الملفات\n\nاستعلام:\n\nis_absolute: هل هو مطلق؟.\nsamefile: هل مساران يشيران إلى نفس الملف؟.\nexists: هل هو مسار موجود؟.\nis_file: هل هو مسار ملف؟.\nis_dir: هل هو مسار دليل؟.\nis_symlink: هل هو ارتباط رمزي؟.\nstat: سرد إحصائيات نظام الملفات.\nlstat: سرد إحصائيات نظام الملفات دون متابعة الارتباطات الرمزية.\n\nعمليات تغيير:\n\nopen: فتح ملف للقراءة أو الكتابة أو الإضافة.\nmkdir: إنشاء دليل.\nrmdir: حذف دليل فارغ.\nunlink: حذف ملف.\nrename: تعديل اسم ملف.\nreplace: تعديل اسم ملف مع الكتابة فوقه إذا لزم الفعل.\nchmod: تغيير أذونات الملف.\nlchmod: تغيير أذونات الملف دون متابعة الارتباطات الرمزية.\ntouch: تحديث الطابع الزمني للملف.\n\n\n\n\nالارتباطات الرمزية والصلبة\n\nsymlink_to: إنشاء ارتباط رمزي.\nhardlink_to: إنشاء ارتباط صلب.\nreadlink: قراءة الهدف من ارتباط رمزي.\n\n\n\nالتكرار والبحث\n\niterdir: تكرار على قائمة الدليل.\nglob: البحث عن الملفات المطابقة لنمط.\nrglob: البحث بشكل متكرر عن الملفات المطابقة لنمط.\nwalk: التنقل بشكل متكرر في شجرة الأدلة.",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/a2_directories.html#النسخ-والحذف-والنقل-shutil",
    "href": "chapters/08_files_and_directories/a2_directories.html#النسخ-والحذف-والنقل-shutil",
    "title": "11  الدليل",
    "section": "11.2 النسخ والحذف والنقل (shutil)",
    "text": "11.2 النسخ والحذف والنقل (shutil)\n\nshutil.copy2: نسخ ملف.\nshutil.copytree: نسخ شجرة أدلة.\nshutil.rmtree: حذف شجرة أدلة.\nshutil.move: نقل ملف أو دليل.",
    "crumbs": [
      "باب الملفات (Files)",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>الدليل</span>"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/b_context.html",
    "href": "chapters/08_files_and_directories/b_context.html",
    "title": "تطبيقات",
    "section": "",
    "text": "تصنيف التغريدات\nلدينا ثلاثة ملفات:\nنريد تصنيف التغريدات بناءً على عدد الكلمات الإيجابية والسلبية فيها.\nfrom pathlib import Path\n\ndata_dir = Path('../../datasets/tweets')\nبعد النظر في شكل الملفات. يتبين لنا أن السطر الواحد يحتوي على “شيء” واحد. وبالتالي سنقسم البيانات على كل سطر.\nونلاحظ أيضًا وجود أسطر خاوية، يجب التخلص منها.\ndef read_lines(file_path: Path) -&gt; list[str]:\n    \"\"\"skips empty lines and converts to lowercase\"\"\"\n    result = []\n    with open(file_path, 'r') as file:\n        for line in file:\n            x = line.strip()\n            if len(x) &gt; 0:\n                x = x.lower()\n                result.append(x)\n    return result\nنستدعي الفعل لقراءة الملفات الثلاث:\ntweets = read_lines(data_dir / 'tweets.txt')\npositive_words = read_lines(data_dir / 'words_positive.txt')\nnegative_words = read_lines(data_dir / 'words_negative.txt')\nfor i, tweet in enumerate(tweets):\n    print(i, tweet)\n\n0 grateful for the amazing people in my life who make it so wonderful\n1 the beautiful flowers were in full bloom and the sweet scent filled the air. the birds were singing merrily and the sun was shining brightly. it was a perfect day\n2 the kind and generous old man was always willing to help others. he was a role model for the entire community and he was loved by everyone\n3 the intelligent and talented young woman had a bright future ahead of her. she was passionate about her work and she was determined to make a difference in the world\n4 sending out good vibes to everyone today! have a beautiful day!\n5 i've been feeling so anxious and stressed lately with everything going on. really need a break from it all.\n6 traffic was the worst it's ever been today. the long commute just made me feel grumpy and drained.\n7 had an awful morning - overslept and missed my first meeting. feeling uneasy about how my boss will react.\n8 all the noise from the construction outside is driving me nuts. it's making working from home dreadful.\n9 went out with some friends last night but didn't have as much fun as i thought. felt a bit lonely and left early feeling uneasy.\nfor p in positive_words:\n    print(p)\n\ngrateful\namazing\nwonderful\nbeautiful\nsweet\nperfect\nkind\ngenerous\nhelp\nloved\nintelligent\ntalented\nyoung\nbright\npassionate\ndetermined\ngood\nbeautiful\nfriends\nfun\nhappy\nfor n in negative_words:\n    print(n)\n\nanxious\nstressed\nworst\ngrumpy\ndrained\nawful\noverslept\nmissed\nuneasy\nboss\nnoise\ndreadful\nlonely\nsad\nالآن نقوم بتصنيف التغريدات:\ndef classify(text: str) -&gt; (int, int):\n    \"\"\"Returns the number of positive and negative words in the text\"\"\"\n    \n    positive_count = 0\n    for word in positive_words:\n        if word in text:\n            positive_count += 1\n    \n    negative_count = 0\n    for word in negative_words:\n        if word in text:\n            negative_count += 1\n    \n    return positive_count, negative_count\n\nassert classify('i am happy') == (1, 0)\nassert classify('i am sad') == (0, 1)\nassert classify('i am happy and sad') == (1, 1)\nassert classify('i shall walk to the store') == (0, 0)\nنستدعي الفعل على التغريدات، ونفرز النتائج في ثلاثة قوائم:\npositive_tweets = []\nnegative_tweets = []\nneutral_tweets = []\nfor tweet in tweets:\n    pos, neg = classify(tweet)\n    score = pos - neg\n    print(f'-{neg} +{pos} = {score:+}')\n    if score &gt; 0:\n        positive_tweets.append((tweet, score))\n    elif score &lt; 0:\n        negative_tweets.append((tweet, score))\n    else:\n        neutral_tweets.append((tweet, score))\n\n-0 +3 = +3\n-0 +5 = +5\n-0 +4 = +4\n-0 +6 = +6\n-0 +3 = +3\n-2 +0 = -2\n-3 +0 = -3\n-5 +0 = -5\n-2 +0 = -2\n-2 +2 = +0\nنعرض التغريدات بحسب التصنيف مرتبة بقوة التصنيف من الأعلى إلى الأسفل:\nprint('positive_tweets:')\nfor tweet, score in sorted(positive_tweets, key=lambda x: x[1], reverse=True):\n    print(f'{score:+} {tweet}')\n\npositive_tweets:\n+6 the intelligent and talented young woman had a bright future ahead of her. she was passionate about her work and she was determined to make a difference in the world\n+5 the beautiful flowers were in full bloom and the sweet scent filled the air. the birds were singing merrily and the sun was shining brightly. it was a perfect day\n+4 the kind and generous old man was always willing to help others. he was a role model for the entire community and he was loved by everyone\n+3 grateful for the amazing people in my life who make it so wonderful\n+3 sending out good vibes to everyone today! have a beautiful day!\nprint('negative_tweets:')\nfor tweet, score in sorted(negative_tweets, key=lambda x: x[1]):\n    print(f'{score:+} {tweet}')\n\nnegative_tweets:\n-5 had an awful morning - overslept and missed my first meeting. feeling uneasy about how my boss will react.\n-3 traffic was the worst it's ever been today. the long commute just made me feel grumpy and drained.\n-2 i've been feeling so anxious and stressed lately with everything going on. really need a break from it all.\n-2 all the noise from the construction outside is driving me nuts. it's making working from home dreadful.\nprint('neutral_tweets:')\nfor tweet, score in neutral_tweets:\n    print(f'{score} {tweet}')\n\nneutral_tweets:\n0 went out with some friends last night but didn't have as much fun as i thought. felt a bit lonely and left early feeling uneasy.",
    "crumbs": [
      "باب الملفات (Files)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/08_files_and_directories/b_context.html#تصنيف-التغريدات",
    "href": "chapters/08_files_and_directories/b_context.html#تصنيف-التغريدات",
    "title": "تطبيقات",
    "section": "",
    "text": "الأول يحوي تغريدات\nالثاني يحوي كلمات إيجابية\nالثالث يحوي كلمات سلبية",
    "crumbs": [
      "باب الملفات (Files)",
      "تطبيقات"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html",
    "href": "chapters/09_oop/a1_classes.html",
    "title": "12  الأنواع",
    "section": "",
    "text": "12.1 تعريف النوع\nتتخذ بايثون نموذجًا في البرمجة يسمى البرمجة الشيئية؛ فالمتغيرات تحمل أشياء: فالرقم شيء، والنص شيء، والقائمة شيء، والمصفوفة شيء، وهلم جرا.\nوالشيء يختصُّ بما أُسنِدَ إليه:\nيُعرَّف الفعل بالكلمة class ويُبتدأُ غالبًا بتعريف فعل الإنشاء __init__ ليتم تعيين الصفات فيه بالإسناد للاسم self الذي يشير إلى الشيء المعين الذي يتم إنشاؤه الآن.\nأما تعريف الأفعال فكالأفعال مثل def move بزيادة self في الابتداء.\nتأمل المثال:\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\nوالآن نستطيع إنشاء معيَّنات من هذا النوع ونمرر القيم x, y بحسب ما هو موجود في الفعل المخصص للإنشاء: __init__ على النحو التالي:\np1 = Point(3, 4)\np2 = Point(7, 1)\nنستعمل حرف النقطة . بعد اسم المعيَّن للإشارة لصفةٍ أو فعل، نحو: p1.x:\nx_diff = abs(p1.x - p2.x)\ny_diff = abs(p1.y - p2.y)\nprint(f'X difference is {x_diff} and Y difference is {y_diff}.')\n\nX difference is 4 and Y difference is 3.\nوهذا مثال لطلب الفعل: p1.move()\np1.move(4, 4)\nprint(p1.x, p1.y)\n\n7 8\nلو أردنا طباعة النقطة، كيف تظهر؟\nprint(p1)\n\n&lt;__main__.Point object at 0x7392f42112b0&gt;\nلتخصيص طريقة عرض الشيء، بحيث لو طبعناه أو ذكرناه في آخر السطر يظهر البشكل الذي نريده، يمكن تغيير الفعل المخصص __repr__ أي: التمثيل .. هكذا:\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\nوالآن إن عرفنا نقطة جديدة، ووضعناها على السطر لوحدها ، ستظهر لنا الإحداثيات، لا عنوانها الذاكري:\np = Point(3, 4)\np.move(7, 6)\np\n\nPoint(10, 10)\nالفعل الثابت هو ما يُسنَدُ للنوع نفسه لا للأعيان. ويتم تثبيت الفعل بعلامة المزيِّن @staticmethod. لاحظ عدم وجود self في الفعل الجديد distance لأنه ثابت:\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n                \n    @staticmethod\n    def distance(p1, p2):\n        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\nويتم استدعاؤه بذكر اسم النوع والنقطة .:\na = Point(0, 1)\nb = Point(1, 0)\n\nPoint.distance(a, b)\n\n1.4142135623730951\nكذلك يُجعل المتغير من النوع الثابت بتعيينه بمحاذاة غيره من الأفعال نحو ما فعلنا هنا بالمتغير distance_type. ولاحظ استعماله في الفعل distance في جملة if-else من غير استعمال self لأننا لا نشير إلى معيَّن:\nclass Point:\n    distance_type = 'euclidean'\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2):\n        if Point.distance_type == 'euclidean':\n            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n        elif Point.distance_type == 'manhattan':\n            return abs(p1.x - p2.x) + abs(p1.y - p2.y)",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#التغليف-encapsulation",
    "href": "chapters/09_oop/a1_classes.html#التغليف-encapsulation",
    "title": "12  الأنواع",
    "section": "12.2 التغليف (Encapsulation)",
    "text": "12.2 التغليف (Encapsulation)\nفكرة التغليف في البرمجة الشيئية هي إبعاد التفاصيل عن المستفيد.\nفي المثال التالي لا نريد للمستفيد أن يعدِّل على الرصيد balance إلا عن طريق الفعل deposit الذي يضمن أن الزيادة تكون موجبة.\nولاحظ أن استعمال __balance عرفٌ بين المبرمجين في بايثون لنقول أن الصفة مخفيَّة عن المستفيد، وأنه يجب أن لا يغيرها مباشرةً.\nأما المزيِّن @property في الفعل balance فإنه يرجع بقيمة الصفة لا بالصفة نفسها. وذلك ليمنع التعديل عليها.\n\nclass Account:\n    def __init__(self, name, balance):\n        self.name = name\n        self.__balance = balance\n\n    def deposit(self, amount):\n        if amount &lt;= 0:\n            raise ValueError(\"must be positive\")\n        self.__balance += amount\n        print('time of deposit:', '2027-07-07')\n\n    @property\n    def balance(self):\n        return self.__balance\n\n\na1 = Account('Adam', 100)\na1.balance\n\n100\n\n\n\na1.deposit(100)\na1.balance\n\ntime of deposit: 2027-07-07\n\n\n200\n\n\nولو حاولت التغيير مباشرة فلن تستطيع (من غير الشرطتين السفليتين):\n\na1.balance = 1000\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[70], line 1\n----&gt; 1 a1.balance = 1000\n\nAttributeError: property 'balance' of 'Account' object has no setter",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#تصنيف-الأنواع",
    "href": "chapters/09_oop/a1_classes.html#تصنيف-الأنواع",
    "title": "12  الأنواع",
    "section": "12.3 تصنيف الأنواع",
    "text": "12.3 تصنيف الأنواع\nتصنف الأنواع في البرمجة بطريقتين:\n\nتصنيف اسمي: حيث يتم التصريح بأن النوع فلان، يستمد من النوع فلان (وقد يتعدد). وتتم بالوراثة (Inheritance)\nتصنيف عملي: حيث يكون اعتبار التصنيف بحسب أفعال النوع. وتتم بالواجهة (Interface) وهو نوعٌ من التركيب (Composition)",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#التصنيف-الاسمي-الوراثة-inheritance",
    "href": "chapters/09_oop/a1_classes.html#التصنيف-الاسمي-الوراثة-inheritance",
    "title": "12  الأنواع",
    "section": "12.4 التصنيف الاسمي: الوراثة (Inheritance)",
    "text": "12.4 التصنيف الاسمي: الوراثة (Inheritance)\nالوراثة: أن يندرج النوع تحت نوعٍ آخر؛ فهو يستمد منه ويزيد عليه صفةً أو فعلاً (أو أكثر).\nوهو اسميٌّ لأن المعتبر هو أسماء الأنواع؛ فتقول:\n\nالشكل هو ما كان له محيط\nالمستطيل شكلٌ (إذًا له محيط) و فوق ذلك فإنه له: طولًا وعرضًا ومساحة\nوالمثلث شكلٌ (إذًا له محيط) و فوق ذلك فإنه له: ثلاثةَ أضلاعٍ ومساحة\nأما المربع فهو مستطيل (إذًا له محيط لأن المستطيل شكل، وله طول وعرض ومساحة): لكن عرضه وطوله متساويان\n\nوهذه شجرة التوارث للأنواع المذكورة:\n\n\n\n\n\nflowchart BT\n  Shape\n  Rectangle -- \"is a\" --&gt; Shape\n  Square -- \"is a\" --&gt; Rectangle\n  Triangle -- \"is a\" --&gt; Shape\n\n\n\n\n\n\nويستعمل الإجراء super() للإشارة إلى النوع الأصل الذي استمدَّ منه. فإننا في فعل الإنشاء __init__ في المخصص نطلب فعل الإنشاء __init__ في الأصل.\n\nclass Shape:\n    def __init__(self, *sides):\n        self.sides = sides\n    \n    @property\n    def perimeter(self):\n        return sum(self.sides)\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        super().__init__(width, height, width, height)\n    \n    @property\n    def width(self):\n        return self.sides[0]\n    \n    @property\n    def height(self):\n        return self.sides[1]\n    \n    @property\n    def area(self):\n        return self.width * self.height\n    \nclass Triangle(Shape):\n    def __init__(self, a, b, c):\n        super().__init__(a, b, c)\n\n    @property\n    def a(self):\n        return self.sides[0]\n    \n    @property\n    def b(self):\n        return self.sides[1]\n    \n    @property\n    def c(self):\n        return self.sides[2]\n    \n    @property\n    def area(self):\n        s = self.perimeter / 2\n        return (s * (s - self.a) * (s - self.b) * (s - self.c))**0.5\n    \n\nclass Square(Rectangle):\n    def __init__(self, side):\n        super().__init__(side, side)\n\n\nx = Triangle(10, 10, 10)\nprint(\"Triangle\")\nprint(\"Perimeter:\", x.perimeter)\nprint(\"Area:\", round(x.area, 2))\nprint(f\"Sides: a={x.a}, b={x.b}, c={x.c}\")\n\nTriangle\nPerimeter: 30\nArea: 43.3\nSides: a=10, b=10, c=10\n\n\n\ny = Rectangle(10, 20)\nprint(\"Rectangle\")\nprint(\"Perimeter:\", y.perimeter)\nprint(\"Area:\", round(y.area, 2))\nprint(f\"Sides: width={y.width}, height={y.height}\")\n\nRectangle\nPerimeter: 60\nArea: 200\nSides: width=10, height=20\n\n\nوتجد في شجرة المجموعات شكل 1 أن المجموعات المتغيرة نوع مخصص من الأنواع الجامدة:\n\nالقائمة (list) مخصصة من التسلسل المتغير (MutableSequence) الذي هو من نوع التسلسل (Sequence).\nالمجموعة (set) مخصصة من المجموعة المتغيرة (MutableSet) التي هي من نوع المجموعة (Set).\nالقاموس (dict) مخصص من القاموس المتغير (MutableMapping) الذي هو من نوع القاموس (Mapping).\n\nيفضل كثير من الممارسين التصنيف العملي على التصنيف الاسمي في أغلب الأحيان. لمرونته التي نحتاجها في التطوير المستمر للبرنامج، بينما التصنيف الاسمي جامد، وتخرق قواعده الصرامة بسرعة عند التغيير. وكثيرٌ مما ينظَّرُ له في التصنيف الاسمي يمكن تحقيقه بجملة if-elif-else أو جملة match-case وتنتهي القصة. ولذلك يجب استعماله في حالات قليلة يكون الاستمداد فيها من حيثية محددة: مثل التغيُّر (Mutability) كما في المثال السابق.",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#التصنيف-العملي-التركيب-composition",
    "href": "chapters/09_oop/a1_classes.html#التصنيف-العملي-التركيب-composition",
    "title": "12  الأنواع",
    "section": "12.5 التصنيف العملي: التركيب (Composition)",
    "text": "12.5 التصنيف العملي: التركيب (Composition)\nومثاله في نفس شجرة المجموعات شكل 1 هو نوع الجمع (Collection)، حيث له ثلاثة اعتبارات:\n\nكونها تقبل العضويَّة: x in s وفعلها هو: __contains__ تصنَّف أنها حاوية (Container)\nكونها تقبل التكرار: for x in s وفعلها هو: __iter__ تصنَّف أنها متوالية (Iterable)\nكونها تقبل العد: len(s) وفعلها هو: __len__ تصنَّف أنها محجَّمة (Sized)\n\nوكذلك المتسلسلة (Sequence) تقبل العكس، وفعلها المخصص هو: __reversed__؛ فبهذا الاعتبار هي من النوع القابل للعكس (Reversible).\nفمثلاً: أيُّ شيءٍ يعرِّفُ الفعل len(sized)__ -&gt; int__ فإنه ينتمي لنوع ذوات الحجم (Sized)، ونمثل لذلك بنوع المتجه في فضاء ثنائي الأبعاد حيث يتكون من عنصرين:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __len__(self):\n        return 2\n\nv1 = Vector(10, 20)\nlen(v1)\n\n2\n\n\nولاحظ عدم وجود ذكر اسم النوع Sized البتة، فليس بينهما علاقة مباشرة، ولكن تم تعريف ذلك الصنف المجرَّد لاحقًا لاعتبار جميع ما له الفعل __len__ لمعرفة عدد عناصره.\nويكثر فيه المجرَّداتُ ذات الفعل الواحد أو الفعلين. لأننا نريد أشياء كثيرة تنتمي بحسب ما يكون فيها من أفعال.",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a1_classes.html#المعاملات-operators",
    "href": "chapters/09_oop/a1_classes.html#المعاملات-operators",
    "title": "12  الأنواع",
    "section": "12.6 المعاملات (Operators)",
    "text": "12.6 المعاملات (Operators)\nتأمل التالي وتوقَّع النتيجة وعلل إجابتك. ما هي نتيجة:\nالأول:\n[1, 2, 3] + [4, 5, 6]\nالثاني:\n[1, 2, 3] * [4, 5, 6]\nالثالث:\n[1, 2, 3] * 5\nالرابع:\n[1, 2, 3] - 3\nكل الذي سبق، قد تم تعريفه في بايثون لهذه الأنواع التي تراها بالتحديد عن طريق أفعال مخصصة. وإليك هذا الجدول للمعاملات المخصصة:\n\n\n\nمثال معامله\nالفعل\n\n\n\n\nself + other\n__add__\n\n\nself - other\n__sub__\n\n\nself * other\n__mul__\n\n\nself / other\n__truediv__\n\n\nself // other\n__floordiv__\n\n\nself % other\n__mod__\n\n\nself ** other\n__pow__\n\n\n\n(وانظر توثيق بايثون لمحاكاة العمليات الرقمية).\nفنستطيع تعريف نوع متجَّه على النحو التالي.\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, other):\n        return Vector(self.x * other.x, self.y * other.y)\n\nوالآن يمكننا إنشاء متجهين وفعل العمليات المخصصة:\n\nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\n\nv1 + v2\n\nVector(4, 6)\n\n\n\nv1 - v2\n\nVector(-2, -2)\n\n\n\nv1 * v2\n\nVector(3, 8)\n\n\nماذا لو أردنا إضافة عمليات بين المتجه والعدد، نحو: v1 + 3? يتطلب ذلك إضافة شرط لفحص النوع:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x + other.x, self.y + other.y)\n        else:\n            return Vector(self.x + other, self.y + other)\n    \n    def __sub__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x - other.x, self.y - other.y)\n        else:\n            return Vector(self.x - other, self.y - other)\n    \n    def __mul__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x * other.x, self.y * other.y)\n        else:\n            return Vector(self.x * other, self.y * other)\n\nوالآن يمكننا فعل العمليات المخصصة:\n\nv1 = Vector(1, 2)\nv1 + 3\n\nVector(4, 5)\n\n\nلكن لاحظ أنك لو وضعت العدد أولاً فسيظهر خطأ:\n\n3 + v1\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[81], line 1\n----&gt; 1 3 + v1\n\nTypeError: unsupported operand type(s) for +: 'int' and 'Vector'\n\n\n\nهذا لأن عملية الجمع الآن لا تنظر في نوع العدد (int) ولا تجد فيه قبولاً للمتجه (فقد عرفناه للتو). ولحل هذه المشكلة توفر بايثون لكل فعل مخصص مقابل يبدأ بحرف r على النحو التالي:\n\n\n\nالمعامل\nالفعل\n\n\n\n\nother + self\n__radd__\n\n\nother - self\n__rsub__\n\n\nother * self\n__rmul__\n\n\n\nنعدل الفعل بحيث نضيف إليه المقابل:\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x + other.x, self.y + other.y)\n        else:\n            return Vector(self.x + other, self.y + other)\n\n    def __radd__(self, other):\n        return self + other\n\nوالآن كلاهما يعمل بشكل صحيح:\n\nv1 = Vector(1, 2)\n3 + v1\n\nVector(4, 5)\n\n\n\nv1 + 3\n\nVector(4, 5)",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الأنواع</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html",
    "href": "chapters/09_oop/a2_classes.html",
    "title": "13  التجريد",
    "section": "",
    "text": "13.1 التعميم\nومن الخصائص الممتعة في بناء البرمجيات: العلاقات بين المجردات في المستويات المختلفة من التجريد. وسنمثل لذلك بـ:\nنريد أن نعمم نوع المتجه بحيث لا يتقيد بعنصرين x,y بل يقبل أن يكون أكثر من ذلك:\nclass Vector:\n    def __init__(self, *args):\n        self.elements = args\n    \n    def __repr__(self):\n        str_elements = [str(e) for e in self.elements]\n        return f\"Vector({', '.join(str_elements)})\"\n    \n    def __add__(self, other):\n        result = []\n        if isinstance(other, Vector):\n            if len(self.elements) != len(other.elements):\n                raise ValueError(\"Vectors must have the same length\")\n            for a, b in zip(self.elements, other.elements):\n                result.append(a + b)\n        else:\n            for a in self.elements:\n                result.append(a + other)        \n        return Vector(*result)\n    \n    def __radd__(self, other):\n        return self + other\nأما السطر الأخير: return Vector(*result) فعلامة النجمة تفك القائمة بحيث تمرر عناصرها كمعيَّنات منفصلة لفعل الإنشاء.\nv1 = Vector(10, 20, 30)\nv2 = Vector(60, 50, 40)\n\nv1 + v2\n\nVector(70, 70, 70)\nv1 + 10\n\nVector(20, 30, 40)\n10 + v1\n\nVector(20, 30, 40)",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html#التركيب",
    "href": "chapters/09_oop/a2_classes.html#التركيب",
    "title": "13  التجريد",
    "section": "13.2 التركيب",
    "text": "13.2 التركيب\nلو كان عندنا تعريف نوع نقطة ..\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2):\n        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n\nيمكننا تركيب شيء مكون من النقاط، وهو المضلَّع، على النحو التالي:\n\nيأخذ فعل الإنشاء __init__ سلسلة من النقاط ويعيِّنُها لمتغير اسمه points\nيعرض فعل التمثيل __repr__ كلمة Polygon وداخل أقواسها يضع تمثيل النقاط\nلاحظ أن فعل perimeter يُنتج قُطر المضلَّع؛ وهو مجموع المسافات بين النقاط المتوالية\n\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def __repr__(self):\n        return f\"Polygon({self.points})\"\n\n    def perimeter(self):\n        n = len(self.points)\n        s = 0\n        for i in range(n):\n            s += Point.distance(self.points[i], self.points[(i+1)%n])\n        return s\n\nلاحظ أن إنشاء المضلَّع يتطلَّب إنشاء نقاط. ولاحظ أننا جعلنا كل نقطة في سطر، لكنها في الحقيقة كلها عناصر لقائمة، وهو واضحٌ بملاحظة القوسين المربعين [ ]:\n\npoly = Polygon([\n    Point(0, 0),\n    Point(5, 0),\n    Point(5, 5),\n    Point(0, 5),\n])\npoly\n\nPolygon([Point(0, 0), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nوالآن يمكن استعمال فعل حساب المحيط:\n\npoly.perimeter()\n\n20.0\n\n\nولأن هذا المركَّب مكوَّن من أفراد، فنريده أن يُشابه الأنواع الحاوية، التي لها أفعال معيَّنة. وذلك ممكنٌ باستعمال الأفعال المخصصة:\n\nالعد: len(s) يُسمَّى فعله: __len__\nالإشارة: s[i] يُسمَّى فعله: __getitem__\nالتعيين: s[i] = p يُسمَّى فعله: __setitem__\nالحذف: del s[i] يُسمَّى فعله: __delitem__\n\nانظر التوثيق الرسمي لبايثون حول محاكاة أنواع الحاويات لمزيد من المعلومات.\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def __repr__(self):\n        return f\"Polygon({self.points})\"\n\n    def __len__(self):\n        return len(self.points)\n    \n    def __getitem__(self, i):\n        return self.points[i]\n\n    def __setitem__(self, i, p):\n        self.points[i] = p\n\n    def __delitem__(self, i):\n        del self.points[i]\n    \n    def perimeter(self):\n        n = len(self.points)\n        s = 0\n        for i in range(n):\n            s += Point.distance(self.points[i], self.points[(i+1)%n])\n        return s\n\n\npoly = Polygon([\n    Point(0, 0),\n    Point(5, 0),\n    Point(5, 5),\n    Point(0, 5),\n])\npoly\n\nPolygon([Point(0, 0), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nوالآن نستطيع عدَّ النقاط بالفعل المعروف len الذي بدوْره يستدعي الفعل المتعلق بالشيء __len__ (فُهما سواء):\n\nassert len(poly) == poly.__len__()\nlen(poly)\n\n4\n\n\nبتعريفنا لفعل معرفة الطول، انسجم هذا النوع مع المجموعات مثل القائمة ومجموعة الفرائد والروابط والسلسلة النصية وغيرها.\nوقد تتساءل: هل أي كلمة أكتبها بين الشرطتين السفليتين استطيع استعماله مثل len؟ والجواب: للأسف لا؛ وإنما هي أسماء مخصوصة.\nأما قبول الفعل len لأنواع مغايرة عن بعضها فهي خاصيَّة تعدد الأشكال (Polymorphism): أي أن الفعل الواحد يقبل أنواع متعددة في الحقيقة لكنَّها في تُظهر نفس السلوك الخارجي. بعبارة أخرى نقول:\n\nالظاهر: المدخلات والمخرجات واحدة\nالحقيقة: الخوارزمية قد تختلف اختلافًا جذريًّا !\n\nوهذا كثيرٌ في البرمجيات.\nثم الإشارة برقم أو بشريحة:\n\nprint(poly[0])\nprint(poly[-1])\nprint(poly[1:3])\nprint(poly[::-1])\n\nPoint(0, 0)\nPoint(0, 5)\n[Point(5, 0), Point(5, 5)]\n[Point(0, 5), Point(5, 5), Point(5, 0), Point(0, 0)]\n\n\nثم التعيين:\n\npoly[0] = Point(10, 10)\npoly\n\nPolygon([Point(10, 10), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nوأخيرًا الحذف:\n\ndel poly[0]\npoly\n\nPolygon([Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nتبين بهذا محاكاة بعض أفعال الحاويات الأساسية مثل list وset وtuple وstr وdict. وقد تقدَّم معنا أن النقطة تستطيع محاكاة الأنواع العددية باستعمال الفعل المخصص للجمع + الذي هو __add__.",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html#التخصيص",
    "href": "chapters/09_oop/a2_classes.html#التخصيص",
    "title": "13  التجريد",
    "section": "13.3 التخصيص",
    "text": "13.3 التخصيص\nيكثر استعمال الطابور كهيكل بيانات لحل مجموعة من المسائل بطريقة سهلة. نستعرض في هذا المثال كيفية تخصيص القائمة (list) ذات الأفعال الكثيرة من الحذف والإضافة والتعديل، لنوع له أفعال مختلفة لكنها مبنية عليها.\nالطابور يُعرَّف بفعلين أساسيين:\n\nالإدخال من جهة\nالإخراج من الجهة المقابلة (بحيث يكون ما دخل أولاً هو الذي يخرج أولاً)\n\nفهو بهذا أخص من القائمة التي تزيد عليه: الإشارة لعنصر برقمٍ وإمكان تعديله أو حذفه أو الإضافة في الوسط، وغيرها.\n\n\n\nتوضيح الطابور\n\n\nفهذا مثال لكتابة نوع الطابور:\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the end of the queue\"\"\"\n        self.items.append(item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the front of the queue\"\"\"\n        if not self.is_empty():\n            return self.items.pop(0)\n        return None\n\n    def peek(self):\n        \"\"\"Return the item at the front without removing it\"\"\"\n        if not self.is_empty():\n            return self.items[0]\n        return None\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return len(self.items) == 0\n    \n    def __len__(self):\n        return len(self.items)\n\n    def __repr__(self):\n        \"\"\"Return the underlying list representation\"\"\"\n        return repr(self.items)\n\n\nلاحظ أن فعل الإنشاء __init__ يعيِّن قائمة فارغة للشيء self\nثم الفعل enqueue يتم بواسطة فعل القائمة append\nوالفعل dequeue يتم بواسطة فعل القائمة pop\nوكذلك peek باستعمال الإشارة بالرقم للعنصر في الموضع 0\nثم is_empty بالنظر لطول القائمة بالفعل len\n\nنختبر ذلك الآن:\n\nq = Queue()\n\nq.enqueue(1)\nq.enqueue(2)\nq.enqueue(3)\n\nprint(q)\n\n[1, 2, 3]\n\n\nنزيل عُنصرًا:\n\nq.dequeue()\nprint(q)\n\n[2, 3]\n\n\nهل يمكننا معرفة عدد العناصر؟:\n\nlen(q)\n\n2\n\n\nصحيح أن القائمة أكثر قدرة (إذْ تتضمن عمليات أكثر)، إلا أن الطابور مخصص لخدمة وظيفة محددة. وليس يهمنا ما ينطوي خلفه (قائمة أم صف أم غير ذلك)؛ بل يهمنا أفعاله الظاهرة لنا. أما طريقة عمله فقد تجرَّدنا عنها.",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/09_oop/a2_classes.html#التسلسل",
    "href": "chapters/09_oop/a2_classes.html#التسلسل",
    "title": "13  التجريد",
    "section": "13.4 التسلسل",
    "text": "13.4 التسلسل\nومن الأنواع ما يتسليل مثل الشجرة، حيث فروعها قد تكون أصولاً لفروع أخرى. وهكذا يتسلسل الفعل حتى نصل إلى الأوراق / الثمار (القيم الأخيرة).\nومثل هذا له استعمالات كثيرة في هيكلة البيانات بأمثل بنية تكون فيها أسرع في البحث والإدراج والحذف ونحو ذلك. لكننا نكتفي بمثال نتأمله، نعرف فيه الشجرة الثنائية:\n\nclass BinaryTreeNode:\n    def __init__(self,\n        value,\n        left: 'BinaryTreeNode' = None,\n        right: 'BinaryTreeNode' = None):\n        self.value = value\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        if self.left is None and self.right is None:\n            return f\"{self.value}\"\n        return f\"({self.left}) &lt;-- [{self.value}] --&gt; ({self.right})\"\n\n\ntree = BinaryTreeNode(10)\ntree.left = BinaryTreeNode(5)\ntree.right = BinaryTreeNode(15)\n\ntree\n\n(5) &lt;-- [10] --&gt; (15)\n\n\n\ntree.left.left = BinaryTreeNode(3)\ntree.left.right = BinaryTreeNode(7)\ntree.right.left = BinaryTreeNode(13)\ntree.right.right = BinaryTreeNode(17)\n\ntree\n\n((3) &lt;-- [5] --&gt; (7)) &lt;-- [10] --&gt; ((13) &lt;-- [15] --&gt; (17))",
    "crumbs": [
      "باب الأصناف (Classes)",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>التجريد</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html",
    "href": "chapters/10_time/a_time.html",
    "title": "14  الوقت",
    "section": "",
    "text": "14.1 مقدمة",
    "crumbs": [
      "باب الوقت (Time)",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#مقدمة",
    "href": "chapters/10_time/a_time.html#مقدمة",
    "title": "14  الوقت",
    "section": "",
    "text": "الساعات والأيام\nتذكر بعض المصادر أن الأولين كانوا يقسمون الوقت على 12 ساعة ليلية (تبدأ بعد غروب الشمس) تتلوها 12 ساعة نهارية (تبدأ بعد شروق الشمس). وهي ساعات متغيرة؛ ففي الصيف تزيد طول ساعة النهار (فوق 60 دقيقة معتدلة) بينما تقصر ساعة الليل (دون 60 دقيقة معتدلة)، ويحصل العكس في الشتاء (فيكون الليل أطول والنهار أقصر). أما عند اعتدال الشمس في أشهر معيَّنة في خط الاستواء فإن ساعات الليل والنهار 60 دقيقة (وهو مقياس الاعتدال). والمرجع في ذلك الساعة الشمسية (المزوَّلة). ولحساب الفترة الزمنية كانوا يستعملون ما يُحرَق كالشمع، أو ثقب في وعاء مدرَّج من ماء أو رمل.\nانظر كتاب فقه اللغة للثعالبي:\n\nالفصل السابع عشر “في تَعْدِيدِ سَاعَاتِ النَّهارِ واللَّيل على أربع وعشرين لفظة”.\nعن حمزة بن الحسن وعليه عهدتها:\nسَاعَاتُ النَّهارِ: الشُرُوقُ. ثُمَّ البكورُ. ثُمَّ الغُدْوَةُ. ثُمَّ الضُّحَى. ثُمَّ الهاجِرَةُ. ثُمَّ الظَهِيرَةُ. ثُمَّ الرَّوَاحُ. ثُمَّ العَصْرُ. ثُمَّ القَصْرُ. ثُمَّ الأصِيلُ. ثُمَّ العَشِيُّ. ثُمَّ الغُروبُ. سَاعَاتُ اللَّيلِ: الشَّفَقُ. ثُمَّ الغَسَقُ. ثُمَّ العَتَمَةُ. ثُمَّ السُّدْفَة. ثُمَّ الفَحْمَةُ. ثُمَّ الزُّلَّةُ. ثُمَّ الزُّلْفةُ. ثُمَّ البُهْرَةُ. ثُمَّ السَّحَرُ. ثُمَّ الفَجْرُ. ثُمَّ الصُّبْحُ. ثُمَّ الصَّباحُ\n\nثم جاءت الساعات الميكانيكية الثابتة التي تعمل وكأن جميع الساعات 60 دقيقة (وكأنها على خط الاستواء وفي وقت اعتدال الشمس عليه)؛ ولا تعتبر شتاءً ولا صيْفًا، ولا نهارًا ولا ليلاً .. لكنها أصبحت هي المتداولة. وقد مرَّ ضبط الساعة (حتى لا تحيد) بمستويات متطورة من الدقة، فبدأت من الساعة المتأرجحة (1657) إلى الكرونومتر (1762) إلى مذبذب الكوارتز (1927) إلى الساعة الذرية (1949) إلى ساعة شعاع السيزيوم (1955) إلى ساعة نافورة السيزيوم (1993) إلى الساعة الضوئية (Optical Clock: 2006) والتي تحيد بمقدار ثانية بعد كل 30 مليار سنة.\n\n\nالتوقيت العالمي والمناطق الزمنية\nظهر نظام التوقيت العالمي المنسق (UTC: Coordinated Universal Time) حوالي سنة 1967، لتسهيل التعامل بين الدول والتواصل عبر القارات. فهو نظام للوقت يعتمد على خطوط الطول الأرضية، تقسَّم فيه الجغرافيا لمناطق زمنية بحسب بعدها عن خط طول جرينيتش الذي كان هو نقطة الصفر (UTC+00:00) أي: المرجِع: فما يكون شرقيها يكون الفارق فيه بالموجب، وما يكون غربيَّها يكون الفارق فيه بالسالب.\nوكل منطقة زمنية لها توقيت محلي تعتمده في معاملاتها اليومية فيما يتعلق بالوقت من تواصل وتنسيق ومواعيد ونحو ذلك. في الخريطة أدناه نرى تقسيم المناطق الزمنية:\n\n\n\nخريطة تظهر تقسيم المناطق الزمنية\n\n\nلاحظ أولاً أن الخطوط ليست طوليَّة بالفعل، انظر إلى الألوان فليست هي مستطيلات بل تتعرَّج بحسب حدود الدُّول في الغالب. فالفعل ليس بالبساطة التي قد نعتقدها: فليس الوقت المحلي هو فقط زيادة أو نقص من الوقت العالمي .. بل هناك عدة اعتبارات للتحويل بينها:\n\nمناطق عريضة جغرافيًّا: كالصين التي تمتد لتغطي مجموعة خطوط طول إلا أنها تعتمد توقيتًا موحَّدًا.\nالتوقيت الصيفي: بعض المناطق الزمنية تقدِّم الوقت ساعة عند الربيع (أو نهاية الشتاء) ثُم تعيدُه في الخريف، وذلك لتنظيم جدوَل الناس بحيث يتعرضوا للشمس أكثر.\nقرارات سياسية: قررت بعض الدوَّل أن تغير منطقتها الزمنية في سنة من السنوات؛ فذلك يجب أن يؤخذ في عين الاعتبار عند حساب الأوقات قبل أو بعد هذه السنة لهذه الدُّوَل.\n\nمعلومة جانبية: مصطلح التنسيق في التوقيت العالمي المنسق يشير إلى أنه يضع في الحسبان الاختلاف اليسير بسبب الثواني الكبسية، فتعاد ضبط الأوقات لاعتبارها.\nنخلص من ذلك أن التعامل مع الوقت له اعتبارات كثيرة بسبب ظروف تاريخية وسياسية وليس خاضعًا لقوانين فيزيائية أو أرضية أو فلكية بحتة. ولذلك ظهرت قاعدة بيانات للمناطق الزمنية (بمجهود جماعي) تتضمن معلومات الدول بشكل يتم تحديثه بشكل مستمر لمتابعة التغيرات، تسمَّى: (tz database).",
    "crumbs": [
      "باب الوقت (Time)",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#الوقت-في-الحاسب",
    "href": "chapters/10_time/a_time.html#الوقت-في-الحاسب",
    "title": "14  الوقت",
    "section": "14.2 الوقت في الحاسب",
    "text": "14.2 الوقت في الحاسب\nيظهر وقت التقويم (Calendar Time) على هذا النحو:\n\nالتاريخ: 2024-11-25\nالساعات: 08:30:25\nالمنطقة الزمنية: GMT+3 (أي: ثلاث ساعات متقدِّمة عن جرينيتش)\n\nلكن تمثيل الزمن في الحاسب هو: عدد صحيح (int) ويمثِّل عدد الثواني من بزوغ فجر نظام يونكس (Unix Epoch) وهو تاريخ ووقت اعتباطي تمَّ وضعه على أن يكون:\n\nتاريخ: 1970-01-01\nالساعة: 00:00:00\nالمنطقة الزمنية: UTC التي هي GMT+0\n\nمثال: لنشير إلى سنة واحدة تمامًا بعد النقطة الصفرية، أي: الساعة 00:00:00 بتاريخ 1 يناير1971 ، فإن السنة الواحدة فيها 31,536,000 ثانية ، وبالتالي يكون هذا الرقم هو الذي يمثل ذلك الوقت.\nولو أردت الترجمة بالعكس، فتقول إن 1,000,000,000 ثانية منذ النقطة الصفرية يوافق 9 سبتمبر 2001 01:46:40 في وقت التقويم على منطقة UTC.\nمشكلة سنة 2038 تحصل في الأنظمة ذات 32-بت؛ إذْ عدد الثواني يصل إلى أقصى مداه عند نقطتين زمنيتين:\n\nففي النزول تستطيع أن تصل إلى: 20:45:52 UTC بتاريخ 1901-12-13 (باختيار عدد سالب)\nوكذلك في الصعود؛ لا يمكن أن تتعدى: 03:14:07 UTC بتاريخ 2038-01-19\n\nوالحل في ذلك بسيط، وهو نقل البرنامج لنظام 64-بت.",
    "crumbs": [
      "باب الوقت (Time)",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#الوقت-في-بايثون",
    "href": "chapters/10_time/a_time.html#الوقت-في-بايثون",
    "title": "14  الوقت",
    "section": "14.3 الوقت في بايثون",
    "text": "14.3 الوقت في بايثون\nننتقل الآن إلى الوقت والتاريخ في بايثون، حيث يوجد لدينا المفاهيم التالية:\nأولاً: datetime.date وهو تاريخ مثالي يفترض أن التقويم الغريغوري يمتد إلى ما لا نهاية في المستقبل والماضي (رغم أنه في الحقيقة حل مكان التاريخ الجولياني سنة 1582). سمات هذا الكائن: السنة والشهر واليوم.\nثانيًا: datetime.time هو وقت مثالي يفترض 86,400 ثانية في اليوم (بدون ثوانٍ كبيسة). سمات هذا الكائن: الساعة والدقيقة والثانية والميكروثانية وtzinfo (معلومات المنطقة الزمنية).\nثالثًا: datetime.datetime وهو التاريخ والوقت معًا؛ فلديه سمات كلا الجزئين.\nرابعًا: datetime.timedelta وهو فترة زمنية. ولكننا سنستبدله بـ dateutil.relativedelta إذ هي كذلك فترة زمنية إلا أن نطاقها أوسع (تستوعب السنين والأشهر، وتعتبر السنوات الكبيسة في الحسبان).\nالوقت الصحيح لا بد له من نسبة إلى منطقة زمنيَّة (كأن تقول الساعة 04:00:00 صباحًا بتوقيت UTC+03)؛ فهذا تسميه بايثون وقت واع (Aware)، وأما الوقت الذي لم تحدد منطقته الزمنية (كما لو قُلت في الساعة 04:00:00 صباحًا) فهذا غير منسوب لمنطقة زمنية وبالتالي فهو ساذج (Naive) على تعبيرهم.\nويرشدنا توثيق المكتبة للتوسع في استعمال قاعدة بيانات المناطق الزمنية، والقدرة على تفسير التواريخ والأوقات بمرونة لاستخدام مكتبة dateutil المتوفرة في PyPI.\nلتثبيت المكتبة نستعمل pip على النحو التالي:\npip install python-dateutil\nالآن نستورد المكتبة الأساسية datetime ومكتبة dateutil:\n\nfrom datetime import date, time, datetime, timedelta\nfrom dateutil import tz\n\nنريد الآن معرفة الوقت العالمي والمحلي، وكذلك الوقت في القاهرة، وكذلك الوقت في لندن (هنا قائمة بالأسماء):\n\nprint(datetime.now(tz=tz.tzutc()))\nprint(datetime.now(tz=tz.tzlocal()))\nprint(datetime.now(tz=tz.gettz('Africa/Cairo')))\nprint(datetime.now(tz=tz.gettz('Europe/London')))\n\n2024-12-13 18:09:15.844209+00:00\n2024-12-13 21:09:15.844276+03:00\n2024-12-13 20:09:15.844794+02:00\n2024-12-13 18:09:15.845219+00:00\n\n\nلاحظ أن شكل الوقت كاملاً على النحو التالي:\n    2024-11-19 11:32:35.355104+03:00\n    YYYY-MM-DD HH:MM:SS.ssssss+HH:MM\nنفكك ذلك:\n\nYYYY-MM-DD هو التاريخ (يبدأ بالسنة ثم الشهر ثم اليوم)\nHH:MM:SS.ssssss هو الوقت (بالساعات والدقائق والثواني والميكروثواني)\n+HH:MM هو الفرق بين الوقت المحلي لتلك المنطقة الزمنية والوقت العالمي المنسق (UTC).\n\n\nالتفسير: تحويل النص إلى تاريخ ووقت\nوقراءة التواريخ أفضل بكثير في مكتبة dateutil بدلاً من استعمال المكتبة الأساسية datetime. وتكثر الحاجة لذلك عند استقبال معلومات من الشبكة أو من ملفات أو من المستخدمين:\n\nfrom dateutil.parser import parse\n\nهنا نحدد وقتًا افتراضيًّا عند القراءة، بحيث لو لم توجد المعلومة عند القراءة فإنها تستعمل القيم الافتراضية:\n\nDEFAULT = datetime(2003, 9, 25)\nparse(\"Thu Sep 25 10:36:28\", default=DEFAULT)\n\ndatetime.datetime(2003, 9, 25, 10, 36, 28)\n\n\nونرى كيف أن المفسر يحاول معرفة المعلومات ولو كانت ناقصة:\n\nدون السنة\nدون الشهر\nدون الثواني\nدون اليوم\n\n\nprint(parse(\"Thu Sep 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36\", default=DEFAULT))\nprint(parse(\"10:36\", default=DEFAULT))\n\n2003-09-25 10:36:28\n2003-09-25 10:36:28\n2003-09-25 10:36:00\n2003-09-25 10:36:00\n\n\n\n\nالحسابات الزمنية\n\nfrom dateutil.relativedelta import relativedelta\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nحساب الزمن المنقضي\n\ntoday = datetime.now(tz=tz.tzlocal())\nbirthday = datetime(1970, 1, 1, tzinfo=tz.tzlocal())\nage = relativedelta(today, birthday)\nprint(f'You are {age.years} years and {age.months} months old')\n\nYou are 54 years and 11 months old\n\n\n\n\nحساب الزمن لموعد\n\ntoday = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2025, 1, 15, tzinfo=tz.tzlocal())\ndiff = relativedelta(exam_date, today)\nprint(f'There are {diff.days} days and {diff.hours} hours remaining')\n\nThere are 1 days and 2 hours remaining\n\n\n\n\nمقارنة الوقت\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=9, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif now &gt; exam_date:\n    print('The exam has passed')\nelif now &lt; exam_date:\n    print('The exam is coming')\n\nThe exam has passed\n\n\n\n\nمقارنة الفترة\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=15, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif relativedelta(now, exam_date).hours &lt; 1:\n    print('Hurry up!')\nelif relativedelta(now, exam_date).hours &lt; 4:\n    print(f'Remember you have an exam today at {exam_date:%H:%M}')\nelse:\n    print(f'You have plenty of time to prepare for the exam')\n\nYou have plenty of time to prepare for the exam\n\n\n\n\nالجمعة القادمة\n\ntoday = datetime.now(tz=tz.tzlocal())\nnext_friday = today + relativedelta(days=+1, weekday=FR)\nprint(f'The next Friday is {next_friday:%Y-%m-%d}')\n\nThe next Friday is 2024-12-20\n\n\n\n\nالجمعة الفائتة\n\nlast_friday = today - relativedelta(days=+1, weekday=FR(-1))\nprint(f'The last Friday is {last_friday:%Y-%m-%d}')\n\nThe last Friday is 2024-12-06\n\n\n\n\nحساب الوقت باعتبار منطقتين زمنيتين\nلديك اجتماع في وقت محدد بتوقيت لندن، وتريد معرفة وقت الوصول بالطائرة إن كانت الرحلة تستغرق 4 ساعات والإقلاع من القاهرة في الساعة 01:00:00 صباحًا والوجهة لندن:\n\ndeparture_tz = tz.gettz('Africa/Cairo')\narrival_tz = tz.gettz('Europe/London')\n\ndeparture_time = datetime(2024, 11, 19, hour=1, tzinfo=departure_tz)\n\narrival_time = departure_time + relativedelta(hours=4)\n\nprint(f'You leave at {departure_time.astimezone(departure_tz)} in Cairo time')\nprint(f'You arrive at {arrival_time.astimezone(arrival_tz)} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz)} in Cairo time')\n\nYou leave at 2024-11-19 01:00:00+02:00 in Cairo time\nYou arrive at 2024-11-19 03:00:00+00:00 in London time\nwhich corresponds to 2024-11-19 05:00:00+02:00 in Cairo time\n\n\n\n\n\nتنسيق التاريخ والوقت\nوانظر الجدول لتنسيق مظهر التاريخ والوقت:\n\nprint(f'Departure time: {departure_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\nprint(f'Arrival time: {arrival_time.astimezone(arrival_tz):%d %b, %X %Z} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\n\nDeparture time: 19 Nov, 01:00:00 EET in Cairo time\nArrival time: 19 Nov, 03:00:00 GMT in London time\nwhich corresponds to 19 Nov, 05:00:00 EET in Cairo time\n\n\n\n\nالتكرار\nتكرار التواريخ يتم في هذه المكتبة باستعمال rrule ويحدد على النحو التالي:\n\nfrom dateutil.rrule import rrule\nfrom dateutil.rrule import DAILY, WEEKLY, MONTHLY, YEARLY, HOURLY, MINUTELY, SECONDLY\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nيوم ويوم\nتكرار أوقات بأخذ يوم وترك يوم، ابتداءً من وقت معين في الساعة العاشرة صباحًا:\n\nlist(\n    rrule(DAILY, interval=2, count=10, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 21, 10, 0),\n datetime.datetime(2024, 11, 23, 10, 0),\n datetime.datetime(2024, 11, 25, 10, 0),\n datetime.datetime(2024, 11, 27, 10, 0),\n datetime.datetime(2024, 11, 29, 10, 0),\n datetime.datetime(2024, 12, 1, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 5, 10, 0),\n datetime.datetime(2024, 12, 7, 10, 0)]\n\n\n\n\nأسبوعي\n\nlist(\n    rrule(WEEKLY, interval=1, count=4, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 26, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 10, 10, 0)]\n\n\n\n\nشهريًّا إلى وقت محدد\n\nlist(\n    rrule(MONTHLY, interval=1,\n        dtstart=datetime(2024, 8, 1),\n        until=datetime(2025, 4, 1),\n    )\n)\n\n[datetime.datetime(2024, 8, 1, 0, 0),\n datetime.datetime(2024, 9, 1, 0, 0),\n datetime.datetime(2024, 10, 1, 0, 0),\n datetime.datetime(2024, 11, 1, 0, 0),\n datetime.datetime(2024, 12, 1, 0, 0),\n datetime.datetime(2025, 1, 1, 0, 0),\n datetime.datetime(2025, 2, 1, 0, 0),\n datetime.datetime(2025, 3, 1, 0, 0),\n datetime.datetime(2025, 4, 1, 0, 0)]\n\n\n\n\nكل 15 دقيقة لمدة 6 مرات\n\nlist(\n    rrule(MINUTELY, interval=15, count=6, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 19, 10, 15),\n datetime.datetime(2024, 11, 19, 10, 30),\n datetime.datetime(2024, 11, 19, 10, 45),\n datetime.datetime(2024, 11, 19, 11, 0),\n datetime.datetime(2024, 11, 19, 11, 15)]\n\n\nوندعوك للاطلاع على المزيد من الأمثلة على مكتبة dateutil.",
    "crumbs": [
      "باب الوقت (Time)",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/10_time/a_time.html#التاريخ-الهجري-في-بايثون",
    "href": "chapters/10_time/a_time.html#التاريخ-الهجري-في-بايثون",
    "title": "14  الوقت",
    "section": "14.4 التاريخ الهجري في بايثون",
    "text": "14.4 التاريخ الهجري في بايثون\nتوفر مكتبة hijridate التعامل مع التاريخ الهجري والتحويل بينه وبين الجريجوري (الميلادي):\nfrom hijridate import Hijri, Gregorian\n\ng = Hijri(1446, 5, 17).to_gregorian()\nh = Gregorian(2024, 11, 19).to_hijri()\n\nprint(g)\nprint(h)",
    "crumbs": [
      "باب الوقت (Time)",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html",
    "href": "chapters/11_errors/a1_errors.html",
    "title": "15  الخطأ",
    "section": "",
    "text": "15.1 الخطأ النحوي: الخطأ في المبنى\nينقسم الخطأ لثلاثة أنواع:\nفي هذا الفصل، نناقش كل نوع من الأخطاء وكيفية التعامل معها.\nالأخطاء النحوية تتعلق بتركيب اللغة لا أكثر ولا أقل. إليك ثلاثة أمثلة.",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html#الخطأ-النحوي-الخطأ-في-المبنى",
    "href": "chapters/11_errors/a1_errors.html#الخطأ-النحوي-الخطأ-في-المبنى",
    "title": "15  الخطأ",
    "section": "",
    "text": "فقدان النقطتين :\n\nif (x &gt; 5)\n    print(\"x\")\n\n\n  Cell In[1], line 1\n    if (x &gt; 5)\n              ^\nSyntaxError: expected ':'\n\n\n\n\n\n\nعلامات اقتباس غير متوازنة\n\nprint(\"x\n\n\n  Cell In[2], line 1\n    print(\"x\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\nاسم متغير غير صالح\n\nmy-variable = 10\n\n\n  Cell In[3], line 1\n    my-variable = 10\n    ^\nSyntaxError: cannot assign to expression here. Maybe you meant '==' instead of '='?\n\n\n\n\n\n\nأخطاء المحاذاة\nمن الأخطاء النحوية الشائعة في بايثون: أخطاء المحاذاة (Indentation Error).\nوذلك أن بايثون تقبل نوعين من المسافات البادئة للسطر؛ إما بحرف المسافة التي بين الكلمات \\s أو بحرف المسافة بين الأعمدة \\t. وقد يستعمل بعض الناس هذه وبعضهم ذلك، ثم تأخذ كودًا من هنا وكودًا من هناك، فترى الكود عنك لا يعمل، والسبب هو الخلط بينهما في نفس الكود. وبايثون لا تقبل ذلك. فيجب توحيد النوع. إما هذه أو هذه. لذلك يضبط VS Code ومحررات الأكواد الأخرى تحويل البادئة تلقائيًا إلى مسافة أو العكس.\nإليك بعض الأمثلة لما يحصل من أخطاء في المحاذاة:\nعدم وجود مسافة بادئة، عندما تكون متوقعة:\n\nif True:\nprint(\"x\")\n\n\n  Cell In[4], line 2\n    print(\"x\")\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\nعدم تطابق المحاذاة:\n\nif True:\n    print(\"x\")\n     print('y')\n\n\n  Cell In[5], line 3\n    print('y')\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\nتجويد العبارة\nمن تجويد العبارة تسمية المتغيرات بما يدل على وظيفتها، مثل:\n\nrate = 50\nhours_per_day = 6\ndays = 5\npay = rate * hours_per_day * days\nprint(pay)\n\n1500\n\n\nوإن كان ليس من الخطأ النحوي كتابتها بطريقة مختلفة وبأسماء غير معبِّرة، إلا أنه فعلٌ غير مستحسن:\n\nr, hpd, d = 50, 6, 5\np = r * hpd * d\nprint(p)\n\n1500\n\n\nوفي هذا نصائح كثيرة، يراجع فيها دليل أسلوب الكتابة في بايثون.",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html#الخطأ-المنطقي-الخطأ-في-المعنى",
    "href": "chapters/11_errors/a1_errors.html#الخطأ-المنطقي-الخطأ-في-المعنى",
    "title": "15  الخطأ",
    "section": "15.2 الخطأ المنطقي: الخطأ في المعنى",
    "text": "15.2 الخطأ المنطقي: الخطأ في المعنى\nوهي التي نقصدها حين نقول: Bug، ولذلك قيل للبرنامج الذي يساعد في إصلاحها: Debugger، وعملية البحث عنها وإصلاحها: Debugging.\nالأخطاء المنطقية صامتة. إذ لا يكتشفها المترجم، وتتسبب في تصرف البرنامج بشكل غير صحيح. الأخطاء المنطقية هي الأصعب في التتبع والإصلاح لأنها ليست واضحة. يمكن أن تكون ناجمة عن:\n\nافتراضات غير صحيحة\nتطبيق غير صحيح للخوارزمية أو\nتحضير غير صحيح للبيانات\n\nاقرأ المزيد عن أنواع الأخطاء وإليك بعض الأمثلة.\n\nاستعمال الفعل الخاطئ\n\nimport math\n\nsquare = math.sqrt(4) # should use math.pow(4, 2) instead\n\n\n\nاستعمال العامل الخاطئ\n\nx = 16\nif (x == \"16\"):\n    print('equal')\n\n\n\nمستوى محاذاة خاطئ\nهنا كانت النية تقتضي أن تكون print(j) داخل الحلقة الداخلية:\n\nfor i in range(2):\n    for j in range(3):\n        print(i)  \n    print(j)\n\n0\n0\n0\n2\n1\n1\n1\n2\n\n\n\n\nخطأ الحافَّة\nيكاد يكون أشهر الأخطاء في البرمجة: خطأ الحافَّة. ويسمى (Off-by-one error).\nنشرحه بمثال: النية هنا هي طباعة الأرقام من 5 إلى 0 بما في ذلك 0، ولكن الحلقة تتوقف عند 1.\n\nfor i in range(5, 0, -1):\n    print(i)\n\n5\n4\n3\n2\n1",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a1_errors.html#كشف-الأخطاء-المنطقية",
    "href": "chapters/11_errors/a1_errors.html#كشف-الأخطاء-المنطقية",
    "title": "15  الخطأ",
    "section": "15.3 كشف الأخطاء المنطقية",
    "text": "15.3 كشف الأخطاء المنطقية\nلكونها جملاً صحيحة في ذاتها؛ لا يستطيع البرنامج كشف هذه الأخطاء لوحده. بل يجب على من يُدركُ حقيقة المطلوب من البرنامج أن يتكفل بذلك. وهنا تكون الحاجة ماسَّة لجمل التوكيد: assert وقد رأيناها كثيرًا.\nوالتدقيق؛ إذْ أفضل طريقة لحل الأخطاء المنطقية هي تنفيذ الكود والنظر في الناتج، وتتبع المنطق مرة أخرى إلى الكود سطرًا بسطر. يمكنك استخدام عبارات الطباعة print لتصحيح الأخطاء وفهم تدفق البرنامج. وقد يكون الأفضل من ذلك استعمال المدقق (Debugger).\nمراجعة الأقران: بحيث يطلع على الكود شخص آخر، فإنه قد يرى منه ما تعذر عليك رؤيته. وقد يتم تنظيمه بين أعضاء الفريق الواحد بأحد برمجيات التعاون مثل: GitHub وGitLab وBitbucket وغيرها. لكن ليس شرطًا أن يكون بطريقة منظَّمة حتى تستفيد منه.",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الخطأ</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html",
    "href": "chapters/11_errors/a2_exceptions.html",
    "title": "16  الخطأ الواقعي: الاستثناء",
    "section": "",
    "text": "16.1 الفرق بين الوقاية والتدارك\nالاستثناء (Exception) هو خروج البرنامج عن المسار المثالي. ويسمى خطأً (Error).\nمثل أن يؤمَر بقراءة ملف .. والواقع أن هذا الملف غير موجود! أو أن يطلب من المستخدم رقمًا فيعطيه كلاماً! أو أن يطلب من الشبكة شيئًا .. فتنقطع الشبكة! فكل هذه تعتبر مسارات غير مثالية لكنها تحصل في ظروف واقعيَّة. فيجب كتابة قطع في البرنامج تتعامل معها. ولذا فإن بعض الممارسين لا يفضلون استعمال كلمة استثناء لأنَّ مثل ذلك يحصل كثيرًا فهو ليس خارجًا عن العادة؛ بل من الطبيعي أن يحصل ذلك في الواقع.\nتصوَّر أن البرنامج سلسلة من الأفعال بحيث يختص كل فعل بمهمة معيَّنة (بناءً على مدخلاته يُعطي مخرجاته) فإننا نتعمَّد أن يكون وعيُه محدودًا بمدخلاته حتى نقلل من تشابك قطع الكود حتى نيسِّر على أنفسنا التحقق من صحَّة المنطق. وهذه فكرة ظرف التنفيذ الذي سبق الحديث عنها في باب الفعل.\nفللخطأ حالتان -لا غير- في علاقتها مع من يتعامل معه:\nومنشؤ الخطأ أحد أمرين:\nوللتعامل مع الخطأ حين يستوعبه السياق طريقتان:\nهذا الفعل مسؤول عن تهيئة البرنامج، ومن خطواته أنه يقرأ ملف الضبط المخصص custom_config.json. وفي هذه الحالة قد يحصل خطأ. إذْ قد لا يكون الملف موجودًا أصلا!\nهذا الفعل مسؤول عن تهيئة البرنامج، ومن خطواته أنه يقرأ ملف الضبط المخصص custom_config.json. وفي هذه الحالة قد يحصل خطأ. إذْ قد لا يكون الملف موجودًا أصلا!\nففي هذه الحالة يحصل استثناء من نوع FileNotFoundError.\nفإذا اخترنا طريق الوقاية فإننا أولاً نلتمس وجوده قبل فتحه. ونتعامل مع حالة الخطأ هذه (أي: عدمه)، بأن -مثلاً- نقرأ ملف الضبط الافتراضي default.json بدلاً من الملف المطلوب. والفرق بين هذا الملف والذي قبله أننا موقنون بوجوده، والأوَّل وجوده مظنون إذْ الذي يضعه هو المستخدم.\nوقد تقول، حسنًا ماذا يكون لو عُدم ملف default.json أيضًا؟ فنقول: لا بأس أن يحصل خطأ يوقف البرنامج. إذْ ذاك يعتبر خطأ منطقيًّا يجب إصلاحه بإضافة الملف، وليس ثمة مجال لأن يصلحه الكود بنفسه.\nأما التدارك فيكون بجملة try-except على النحو التالي:\nأما استعمال الوقاية ففيه شك بوجود فجوة زمنية بين عملية التحقق من وجود الملف وبين قراءته. فالحاسب تتوارد عليه البرمجيات، ولا يستأثر به برنامج واحد. فإذا تغيَّر الحال في هذه الفجوة الزمنية وعاد بالنقض على التحقق بعد حصوله انتفت الفائدة منه. لذا فالتدارك أضمن.",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#الفرق-بين-الوقاية-والتدارك",
    "href": "chapters/11_errors/a2_exceptions.html#الفرق-بين-الوقاية-والتدارك",
    "title": "16  الخطأ الواقعي: الاستثناء",
    "section": "",
    "text": "file = open('custom_config.json')\n\ndef initialize_program():\n    # ... code before\n    file = open('custom_config.json')\n    # ... code after\n\n\ndef initialize_program():\n    # ... code before\n    if os.path.exists('custom_config.json'):\n        file = open('custom_config.json')\n    else:\n        file = open('default.json')\n    # ... code after\n\n\ndef initialize_program():\n    # ... code before\n    try:\n        file = open('custom_config.json')\n    except FileNotFoundError:\n        file = open('default.json')\n    # ... code after\n\n\nالحالة الأولى: خطأ جديد يستوعبه السياق\nمثاله ما لو لم تكن أحد الصفات محددة، فيمكن تعيينها بقيمة افتراضية، ولا يلزمنا تصعيد الخطأ:\ndef save_user(user: dict):\n    if 'language' not in user:\n        user['language'] = 'ar'\n    # ... rest of the code\n    save_to_database(user)\n\n\nالحالة الثانية: خطأ مرفوع يستوعبه السياق\nوقد مثلنا له بفتح الملف، ونمثل له بمثال آخر:\n\ndef get_user_guess() -&gt; int:\n    print('Please enter a number')\n    guess = input()\n    try:\n        guess = int(guess)\n    except ValueError:\n        print(f'The value \"{guess}\" is not a number')\n        guess = get_user_guess() # recursive call\n    return guess\n\n\n\nالحالة الثالثة: خطأ جديد لا يستوعبه السياق\nفي هذا المثال يجب أن تكون الوحدة إحدى القيم المسموحة: C أو F. وإلا فلا حيلة للفعل أن يتم وظيفته. لذا نرفع خطأ جديدًا بجملة raise.\ndef convert_temperature(value: float, unit: str) -&gt; float:\n    if unit not in {'C', 'F'}:\n        raise ValueError(f\"Invalid unit: {unit}\")\n    \n    if unit == 'C':\n        return value * 9/5 + 32\n    elif unit == 'F':\n        return (value - 32) * 5/9\n\n\nالحالة الرابعة: خطأ مرفوع لا يستوعبه السياق\nففي هذا المثال عملية قسمة قد يحصل فيها قسمة على صفر في (a / b)، فيرتفع خطأ اسمه ZeroDivisionError من تلك العملية. والحقيقة أننا في هذا السياق ليس لنا أن نعدِّل الرقم، بل نريد لمن استدعى الفعل أن يعلم بالخطأ، ولسنا نريد إضافة معلومة أخرى فوق ذلك. لذا نسكت عنه (أي: لا نضع try-except) وهذا يجعله ينتقل مباشرة للفعل المستدعي.\ndef divide_lists(list1: list, list2: list) -&gt; list:\n    result = []\n    for a, b in zip(list1, list2):\n        result.append(a / b)\n    return result\nفإن من الأخطاء ما يتعذر على البرنامج معالجته بنفسه:\n\nإذا كانت المشكلة بامتلاء الذاكرة في الجهاز؛ فإن البرنامج ليس له إلا أن يخرج برسالة للمستخدم أو المسؤول عن الجهاز .. وليس للبرنامج أن يمسح بيانات المستخدم!\nأما إذا كانت المشكلة في تأخر الإجابة من الخادم مثلاً، فقد نعيد المحاول مرة أخرى بعد ثوانٍ، ونعيدها لعددٍ محدد من المرات، أملاً في الحصول على إجابة. ثم بعد ذلك لا يمكن إلا أن نظهر رسالة خطأ إن نفدت جميع المحاولات.",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#إلتقاط-جميع-الأخطاء",
    "href": "chapters/11_errors/a2_exceptions.html#إلتقاط-جميع-الأخطاء",
    "title": "16  الخطأ الواقعي: الاستثناء",
    "section": "16.2 إلتقاط جميع الأخطاء",
    "text": "16.2 إلتقاط جميع الأخطاء\nمن الخطأ في المنطق البرمجي إلتقاط جميع الأخطاء في الأفعال باستعمال except Exception وهو النوع الشامل لجميع الأخطاء. فهذه الطريقة لا تخبرنا بنوع الخطأ وبالتالي لا نتعامل معه بحسبه، وإنما غاية ما تحقق هو منع تصعيد الخطأ لأعلى طبقة، إذْ حين يحصل ذلك توقف بايثون البرنامج (وعندها تظهر سلسلة الطلبات).\nلكن يجوز ذلك في قطع الكود التي يُراد لها الاستمرار، وإن فشلَ شيئٌ فيها. مثلاً: لا تريد للخادم أن يتوقف تمامًا بمجرد حصول خطأ واحد في أحد خيوط التنفيذ الخاصة بخدمة أحد الطلبات. ففي مثل ذلك يسوغ استخدام except Exception الشاملة. انظر مثلاً قطعة الكود في إطار الويب فلاسك المسؤول عن استقبال الطلبات.",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#أنواع-الاستثناء-في-بايثون",
    "href": "chapters/11_errors/a2_exceptions.html#أنواع-الاستثناء-في-بايثون",
    "title": "16  الخطأ الواقعي: الاستثناء",
    "section": "16.3 أنواع الاستثناء في بايثون",
    "text": "16.3 أنواع الاستثناء في بايثون\nوقد تم تعريف أنواع من الأخطاء في بايثون بحسب الحالة، وتم تقسيمها هكذا:\n\nSyntaxError\nالسبب: خطأ نحوي في صياغة اللغة:\n\nكلمة غير صحيحة: خطأ في الإملاء\nفي وضع كلمة صحيحة في غير سياقها\nمحاذاة غير متسقة (IndentationError)\n\nالحل: اقرأ رسالة الخطأ وستدلُّك على السبب والموضع الذي حصل فيه الخطأ.\n\n\nTypeError\nالسبب:\n\nطلب فعل بعدد أكثر أو أقل من العوامل الواجبة (مثل: len(1, 2))\nطلب فعل بعوامل لا تطابق النوع المحدد في تعريفه (مثل: math.sqrt('nine') أو 5 + '5')\n\nالحل: الوقاية بـ type() أو isinstance() أو بالتأكد من تحويل النوع مسبقًا.\na = 5\nb = input('Enter a number: ')\nresult = a + int(b)\n\n\nValueError\nالسبب: أن يكون النوع صحيحًا (فلا يحصُل TypeError) لكن القيمة غير مقبولة.\n\nمثلاً: طلب فعل بقيمة نوعها عددي لكنَّها سالبة وهو لا يقبل إلا الموجبة. نحو: math.sqrt(-16) فالجذر التربيعي لا يقبل السالب.\n\nالحل: الوقاية بفحص مدى القيمة ، نحو: if x &gt;=0: math.sqrt(x)\n\n\nIndexError & KeyError\nالسبب: الرقم الذي استعمل في عملية الإشارة [index]list (قائمة) أو dict[key] (قاموس) يشير لما هو خارج المجموعة.\nنحو:\n\nmy_list = [10, 20, 30]\nidx = 3\nvalue = my_list[idx]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[18], line 3\n      1 my_list = [10, 20, 30]\n      2 idx = 3\n----&gt; 3 value = my_list[idx]\n\nIndexError: list index out of range\n\n\n\nالحل بالوقاية:\nif idx &lt; len(my_list):\n    value = my_list[idx]\nelse:\n    # do something else\nأو بالتدارك:\ntry:\n    value = my_list[idx]\nexcept IndexError:\n    # do something else\nوكذلك في القاموس، نحو:\n\nmy_dict = {'A': 10, 'B': 20, 'C': 30}\nkey = 'Z'\nvalue = my_dict[key]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[19], line 3\n      1 my_dict = {'A': 10, 'B': 20, 'C': 30}\n      2 key = 'Z'\n----&gt; 3 value = my_dict[key]\n\nKeyError: 'Z'\n\n\n\nالحل بالوقاية\nif key in my_dict:\n    value = my_dict[key]\nelse:\n    # do something else\nأو هكذا (تعيين قيمة افتراضية):\nvalue = my_dict.get(key, 0)\nأو بالتدارك:\ntry:\n    value = my_dict[key]\nexcept KeyError:\n    # do something else\n\n\nAttributeError & NameError\nالسبب: استعمال متغير أو فعل قبل تعريفه.\n\nفإن أسنِد إلى كائن؛ وقع AttributeError\nوإلا وقع NameError\n\n\na = 10\na + X\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[20], line 2\n      1 a = 10\n----&gt; 2 a + X\n\nNameError: name 'X' is not defined\n\n\n\n\nsome_function(55)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 some_function(55)\n\nNameError: name 'some_function' is not defined\n\n\n\n\nclass A:\n    pass\n\na = A()\na.x\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[22], line 5\n      2     pass\n      4 a = A()\n----&gt; 5 a.x\n\nAttributeError: 'A' object has no attribute 'x'\n\n\n\n\na.do_something()\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 a.do_something()\n\nAttributeError: 'A' object has no attribute 'do_something'\n\n\n\n\n\nModuleNotFoundError\nالسبب: فشل جُملة الاستيراد import numpy\nالحل:\n\nتأكد من صحة الإملاء\nتأكد من تثبيت الوحدة في البيئة التي يعمل فيها البرنامج: pip install numpy",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#تعريف-أخطاء-جديدة",
    "href": "chapters/11_errors/a2_exceptions.html#تعريف-أخطاء-جديدة",
    "title": "16  الخطأ الواقعي: الاستثناء",
    "section": "16.4 تعريف أخطاء جديدة",
    "text": "16.4 تعريف أخطاء جديدة\nتعريف الخطأ يكون بتعريف نوع جديد يرث من النوع Exception، وهذا ما يحققه السطر الأول بين القوسين. وتستطيع أن ترث ممن يرث، فتتكون لديك فروع من هذا الخطأ:\n\nclass ParentError(Exception):\n    pass\n\nclass XError(ParentError):\n    pass\n\nclass YError(ParentError):\n    pass\n\n\n\n\n\n\nflowchart TD\n    A[ParentError] --&gt; B[XError]\n    A --&gt; C[YError]\n\n\n\n\n\n\nوهذا الفعل يحصل فيه الخطأ بطريقة مصطنعة لكنها توضح ما نريد، وهو الخطأ الفرعي XError الذي يرث من الخطأ الأصلي ParentError:\n\ndef do_something():\n    raise XError('Something went wrong')\n\nثم حين نفحص، تسطيع أن نطابق بالأصل أو الفرع:\n\ntry:\n    do_something()\nexcept ParentError as e:\n    print(\"caught you:\", e)\n\ncaught you: Something went wrong",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "chapters/11_errors/a2_exceptions.html#منظور-آخر-للخطأ",
    "href": "chapters/11_errors/a2_exceptions.html#منظور-آخر-للخطأ",
    "title": "16  الخطأ الواقعي: الاستثناء",
    "section": "16.5 منظور آخر للخطأ",
    "text": "16.5 منظور آخر للخطأ\nفائدة: لدينا طريقتان في التعامل مع الخطأ الواقعي، واختارت بايثون طريقة الاستثناء:\nالأولى: رفع قيمة الخطأ بالاسثناء: لغات مثل C++ (1979)، Java (1998)، Python (1991) و JavaScript (1995) ترمي/ترفع الاستثناءات باستعمال عبارة مثلة raise أو عبارة throw على حسب اللغة. وتكون معالجة الخطأ بجملة try-catch أو try-except.\nالثانية: الرجوع بقيمة الخطأ: اللغات الحديثة مثل Go (2009) و Rust (2015) ببساطة تعيد الخطأ كشيء (قيمة) عند حدوثه باستعمال جملة return التي في الفعل. وتكون معالجة الخطأ بجملة شرطية عاديَّة نحو: if error == error_type\nوبعض اللغات مثل: C (1978) وكذلك C++ (1985) تخلط بين النوعين!\n\nالمراجع:\n\nPython Tutorial: Exceptions\nMiguel Grinberg: The Ultimate Guide to Error Handling in Python",
    "crumbs": [
      "باب الخطأ والاستثناء (Errors and Exceptions)",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>الخطأ الواقعي: الاستثناء</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html",
    "href": "appendix_collections.html",
    "title": "خريطة المجموعات",
    "section": "",
    "text": "classDiagram\n    class Container {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n    }\n\n    class Iterable {\n        &lt;&lt;abstract&gt;&gt;\n        +__iter__()\n    }\n\n    class Iterator {\n        &lt;&lt;abstract&gt;&gt;\n        +__next__()\n        +__iter__()\n    }\n\n    class Reversible {\n        &lt;&lt;abstract&gt;&gt;\n        +__reversed__()\n    }\n\n    class Sized {\n        &lt;&lt;abstract&gt;&gt;\n        +__len__()\n    }\n\n    class Collection {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n    }\n\n    class Sequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__len__()\n        +__contains__()\n        +__iter__()\n        +__reversed__()\n        +index()\n        +count()\n    }\n\n    class MutableSequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__len__()\n        +insert()\n        +append()\n        +clear()\n        +reverse()\n        +extend()\n        +pop()\n        +remove()\n        +__iadd__()\n    }\n\n    class Set {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +__le__()\n        +__lt__()\n        +__eq__()\n        +__ne__()\n        +__gt__()\n        +__ge__()\n        +__and__()\n        +__or__()\n        +__sub__()\n        +__xor__()\n        +isdisjoint()\n    }\n\n    class MutableSet {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +add()\n        +discard()\n        +clear()\n        +pop()\n        +remove()\n        +__ior__()\n        +__iand__()\n        +__ixor__()\n        +__isub__()\n    }\n\n    class Mapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__iter__()\n        +__len__()\n        +__contains__()\n        +keys()\n        +items()\n        +values()\n        +get()\n        +__eq__()\n        +__ne__()\n    }\n\n    class MutableMapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__iter__()\n        +__len__()\n        +pop()\n        +popitem()\n        +clear()\n        +update()\n        +setdefault()\n    }\n\n    Iterable &lt;|-- Iterator\n    Iterable &lt;|-- Reversible\n    Sized &lt;|-- Collection\n    Iterable &lt;|-- Collection\n    Container &lt;|-- Collection\n    Reversible &lt;|-- Sequence\n    Collection &lt;|-- Sequence\n    Sequence &lt;|-- MutableSequence\n    Collection &lt;|-- Set\n    Set &lt;|-- MutableSet\n    Collection &lt;|-- Mapping\n    Mapping &lt;|-- MutableMapping\n\n\n\n\nشكل 1: الأنواع المجردة حول المجموعة (Collection)",
    "crumbs": [
      "الملحقات",
      "خريطة المجموعات"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "قاموس المصطلحات",
    "section": "",
    "text": "Tuple",
    "crumbs": [
      "الملحقات",
      "قاموس المصطلحات"
    ]
  },
  {
    "objectID": "glossary.html#tuple",
    "href": "glossary.html#tuple",
    "title": "قاموس المصطلحات",
    "section": "",
    "text": "Etymology. The term originated as an abstraction of the sequence: single, couple/double, triple, quadruple, quintuple, sextuple, septuple, octuple, …, n‑tuple, …, where the prefixes are taken from the Latin names of the numerals. The unique 0-tuple is called the null tuple or empty tuple. Wikipedia",
    "crumbs": [
      "الملحقات",
      "قاموس المصطلحات"
    ]
  },
  {
    "objectID": "glossary.html#parameter",
    "href": "glossary.html#parameter",
    "title": "قاموس المصطلحات",
    "section": "Parameter",
    "text": "Parameter\n\nA parameter (from Ancient Greek παρά (pará) ‘beside, subsidiary’ and μέτρον (métron) ‘measure’), generally, is any characteristic that can help in defining or classifying a particular system (meaning an event, project, object, situation, etc.). Wikipedia",
    "crumbs": [
      "الملحقات",
      "قاموس المصطلحات"
    ]
  }
]