[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "فاتحة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.\nكتبت هذا الكتاب لمن أراد تعلم البرمجة بلغة عربية سهلة ، وبطريقة منهجية مرتبة مع مراعاة الجانبين: النظري والعملي. وليس الهدف منه تعلم طريقة التفكير، فهذا يُدرس في الخوارزميات وهياكل البيانات، ولكن الهدف هو التعرف على الأدوات البرمجية نفسها عن طريق طرح مسائل نستعمل فيها هذه الأدوات.\nولم يكن الهدف من الكتاب ترجمة كتب علمية أو مقالات برمجية إلى اللغة العربية؛ بل الهدف هو تعلم البرمجة. فحرصت على أن يكون الكلام متداولاً ولو لم تكن المصطلحات قاموسية. واخترت من الاصطلاح ما يزول به الغموض مراعيًا السياقات المختلفة لتكون أقرب لفهم المتعلم العربي.\nواخترت لغة بايثون لتعليم البرمجة لسهولتها وشهرتها مما يجعل كثيرًا من التطبيقات في المتناول، إذ الجهود متظافرة على خدمةمكتباتها من المجتمعات التي تتمحور حول صنف ما من التطبيقات. وقد نقسم أنواع التطبيقات إلى ثلاثة:\nأنظمة تحاكي الواقع: مثلاً برنامج لمحاكاة القوى المؤثرة وتوزيع الأحمال على جسر (أو عمارة أو باخرة أو طائرة) يساعد المهندسين على بناء الجسر (وربما خطة تفصيلية متدرِّجة).\nأنظمة فاعلة في الواقع: مثلاً في المصنع: الذراع الآلية ، وآلة القص ، وآلة الكبس ، …إلخ. من الآلات التي تعمل ضمن مجموعة متسقة لتنتج ما تنتج على خط الإنتاج.\nأنظمة المعلومات: تُعنى بجمع المعلومات وحفظها وفهرستها وترتيبها وتقسيمها وعرضها وتسهيل الحصول عليها بالسؤال المباشر وغير المباشر، والتحقق منها وتوفيرها والاستفادة منها وترجمتها ونحو ذلك. وهذا النوع هو الأغلب. مثل: محرك بحث قوقل (يعمل على ترتيب شبكة الإنترنت) ، ونظام الدفع عبر البطاقة ، والبرمجيات المكتيبة (تقارير ، محاسبة ، تخطيط، …إلخ) ، ونحو ذلك .",
    "crumbs": [
      "فاتحة"
    ]
  },
  {
    "objectID": "index.html#تمهيد",
    "href": "index.html#تمهيد",
    "title": "البايثونية",
    "section": "تمهيد",
    "text": "تمهيد\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nوأدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة الحفظ.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة المتعددة.",
    "crumbs": [
      "فاتحة"
    ]
  },
  {
    "objectID": "00_setup.html",
    "href": "00_setup.html",
    "title": "1  إعداد بيئة التطوير",
    "section": "",
    "text": "نبدأ بالتعرف على بيئة التطوير ، وتثبيتها في جهازك؛ وذلك أنني أؤمن بضرورة إكساب الفرد أعلى قدر من التحكم في أدواته حتى يتمكن منها ومن تطويعها لعمل ما يريد بالشكل الأمثل.\nبيئة التطوير هي الأدوات البرمجية الأساسية والمساعدة لعمليات كتابة الكود وتنفيذه واختباره ونحو ذلك.\nأول ما نحتاج إليه هو حزمة برمجيات بايثون التي تتضمَّن الأداة التي تترجم ما نكتبه من كود بلغة بايثون لأوامِر ثنائية (صفر وواحد) لتكون مفهومة على مستوى نظام التشغيل ومعمارية الحاسب (إذ هي مستويات أكثر تفصيلاً)؛ ونسميه المُفَسِّر (Interpreter) وإن شئت قُل مترجم.\nكما تتضمن هذه الحزمة برنامج pip المسؤول عن تثبيت الحِزَم البرمجية المكتوبة بلغة بايثون؛ وذلك حتى تتمكن من البناء عليها عند كتابة أكواد بايثون (وبهذا الاعتبار تسمى مكتبات)، أو فقط لاستعمال برمجيات مكتوبة ببايثون (وبهذا الاعتبار تسمى برمجيات).\nأما محرر الكود فسنختار استوديو البرمجة المرئية (Visual Studio Code) (وهو مختلف عن بيئة تطوير فيجوال ستوديو (Visual Studio)) ولعلنا نسميه محرر أكواد مايكروسوفت (الذي يستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024) لأن الشركة أسسته ثم فتحت للمجتمع البرمجي أكواده. وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن. وتعني الشركة بدعمه وصيانته باستمرار وتطويره، كما أتيح بفتح أكواده سهولة كشف الأخطاء فيه، وأتيح بفضل تصميمه لأن يُخصص وتمتد إمكانياته بإضافات برمجيَّة قابلة للتثبيت يقوم بتزويدها لبعضهم البعض المجتمع البرمجي على مختلف لغاته واستعمالاته.\nونرى أن التعلم يكون أسهل على دفتر جوبيتر (Jupyter Notebook) داخل محرر الأكواد ، وذلك لأنه يتيح تجربة قطع الكود بطريقة مباشرة ومنفصلة سنراها في حينها بدل تنفيذ الكود كملف كامل.\nنأتي الآن على كيفية تثبيت هذه المكونات في الجهاز.\n\nتنزيل مثبِّت حزمة برمجيات بايثون؛ بالذهاب لصفحة https://www.python.org/ والضغط على زر (Download).\n\n\n\n\nHow to download Python from https://www.python.org/\n\n\n\nتنزيل مثبِّت محرر الأكواد من: Visual Studio Code\nلربط لغة البايثون في محرر الكود .. قم بتثبيت Python Extension.\nولربط المحرر بدفتر جوبيتر ، قم بتثبيت Jupyter Extension.\nقم بتثبيت حزمة ipykernel عن طريق pip وذلك لتتمكن من تنفيذ قطع الكود الواقعة في دفتر جوبيتر. يستلزم ذلك أن تفتح نافذة الأوامر (Terminal) ثم تكتب فيها هذا السطر:\n\npip install ipykernel\n\nأنشئ دفتر جوبيتر، وذلك بإنشاء ملف جديد بصيغة ipynb. عن طريق محرر الكود.\n\nبعد ذلك تكون جاهزًا للبدء في الدرس الأول!",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>إعداد بيئة التطوير</span>"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "2  مقدمة",
    "section": "",
    "text": "2.1 الشيء المفرد\nويندرج تحت صنف الأرقام مجموعة أصناف وإن شئت قل: أنواع، وهي: (العدد الصحيح، والعدد العشري، والعدد التخيلي) وكذلك يندرج تحتها في نموذج بايثون (العدد الثنائي) الذي يكون إما صفرًا أو واحدًا (0 أو 1).\nفاشتراكها في صفة الرقمية (الذي جعلها تحت صنف الأرقام) أتى من حيث أنها تقبل إجراءات الجمع والطرح والقسمة ، وكذلك إجراءات المقارنة (أكبر من ، وأصغر من ، والمساواة) ونحو ذلك مما تقبله الأرقام. وسيأتي الحديث عنها بالتفصيل في باب الأرقام.\nمثال بلغة البرمجة نقول:\nx = 123\nfoo = 123.45\nok = True\nnot_ok = False\nفالسطر الأول يعين قيمة 123 (وهي من جنس الأعداد الصحيحة) للاسم x وذلك عن طريق عملية التعيين (=). والثاني مثله لكن عدد عشري (لاحظ أنه يمكن للمسمى أن يكون كلمة ولا يشترط أن يكون حرفًا كما في الرياضيات). والثالث مثله لكن قيمة ثنائي تساوي 1 (“نعم”). والخامس مثله لكن تساوي 0 (“لا”). فكل هذه أرقام.\nونستعرض الآن كيف نجري إجراءات على الأرقام:\nx = 5\ny = 10\nz = x + y\nprint(z)\n\n15\nلاحظ أن علامة الـ(=) ليست تعني مساواة الطرفين كما في المعدالات الرياضية. وإنما هي عملية تعيين (مثلها مثل عملية الجمع +) تقوم بإسناد قيمة لمسمى (وهو x هنا)؛ كأنما تُخزِّن القيمة في صندوقٍ معنوَن بالاسم x. وقل مثل ذلك في y وكذلك في z.\nوتستطيع أن تقول إن ما قبل علامة التعيين (=) أصبح اسمًا مُعرَّفًا يُشير إلى شيء. وما بعد العلامة هو الشيء: وله صفتان أساسيتان: البيانات (5) والإجراءات التي تُعرَف ضِمنيًّا بحسب النوع (int) وتعني صِنف الأعداد الصحيحة (Integers)، الذي يندرج تحت صنف الأرقام (numbers).\nلو أردنا معرفة نوع الشيء، فلدينا الكلمة type(x) نستخدمها هكذا:\nprint(type(10))\n\n&lt;class 'int'&gt;\nprint(type(100 + 200))\n\n&lt;class 'int'&gt;",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "01_intro.html#الشيء-المفرد",
    "href": "01_intro.html#الشيء-المفرد",
    "title": "2  مقدمة",
    "section": "",
    "text": "في السطر الأول: قمنا بتعيين القيمة 5 لمعرف x\nفي السطر الثاني: مثل الأول لمعرف y\nفي السطر الثالث: تعيين ناتج عملية الجمع (+) بين عددين\nفي السطر الرابع: print هي إجراء تقدَّم تعريفها ضمن المكتبة الأساسية في حزمة البايثون، تعمل هنا على الكائن الرقمي z ليكون حاصلها: كتابة قيمة الرقم على الشاشة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "01_intro.html#الشيء-المجموع",
    "href": "01_intro.html#الشيء-المجموع",
    "title": "2  مقدمة",
    "section": "2.2 الشيء المجموع",
    "text": "2.2 الشيء المجموع\nتعلمنا كيف نخزن قيمة عدد في x وقيمة عدد آخر في y. لكن لو أردنا التعامل مع مجموعة أعداد معًا لنحسب جمعها أو متوسطها أو غير ذلك من الإجراءات سواءً البسيطة منها والمعقدة، فإن لغة بايثون تستطيع التعبير عن ذلك. بل إن الشيء المعبر عن ذلك هو المتسلسلة: مجموعة مرتَّبة من الأشياء.\nففي المثال التالي تعيين شيئين من نوع متسلسلة متغيرة (وكونها متغيرة يعني أنها تقبل الزيادة والنقص)، تحوي أشياء؛ وهذه الأشياء هي أعدادًا صحيحة في هذه الحالة. ثم نرى كيفية إجراء عملية محددة بعلامة + بين المتسلسلتين.\n\none = [10, 20, 30]\ntwo = [40, 50, 60]\ncombined = one + two\nprint(combined)\n\n[10, 20, 30, 40, 50, 60]\n\n\nلاحظ أن النتيجة هي إضافة المتسلسلة الثانية للمتسلسلة الأولى لتصبح متسلسلة جديدة فيها العناصر الأولى تتبعها الثانية عناصر الثانية. وقد تتساءل لماذا لم تكن النتيجة جمع الأعداد المتقابلة؟ والإجابة هي: أنها عُرِّفَت هكذا هذه العملية للأشياء التي من نوع متسلسلة.\nكما يوجد لنوع المتسلسلة (سواءً المتغيرة والثابتة) إجراءات خاصة مثل len التي ناتجها عدد عناصرها؛ وتستعمل على النحو التالي:\n\nx = len(one)\nprint(x)\n\n3\n\n\nنقرأ القطعة السابقة فنقول: إن إجراء len تأخذ قيمة المعرف one (أو نقول: إننا نُمرِّر قيمة المعرف)؛ لتعطينا عدد العناصر (الذي هو عدد صحيح)؛ فنُعيِّن تلك القيمة بعلامة (=) للمعرف x. ثم نطبع ذلك باستخدام إجراء print.\nولسنا بحاجة للمعرف x إذ يُمكن كتابة الإجراء على ناتج الإجراء السابق مباشرة بحيث تكون التي في الأقواس أوَّل تنفيذًا ثم التي الأقواس الأشمل، وهكذا على النحو التالي:\n\nprint(len(one))\n\n3\n\n\nونأتي الآن لنوع آخر يكثر استخدامه وهو متسلسلة الأحرف وهي في الحقيقة صنف مركَّب من المتسلسلة (سنتعلم كيفية التركيب في باب: الأصناف). فهي تستمد منها خصائصها (مثل أنها تقبل الدمج بعلامة +) وتضيف فوق ذلك إجراءات إضافية خاصة للتعامل مع الأحرف.\nولكثرة استخدامها جُعل لها في اللغة علامة التنصيص (\") لتحدد عناصرها بدلا من الأقواس المربعة ([ ]) التي تحدد عناصر السلسلة المتغيرة.\nانظر هذا المثال الذي نعرف فيه message ليشير إلى متسلسلة أحرف. ثم نستخدم نفس الإجراء الذي استخدمناه مع المتسلسلة التي كانت تحتوي على أرقام لمعرفة عدد العناصر (len) ونخزن ذلك في مُعرَّف length ثم نقوم بطباعته عن طريق عملية print.\n\nmessage = \"Adam\"\nlength = len(message)\nprint(length)\n\n4",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "01_intro.html#عملية-مسندة-لشيء",
    "href": "01_intro.html#عملية-مسندة-لشيء",
    "title": "2  مقدمة",
    "section": "2.3 عملية مُسندة لشيء",
    "text": "2.3 عملية مُسندة لشيء\nوللإجراءات شكلٌ آخر تستخدمه لغات البرمجة الشيئية، وهو أن توضَع علامة نقطة . بعد الشيء ثم كتابة اسم الإجراء على النحو التالي:\n\nmessage = \"hello adam\"\nup = message.upper()\nprint(up)\n\nHELLO ADAM\n\n\nوقد تتساءل عن الأقواس الفارغة فتقول: ما هي مدخلات هذا الإجراء فنقول: في البرمجة الشيئية: هذه العبارة تجعل العامل الأوَّل (المُدخل الأوَّل) لها هو ذات الشيء المذكور. ثم ما تضعه في الأقواس يكون مُدخلاً ثانيًا وثالثًا وهكذا إن وُجدوا.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "01_intro.html#علامة-بين-الأشياء",
    "href": "01_intro.html#علامة-بين-الأشياء",
    "title": "2  مقدمة",
    "section": "2.4 علامة + بين الأشياء",
    "text": "2.4 علامة + بين الأشياء\nوننبه هنا على أمرٍ يختلط على المبتدئ في البرمجة، وهو التفريق بين صنف الرقم وصنف متسلسلة الأحرف، كما في المثال الآتي. فنقول: علامة + بين عددين تشير لعملية الجمع بينهما:\n\nx = 20 + 20\nprint(x)\n\n40\n\n\nبينما تعريف علامة + بين متسلسلتين من الحروف (وذلك لوجود علامة التنصيص \")، تكون عملية دمج:\n\ny = '20' + \"20\"\nprint(y)\n\n2020\n\n\nملاحظة: لغة بايثون لا تفرق بين علامة التنصيص المفرد ('A') والتنصيص المزدوج (\"A\") كما تفرق بينهما لغات أخرى مثل سي (C) أو جافا (Java).\nأما إن حاولت وضع علامة (+) بين شيئين لم تُعرَّف العملية هذه بينهما فإن البرنامج سيقف برسالة خطأ، تفيد بأن العلامة غير مُسندة لعملية مُعرَّفة بين هذين الشيئين (هو لم يجد أنها جمع ولا دمج). لاحظ هنا أن العملية بين عدد ومتسلسلة نصية:\n\nprint(x + y) \n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 print(x + y) \n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nفيمثل الشيء x قيمة عدد صحيح يُمكن جمعه وطرحه وقسمته ونحو ذلك، أما y فيشير لمتسلسلة حروف؛ لا تتيح الحساب الرقمي ، وإنما يمكن دمجها وفصلها وتكرارها ونحو ذلك؛ لأنها في الحقيقة حرفان وليست عددًا.\nوإن أردت تحويل نوع لنوع، فذلك عادة يكون باستعمال عملية لها نفس اسم ذلك النوع. تأمثل المثال التالي:\n\nx = 40\ny = \"2020\"\nz =  int(y)\nprint(type(x))\nprint(type(y))\nprint(type(z))\nprint(x + z)\n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'int'&gt;\n2060",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "01_intro.html#نمو-اللغة-بتراكم-البنى-المنطقية",
    "href": "01_intro.html#نمو-اللغة-بتراكم-البنى-المنطقية",
    "title": "2  مقدمة",
    "section": "2.5 نمو اللغة بتراكم البنى المنطقية",
    "text": "2.5 نمو اللغة بتراكم البنى المنطقية\nتتضمن بايثون مركبات لغوية تسمح بتعريف الأشياء (مثل =) وتسمح بالعبارات الشرطية (if و else) وحلقات التكرار (for) ونحو ذلك كثير مما سنراه في الدروس القادمة إن شاء الله. وفوق ذلك نجد في حزمة بايثون المكتبة الأساسية (المكتبة: حزمة إجراءات وأشياء) تعتبر هي والمركبات اللغوية حجر أساس في بناء البرمجيات فوقها. وهي التي تحدد الحدود التي يمكن أن تصل إليها أيها المبرمج بهذه اللغة.\nونستعرض هنا بعض الإجراءات الأساسية (مثل: sum, len, max, min)، وذلك باستعمال المفردات المُعرَّفة علنًا. (لاحظ أن ما يُكتب بعد علامة # فإنه يعتبر كلامًا عاديًّا ولا يُعدُّ من البرمجة)\nxs = [1, 2, 3, 4, 5]\n\n# length\nl = len(xs)\n\n# sum\nresult = sum(xs)\n\n# max and min\na = max(xs)\nb = min(xs)\n\nif a &gt; 100:\n    print('do this')\n\nif b &lt; 0:\n    print('do that')\nوسيأتي بالتفصيل الكلام عن هذا.\nثم نستعرض هنا الحزم الأساسية كحزمة math وهي ضمن المكتبة الأساسية:\n\nimport math\n\nsq = math.sqrt(16)\nprint(sq)\n\n4.0\n\n\nفهذه عملية الجذر التربيعي أتينا بها بطلب الحزمة (math) ثم أشرنا إلى المُعرَّف sqrt المندرج تحتها عن طريق علامة النقطة . مع القوسين ليعمل هذا الإجراء على مدخلات معيَّنة (16) فتنتج لنا شيئًا نعيِّنُه عن طريق عملية (=) للمُعرَّف sq.\nبهذا تبيَّن أن لغة بايثون قابلة للتطوُّر بشكل قوي جدًّا، بحيث يبني كل شخص على:\n\nالعبارات البرمجية (عبارة تعيين ، عبارة شرط ، عبارة تكرار، …إلخ) التي تستعمل كلمات أصلية في اللغة\nالمكتبة الأساسية التي تتضمن إجراءات أساسية وحِزَمًا تتضمن أشياء وإجراءات إضافية\n\nفيستطيع كل شخص تركيب حزمة جديدة مكونة من أشياء مركبة وإجراءات مركبة يستفيد هو في ذلك من حزم أشخاص آخرين ، ثم يوفرها هو لأشخاص آخرين. وهكذا ينمو النتاج البرمجي ، حزمةً تِلو الأخرى بحسب اهتمامات كل مجتمع برمجي.\nفالمجتمعات البرمجية التي تدور حوْل حزم تطوِّرها بالتشارك العلني في بايثون متعددة جدًا باهتمامات مختلفة، منها على سبيل المثال لا على سبيل الحصر:\n\nتطوير مواقع شبكة الانترنت: Django و FastAPI\nبناء نماذج البيانات: statsmodels, scikit-learn, TensorFlow, PyTorch\nتصوير البيانات: seaborn, matplotlib\nالتحليل الرياضي والهندسة: sympy, PySR, SciPy\nأتمتة إجراءات نظم المعلومات: ansible, salt\n\nوتصل عدد المشاريع (تقريبًا عدد الحزم) في قاعدة بيانات (PyPI) اليوم ما يزيد على 580,000 مشروع. وتجد الكود مشاعًا على أكبر منصة لإدارة الأكواد البرمجية: GitHub.\nبعد أن أخذنا نظرة عامة على لغة بايثون، سنأتي على المفاهيم الأساسية على وجه التفصيل في الدروس القادمة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>مقدمة</span>"
    ]
  },
  {
    "objectID": "02_numbers.html",
    "href": "02_numbers.html",
    "title": "3  الأعداد",
    "section": "",
    "text": "3.1 وظيفة الأعداد في لغة البرمجة\nالأعداد الصحيحة (Integers) للفهرسة والعد والترتيب: ..., -2, -1, 0, 1, 2, ...\nالأعداد العشرية (Floats) لتمثيل الكميات مثل المال، المسافة، والوقت: 3.14, 2.718, 0.0, 15.0\nالأعداد المركبة (Complex) في الرياضيات والهندسة: (1 + 2j), (1.0 - 2.0j)\nالقيم المنطقية (Booleans) لتمثيل قيم الحقيقة: True, False\nx = 5\ny = 3.0\nz = -10\nb = True\nc = 1 + 2j\nprint(type(x))\nprint(type(y))\nprint(type(z))\nprint(type(b))\nprint(type(c))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'int'&gt;\n&lt;class 'bool'&gt;\n&lt;class 'complex'&gt;",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "02_numbers.html#وظيفة-الأعداد-في-لغة-البرمجة",
    "href": "02_numbers.html#وظيفة-الأعداد-في-لغة-البرمجة",
    "title": "3  الأعداد",
    "section": "",
    "text": "العمليات الحسابية (Arithmetic operations)\n\nprint(x + y) # الجمع (Addition)\nprint(x - y) # الطرح (Subtraction)\nprint(x * y) # الضرب (Multiplication)\nprint(x / y) # القسمة (Division)\nprint(x % y) # باقي القسمة (Remainder)\nprint(x ** y) # الأس (Exponentiation)\n\n8.0\n2.0\n15.0\n1.6666666666666667\n2.0\n125.0\n\n\n\n\nماذا تعني صفة العددية؟\nالاشتراك في صفة العددية يعني أنها تقبل العمليات الحسابية ، مع ملاحظة أن النوع الأقل دقة يتحول إلى النوع الأعلى دقة:\n\nفمثلاً: int + float = float\nوكذلك: int / int = float\nوأيضًا: bool * int = int\nوهكذا: int * complex = complex\n\n\nprint(x + z)\nprint(x + y)\nprint(y * z)\nprint(b * x)\nprint(c + x)\n\n-5\n8.0\n-30.0\n5\n(6+2j)\n\n\nلاحظ أن قسمة الصحيح تقوم بتقريب النتيجة إلى الأقرب:\n\nprint(7 / 2)\nprint(7 // 2)\n\n3.5\n3\n\n\n\nتمرين\nتحقق من نوع كل من التعبيرين السابقين باستخدام الدالة type(). هل يمكنك استخراج قاعدة من هذه الأمثلة؟\n\n7 / 2\n7 // 2\n7.0 / 2\n7 / 2.0\n\n# try it\nجرب الآتي حتى تستكشف ماذا يحصل لو:\n\nint + bool\nint * str\nstr * int\nstr + str\nint + str (لاحظ أن هذه العملية ستفشل)\n\n\ni = 5\nb = True\ns1 = '5'\ns2 = '11'\n\nprint(i + b)  # int + bool\n# ... أكمل البقية ...\n\n6\n\n\n\n\n\nترتيب العمليات (Operator precedence)\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\n\nتمرين\nأضف أقواس لتغيير النتيجة لتطابق التوكيد:\n\nassert 3 + 2 * 5 == 25\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 assert 3 + 2 * 5 == 25\n\nAssertionError: \n\n\n\nالحل:\n\nassert (3 + 2) * 5 == 25\n\nمثال آخر:\n\nassert 8 - 4 / 2 == 2\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 assert 8 - 4 / 2 == 2\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n# try it\nمثال أخير:\n\nassert 2 ** 3 * 4 == 4096\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 assert 2 ** 3 * 4 == 4096\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n# try it",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "02_numbers.html#الدوال-المدمجة-ودوال-المكتبة-الأساسية-built-in-and-standard-library-functions",
    "href": "02_numbers.html#الدوال-المدمجة-ودوال-المكتبة-الأساسية-built-in-and-standard-library-functions",
    "title": "3  الأعداد",
    "section": "3.2 الدوال المدمجة ودوال المكتبة الأساسية (Built-in and Standard Library Functions)",
    "text": "3.2 الدوال المدمجة ودوال المكتبة الأساسية (Built-in and Standard Library Functions)\nتتضمن لغات البرمجة دوال مساعدة مكتوبة من قِبل فريق اللغة ومضمَّنة مع حزمة تثبيت اللغة؛ أي أنها لا تستدعي من المبرمج تثبيت حِزَم إضافية. وهي على قسمين:\n\nدوال مدمجة (Built-in functions)\nدوال المكتبة الأساسية ، وتسمى (Standard Library) وتختصر stdlib\n\n\nدوال مدمجة\nوهي الدوال المتاحة المعرَّفة من غير أن نعرِّفها نحن. مثلاً:\n\nprint(abs(-99)) # القيمة المطلقة\nprint(pow(2, 4)) # القوة\nprint(max(10, 20)) # القيمة العظمى\nprint(min(10, 20)) # القيمة الصغرى\n\n99\n16\n20\n10\n\n\nوهنا قائمة بجميع الدوال المدمجة.\n\n\nدوال المكتبة الأساسية\nوهي دوالّ متوفِّرة لكن يجب استيرادها من المكتبة الأساسية بجملة import.\nفمثلاً للوصول إلى دوال رياضية إضافية: import math، ثم نستخدم البادئة math. للوصول إلى الدوال.\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تُحسب باستخدام الصيغة التالية:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\n\nimport math\n\nx = 5.4\nprint(math.floor(x)) # تقريب لأقرب عدد صحيح أصغر\nprint(math.ceil(x)) # تقريب لأقرب عدد صحيح أكبر\nprint(math.trunc(x)) # حذف ما بعد الفاصلة\nprint(round(x, 2)) # تقريب إلى رقمين بعد الفاصلة\n\n5\n6\n5\n5.4\n\n\nملاحظة: الدالة الأخيرة round ليست مستوردة من math وإنما هي مُدمجة.\nوهنا مرجع المكتبة الأساسية لبايثون.\n\nتمرين\nاكتب برنامجًا ليعرف رقمين ثم اطبع مجموعهما، الفرق بينهما، حاصل ضربهما، خارج القسمة، وباقي القسمة. استخدم أسماء متغيرات وتعليقات مناسبة.\n# try it\n\n\nتمرين\nاحسب مساحة المكعب باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\n\nقم بتعيين العرض (width)، الطول (length)، والارتفاع (height) إلى متغيرات.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\n# try it\n\n\nتمرين\nاكتب برنامجًا يطلب من المستخدم إدخال عدد الساعات (hours) ومعدل الأجر لكل ساعة (rate per hour) لحساب الأجر الإجمالي (gross pay).\n# your code here\n\n\nتمرين\nاكتب برنامجًا يحسب مساحة الدائرة باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nقم بتعيين نصف القطر إلى متغير.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\nتلميح: يمكنك استخدام الثابت math.pi للحصول على قيمة \\(\\pi\\).\n# your code here\n\n\nتمرين\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n# your code here",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "02_numbers.html#المراجع",
    "href": "02_numbers.html#المراجع",
    "title": "3  الأعداد",
    "section": "3.3 المراجع",
    "text": "3.3 المراجع\n\nhttps://docs.python.org/3/reference/simple_stmts.html",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html",
    "href": "03_control-flow.html",
    "title": "4  التحكم في سير الأوامر",
    "section": "",
    "text": "4.1 التعبير المنطقي\nأما الشروط فتستند إلى المنطق الرقمي الثنائي الذي نجد له في بايثون كلمتين من أصل اللغة هما: True (تساوي الرقم 1) وتعبِّر عن تحقق الأمر، وكلمة: False (تساوي الرقم 0) وتعبِّر عن عدم التحقق. وكلاهُما شيء من الصنف: ثنائي.\nالتعبيرات المنطقية هي تعبيرات تؤول إما إلى True أو False. ولذا فإن منها جُمل المقارنة:\nلنستكشف سويًّا التعبيرات المنطقية وما يمكن بينها:\nb1 = 5 &gt; 9\nprint(b1)\n\nFalse\nb2 = len('12345') &gt; len('123456789')\nprint(b2)\n\nFalse\nيمكن دمج التعبيرات المنطقية باستخدام العوامل and، or، و not:\nb3 = b1 and b2\nprint(b3)\n\nFalse\nb4 = b1 or b2 or b3\nprint(b4)\n\nFalse\nb5 = not b1\nprint(b5)\n\nTrue",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html#التعبير-المنطقي",
    "href": "03_control-flow.html#التعبير-المنطقي",
    "title": "4  التحكم في سير الأوامر",
    "section": "",
    "text": "العلامة\nالوصف\n\n\n\n\na == b\nيساوي\n\n\na != b\nلا يساوي\n\n\na &gt; b\nأكبر من\n\n\na &lt; b\nأصغر من\n\n\na &gt;= b\nأكبر من أو يساوي\n\n\na &lt;= b\nأصغر من أو يساوي\n\n\n\n\n\n\n\n\n\n\nA\nB\nAND\nOR\nXOR\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n\n\nAND (و): تُعطي النتيجة 1 فقط إذا كان كلا المدخلين 1.\nOR (أو): تُعطي النتيجة 1 إذا كان أحد المدخلين على الأقل 1.\nXOR (أو الحصرية): تُعطي النتيجة 1 إذا كان المدخلان مختلفين.\nNOT (ليس): يعكس المدخل (1 يصبح 0، و0 يصبح 1).",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html#جملة-التوكيد",
    "href": "03_control-flow.html#جملة-التوكيد",
    "title": "4  التحكم في سير الأوامر",
    "section": "4.2 جملة التوكيد",
    "text": "4.2 جملة التوكيد\nتُدرَج جُملَ التوكيد في ثنايا الكود للتحقق من صحَّة التسلسل المنطقي. فالتوكيد يُحدثُ خطأ إذا كانت القيمة التي نؤكدها خاطئة. مثلاً:\n\nassert False\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 assert False\n\nAssertionError: \n\n\n\nكما تُسحتب الكتابة بلغة البشر لما يجب أن يكون ، بعد الفاصلة، هكذا ، لتظهر في رسالة الخطأ واضحة:\n\nx = 10\ny = 20\nassert x &gt; y, 'x should be greater than y'\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[8], line 3\n      1 x = 10\n      2 y = 20\n----&gt; 3 assert x &gt; y, 'x should be greater than y'\n\nAssertionError: x should be greater than y\n\n\n\nأما إذا كانت العبارة صحيحة فلا خطأ:\n\nassert True\n\n\nx = 2 ** 4\ny = pow(2, 4)\nassert x == x, 'x should be equal to x'\n\nهذه الجُمَل البسيطة تساعد في اختبار الكود وكشف الأخطاء في وقتٍ مبكِّر ، كما أنها تساعد في التعلُّم (الآن عرفت أن ** هي عملية الأس pow) كما سنستخدمها الآن لأنها تحقق ما نحن بصدد التحقق منه. وهي تغنينا عن كثيرٍ من جُمَل print().",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "03_control-flow.html#الجملة-الشرطية",
    "href": "03_control-flow.html#الجملة-الشرطية",
    "title": "4  التحكم في سير الأوامر",
    "section": "4.3 الجملة الشرطية",
    "text": "4.3 الجملة الشرطية\nتُستخدم العبارات الشرطية لتنفيذ أجزاء مختلفة من الكود بناءً على قيمة تعبير منطقي. مثال:\n\nif b5:\n    print('Inside')\nprint('Outside')\n\nInside\nOutside\n\n\n\nالمحاذاة العمودية (Indentation)\nلاحظ أن المحاذاة العمودية (المسافات البيضاء أسفل كلمة if) في الكود أعلاه ليست لمجرد تسهيل قراءة الكود، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال الكود.\nلاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في الكود:\n\nif b5:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[12], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل الكود بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\nif b5:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\nيؤدي الكود السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في كتابة كود بايثون!\n\n\nتركيب الشروط\nيمكنك دمج شروط متعددة باستخدام العوامل and، or، و not، لأنها تنتج قيمة منطقية (boolean value). على سبيل المثال:\n\nage = 20\nheight = 175\n\nif age &gt; 18 and height &gt; 170:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nيمكننا استخدام الأقواس لتجميع الشروط معًا. كما أنها تزيل أي غموض في ترتيب العمليات:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\nيُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون True أو False ولا بأس بتجزئته حينما يسهل بذلك الفهم:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\nb = is_minor or (is_cold and not is_wearing_coat)\n\nif b:\n  print(\"I suggest you don't go outside\")\n\n\n\nالجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية على النحو التالي:\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelse:\n    &lt;code&gt;\nقد يوجد elif واحدة أو أكثر، وقد توجد else واحدة فقط. أما الكلمة elif فهي اختصار لـ else if. تسلسل if … elif … elif … هو بديل لجمل switch أو case الموجودة في لغات أخرى.\nجرب الكود التالي بقيم مختلفة لـ x وحاول تتبع تدفق التحكم:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Negative changed to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nNegative changed to zero\nAlways: 0\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.\n\n\nتضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\nلاحظ أيضًا أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\nمثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>التحكم في سير الأوامر</span>"
    ]
  },
  {
    "objectID": "04_functions.html",
    "href": "04_functions.html",
    "title": "5  الإجراءات",
    "section": "",
    "text": "5.1 العوامل بين الترتيب والتسمية\nنفهم من تعريف الإجراء pow(base, exp, mod=None) أن لديها ثلاثة عوامل: base، exp، و mod بهذا الترتيب. لاحظ أن العامل mod اختياري (لوجود التعيين الافتراضي mode=None). هذا يعني أن الإجراء يمكن استعمالها بطرق مختلفة:\nprint(pow(2, 4))\nprint(pow(2, exp=4))\nprint(pow(base=2, exp=4))\nprint(pow(exp=4, base=2))\n\n16\n16\n16\n16\nفإن أردنا تعريف عوامل تستعمل بهذه الطريقة، فإننا نضعها في التعريف على النحو التالي:\ndef calculate_bmi(weight, height, unit='metric'):\n    \"\"\" Calculate the Body Mass Index (BMI)\n        \n        weight and height must be of the same unit.\n\n        unit is either 'metric' or 'imperial'.\n    \"\"\"\n    if unit == 'imperial':\n        weight *= 0.453592\n        height *= 0.0254\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\nالآن يمكننا استعمال الإجراء بطرق مختلفة. لاحظ أن استخدام assert هنا للتحقق من أن الإجراء تنتج نفس القيمة بغض النظر عن كيفية تمرير العوامل.\nw = 70   # kg\nh = 1.75 # meters\n\nprint(calculate_bmi(w, h))\n\nassert (\n    calculate_bmi(w, h) ==\n    calculate_bmi(w, height=h) ==\n    calculate_bmi(weight=w, height=h) ==\n    calculate_bmi(height=h, weight=w)\n)\n\n22.86\nونفس الأمر بالنسبة للعامل الذي عينت له قيمة افتراضية units='imperial':\nw = 154 # pounds\nh = 70  # inches\n\nprint(calculate_bmi(w, h, 'imperial'))\n\nassert (\n    calculate_bmi(w, h, 'imperial') ==\n    calculate_bmi(w, h, unit='imperial')\n)\n\n22.1",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "04_functions.html#التعليق-في-مقدمة-الإجراء",
    "href": "04_functions.html#التعليق-في-مقدمة-الإجراء",
    "title": "5  الإجراءات",
    "section": "5.2 التعليق في مقدمة الإجراء",
    "text": "5.2 التعليق في مقدمة الإجراء\nتحتوي بايثون على إجراء أساسية تسمى help() تظهر معلومات عن إجراء ما:\n\nhelp(pow)\n\nHelp on built-in function pow in module builtins:\n\npow(base, exp, mod=None)\n    Equivalent to base**exp with 2 arguments or base**exp % mod with 3 arguments\n\n    Some types, such as ints, are able to use a more efficient algorithm when\n    invoked using the three argument form.\n\n\n\nكذلك يمكن استعمالها في أي إجراء مُعرَّفة، فهي تأخذ التعليق الذي يبدأ بثلاثة علامات تنصيص (\"\"\") بداية الإجراء (انظر كيف استعملناها في الإجراء calculate_bmi):\n\nhelp(calculate_bmi)\n\nHelp on function calculate_bmi in module __main__:\n\ncalculate_bmi(weight, height, unit='metric')\n    Calculate the Body Mass Index (BMI)\n\n    weight and height must be of the same unit.\n\n    unit is either 'metric' or 'imperial'.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>الإجراءات</span>"
    ]
  },
  {
    "objectID": "05_loops.html",
    "href": "05_loops.html",
    "title": "6  الحلقات",
    "section": "",
    "text": "6.1 التعيين النسبي\nملاحظة جانبية: انظر التعيين النسبي (Augmented assignment statements) فإنها عند التدقيق تختلف.\nجرب الكود أدناه لترى النتيجة:\ni = 0\nprint(i)\n\n0\ni = i + 1\nprint(i)\n\n1\ni += 1\nprint(i)\n\n2\nلاحظ أن i++ تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:\ni++\nprint(i)\n\n\n  Cell In[19], line 1\n    i++\n       ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#التعيين-النسبي",
    "href": "05_loops.html#التعيين-النسبي",
    "title": "6  الحلقات",
    "section": "",
    "text": "i = i + 1 تعادل i += 1\ni = i - 1 تعادل i -= 1\ni = i * 2 تعادل i *= 2\ni = i / 2 تعادل i /= 2",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#الحلقة-المطلقة",
    "href": "05_loops.html#الحلقة-المطلقة",
    "title": "6  الحلقات",
    "section": "6.2 الحلقة المُطْلقة",
    "text": "6.2 الحلقة المُطْلقة\nالحلقة المُطْلقة (لها كلمة while) هي مثل if لكن مكررة، فكلما انتهت العبارات المضمَّنة داخلها، تعود لسطر الشرط وتنفذه مرة أخرى؛ إلى حين انتفاء الشرط (False).\nأما كونُها مطقلة يعني أن الكود المضمَّن داخل الحلقة هو الذي يحدد متى تتوقف. بينما المقيَّدة يكون التكرار فيها مُحددًّا بعدد معيَّن في نفس الجُملة، وهو على النحو التالي: (for x in items) سيأتي الحديث عنه إن شاء الله في درس قادم.\nصيغة حلقة while كما يلي:\nwhile &lt;boolean expression&gt;:\n    &lt;code&gt;\nيتم تكرار اللبنة الواقعة في نطاق جملة الشرط ما بقي الشرط (True). وإذا انتفى الشرط (False) في البداية، فلن يتم الدخول في اللبنة أصلاً.\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\nونلاحظ هنا أنك إذا نسيت زيادة قيمة i، فإن الحلقة لن تنتهي أبدًا؛ وهذا ما يسمى حلقة لانهائية (infinite loop).\nلنقم بتتبع الخطوات عندما تكون i = 0:\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\nنستخدم دالة input() حيث تقطَع سير البرنامج (Interrupt) فيتوقَّف لتمنح التحكم للمستخدم لتقديم بعض المدخلات، وتنتظر حتى يتم الضغط على مفتاح Enter للإشارة إلى أن الإدخال اكتمل ، ليعود التحكم للبرنامج كي يُكمِل سيره.\nيمكن استعمال الحلقة المطلقة مثلاً لتكرار السؤال عن رقم حتى يتم تخمينه بشكل صحيح:\nnum = \"9\"\nguess = input(\"Guess the number (0-9): \")\nwhile guess != num:\n    guess = input(\"Try again: \")\nprint(\"You guessed it!\")\nوهكذا معظم البرامج كالخوادم (Servers) يكون في داخلها حلقة مطلقة وذلك لاستقبال طلبات المتسفيدين من البرنامج.\n\nتكرار القطع البرمجية\n\nتستخدم كلمة break لإيقاف التكرار تمامًا.\nتستخدم كلمة continue للانتقال إلى التكرار التالي متخطيةً بقية الخطوات في التكرار الحالي.\n\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\nوهذا مثال لاستخدام continue:\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\nأما عبارة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط. وهذا مثال:\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#المتتالية",
    "href": "05_loops.html#المتتالية",
    "title": "6  الحلقات",
    "section": "6.3 المتتالية",
    "text": "6.3 المتتالية\nنستخدم الجملة: for item in iterable لقراءة متتالية (Iterable). والتي تتضمن المجموعات (Collections) وهي معظم الكائنات الحاوية للبيانات. (وسيأتي الحديث عنها في درس قادم).\n\nfor x in (1, 20, 'ABB', True, False, 1.234):\n    print(x)\n\n1\n20\nABB\nTrue\nFalse\n1.234\n\n\nوهذا البرنامج يصفي قائمة أرقام إلى قائمتين: إحداها زوجية والأخرى فدرية. ملاحظة: علامة % تعني باقي القسمة. فإذا كان الباقي يساوي صفر، فهذا يعني أن العدد زوجي:\n\nnumbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nevens = []\nodds = []\n\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\n    else:\n        odds.append(x)\n\nprint('list of evens:', evens)\nprint('list of odds:', odds)\n\nlist of evens: [12, 14, 16, 18, 20]\nlist of odds: [11, 13, 15, 17, 19]",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "05_loops.html#النطاق-range",
    "href": "05_loops.html#النطاق-range",
    "title": "6  الحلقات",
    "section": "6.4 النطاق (range)",
    "text": "6.4 النطاق (range)\nنوع range يمثل تسلسلًا غير قابل للتغيير من الأرقام. ويستخدم عادةً للتكرار عددًا محددًا من المرات في حلقات for.\nوفقًا لوثائق بايثون فإن النطاق له شكلان:\n\nclass range(stop)\nclass range(start, stop[, step])\n\nنشرح العوامل:\n\nstart: موضع الابتداء (وهو مشمول في النطاق). (القيمة الافتراضية 0)\nstop: موضع الانتهاء (وهو غير مشمول في النطاق).\nstep: الخطوة، أي: مقدار الزيادة أو النقص بعد كل كرة (القيمة الافتراضية 1)\n\nفإذا قمت بتعيين عامل واحد فسيكون هو stop:\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nوإذا قمت بتعيين عاملين فسيكون الأول start والثاني stop:\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، مع قلب البداية والنهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\nالتكرار على قوائم باستخدام النطاق:\n\nnumbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nfor i in range(1, len(numbers), 2):\n    print(numbers[i])\n\n20\n40\n60\n80\n100",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الحلقات</span>"
    ]
  },
  {
    "objectID": "06_sequences.html",
    "href": "06_sequences.html",
    "title": "7  التسلسل",
    "section": "",
    "text": "7.1 استعمالات التسلسل\nلا تحزن إذا لم يكن الكود واضحًا بعد. فإن الغرض هنا استعراض حالات من الاستخدام. بعد ذلك سنبدأ بالفهم خطوة خطوة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#استعمالات-التسلسل",
    "href": "06_sequences.html#استعمالات-التسلسل",
    "title": "7  التسلسل",
    "section": "",
    "text": "سلسلة أعداد\n\nxs = [10, 20, 30, 40, 50]\n\nإجراء لجمع الأعداد:\n\ndef summation(numbers):\n    total = 0\n    for n in numbers:\n        total += n\n    return total\n\nsummation(xs)\n\n150\n\n\nحساب المتوسط عن طريق إجراء الجمع ثم القسمة على عدد العناصر:\n\ndef average(numbers):\n    return summation(numbers) / len(numbers)\n\naverage(xs)\n\n30.0\n\n\nنرشح الأعداد الموجبة فقط:\n\ndef filter_positive(numbers):\n    result = []\n    for n in numbers:\n        if n &gt;= 0:\n            result.append(n)\n    return result\n\nنرشح الأعداد الموجبة ثم نجمعها هي فقط:\n\npositives = filter_positive(xs)\nsummation(positives)\n\n150",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#تفكيك-المركبات",
    "href": "06_sequences.html#تفكيك-المركبات",
    "title": "7  التسلسل",
    "section": "7.2 تفكيك المركبات",
    "text": "7.2 تفكيك المركبات\nهذا مثال لشيء مركب (وهو النص المكتوب) نمثل هنا لشيء يكثر استعماله وهو تحويل أي شيء مركب إلى مجموعة من الأجزاء ليتم التعامل معها بشكل منفصل.\nمثلاً، نريد عد الكلمات في نص. لدينا الإجراء split() الذي يقوم بتقسيم النص إلى كلمات.\n\ns = \"this is five woooords long\"\nwords = s.split()\nprint(words)\n\n['this', 'is', 'five', 'woooords', 'long']\n\n\nالبحث عن أطول كلمة:\n\ndef longest_word(words):\n    longest = \"\"\n    for word in words:\n        if len(word) &gt; len(longest):\n            longest = word\n    return longest\n\nlongest_word(words)\n\n'woooords'\n\n\nويمكن تحويل الكلمات إلى حروف كبيرة:\n\ndef to_upper(words):\n    result = []\n    for word in words:\n        result.append(word.upper())\n    return result\n    \nto_upper(words)\n\n['THIS', 'IS', 'FIVE', 'WOOOORDS', 'LONG']\n\n\nيجدُر بالذكر أن النصوص نفسها هي تسلسلات من الحروف، لذا يمكن استعمال العمليات نفسها على النصوص. لكن لن استعجل الحديث عن ذلك، فلنتعمق أكثر في القوائم والصفوف أولاً.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#القائمة-list",
    "href": "06_sequences.html#القائمة-list",
    "title": "7  التسلسل",
    "section": "7.3 القائمة (List)",
    "text": "7.3 القائمة (List)\nالقائمة (list) سلسلة مرتبة من الأشياء، يمكن التعديل على هذه السلسلة بالحذف والإضافة في الأول أو الأخير أو الوسط. كما يمكن أن تحتوي على عناصر من أنواع مختلفة، بما في ذلك قائمة داخل قائمة.\n\nl1 = []        # empty list\nl2 = [1]       # list with one item\nl3 = [1, 2, 3] # list with three items\nl4 = ['abb', 1, 2.0, True] # list with different types\n\nيمكن أيضًا تركيب القوائم عن طريق:\n\nالدمج: باستخدام معامل +\nالتكرار: باستخدام معامل *\n\n\nl5 = [1, 2, 3] + [4, 5]\nl6 = l5 * 2\nprint(l5)\nprint(l6)\n\n[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n\n\n\nجرب\n\nlen(l3) للحصول على طول القائمة l3\n'abb' in l4 للتحقق مما إذا كانت 'abb' عنصرًا في القائمة l4\n\nبعد ذلك، جرب 'abb' not in l4\n\nجرب min(l3), max(l3), sum(l3) وانظر ماذا يحدث\n\n\n\nالإشارة (Indexing)\nللوصول إلى عنصر من القائمة، استخدم عملية الإشارة []. يجب أن يكون المؤئر عددًا صحيحًا (int) في النطاق 0 &lt;= index &lt; len(s) - 1.\n\nl1 = [10, 20, 30, 40, 50]\nprint(l1[0])\n\n10\n\n\n\nجرب\nكذلك، جرب l1[1], l1[2], و l1[3].\n\nl2 = [\"Apple\", \"Banana\", \"Orange\", \"Lemon\"]\n\nفي القائمة l2، الفهرس على النحو التالي:\n0       1        2        3       4\n+-------+--------+--------+-------+\n| Apple | Banana | Orange | Lemon |\n+-------+--------+--------+-------+\n-4      -3       -2       -1\n\n\n\nجرب\n\nl[1]\nl[2]\nl[3]\n\nوجرب أيضًا:\n\nl[4] (لماذا هذا خطأ؟)\nl[-1] و l[len(l) - 1]; هل هما نفس الشيء؟\nl[-2]\n\n\n\nالتقطيع (Slicing)\n\nيأخذ التقطيع الشكل s[start : end : step]\nالقيم الافتراضية عند الإغفال هي:\n\nstart = 0\nend = len(list)\nstep = 1\n\n\n\nl1 = [10, 20, 30, 40, 50]\nprint(l1[1:3])\n\n[20, 30]\n\n\n\nجرب\n\nl1[1:4]\nl1[1:]\nl1[:3]\nl1[:]\nl1[::2]\nl1[::-1]\n\n\n\n\nالبحث .index()\nطريق .index() تخرج موقع أول ظهور للقيمة المحددة.\n\nl1 = ['A', 'A', 'B', 'A', 'B']\nidx = l1.index('B')\nprint(l1[idx], 'is at index', idx)\n\nB is at index 2\n\n\nإذا لم يكن العنصر موجودًا في القائمة، فإنه يخرج خطأ.\n\nl1 = [10, 20, 30, 40, 50]\nl1.index(4444)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[15], line 2\n      1 l1 = [10, 20, 30, 40, 50]\n----&gt; 2 l1.index(4444)\n\nValueError: 4444 is not in list\n\n\n\nرسالة الخطأ تخبرنا أن 4444 غير موجود في القائمة. دعنا نتعامل مع هذه الحالة في لبنة else، بدلاً من ترك البرنامج أن يتعطل.\n\nl1 = [10, 20, 30, 40, 50]\nif 4444 in l1:\n    idx = l1.index(4444)\n    print(l1[idx], 'is at index', idx)\nelse:\n    print('Item not found')\n\nItem not found\n\n\n\n\nالتغيير (Mutation)\nالقوائم قابلة للتغيير، مما يعني أنه يمكن تعديلها بعد إنشائها. يشمل التغيير:\n\nالإضافة: l.append(x) لإضافة عنصر إلى نهاية القائمة\nالإزالة: l.remove(x)\nالإدراج: l.insert(i, x) لإدراج عنصر في موضع محدد\nالاستبدال: l[i] = x\nالترتيب: l.sort()\n\nولأن القائمة متتالية قابلة للتغيير فهي تحقق جميع عمليات تسلسل. راجع ملحق عمليات تسلسل.\n\nl1 = [10, 20, 30, 40, 50]\nl1[0] = 100 # replace the first element\nprint(l1)\n\n[100, 20, 30, 40, 50]\n\n\n\nجرب\n\nl1.append(60)\nl1.remove(10)\nl1.insert(2, 300)\n\n\n\n\nاستبدال المقاطع\nاستبدال عنصرين بعنصرين:\n\nl1 = [10, 20, 30, 40, 50]\nl1[1:3] = [200, 300]\nprint(l1)\n\n[10, 200, 300, 40, 50]\n\n\n\nجرب\n\nاستبدال عنصرين بعنصرين: l1[1:3] = [200, 300]\nاستبدال عنصرين بثلاثة عناصر: l1[1:3] = [200, 300, 400]\nاستبدال عنصرين بعنصر واحد: l1[1:3] = [200]\nاستبدال عنصرين بصفر عناصر: l1[1:3] = []",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#عبور-التسلسل",
    "href": "06_sequences.html#عبور-التسلسل",
    "title": "7  التسلسل",
    "section": "7.4 عبور التسلسل",
    "text": "7.4 عبور التسلسل\nنستخدم الجملة: for &lt;item&gt; in &lt;sequence&gt; لقراءة التسلسل. على سبيل المثال، هذا البرنامج يعبر العناصر واحدًا تلو الآخر بالترتيب ويطبعها:\n\nnumbers = [10, 20, 30, 40, 50]\nfor x in numbers:\n    print(x)\n\n10\n20\n30\n40\n50\n\n\nوهذا البرنامج ينتج من القائمة اثنين: إحداها زوجية والأخرى فدرية:\n\nnumbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nevens = []\nodds = []\n\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\n    else:\n        odds.append(x)\n\nprint('list of evens:', evens)\nprint('list of odds:', odds)\n\nlist of evens: [12, 14, 16, 18, 20]\nlist of odds: [11, 13, 15, 17, 19]",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#النطاق-range",
    "href": "06_sequences.html#النطاق-range",
    "title": "7  التسلسل",
    "section": "7.5 النطاق range",
    "text": "7.5 النطاق range\nنوع range يمثل تسلسلًا غير قابل للتغيير من الأرقام.\nويستخدم عادةً للتكرار عددًا محددًا من المرات في حلقات for.\nوفقًا لوثائق بايثون فإن النطاق له شكلان:\n\nclass range(stop)\nclass range(start, stop[, step])\n\nدعونا نفصل المحددات أولاً:\n\nstart: موضع الابتداء، وهو مشمول في النطاق. (القيمة الافتراضية هي 0)\nstop: موضع الانتهاء، وهو غير مشمول في النطاق.\nstep: مقدار الزياة أو النقص بعد كل كرة (القيمة الافتراضية هي 1)\n\nفإذا قمت بتعيين محدد واحد فسيكون هو stop:\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nوإذا قمت بتعيين محددين، فسيكون الأول start والثاني stop:\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا حددتها ثلاثة، فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتحديد step بقيمة سالبة، وتقلب البداية والنهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#الصف-tuple",
    "href": "06_sequences.html#الصف-tuple",
    "title": "7  التسلسل",
    "section": "7.6 الصف (Tuple)",
    "text": "7.6 الصف (Tuple)\nالصف هو مثل القائمة (تسلسل)، لكن يفترق عنها في نقطة واحدة: أنه غير قابل للتغيير.\nعدا ذلك، كل ما ينطبق على القائمة ينطبق أيضًا على الصف؛ إذ كلاهما يشتركان في خاصية كونهما تسلسل.\nبدلاً من الأقواس الحادة []، يستخدم الصف الأقواس المنحنية ():\n\nt1 = ()        # empty tuple\nt2 = (1,)      # tuple with one item\nt3 = (1, 2, 3) # tuple with three items\nt4 = ('abb', 1, 2.0, True) # tuple with different types\n\nيمكن أيضًا إنشاء الصف بوسائل:\n\nالدمج: باستخدام معامل +\nالتكرار: باستخدام معامل *\n\n\nt5 = (1, 2, 3) + (4, 5)\nt6 = t5 * 2\nprint(t5)\nprint(t6)\n\n(1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n\nلو حاولت تغيير عنصر في الصف، ستحصل على خطأ\n\nt1 = (10, 20, 30, 40, 50)\nt1[0] = 100\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[27], line 2\n      1 t1 = (10, 20, 30, 40, 50)\n----&gt; 2 t1[0] = 100\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nرسالة الخطأ تخبرنا أننا لا نستطيع تغيير قيمة عنصر في هذا الجمع.\nكما ستلاحظ عدم وجود إجراءات الحذف والإضافة ونحوها.\n\nتحويل list &lt;-&gt; tuple\nيمكن تحويل القوائم إلى جموع والعكس باستخدام الإجراءات list() و tuple().\n\nl1 = [10, 20, 30, 40, 50]\nt1 = tuple(l1)\nl2 = list(t1)\nprint(t1)\nprint(l2)\n\n(10, 20, 30, 40, 50)\n[10, 20, 30, 40, 50]\n\n\nمن المهم ملاحظة أن الإجراءات tuple() و list() تُنشئ كائنًا جديدًا، ولا تقوم فعليًا بتحويل الكائن في مكانه. لذا، تبقى l1 قائمة وتبقى t1 صفًا.\nالقوائم أكثر قدرة، فأين نستخدم الصف؟ يستخدم المبرمجون الأنواع غير القابلة للتغيير عندما يريدون توصيل أن البيانات لا ينبغي تغييرها. هذا مفيد بشكل خاص عند تمرير البيانات في البرنامج، حيث يمكن تمريرها دون الخوف من تغييرها.\n\n\nإنتاج صف من نتيجة إجراء\nكما أن الإجراءات تأخذ مجموعة مدخلات، يمكن أيضًا أن تنتج مجموعة مخرجات، وذلك باستخدام النوع tuple (صف):\nعلى سبيل المثال، هذا الإجراء يقسم سلسلة إلى جزئين بناءً على نسبة معينة:\n\ndef split_data(seq, ratio):\n    idx = int(len(seq) * ratio)\n    return seq[:idx], seq[idx:]\n\nنختبر الإجراء ونلاحظ أن الناتج من نوع صف (tuple). فنستعمل التعيين المتعدد لاستخراج القيم من الصف:\n\nmy_data = list(range(1, 10 + 1))\nt = split_data(my_data, 0.80)\n\nprint(type(t))\na, b = t\nprint(a, b)\n\nassert a == [1, 2, 3, 4, 5, 6, 7, 8]\nassert b == [9, 10]\n\n&lt;class 'tuple'&gt;\n[1, 2, 3, 4, 5, 6, 7, 8] [9, 10]",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>التسلسل</span>"
    ]
  },
  {
    "objectID": "07_mapping.html",
    "href": "07_mapping.html",
    "title": "8  القاموس",
    "section": "",
    "text": "القاموس (dict) هو مجموعة مرتبة من المؤشرات الفريدة الدالة على أشياء. يمكن أن تكون المؤشرات من نوع: سلسلة نصية، أو رقم، أو صف وما هو قابل للتجزئة (Hashable). أما القيَم فتكون من أي نوع.\nيدعم القاموس العمليات التالية:\n\nمعرفة عدد المؤشرات: len(dict)\nالتكرار: for key in dict\nالعضوية: key not in dict\nالإشارة: dict[key] أو dict.get(key)\nنزع قيمة: dict.pop(key)\nإضافة أو تعديل رابط: dict[key] = value\nإضافة أو تعديل مجموعة روابط: dict.update(new_data)\nالحذف: del dict[key]\n\nيعرف القاموس على النحو التالي:\n\ndata = {'key1': 'value1', 'key2': 'value2'}\n\nلكن حين تكثر القيم نفردها على الأسطر لتكون أوضح للقراءة (وليس هذا بلازم):\n\ndata = {\n    'key1': 'value1',\n    'key2': 'value2',\n}\n\nوهنا نمثل لبعض العمليات:\n\nassert data['key1'] == 'value1'\ndel data['key1']\nassert 'key1' not in data\n\nوهنا نستعرض مجموعة من الاستعمالات لشكل القاموس. أولاً كقاموس بالمعنى الذي يشير إليه اللفظ (الكلمة ومعناها).\n\nالكلمة ومعناها\nنفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:\n\nenglish_to_arabic = {\n    'apple': 'تفاحة',\n    'banana': 'موزة',\n    'orange': 'برتقالة',\n}\n\nأو الاختصارات إلى الكلمة التامة:\n\nabbreviations = {\n    'SAR': 'Saudi Riyal',\n    'KSA': 'Kingdom of Saudi Arabia',\n    'ASAP': 'As Soon As Possible',\n    'FYI': 'For Your Information',\n}\n\n\n\nحفظ معلومات المستخدم\nوهذا مثال على استعمال القاموس لتخزين معلومات شخص. لاحظ أن القيمة المقابلة لكل مؤشر قد تكون من أي نوع في بايثون، تمامًا مثل ما تُسنِد قيَم لمعرَّفات. فلدين النص والرقم والقاموس (داخل القاموس) والقيَم الثنائية (True, False) والقائمة [ ] (داخل القاموس).\n\nperson = {\n    'name': 'Adam',\n    'language': 'Arabic',\n    'phone': '966xxxxxxxxx',\n    'last_updated': '2021-09-01',\n    'age': 25,\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\n\n\nسلة المشتريات\nنفترض أن لدينا سلة تحتوي على مشتريات العميل (basket)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس prices بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).\n\nprices = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nbasket = ['apple', 'apple', 'banana', 'orange', 'banana']\n\nنحتاج أن نأتي على السلة عنصرًا عنصرًا، ونجمع قيمة كل فاكهة إلى المجموع الكلي:\n\ntotal = 0\n\nfor fruit in basket:\n    total += prices[fruit]\n\nprint(total)\n\n55\n\n\n\n\nالذاكرة القريبة (Cache)\nوهي الذاكرة التي تحتفظ بنتائج العمليات المتكررة (خصوصًا إذا كانت خوارزميات معقَّدة) حتى لا نحتاج لحسابها كل مرة؛ فنقتصد في موارد المعالجة في مقابل توظيف موارد الذاكرة (والتخزين).\n\nfactorial_table = {\n    0: 1,\n    1: 1,\n    2: 2,\n    3: 6,\n}\n\ndef factorial(n):\n    if n not in factorial_table:\n        factorial_table[n] = n * factorial(n - 1)\n    return factorial_table[n]\n\nبل إن بايثون توفر هذه الخاصية للدوال عن طريق المزيِّن (decorator) @functools.lru_cache، هكذا:\n\nimport functools\n\n@functools.lru_cache\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nلاحظ عدم الحاجة لتعريف القاموس factorial_table، بل يقوم المزيِّن هو بذلك تلقائيًّا.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>القاموس</span>"
    ]
  },
  {
    "objectID": "08_strings.html",
    "href": "08_strings.html",
    "title": "9  النصوص",
    "section": "",
    "text": "9.1 تعريف النصوص\nقيمة النص تحدد:\nمثلاً:\nname = 'Adam'\naddress = \"Riyadh, Saudi Arabia\"\nولاحظ هذا النص الذي يبتدئ في السطر الأول ويتمد لأربعة أسطر:\nmessage = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\nprint(message)\n\nSalam everyone,\nI hope you are enjoying the course,\n\nThank you.\nولكون النص تسلسلاً فإنه يدعم جميع عمليات التسلسل السابقة ذكرها (انظر فصل التسلسل). وهو فوق ذلك يدعم عمليات خاصلة بتسلسل الأحرف.\ns = 'Arabian'\n\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "08_strings.html#تعريف-النصوص",
    "href": "08_strings.html#تعريف-النصوص",
    "title": "9  النصوص",
    "section": "",
    "text": "بعلامة اقتباس مفردة: 'السلام عليكم!'\nبعلامة اقتباس مزدوجة: \"السلام عليكم!\" وليس بينهما فرق تمامًا.\nبعلامة اقتاس مكررة ثلاثة مرات: \"\"\"السلام عليكم!\"\"\" وذلك للنصوص التي تمتد على أكثر من سطر.\n\n\n\n\n\n\n\nالإشارة: s[i]\nمعرفة موضع شيء (إن وجد): s.index(x)\nعد تكرارات شيء: s.count(x)\nمعرفة الطول: len(s)\nالتكرار: for x in s\nالعضوية: x not in s\n\n\n 0   1   2   3   4   5   6   7\n +---+---+---+---+---+---+---+\n | A | r | a | b | i | a | n |\n +---+---+---+---+---+---+---+\n-7  -6  -5  -4  -3  -2  -1\n\nجرب\n\ns[1:5]\ns[1:5:2]\ns[::2]\ns[::-1]\n\nلاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:\n\ns = ('A', 'r', 'a', 'b', 'i', 'a', 'n')\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\nفالنص ، مثل الصف وبخلاف القائمة، غير قابل للتغيير. فلو حاولت تغيير حرف في النص. ستحصل على خطأ:\n\ns = 'Arabian'\ns[0] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 s = 'Arabian'\n----&gt; 2 s[0] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nلكن يمكنك تعديل النص بإنشاء نص جديد:\n\ns = 'Arabian'\ns = 'a' + s[1:]\nprint(s)\n\narabian\n\n\nلاحظ أننا أسندنا النص الجديد إلى المتغير s، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "08_strings.html#العمليات-الخاصة-بالنصوص",
    "href": "08_strings.html#العمليات-الخاصة-بالنصوص",
    "title": "9  النصوص",
    "section": "9.2 العمليات الخاصة بالنصوص",
    "text": "9.2 العمليات الخاصة بالنصوص\nلاستبدال جزء من النص، نستخدم إجراء .replace():\n\ns = 'Arabian'\ns = s.replace('ian', 'y')\nprint(s)\n\nAraby\n\n\nكما لدينا علميات .strip() لإزالة المسافات البيضاء من بداية ونهاية النص.\n\nassert '  Arabian  '.strip() == 'Arabian'\n\nوكذلك لدينا عمليات البحث:\n\nالتحقق من البدء والنهاية وما بينهما: .startswith(prefix) و .endswith(suffix) أو sub in string وهي أعم.\nلمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص .find()\n\n\ns = 'Arabian'\nassert s.startswith('A')\nassert not s.startswith('a')\nassert s.endswith('n')\nassert s.find('a') == 2\n\nانظر ملحق أنماط السلاسل للتعمق في علميات البحث والاستبدال بأنماط معقدة.\nالفصل والوصل:\n\nفصل النص لقائمة: list.split(seperator)\nدمج القائمة إلى نص: seperator.join(list)\n\n\ncsv = \"Adam,25,Riyadh\"\nassert csv.split(',') == ['Adam', '25', 'Riyadh']\n\n\ncsv = \"\"\"name,age,city\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\n\"\"\"\n\ncsv = csv.strip()\n\ndata = []\nfor line in csv.split(sep='\\n'):\n    d = line.split(sep=',')\n    data.append(d)\ndata\n\n[['name', 'age', 'city'],\n ['Adam', '25', 'Riyadh'],\n ['Belal', '30', 'Jeddah'],\n ['Camal', '35', 'Dammam']]\n\n\nوهذا مثال للوصل:\n\ndata = ['Adam', '25', 'Riyadh']\ncsv = ','.join(data)\nassert csv == 'Adam,25,Riyadh'\n\nتفسير الأرقام المكتوبة كسلسلة من الحروف، وهذا تكثر الحاجة إليه عندما نقرأ ملفات أو نتعامل مع بيانات مُدخلة من المستخدم، إذ دائمًا ما يكون الإدخال على شكل نصوص:\n\nint(x) لتحويل سلسلة نصية إلى عدد صحيح.\nfloat(x) لتحويل سلسلة نصية إلى عدد عشري.\n\nلاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:\n\nx = '20'\ny = '40'\nprint(x + y)\n\n2040\n\n\nالواجب تحويلهما إلى أعداد أولاًً:\n\nx2 = float(x)\ny2 = float(y)\nprint(x2 + y2)\n\n60.0\n\n\nوهنا عمليات خاصة بالنصوص الإنجليزية:\n\nupper() لتحويل النص إلى حروف كبيرة.\nlower() لتحويل النص إلى حروف صغيرة.\ncapitalize() لتحويل الحرف الأول إلى كبير.\ntitle() لتحويل النص إلى حالة عنوان.\n\n\nname = 'Adam ibraheeM'\nprint(name.upper())\nprint(name.lower())\nprint(name.capitalize())\nprint(name.title())\n\nADAM IBRAHEEM\nadam ibraheem\nAdam ibraheem\nAdam Ibraheem\n\n\nوانظر مستندات النصوص لمعرفة كافة الإجراءات الممكنة على النصوص.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "08_strings.html#تنسيق-السلاسل-النصية",
    "href": "08_strings.html#تنسيق-السلاسل-النصية",
    "title": "9  النصوص",
    "section": "9.3 تنسيق السلاسل النصية",
    "text": "9.3 تنسيق السلاسل النصية\nنستعرض ثلاث طرق لدمج السلاسل النصية في بايثون:\n\nالأولى: تحويل الشيء إلى نص قبل دمجه مع النص..\nالثانية: استعمال فراغات {} مع الإجراء .format() لتمرير ما يحل فيها.\nالثالثة: استعمال f-string بأن تضع الحرف f قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل القواس المعكوفة {}. وهي الطريقة التي نفضلها.\n\n\nname = \"John\"\nlvl = 300\n\nx1 = \"I am \" + name + \" and I want to reach level \" + str(lvl) # + operator\nx2 = \"I am {} and I want to reach level {}\".format(name, lvl)  # .format() method\nx3 = f\"I am {name} and I want to reach level {lvl}\"            # f-strings\nassert x1 == x2 == x3\nprint(x1)\n\nI am John and I want to reach level 300\n\n\n\nجرب\nاطبع الجملة \"Hello, my name is John Doe. and I am 30 years old\". باستخدام المتغيرات first_name، last_name، و age عبر الطرق الثلاث المذكورة آنفًا:\nانظر ملحق دقائق النصوص لمعرفة المزيد عنها.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_io.html",
    "href": "09_io.html",
    "title": "10  File I/O with pathlib",
    "section": "",
    "text": "Reading and writing files\nNote, file objects implement methods such as .read() and .write(). They mediate access to a real on-disk file or to another type of storage or communication device (for example standard input/output/error, in-memory buffers, network sockets, etc.).\np = Path('datasets/pathlib/a/a.txt')\n\nf = p.open()\ncontent = f.read()\nf.close()\n\nprint(content)\n\nlorem ipsum dolfet\nweilfur badem zelfur\nHere, we read a text file using the .open() method with read mode 'r' (default). To ensure we never forget to close resources, like a file (which could lead to memroy leaks), Python provides the with statement.\nThe with statement can only be used with Context Manager types (such as a file object) to lock and unlock resources automatically. In this case, the file object is opened at the entry of the with block and is closed when exited.\nLocking also makes sure only one process can access the resource (file) at a time, thus prevent invalid state caused by concurrent writes to the same resource (race condition). Unlocking releases the resource for other processes to use.\np = Path('datasets/pathlib/a/a.txt')\n\nwith p.open(mode='r') as file:\n    contents = file.read()\n    print(contents)\n\nlorem ipsum dolfet\nweilfur badem zelfur\nThe following table specify what mode characters mean:\nRead more about the built-in open() function.\nThe .read() method reads the entire file, but we can also read line by line using the .readline() method.\np = Path('datasets/pathlib/a/a.txt')\n\nwith p.open(mode='r') as file:\n    for i, line in enumerate(file, start=1):\n1        line = line.rstrip()\n        print(f'Line {i}: {line}')\n\n\n1\n\nUsing .rstrip to remove the ‘’ (newline character)\n\n\n\n\nLine 1: lorem ipsum dolfet\nLine 2: weilfur badem zelfur\nWe can also write to a file using the .write() method:\np = Path('datasets/pathlib/a/zzz.txt')\n\nwith p.open(mode='w') as file:\n1    file.write('Hello, World!\\n')\n\n\n1\n\nThe .write() method does not add a newline character, so we need to add it manually.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File I/O with pathlib</span>"
    ]
  },
  {
    "objectID": "09_io.html#pathlib-methods",
    "href": "09_io.html#pathlib-methods",
    "title": "10  File I/O with pathlib",
    "section": "10.1 pathlib methods",
    "text": "10.1 pathlib methods\n\n\n\npathlib\nDescription\n\n\n\n\nPurePath.parent\nReturns the parent directory of the path.\n\n\nPurePath.name\nRetrieves the last component (file or directory name) of the path.\n\n\nPurePath.stem, PurePath.suffix\nstem: Returns the file name without extension. suffix: Returns the file extension (with dot).\n\n\nPurePath.joinpath()\nCombines multiple path components.\n\n\nPurePath.is_absolute()\nChecks if the path is absolute.\n\n\nPurePath.relative_to() \nReturns a version of the path relative to another path.\n\n\nPath.expanduser()\nExpands ~ to the current user’s home directory.\n\n\nPath.resolve()\nReturns the absolute path by resolving symbolic links.\n\n\nPath.absolute()\nReturns the absolute version of the path (without resolving symlinks).\n\n\nPath.exists()\nChecks if the path exists.\n\n\nPath.is_file()\nChecks if the path points to a regular file.\n\n\nPath.is_dir()\nChecks if the path points to a directory.\n\n\nPath.is_symlink()\nChecks if the path points to a symbolic link.\n\n\nPath.is_junction()\nWindows-specific: checks if the path points to a junction.\n\n\nPath.is_mount()\nChecks if the path is a mount point.\n\n\nPath.samefile()\nChecks if two paths refer to the same file.\n\n\nPath.cwd()\nReturns the current working directory.\n\n\nPath.stat()\nReturns file system metadata.\n\n\nPath.lstat()\nLike stat() but does not follow symlinks.\n\n\nPath.iterdir()\nReturns an iterator over the directory contents.\n\n\nPath.walk() \nRecursively walks through a directory tree.\n\n\nPath.mkdir()\nCreates a new directory.\n\n\nPath.hardlink_to()\nCreates a hard link pointing to the path.\n\n\nPath.symlink_to()\nCreates a symbolic link pointing to the path.\n\n\nPath.readlink()\nReturns the path the symlink points to.\n\n\nPath.rename()\nRenames the file or directory.\n\n\nPath.replace()\nRenames the file or directory, overwriting if necessary.\n\n\nPath.unlink()\nRemoves a file.\n\n\nPath.rmdir()\nRemoves an empty directory.\n\n\nPath.chmod()\nChanges file mode and permissions.\n\n\nPath.lchmod()\nLike chmod() but does not follow symlinks.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File I/O with pathlib</span>"
    ]
  },
  {
    "objectID": "zz_set.html",
    "href": "zz_set.html",
    "title": "11  المجموعة الرياضية",
    "section": "",
    "text": "11.1 المجموعة الرياضية (Set)\nالمجموعة الرياضية (set) تحوي أشياء فريدة بغير ترتيب معيَّن. أما نظيرها غير القابلة للتغيير فهو: (frozenset).\nتدعم المجموعة الرياضة لكونها مجموعة (Collection) العمليات التالية:\nباعتبارها مجموعة غير مرتبة، فإن set لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تدعم الإشارة (xs[i]) أو التقطيع (xs[i:j]) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:\nمثال لاستعمال العضوية:\nباعتبارها مجموعة قابلة للتغيير (Mutable Set)، فهي تدعم الإجراءات التالية:\nسميناها رياضية لأنها تدعم عمليات:\nوهذا الكود مثال لجميع هذه العمليات:\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}\n\nunion = set1 | set2\nassert union == {1, 2, 3, 4, 5, 6, 7, 8}\n\nintersection = set1 & set2\nassert intersection == {4, 5}\n\ndiff1 = set1 - set2\nassert diff1 == {1, 2, 3}\n\ndiff2 = set2 - set1\nassert diff2 == {6, 7, 8}\n\nsymmetric_difference = set1 ^ set2\nassert symmetric_difference == {1, 2, 3, 6, 7, 8}\nنصيحة: من الأفضل استعمال اسم الإجراء بدلاً من العلامة التي تقابله حيث أنها تقبل أي نوع من المتكررات (Iterables) وليس المجموعات الرياضية فقط (set).\nوكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:\nوهذا مثال لاستعمالها:\nset1 = {'A', 'B', 'C'}\nset2 = {'A', 'B', 'C', 'D', 'E'}\nset3 = {'سين', 'جيم', 'قاف'}\n\nassert (set1 &lt;= set2) == set1.issubset(set2)\nassert (set2 &gt;= set1) == set2.issuperset(set1)\nassert (\n    set3.isdisjoint(set1 | set2) ==\n    (len(set3 & (set1 | set2)) == 0)\n)\nوتستعمل كذلك لإزالة العناصر المتكررة في أي مجموعة، نحو الكود التالي. فإننا نحول القائمة إلى مجموعة رياضية فتزول تلك العناصر تلقائيًّا، ثم نعيدها كما كانت:\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nunique_numbers = list(set(numbers))\nprint(unique_numbers)\n\n[1, 2, 3, 4, 5]\nوكذلك من الصف:\nt = (1, 2, 2, 3, 4, 4, 5)\nunique_t = tuple(set(t))\nprint(unique_t)\n\n(1, 2, 3, 4, 5)\nوكذلك لمعرفة الكلمات الفريدة في النص. فمعالجة النصوص أمر لابد منه لتحليلها، وهذا مثال على كيفية استخدام المجموعة الرياضية للعثور على الكلمات الفريدة في النص. كذلك نستعمل مجموعة الكلمات الوقفية (stop_words) لإزالتها من النص. ونقوم بتنظيف النص من العلامات الترقيمية باستعمال الإجراء .replace(). ونقوم بتحويل النص إلى حروف صغيرة بواسطة الإجراء .lower():\nstop_words = {'is', 'a', 'to', 'so', 'can', 'it', 'the', 'be', 'not'}\n\ntext = \"Python is a high-level computer programming language. Compared to human language, Python is unambiguous so a computer can interpret it one way.\"\n\n# clean the text\nxs = text.lower()\nxs = xs.replace('.', '')\nxs = xs.replace(',', '')\nclean_text = xs\n\nunique_words = set(clean_text.split())\nimportant_words = unique_words - stop_words\n\nfor w in sorted(important_words):\n    print(w)\n\ncompared\ncomputer\nhigh-level\nhuman\ninterpret\nlanguage\none\nprogramming\npython\nunambiguous\nway",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>المجموعة الرياضية</span>"
    ]
  },
  {
    "objectID": "zz_set.html#المجموعة-الرياضية-set",
    "href": "zz_set.html#المجموعة-الرياضية-set",
    "title": "11  المجموعة الرياضية",
    "section": "",
    "text": "معرفة الطول: len(s)\nالتكرار: for x in s\nالعضوية: x not in s\n\n\n#| error: true\nxs = {10, 20, 30}\nxs[0]\n\nlanguages = {\"Arabic\", \"English\"}\nif 'Python' not in languages:\n    print('you need to add Python to your languages!')\n\n\nالإضافة: add\nالحذف: discard\nأخذ عنصر عشوائي: pop\nالمحو: clear\n\n\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل) .. المعروفة في الرياضيات.\n\n\n\n\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nالاتحاد\nset1 | set2\nset1.union(set2)\n\n\nالتقاطع\nset1 & set2\nset1.intersection(set2)\n\n\nالفرق\nset1 - set2\nset1.difference(set2)\n\n\nالفرق التماثلي\nset1 ^ set2\nset1.symmetric_difference(set2)\n\n\n\n\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nتحقق الجزئية\nset1 &lt;= set2\nset1.issubset(set2)\n\n\nتحقق الشمول\nset1 &gt;= set2\nset1.issuperset(set2)\n\n\nتحقق الانفصال\nlen(set1 & set2) == 0\nset1.isdisjoint(set2)",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>المجموعة الرياضية</span>"
    ]
  },
  {
    "objectID": "zz_comprehension.html",
    "href": "zz_comprehension.html",
    "title": "12  Comprehension",
    "section": "",
    "text": "Suppose we have the following code that computes squares of a list:\n\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nNotice the input to this code is a list, and the output is also a list. We can write this in a single line using list comprehension. A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses.\n\nsquares = [x ** 2 for x in range(10)]\n\nSay we want a condition to filter out only the even numbers. We can use the if clause in the list comprehension, like so:\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nevens = [x for x in numbers if x % 2 == 0]\n\nLet’s comine the two to get the squares of even numbers:\n\nsquared_evens = [x ** 2 for x in numbers if x % 2 == 0]\n\nThere are three parts to this:\n\nexpression: x ** 2 in this case\nfor clause: for x in numbers\nif clause: if x % 2 == 0\n\nHere are some examples, taken from the Python documentation of list comprehensions:\n\nvec = [-4, -2, 0, 2, 4]\n\nfilter the list to exclude negative numbers\n\n[x for x in vec if x &gt;= 0]\n\n[0, 2, 4]\n\n\napply a function to all the elements\n\n[abs(x) for x in vec]\n\n[4, 2, 0, 2, 4]\n\n\ncall a method on each element\n\nfreshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n[weapon.strip() for weapon in freshfruit]\n\n['banana', 'loganberry', 'passion fruit']\n\n\nfilter the list to exclude negative numbers\n\n[x for x in vec if x &gt;= 0]\n\n[0, 2, 4]\n\n\ncreate a list of 2-tuples like (number, square)\n\n[(x, x ** 2) for x in range(6)]\n\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n\n\nNote that the tuple must be parenthesized, otherwise an error is raised.\n\n[x, x ** 2 for x in range(6)]\n\n\n  Cell In[11], line 1\n    [x, x ** 2 for x in range(6)]\n     ^\nSyntaxError: did you forget parentheses around the comprehension target?\n\n\n\n\nIf we have nested loops, we can write nested comprehensions.\nflatten a list using a listcomp with two ‘for’\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nget the Cartesian product of two sets:\n\ncolors = ['red', 'green']\nshapes = ['circle', 'square']\ncartesian_product = [(color, shape) for color in colors for shape in shapes]\ncartesian_product\n\n[('red', 'circle'),\n ('red', 'square'),\n ('green', 'circle'),\n ('green', 'square')]\n\n\nPython also allows comprehension for sets and dictionaries as well.\nextracting unique words from a dictionary of documents\n\nstopwords = {'is', 'and', 'the', 'be', 'not'}\ndocuments = {\n    'Python': \"python is great and Python is easy\",\n    'Java': \"Java is verbose and java is popular\",\n    'JavaScript': \"JavaScript is for the web and javascript is everywhere\"\n}\n\nunique_words = {word.lower() for doc in documents.values() for word in doc.split()}\nunique_words - stopwords\n\n{'easy',\n 'everywhere',\n 'for',\n 'great',\n 'java',\n 'javascript',\n 'popular',\n 'python',\n 'verbose',\n 'web'}\n\n\ninverting a dictionary\n\nidx2label = {\n    0: 'cat',\n    1: 'dog',\n    2: 'bird',\n}\n\nlabel2idx = {label: idx for idx, label in idx2label.items()}\nlabel2idx\n\n{'cat': 0, 'dog': 1, 'bird': 2}\n\n\nfilter out fruits that cost more than 50\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nfiltered_menu = {key: value for key, value in menu.items() if value &lt; 20}\nfiltered_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5}\n\n\napply 20% discount only to items whoose price is above average, while keeping the rest of prices the same. Notice, the expression here is a ternary operator: value * (1 - discount) if value &gt; avg_price else value. It is not the same as the if clause that filters out items; that comes at the end of the comprehension, after the for clause.\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\navg_price = sum(menu.values()) / len(menu)\ndiscount = 0.20\n\ndiscounted_menu = {\n    key: value * (1 - discount) if value &gt; avg_price else value\n    for key, value in menu.items()\n}\ndiscounted_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5, 'cantaloupe': 32.0}\n\n\nIn summary, list comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operation applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.\nSet and dictionary comprehensions are similar to list comprehensions, but produce sets and dictionaries instead of lists.\nSyntax is as follows:\n\nList comprehension: [expression for item in iterable if condition]\nSet comprehension: {expression for item in iterable if condition}\nDictionary comprehension: {key: value for item in iterable if condition}",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Comprehension</span>"
    ]
  },
  {
    "objectID": "zz_pipelines.html",
    "href": "zz_pipelines.html",
    "title": "13  Pipelines",
    "section": "",
    "text": "Subtitle: The map-filter-reduce Pattern\nLambda (\\(\\lambda\\)) expressions are used to create anonymous functions. The expression lambda parameters: expression yields a function object.\nLambda functions are small one-time use functions that are usually passed as arguments to other (higher-order) functions. Let’s take an example:\nIt is common to apply function over each item in a sequence. Let’s define a function that takes a function and a sequence and applies the function to each item in the sequence. Sounds mouthful, but it is simple to implement in Python.\n\ndef apply(func, items):\n    return [func(i) for i in items]\n\nsquared = apply(lambda x: x ** 2, range(1, 5+1))\nsquared\n\n[1, 4, 9, 16, 25]\n\n\nIn this case, apply is a higher-order function because it takes a function as an argument.\nPython already has the built-in map function that does this. The signature of map is map(function, iterable, ...). It applies function to each item of iterable and returns an iterator. Refer to this chapter for more details on iterators.\n\nsquared = map(lambda x: x ** 2, range(1, 5+1))\nsquared\n\n&lt;map at 0x10efa48f610&gt;\n\n\nNotice, the output is a map object. This is because maps are lazily evaluated; i.e., they are not computed until you need them (e.g., when you convert them to a list or iterate over them).\nWe can convert it to a list to see the results.\n\nlist(squared)\n\n[1, 4, 9, 16, 25]\n\n\nThe map-filter-reduce pattern is a common pattern in functional programming. Python provides the map, filter, and reduce functions to support this pattern. We can compose functions using map and filter to make a pipeline of computations. For example, let’s say we want to square the numbers and then add 100 to each of them, and finally filter out the even numbers.\n\nstep_0 = range(1, 5+1)\nstep_1 = map(lambda x: x ** 2, step_0)\nstep_2 = map(lambda x: x + 100, step_1)\nstep_3 = filter(lambda x: x % 2 == 0, step_2)\nstep_3\n\n&lt;filter at 0x10efb5476a0&gt;\n\n\nThis time, let’s iterate over it to access the results:\n\nfor result in step_3:\n    print(result)\n\n104\n116\n\n\nIf you rerun the loop again, you won’t get any output. This is expected because computation progresses throughout the pipeline one item at a time. Once you consume an item, it is gone.\nFinally, we talke about reduce from the functools module. The signature says: functools.reduce(function, iterable, [initial, ]/)\n\nApply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value.\n\nFor example, to sum all the numbers in a list:\n\nfrom functools import reduce\n\nnumbers = [1, 2, 3, 4, 5]\ntotal = reduce(lambda x, y: x + y, numbers)\ntotal\n\n15\n\n\nIt is common to combine map, filter, and reduce to create a pipeline of computations. For example, let’s take the following steps:\nFirst: map transforms each item in a collection\nSecondly, filter filters out some items after said transformation\nWe may interleave more map and filter operations as needed. And each item is processed without any dependency on the others. However, the final reduce step is dependent on all the items.\nIn this examlpe, we are using reduce to sum the numbers after applying the transformations using map and filter.\n\nstep_0 = range(1, 5+1)\nstep_1 = map(lambda x: x ** 2, step_0)\nstep_2 = map(lambda x: x + 100, step_1)\nstep_3 = filter(lambda x: x % 2 == 0, step_2)\n\ntotal = reduce(lambda x, y: x + y, step_3)\ntotal\n\n220\n\n\nThe reduce function may also produce more or less items than there are in the input collection. It is not necesserily a single value as in this case.\nIn summary, lambda functions are small anonymous functions that can be used to create higher-order functions. They are used to create functions that are passed as arguments to other functions. Lambda functions are used in conjunction with functions like map, filter, and reduce to create pipelines of computations.",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pipelines</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Appendix A — الأعداد",
    "section": "",
    "text": "B قاموس المصطلحات\nfrom IPython.display import display, HTML\nimport pandas as pd\n\n# Read the CSV file\ndf = pd.read_csv('assets/glossary.csv')\n\n# Replace NaN values in the 'comment' column with empty strings\ndf['comment'] = df['comment'].fillna('')\n\ndf.rename(columns={\n    'ar': 'عربي',\n    'en': 'English',\n    'comment': 'تعليق'\n}, inplace=True)\n\n# Display the dataframe as an HTML table\ndf.to_html(index=False)\ndisplay(HTML(df.to_html(index=False)))\n\n\n\n\nEnglish\nعربي\nتعليق\n\n\n\n\nVariable\nمُعرَّف\n\n\n\nValue\nقيمة\n\n\n\nExpression\nتعبير\n\n\n\nStatement\nعبارة\n\n\n\nClause\nجملة\n\n\n\nBlock\nلبنة\n\n\n\nCell\nقطعة\n\n\n\nSnippet\nقصاصة\n\n\n\nCode\nكود\nمعربة\n\n\nOperation\nعملية\n\n\n\nProcedure\nإجراء\n\n\n\nFunction\nإجراء\n\n\n\nMethod\nإجراء متعلق بكائن\n\n\n\nObject\nكائن\n\n\n\nClass\nصنف\n\n\n\nType\nنوع\n\n\n\nConatiner\nحاوية\n\n\n\nIterable\nقابل للتكرار\n\n\n\nIterator\nمكرر\n\n\n\nReversible\nقابل للعكس\n\n\n\nGenerator\nمولد\n\n\n\nSized\nمحدد الحجم\n\n\n\nCallable\nقابل للنداء\n\n\n\nCollection\nمجموعة\n\n\n\nSequence\nتسلسل\n\n\n\nIndex\nفهرس أو مؤشر\n\n\n\nMutable Sequence\nتسلسل قابل للتعديل\n\n\n\nSequence\nتسلسل\n\n\n\nString\nنص\n\n\n\nList\nقائمة\n\n\n\nDict (Mapping)\nدالة\n\n\n\nView\nعرض\n\n\n\nTuple\nصف\nفرد، زوج) صف ثلاثي، صف رباعي، ...إلخ\n\n\nSet\nمجموعة رياضية\n\n\n\nParameter\nمعامل\nوهي المتغيرات في التعريف\n\n\nArgument\nمعامل\nوهي القيَم المُمَرَّرَة\n\n\nFile\nملف\n\n\n\nModule\nوحدة\n\n\n\nPackage\nحزمة\n\n\n\nLibrary\nمكتبة\n\n\n\nFramework\nإطار عمل\n\n\n\nBuilt-in\nمدمج",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "glossary.html#tuple",
    "href": "glossary.html#tuple",
    "title": "Appendix A — الأعداد",
    "section": "B.1 Tuple",
    "text": "B.1 Tuple\n\nEtymology. The term originated as an abstraction of the sequence: single, couple/double, triple, quadruple, quintuple, sextuple, septuple, octuple, …, n‑tuple, …, where the prefixes are taken from the Latin names of the numerals. The unique 0-tuple is called the null tuple or empty tuple. Wikipedia",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "glossary.html#parameter",
    "href": "glossary.html#parameter",
    "title": "Appendix A — الأعداد",
    "section": "B.2 Parameter",
    "text": "B.2 Parameter\n\nA parameter (from Ancient Greek παρά (pará) ‘beside, subsidiary’ and μέτρον (métron) ‘measure’), generally, is any characteristic that can help in defining or classifying a particular system (meaning an event, project, object, situation, etc.). Wikipedia",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>الأعداد</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html",
    "href": "appendix_collections.html",
    "title": "Appendix B — المجموعات",
    "section": "",
    "text": "B.1 المجموعة\nclassDiagram\n    class Container {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n    }\n\n    class Iterable {\n        &lt;&lt;abstract&gt;&gt;\n        +__iter__()\n    }\n\n    class Iterator {\n        &lt;&lt;abstract&gt;&gt;\n        +__next__()\n        +__iter__()\n    }\n\n    class Reversible {\n        &lt;&lt;abstract&gt;&gt;\n        +__reversed__()\n    }\n\n    class Sized {\n        &lt;&lt;abstract&gt;&gt;\n        +__len__()\n    }\n\n    class Collection {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n    }\n\n    class Sequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__len__()\n        +__contains__()\n        +__iter__()\n        +__reversed__()\n        +index()\n        +count()\n    }\n\n    class MutableSequence {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__len__()\n        +insert()\n        +append()\n        +clear()\n        +reverse()\n        +extend()\n        +pop()\n        +remove()\n        +__iadd__()\n    }\n\n    class Set {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +__le__()\n        +__lt__()\n        +__eq__()\n        +__ne__()\n        +__gt__()\n        +__ge__()\n        +__and__()\n        +__or__()\n        +__sub__()\n        +__xor__()\n        +isdisjoint()\n    }\n\n    class MutableSet {\n        &lt;&lt;abstract&gt;&gt;\n        +__contains__()\n        +__iter__()\n        +__len__()\n        +add()\n        +discard()\n        +clear()\n        +pop()\n        +remove()\n        +__ior__()\n        +__iand__()\n        +__ixor__()\n        +__isub__()\n    }\n\n    class Mapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__iter__()\n        +__len__()\n        +__contains__()\n        +keys()\n        +items()\n        +values()\n        +get()\n        +__eq__()\n        +__ne__()\n    }\n\n    class MutableMapping {\n        &lt;&lt;abstract&gt;&gt;\n        +__getitem__()\n        +__setitem__()\n        +__delitem__()\n        +__iter__()\n        +__len__()\n        +pop()\n        +popitem()\n        +clear()\n        +update()\n        +setdefault()\n    }\n\n    Iterable &lt;|-- Iterator\n    Iterable &lt;|-- Reversible\n    Sized &lt;|-- Collection\n    Iterable &lt;|-- Collection\n    Container &lt;|-- Collection\n    Reversible &lt;|-- Sequence\n    Collection &lt;|-- Sequence\n    Sequence &lt;|-- MutableSequence\n    Collection &lt;|-- Set\n    Set &lt;|-- MutableSet\n    Collection &lt;|-- Mapping\n    Mapping &lt;|-- MutableMapping\n\n\n\n\nFigure B.1: شجرة المتتاليات في بايثون توضح اشتراك القوائم والجموع والسلاسل النصية في كونها متتاليات.\nنعرض هنا لأربعة أنواع أساسية في بايثون كلها من صنف مجموعة (Collection):\nعرفت بايثون المجموعة أنها حاوية محجَّمة قابلة للتكرار.\nThe use of the two underscores (__) before and after the operation name is a Python convention that indicates that the operation is supported with language syntax: +, in, for, and so on.\nSee:\nLet’s see what this means in practice.\nLet’s say we have a list of objects which we want to calculate some statistics on. We can use the following list as an example:\nthings = [10, 20, 30, 40, 'abb', 2.0, True]\nWe can get the length of the list using the len function. For example:\nlength = len(things)\nprint(length)\n\n7\nWe can loop over the list using a for loop. For example:\nfor t in things:\n    print(t)\n\n10\n20\n30\n40\nabb\n2.0\nTrue\nWe can check for the presence of an item in the list using the in operator. For example:\ncheck1 = 30 in things\ncheck2 = 100 in things\nprint(check1)\nprint(check2)\n\nTrue\nFalse\nThese were just to illustrate what it means for an Object to implement the Collection Abstract Base Class (ABC). Let’s turn our attention to a concrete built-in implementation of a widely used type of collection: the list.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#المجموعة",
    "href": "appendix_collections.html#المجموعة",
    "title": "Appendix B — المجموعات",
    "section": "",
    "text": "القائمة (list) وهي متتالية قابلة للتغيير (Mutable Sequence)\nالصف (tuple) وهو متتالية غير قابلة للتغيير (Immutable Sequence)\nالمجموعة الرياضية (set) وهي مجموعة غير مرتبة (Unordered Collection)\nالقاموس (dict) وهو دالة روابط فردية (MutableMapping)\n\n\n\nالحاوية (Container): تقبل استعلام in\nالمحجَّمة (Sized): تقبل len()\nالقابلة للتكرار (Iterable): تقبل for\n\n\nSized.__len__(): get the length of the collection using the len function\nIterable.__iter__(): loop over the collection using a for loop\nContainer.__contains__(): use the in operator to check if an item is in the collection\n\n\n\n\ncollections.abc\ncollections",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#list",
    "href": "appendix_collections.html#list",
    "title": "Appendix B — المجموعات",
    "section": "B.2 List",
    "text": "B.2 List\nA list is a Mutable Sequence. Which is a Reversible, Collection. This means that it supports the following operations:\nFrom being a Collection, it supports:\n\n__len__: get the length of the list using the len function\n__iter__: loop over the list using a for loop\n__contains__: use the in operator to check if an item is in the list\n\nFrom being a Reversible, it further supports:\n\n__reversed__: reverse the list using the reversed function\n\nFrom being a Sequence, it further supports:\n\n__getitem__: get an item from the list using the [] operator\nindex: get the index of an item in the list\ncount: count the number of occurrences of an item in the list\n\nFrom being a MutableSequence, it further supports:\n\n__setitem__: set an item in the list using the [] operator\ninsert: insert an item into the list at a specific index\nappend: add an item to the end of the list\nextend: add all items from another list to the end of the list\n__delitem__: delete an item from the list using the del operator\npop: remove and return an item from the end of the list\nremove: remove the first occurrence of an item from the list\nclear: remove all items from the list\n\nThis is the full specification of the list class as inferred from the ABC.\n\nNote on Mutability\nA crucial distinction is made in programming on where objects are mutable or immutable. This is important when we have multiple references to the same object. If the object is mutable, we have to synchronize the reads/writes to the object. However, if such synchronization is error-prone, then we can fix this by changing the design of the program, to make the object immutable and avoid the need for synchronization. This is a fundamental concept in concurrent programming (when multiple threads are reading/writing to the same object). A topic for another day.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#عمليات-السلسلة",
    "href": "appendix_collections.html#عمليات-السلسلة",
    "title": "Appendix B — المجموعات",
    "section": "B.3 عمليات السلسلة",
    "text": "B.3 عمليات السلسلة\nفي هذا الفصل، سنلقي نظرة على بعض أنواع المتتاليات (sequences) المدمجة شائعة الاستخدام:\n\nlist\nrange\ntuple\nstr\n\nنسرد في الجدول العمليات على المتتاليات مرتبةً حسب الصيرورة تصاعديًّا (order of evaluation).\nلاحظ أن ما ببين القوسين [ و ] يشير لعناصر اختيارية.\n\ns و t متتاليتان من نفس النوع (sequence)\nn، i، j و k أعداد صحيحة (integers)\nx كائن (object)\n\n\n\n\n\n\n\n\nالعملية\nالنتيجة\n\n\n\n\nx in s\nصحيح إذا كان هناك عنصر من خصائص s يساوي x، وإلا خطأ\n\n\nx not in s\nخطأ إذا كان هناك عنصر من خصائص s يساوي x، وإلا صحيح\n\n\ns + t\nدمج s و t\n\n\ns * n أو n * s\nيعادل إضافة s إلى نفسها n مرات\n\n\ns[i]\nالعنصر i من s، الأصل 0\n\n\ns[i:j]\nشريحة من s من i إلى j\n\n\ns[i:j:k]\nشريحة من s من i إلى j بخطوة k\n\n\nlen(s)\nطول s\n\n\nmin(s)\nأصغر عنصر من s\n\n\nmax(s)\nأكبر عنصر من s\n\n\ns.index(x[, i[, j]])\nفهرس أول ظهور لـ x في s (عند أو بعد الفهرس i وقبل j)\n\n\ns.count(x)\nالعدد الإجمالي لظهور x في s\n\n\n\nانظر: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#عمليات-تعديل-السلسلة",
    "href": "appendix_collections.html#عمليات-تعديل-السلسلة",
    "title": "Appendix B — المجموعات",
    "section": "B.4 عمليات تعديل السلسلة",
    "text": "B.4 عمليات تعديل السلسلة\n\nlist\n\nفي الجدول: - s متتالية قابلة للتغيير (mutable sequence) - t كائن قابل للتكرار (iterable) - x كائن (object)\n\n\n\n\n\n\n\nالعملية\nالنتيجة\n\n\n\n\ns[i] = x\nيتم استبدال العنصر i من s بـ x\n\n\ns[i:j] = t\nيتم استبدال الشريحة من s من i إلى j بمحتويات الكائن القابل للتكرار t\n\n\ndel s[i:j]\nنفس الشيء مثل s[i:j] = []\n\n\ns[i:j:k] = t\nيتم استبدال عناصر s[i:j:k] بعناصر t\n\n\ndel s[i:j:k]\nيتم إزالة عناصر s[i:j:k] من القائمة\n\n\ns.append(x)\nيتم إضافة x إلى نهاية التسلسل (نفس الشيء مثل s[len(s):len(s)] = [x])\n\n\ns.clear()\nيتم إزالة جميع العناصر من s (نفس الشيء مثل del s[:])\n\n\ns.copy()\nيتم إنشاء نسخة سطحية من s (نفس الشيء مثل s[:])\n\n\ns.extend(t) أو s += t\nيتم تمديد s بمحتويات t\n\n\ns *= n\nيتم تحديث s بمحتوياتها مكررة n مرات\n\n\ns.insert(i, x)\nيتم إدراج x في s عند الفهرس المحدد بـ i (نفس الشيء مثل s[i:i] = [x])\n\n\ns.pop() أو s.pop(i)\nيتم استرجاع العنصر عند i وإزالته من s\n\n\ns.remove(x)\nيتم إزالة أول عنصر من s حيث s[i] يساوي x\n\n\ns.reverse()\nيتم عكس عناصر s في مكانها\n\n\n\nانظر: https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types\n\nالإشارة (Indexing)\nنمثل بسلسلة من الأعداد:\n\nxs = [10, 20, 30, 40, 50]\n\nللوصول إلى عنصر من القائمة، استخدم عملية الإشارة []. يجب أن يكون المؤئر عددًا صحيحًا (int) في النطاق 0 &lt;= index &lt; len(s) - 1.\n\nassert xs[0] == 10\nassert xs[-1] == 50\nassert xs[len(xs) // 2] == 30\n\nوإليك تصويرًا لشكل سلسلة من سلالة الأحرف:\n\nfruits = [\"Apple\", \"Banana\", \"Orange\", \"Lemon\"]\n\n0       1        2        3       4\n+-------+--------+--------+-------+\n| Apple | Banana | Orange | Lemon |\n+-------+--------+--------+-------+\n-4      -3       -2       -1\n\nassert fruits[0] == \"Apple\"\nassert fruits[1] == \"Banana\"\nassert fruits[-1] == \"Lemon\"\n\nكما أن العنصر الواحد في السلسلة قد يكون هو مجموعة. بمعنى أننا يمكننان تمثيل مصفوفة مثلاً\n\nmatrix = [\n    [10, 20, 30],\n    [40, 50, 60],\n    [70, 80, 90]\n]\n\nassert matrix[0] == [10, 20, 30]\nassert matrix[-1] == [70, 80, 90]\nassert matrix[1][1] == 50\n\n\n\nالتقطيع\n\nيأخذ التقطيع الشكل s[start : end : step]\nالقيم الافتراضية عند الإغفال هي:\n\nstart = 0\nend = len(list)\nstep = 1\n\n\nدعم اللغة لكتابة : هو في الأصل عملية slice، والتي تنتج كائن slice يمكن استخدامه للتحكم في التقطيع.\n\nassert (\n    [\"Banana\", \"Orange\"] ==\n    fruits[slice(1, 3)] ==\n    fruits[1:3] ==\n    fruits[-3:-1] ==\n    fruits[-3:3] ==\n    fruits[1:-1] ==\n    fruits[-3:-1]\n)\n\nوإن أردت القفز بين العناصر فهكذا:\n\nassert fruits[::2] == [\"Apple\", \"Orange\"]\nassert fruits[1::2] == [\"Banana\", \"Lemon\"]\nassert fruits[::-1] == [\"Lemon\", \"Orange\", \"Banana\", \"Apple\"]\nassert fruits[::-2] == [\"Lemon\", \"Banana\"]\n\n\n\nالبحث\nإجراء .index() تنتج موقع أول ظهور للقيمة المحددة.\n\nl1 = ['A', 'A', 'B', 'A', 'B']\nidx = l1.index('B')\nprint(l1[idx], 'is at index', idx)\n\nB is at index 2\n\n\nإذا لم يكن العنصر موجودًا في القائمة، فإنه يخرج خطأ.\n\nl1 = [10, 20, 30, 40, 50]\nl1.index(4444)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[13], line 2\n      1 l1 = [10, 20, 30, 40, 50]\n----&gt; 2 l1.index(4444)\n\nValueError: 4444 is not in list\n\n\n\nرسالة الخطأ تخبرنا أن 4444 غير موجود في القائمة. دعنا نتعامل مع هذه الحالة في لبنة else، بدلاً من ترك البرنامج أن يتعطل.\n\nl1 = [10, 20, 30, 40, 50]\nif 4444 in l1:\n    idx = l1.index(4444)\n    print(l1[idx], 'is at index', idx)\nelse:\n    print('Item not found')\n\nItem not found\n\n\n\n\nالتغيير\nالسلاسل قابلة للتغيير، مما يعني أنه يمكن تعديلها بعد إنشائها. يشمل ذلك:\n\nالإضافة: l.append(x) لإضافة عنصر إلى نهاية القائمة\nالإزالة: l.remove(x)\nالإدراج: l.insert(i, x) لإدراج عنصر في موضع محدد\nالاستبدال: l[i] = x\nالترتيب: l.sort()\n\nولأن القائمة متتالية قابلة للتغيير فهي تحقق جميع عمليات المتتاليات. راجع ملحق عمليات المتتاليات.\n\nl1 = [10, 20, 30, 40, 50]\nl1[0] = 100 # replace the first element\nprint(l1)\n\n[100, 20, 30, 40, 50]\n\n\nجرب ما يلي:\n\nl1.append(60)\nl1.remove(10)\nl1.insert(2, 300)\n\n\n\nالترتيب والعكس\nملاخظة: reversed تنتج مولدًا للقيم، لا سلسلة جديدة.\n\nxs = [10, -90, 20, 30, 40, -40, -50, 60]\nprint(sorted(xs))\nprint(list(reversed(xs)))\nprint(xs)\n\n[-90, -50, -40, 10, 20, 30, 40, 60]\n[60, -50, -40, 40, 30, 20, -90, 10]\n[10, -90, 20, 30, 40, -40, -50, 60]\n\n\nأما الإجراء المتعلق بالسلسلة نفسها فهو الذي يُحدث تغييرًا في السلسلة نفسها بدل أن يُنتج نسخة معدلة:\n\nxs.sort()\nxs.reverse()\n\n\nxs\n\n[60, 40, 30, 20, 10, -40, -50, -90]\n\n\n\n\nاستبدال المقاطع\nجرب ما يلي:\n\nاستبدال عنصرين بعنصرين: l1[1:3] = [200, 300]\nاستبدال عنصرين بثلاثة عناصر: l1[1:3] = [200, 300, 400]\nاستبدال عنصرين بعنصر واحد: l1[1:3] = [200]\nاستبدال عنصرين بصفر عناصر: l1[1:3] = []\n\nاستبدال عنصرين بعنصرين:\n\n# SOLVED\nl1 = [10, 20, 30, 40, 50]\nl1[1:3] = [200, 300]\nprint(l1)\n\n[10, 200, 300, 40, 50]\n\n\nتوفر القوائم طريقة .sort() التي تقوم بالترتيب في مكانها. إذا كنت تريد إنشاء قائمة جديدة، استخدم الدالة sorted() بدلاً من ذلك. مثال:\n\nl1 = [10, 20, 50, 40, 30]\nl2 = sorted(l1)\nprint(l1)\nprint(l2)\n\n[10, 20, 50, 40, 30]\n[10, 20, 30, 40, 50]\n\n\nلاحظ أنها مختلفة.\nبينما:\n\nl1 = [10, 20, 50, 40, 30]\nl1.sort()\nprint(l1)\n\n[10, 20, 30, 40, 50]\n\n\nلاحظ أن l1 يتم ترتيبها في مكانها، ولا تنشئ قائمة.\n\n\nالتكرار\nهذه متسلسلتان:\n\nstudents = ['Ahmad', 'Belal', 'Camal', 'Dawud', 'Emad']\nmarks = [90, 80, 75, 85, 95]\n\nتقبل علمية التكرار:\n\nfor s in students:\n    print(s)\n\nAhmad\nBelal\nCamal\nDawud\nEmad\n\n\nلو أردنا أن نمر على المتسلسلتين في نفس الوقت:\n\nfor s, m in zip(students, marks):\n    print(s, m)\n\nAhmad 90\nBelal 80\nCamal 75\nDawud 85\nEmad 95",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#النطاق-range",
    "href": "appendix_collections.html#النطاق-range",
    "title": "Appendix B — المجموعات",
    "section": "B.5 النطاق (range)",
    "text": "B.5 النطاق (range)\nنوع range يمثل تسلسلًا غير قابل للتغيير من الأرقام. ويستخدم عادةً للتكرار عددًا محددًا من المرات في حلقات for.\nوقد تقدم الكلام عنه في باب الحلقات. لكننا هنا نعيد النظر من زاوية أنه تسلسل\nالميزة في نوع range على التسلسل هي أن كائن range سيأخذ دائمًا نفس (الصغيرة) كمية الذاكرة، بغض النظر عن حجم النطاق الذي يمثله (حيث يخزن فقط قيم البداية والنهاية والخطوة، ويحسب العناصر الفردية والنطاقات الفرعية حسب الحاجة).\n\nr = range(0, 20, 2)\nr\n\nrange(0, 20, 2)\n\n\n\nprint(11 in r)\nprint(10 in r)\n\nFalse\nTrue\n\n\n\nprint(r.index(10))\n\n5\n\n\n\nprint(r[5])\nprint(r[:5])\nprint(r[-1])\n\n10\nrange(0, 10, 2)\n18\n\n\n\nتحويل range إلى list\nيمكن تمرير الاستدعاء إلى range() إلى استدعاء list() لتحويله. هنا\n\nnumbers = list(range(1000, 0, -100))\nprint(numbers)\n\n[1000, 900, 800, 700, 600, 500, 400, 300, 200, 100]\n\n\nمثال آخر هو إنشاء قائمتين؛ واحدة للأرقام الزوجية والأخرى للأرقام الفردية، مرة أخرى، باستخدام تركيب list(range()).\n\nevens = list(range(0, 10, 2))\nodds = list(range(1, 10, 2))\nprint(evens)\nprint(odds)\n\n[0, 2, 4, 6, 8]\n[1, 3, 5, 7, 9]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#tuple",
    "href": "appendix_collections.html#tuple",
    "title": "Appendix B — المجموعات",
    "section": "B.6 Tuple",
    "text": "B.6 Tuple\nIn cases where we need to use a sequence that should not be changed, we can use a tuple. A tuple is just a Sequence, not a MutableSequence. It is defined using parentheses (), like so:\n\nt = (10, 20, 30, 40, 50)\ncheck1 = 30 in t\ncheck2 = 100 in t\nprint(check1)\nprint(check2)\n\nTrue\nFalse\n\n\nIf you try to change an item in a tuple, you will get an error:\n\nt1 = (10, 20, 30, 40, 50)\nt1[0] = 100\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[32], line 2\n      1 t1 = (10, 20, 30, 40, 50)\n----&gt; 2 t1[0] = 100\n\nTypeError: 'tuple' object does not support item assignment",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#set",
    "href": "appendix_collections.html#set",
    "title": "Appendix B — المجموعات",
    "section": "B.7 Set",
    "text": "B.7 Set\nالمجموعة set هي من صفن (Collection) وهي غير مرتبة ولا قابلة للتغيير. ويمتنع أن تجد عنصرين متماثلين فيها.\nوكذلك: يجب أن تكون عناصرها قابلة للتجزئة (hashable) مثل: str, int و tuple إذ هي الأنواع غير القابلة للتغيير.\nBeing a Mutable Set, it futher supports:\n\nadd: add an element to the set\ndiscard: remove an element from the set if it is a member\nremove: remove an element from the set; raises a KeyError if not a member\npop: remove and return an arbitrary element from the set\nclear: remove all elements from the set\n\nRefer to Python docs for all mutable set operations. The frozenset type is the immutable variant.\nCommon uses for a set include: membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference.\n\nMembership testing\n\nlanguages = {\"Arabic\", \"English\"}\nif 'Python' not in languages:\n    print('you need to add Python to your languages!')\n\nyou need to add Python to your languages!\n\n\n\n\nRemoving duplicates from a sequence\n\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nunique_numbers = list(set(numbers))\nprint(unique_numbers)\n\n[1, 2, 3, 4, 5]\n\n\n\n\nUnordered collection\nBeing an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing (xs[i]), slicing (xs[i:j]), or other sequence-like behavior.\n\nxs = {10, 20, 30}\nxs[0]\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[35], line 2\n      1 xs = {10, 20, 30}\n----&gt; 2 xs[0]\n\nTypeError: 'set' object is not subscriptable\n\n\n\n\n\nMathematical operations\n\n\n\nPython set mathematical operations. Source: www.datacamp.com\n\n\nIntersection, union, difference, and symmetric difference:\n\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}\n\nunion = set1 | set2\nassert union == {1, 2, 3, 4, 5, 6, 7, 8}\n\nintersection = set1 & set2\nassert intersection == {4, 5}\n\ndifference = set1 - set2\nassert difference == {1, 2, 3}\n\nsymmetric_difference = set1 ^ set2\nassert symmetric_difference == {1, 2, 3, 6, 7, 8}\n\nNote, it is better to actually use:\n\nset1.union(set2) instead of the operator version set1 | set2\nset1.intersection(set2) instead of the operator version set1 & set2\nset1.difference(set2) instead of the operator version set1 - set2\nset1.symmetric_difference(set2) instead of the operator version set1 ^ set2\n\nSince the latter methods can accept any iterable as an argument, not just sets.\nOther methods include:\n\nset1.issubset(set2) instead of set1 &lt;= set2\nset1.issuperset(set2) instead of set1 &gt;= set2\nset1.isdisjoint(set2) to check if two sets have no elements in common",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  },
  {
    "objectID": "appendix_collections.html#mapping",
    "href": "appendix_collections.html#mapping",
    "title": "Appendix B — المجموعات",
    "section": "B.8 Mapping",
    "text": "B.8 Mapping\nA dict is a mutable collection of key-value pairs. The keys must be hashable (like: str, int and tuple), and the values can be any object. It is a MutableMapping. It supports:\n\n__len__: get the number of key-value pairs\n__iter__: iterate over the keys\n__contains__: check if a key is in the dictionary\n__getitem__: get the value associated with a key\n__setitem__: set the value associated with a key\n__delitem__: delete a key-value pair\nget: get the value associated with a key, or a default value\npop: remove a key-value pair and return the value\npopitem: remove and return an arbitrary key-value pair\nclear: remove all key-value pairs\nupdate: update the dictionary with another dictionary\nsetdefault: get the value associated with a key, or set it to a default value\nkeys: get a view of the keys\nvalues: get a view of the values\nitems: get a view of the key-value pairs\n\nUpdate (Python 3.7): Dictionaries are now ordered. In Python 3.6 and earlier, dictionaries are unordered.\nيعرف القاموس على النحو التالي:\n\ndata = {'key1': 'value1', 'key2': 'value2'}\n\nلكن حين تكثر القيم نفردها على الأسطر لتكون أوضح للقراءة (وليس هذا بلازم):\n\ndata = {\n    'key1': 'value1',\n    'key2': 'value2',\n}\n\nThere are different ways to create a dictionary. Dictionaries compare equal if and only if they have the same (key, value) pairs (regardless of ordering).\n\nd = {\n    'foo': 10,\n    'two': 20,\n    'three': 30,\n}\n\nd2 = {\n    'three': 30,\n    'two': 20,\n    'foo': 10,\n}\n\nd3 = dict(foo=10, two=20, three=30)\n\nassert d == d2 == d3\n\nYou can also construct a dictionary from two lists (iterables) with zip, like so:\n\nstudents = ['Ahmad', 'Belal', 'Careem', 'David']\nmarks = [90, 80, 75, 85]\ndata = dict(zip(students, marks, strict=True))\ndata\n\n{'Ahmad': 90, 'Belal': 80, 'Careem': 75, 'David': 85}\n\n\n\nAccess\nYou can get the number of pairs using the len() function.\n\nlen(data)\n\n4\n\n\nThe index operator ([]) is used to access the value associated with a given key. Like so: dict[key].\n\nd[\"foo\"] == d.get('foo')\n\nTrue\n\n\nThe .get(key, default=None) method returns None or a default value provided in the 2nd argument.\n\nassert 'five' not in d\nd.get(\"five\", 5000)\n\n5000\n\n\nThree ways to iterate over a dict:\n\nIterate over keys: for key in d.keys()\nIterate over values: for value in d.values()\nIterate over key-value pairs: for key, value in d.items()\n\n\nd = {\n    \"Saudi Arabia\": \"Riyadh\",\n    \"Egypt\": \"Cairo\",\n    \"Turkey\": \"Ankara\",\n    \"Indonesia\": \"Jakarta\",\n    \"Pakistan\": \"Islamabad\",\n}\n\n\nfor key in d.keys():\n    print(key)\n\nSaudi Arabia\nEgypt\nTurkey\nIndonesia\nPakistan\n\n\n\nfor value in d.values():\n    print(value)\n\nRiyadh\nCairo\nAnkara\nJakarta\nIslamabad\n\n\n\nfor key, value in d.items():\n    print(key, value)\n\nSaudi Arabia Riyadh\nEgypt Cairo\nTurkey Ankara\nIndonesia Jakarta\nPakistan Islamabad\n\n\n\n\nMutation\nYou can update dictionary values by simply assigning a new value to a key.\n\nd[\"one\"] = 1000\nd\n\n{'Saudi Arabia': 'Riyadh',\n 'Egypt': 'Cairo',\n 'Turkey': 'Ankara',\n 'Indonesia': 'Jakarta',\n 'Pakistan': 'Islamabad',\n 'one': 1000}\n\n\nOr you may want to update using another dictionary.\n\nu = {\n    'three': 3000,\n    'four': 40,\n}\n\nd.update(u)\nd\n\n{'Saudi Arabia': 'Riyadh',\n 'Egypt': 'Cairo',\n 'Turkey': 'Ankara',\n 'Indonesia': 'Jakarta',\n 'Pakistan': 'Islamabad',\n 'one': 1000,\n 'three': 3000,\n 'four': 40}\n\n\nYou may take out a value:\n\nd = {'one': 100, 'two': 200}\nvalue = d.pop('two')\nassert 'two' not in d\nassert value == 200\n\nYou may want to just delete a pair.\n\nif 'two' in d:\n    del d['two']\nassert 'two' not in d",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>المجموعات</span>"
    ]
  }
]