[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "البايثونية",
    "section": "",
    "text": "فاتحة\nبسم الله الرحمن الرحيم. والحمد لله والصلاة والسلام على رسول الله وآله وصحبه ومن والاه. أما بعد.\nكتبت هذا الكتاب لمن أراد تعلم البرمجة بلغة عربية سهلة ، وبطريقة منهجية مرتبة مع مراعاة الجانبين: النظري والعملي. وليس الهدف منه تعلم طريقة التفكير، فهذا يُدرس في الخوارزميات وهياكل البيانات، ولكن الهدف هو التعرف على الأدوات البرمجية نفسها عن طريق طرح مسائل نستعمل فيها هذه الأدوات.\nولم يكن الهدف من الكتاب ترجمة كتب علمية أو مقالات برمجية إلى اللغة العربية؛ بل الهدف هو تعلم البرمجة. فحرصت على أن يكون الكلام متداولاً ولو لم تكن المصطلحات قاموسية. واخترت من الاصطلاح ما يزول به الغموض مراعيًا السياقات المختلفة لتكون أقرب لفهم المتعلم العربي.\nواخترت لغة بايثون لتعليم البرمجة لسهولتها وشهرتها مما يجعل كثيرًا من التطبيقات في المتناول، إذ الجهود متظافرة على خدمةمكتباتها من المجتمعات التي تتمحور حول صنف ما من التطبيقات. وقد نقسم أنواع التطبيقات إلى ثلاثة:\nأنظمة تحاكي الواقع: مثلاً برنامج لمحاكاة القوى المؤثرة وتوزيع الأحمال على جسر (أو عمارة أو باخرة أو طائرة) يساعد المهندسين على بناء الجسر (وربما خطة تفصيلية متدرِّجة).\nأنظمة فاعلة في الواقع: مثلاً في المصنع: الذراع الآلية ، وآلة القص ، وآلة الكبس ، …إلخ. من الآلات التي تعمل ضمن مجموعة متسقة لتنتج ما تنتج على خط الإنتاج.\nأنظمة المعلومات: تُعنى بجمع المعلومات وحفظها وفهرستها وترتيبها وتقسيمها وعرضها وتسهيل الحصول عليها بالسؤال المباشر وغير المباشر، والتحقق منها وتوفيرها والاستفادة منها وترجمتها ونحو ذلك. وهذا النوع هو الأغلب. مثل: محرك بحث قوقل (يعمل على ترتيب شبكة الإنترنت) ، ونظام الدفع عبر البطاقة ، والبرمجيات المكتيبة (تقارير ، محاسبة ، تخطيط، …إلخ) ، ونحو ذلك .",
    "crumbs": [
      "فاتحة"
    ]
  },
  {
    "objectID": "index.html#تمهيد",
    "href": "index.html#تمهيد",
    "title": "البايثونية",
    "section": "تمهيد",
    "text": "تمهيد\nظل الذكاء الاصطناعي طموحًا عاليًا منذ بزوغ فجر علوم الحاسب (1953). وما زال هذا الهدف دافعًا قويًّا لكل من فهم أننا باختراع الحاسب (1833 - 1871) استطعنا محاكاة المنطق في آلات صماء. ولا حد لإمكانيَّة هذا المعالِج الآلي إلا تعبيرك اللغوي أيها الناطق البشري. فهذا جانب المعالجة.\nوجانب الإدراك فيه:\nأدوات الإحساس التي تُدخِلُ المرئيات والمسموعات ونحوها ؛ وقد تم محاكاتها بآلة التصوير (كاميرا) ولاقط الصوت (مايكروفون). وكذلك أجهزة استشعار دقيقة مثل مستشعر الحرارة أو الرطوبة أو أجهزة قياس المسافة أو ماسحات البصمة أو الرنين المغناطيسي (MRI) أو الموجات الكهرومغناطيسية في الأقمار الصناعية وأجهزة الملاحة الجوية والبحرية والبوصلة أو ميزان التسوية الأفقية (Gyroscope) وغيرها كثير.\nومنها ما يُسجل يدويًّا كما يكون في المستشفى: العمر والوزن والطول، أو بيانات الحضور والانصراف أو المبيعات اليومية، أو بيانات طلاب أو متدربين في دورة تدريبية أو سجلات المخزون ونحو ذلك. وهي كثيرة جدًّا.\nوأدوات الاستيعاب وهي التي تجمع المحسوسات في وعاءٍ واحدٍ للاعتبار جُملةً واحدة، وقد تم محاكاتهُا بما نسميه الذاكرة (وهي على مراحل تَبعُد وتَقترب من مركز المعالجة). وتشبه الذاكرة في الجهاز ما يراه الشخص في الوقت الواحد أو يمكن تصوُّرُه في الذهن وتخيله في لحظة واحدة. أما الذكريات المخزنة لدينا ، وما نكتبه في مذكرات فيكون مسجلاً في أجهزة الحفظ.\nثم تأتي أدوات المعالجة وهي الآلات القابلة للبرمجة؛ مثل وحدة المعالجة المركزية (CPU) ووحدة المعالجة الرسومية (GPU) وغيرها؛ حيث يوضَع المنطق المترجَم من لغات البرمجة المتعددة.",
    "crumbs": [
      "فاتحة"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "1  إعداد بيئة التطوير",
    "section": "",
    "text": "نبدأ بالتعرف على بيئة التطوير ، وتثبيتها في جهازك؛ وذلك أنني أؤمن بضرورة إكساب الفرد أعلى قدر من التحكم في أدواته حتى يتمكن منها ومن تطويعها لعمل ما يريد بالشكل الأمثل.\nبيئة التطوير هي الأدوات البرمجية الأساسية والمساعدة لعمليات كتابة الكود وتنفيذه واختباره ونحو ذلك.\nأول ما نحتاج إليه هو حزمة برمجيات بايثون التي تتضمَّن الأداة التي تترجم ما نكتبه من كود بلغة بايثون لأوامِر ثنائية (صفر وواحد) لتكون مفهومة على مستوى نظام التشغيل ومعمارية الحاسب (إذ هي مستويات أكثر تفصيلاً)؛ ونسميه المُفَسِّر (Interpreter) وإن شئت قُل مترجم.\nكما تتضمن هذه الحزمة برنامج pip المسؤول عن تثبيت الحِزَم البرمجية المكتوبة بلغة بايثون؛ وذلك حتى تتمكن من البناء عليها عند كتابة أكواد بايثون (وبهذا الاعتبار تسمى مكتبات)، أو فقط لاستعمال برمجيات مكتوبة ببايثون (وبهذا الاعتبار تسمى برمجيات).\nأما محرر الكود فسنختار محرر (VS Codium) وهو مفتوح المصدر، وقد بنت عليه شركة مايكروسوفت محررها (Visual Studio Code) (الذي يستعمله 73.6% من 58,121 متجاوب في استبيان StackOverFlow 2024) لأن الشركة أسسته ثم فتحت للمجتمع البرمجي أكواده. وما يميزه أنه سهل بالنسبة للمبتدئ، وقوي بالنسبة للمتمكن. وتعني الشركة بدعمه وصيانته باستمرار وتطويره، كما أتيح بفتح أكواده سهولة كشف الأخطاء فيه، وأتيح بفضل تصميمه لأن يُخصص وتمتد إمكانياته بإضافات برمجيَّة قابلة للتثبيت يقوم بتزويدها لبعضهم البعض المجتمع البرمجي على مختلف لغاته واستعمالاته.\nوهناك طريقتان في العمل مع كود البايثون:\n\nالكتابة على ملف .py وتشغيله من أوله إلى آخره\nالكتابة على دفتر جوبتر (.ipynb) وتشغيل كل جزء على حدة (وهذه الطريقة التي نفضلها)\n\nنأتي الآن على كيفية تثبيت هذه المكونات في الجهاز.\n\nتنزيل مثبِّت حزمة برمجيات بايثون؛ بالذهاب لصفحة https://www.python.org/ والضغط على زر التنزيل (Download).\n\n\n\n\nHow to download Python from https://www.python.org/\n\n\n\nتنزيل مثبِّت محرر الأكواد وتثبيته:\n\nالنسخة المعدلة من مايكروسوفت (التي تتضمن متابعتك والربط مع خدماتها السحابية المدفوعة): Visual Studio Code\nالنسخة الحرة مفتوحة المصدر: VS Codium\n\nيجب أن نربط المحرر باللغة: يجب تثبيت وصلة البايثون: Python Extension.\nكما يجب ربط المحرر بدفتر جوبتر: يجب أن نثبت وصلة جوبيتر: Jupyter Extension.\nلتشغيل الكود في دفتر جوبتر يجب تثبيت حزمة ipykernel عن طريق مدير الحزم pip. يستلزم ذلك أن تفتح نافذة الأوامر (Terminal) ثم تكتب فيها السطر التالي:\n\npip install ipykernel\nأخيرًا:\n\nإن أردت كتابة الكود في دفتر جوبتر: أنشئ ملف جديد بصيغة ipynb. وافتحه.\nإن أردت كتابة الكود في ملف بايثون عادي: أنشئ ملف جديد بصيغة .py وافتحه.\n\nبعد ذلك تكون جاهزًا للبدء في الدرس الأول!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>إعداد بيئة التطوير</span>"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "2  المدخل إلى بايثون",
    "section": "",
    "text": "2.1 الشيء المفرد\nويندرج تحت صنف الأرقام أصناف (وإن شئت قل: أنواع) هي:\nفاشتراكها في صفة الرقمية (الذي جعلها تحت صنف الأرقام) أتى من حيث أنها تقبل إجراءات الجمع والطرح والقسمة ، وكذلك إجراءات المقارنة (أكبر من ، وأصغر من ، والمساواة) ونحو ذلك مما تقبله الأرقام. وسيأتي الحديث عنها بالتفصيل في باب الرقم.\nمثال بلغة البرمجة نقول:\nx = 123        # int (Integer)\nfoo = 123.45   # float (Decimal)\nok = True      # bool (Boolean)\nnot_ok = False # bool (Boolean)\nملاحظات حول هذا الكود:\nذلك كان تخزينًا للقيمة. فماذا عسانا أن نفعل بهذه القيم؟ نستعرض الآن بعض العمليات الحسابية بين الأرقام:\nx = 5\ny = 10\nz = x + y\nprint(z)\n\n15\nلاحظ أن علامة الـ(=) لا تعني استواء الطرفين (ليست معادلة رياضية). وإنما هي عملية تعيين (مثلها مثل عملية الجمع +) تقوم بإسناد قيمة لمسمى (وهو x هنا)؛ فتُخزِّن القيمة في الذاكرة في الحاسوب كأنما توضَع في صندوقٍ معنوَن بالاسم x. وقل مثل ذلك في y وكذلك في z.\nوتستطيع أن تقول إن ما قبل علامة التعيين (=) أصبح اسمًا مُعرَّفًا يُشير إلى شيء. وما بعد العلامة هو الشيء: وله صفتان أساسيتان: البيانات (5) والإجراءات التي تُعرَف ضِمنيًّا بحسب النوع (int) وتعني صِنف الأعداد الصحيحة (Integers)، الذي يندرج تحت صنف الأرقام (numbers).\nلو أردنا معرفة نوع الشيء، فلدينا الكلمة type(x) نستخدمها هكذا:\ntype(100)\n\nint\nt = type(x)\nprint(t)\n\n&lt;class 'int'&gt;\nونستطيع استعمال الناتج من العملية الأولى ليكون داخلاً للعملية الثانية من غير حفظ في مسمى وسيط، وذلك على النحو التالي:\nprint(type(x))\n\n&lt;class 'int'&gt;\nوالعمليات بين الأرقام تنتج أرقامًا، ولذلك نجد النوع يعمل بهذه الطريقة أيضًا:\nprint(type(x + y))\n\n&lt;class 'int'&gt;",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المدخل إلى بايثون</span>"
    ]
  },
  {
    "objectID": "01_intro.html#الشيء-المفرد",
    "href": "01_intro.html#الشيء-المفرد",
    "title": "2  المدخل إلى بايثون",
    "section": "",
    "text": "العدد الصحيح\nوالعدد العشري\nوالعدد التخيلي\nالعدد الثنائي (الذي يكون إما صفرًا أو واحدًا .. وذلك يُحتاج إليه في الجمل الشرطية).\n\n\n\n\n\n\nلاحظ أن ما يُكتب بعد علامة # هو تعليق يُمكن إدراجه في ثنايا الكود وذلك لتوضيحه. ونستعمله هنا للتعليم.\nالمعرَّفات (في الطرف الأيسر) تقبل أن تكون حرفًا أو كلمة ، أو كلمات مفصولة بشرطة سفلية (_) ويكثر استعمال ذلك\n\n\nفالسطر الأول يعين قيمة 123 (وهي من جنس الأعداد الصحيحة) للاسم x وذلك عن طريق عملية التعيين (=).\nوالثاني مثله لكن عدد عشري (لاحظ أنه يمكن للمسمى أن يكون كلمة ولا يشترط أن يكون حرفًا كما في الرياضيات).\nوالثالث مثله لكن قيمة ثنائي تساوي 1 (“نعم”). والأخير مثله لكن تساوي 0 (“لا”). فكل هذه أرقام.\n\n\n\n\nفي السطر الأول: قمنا بتعيين القيمة 5 لمعرف x\nفي السطر الثاني: مثل الأول لمعرف y\nفي السطر الثالث: تعيين ناتج عملية الجمع (+) بين عددين\nفي السطر الرابع: print هي إجراء تقدَّم تعريفها ضمن المكتبة الأساسية في حزمة البايثون، تعمل هنا على الكائن الرقمي z ليكون حاصلها: كتابة قيمة الرقم على الشاشة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المدخل إلى بايثون</span>"
    ]
  },
  {
    "objectID": "01_intro.html#النص",
    "href": "01_intro.html#النص",
    "title": "2  المدخل إلى بايثون",
    "section": "2.2 النص",
    "text": "2.2 النص\nوقد نقول إن النص نوع مُفرد أو نقول إنه نوعٌ مجموع باعتباره سلسلة من الحروف. لكن بغض النظر عن ذلك، فهو نوع محوري في أي لغة برمجة تتعامل مع ما هو مكتوبٌ رقميًّا كالرسائل والمستندات والمقالات والكتب ونحو ذلك. ويأتي الحديث عنه في باب النص.\nلتعريف النص نضع علامات التنصيص المزدوجة أو المفردة (لا فرق بينهما في بايثون) وذلك على النحو التالي:\n\na = 'Ahmad'\nb = \"Belal\"\n\nوإن كان النص يمتد لأسطر كثيرة، فتستعمل ثلاث تنصيصات متتالية على النحو التالي:\n\ntext = \"\"\"Salam Alykom\nI hope you are enjoying Python.\n\nBest wishes.\n\"\"\"\n\nوتأتي النصوص في أغلب الأحيان من الملفات المخزنة في الجهاز أو المنتقلة عبر الشبكة، فنقرؤها ثم نعالجها، على النحو التالي:\n\nwith open('datasets/example_root/something.txt') as file:\n    contents = file.read()\nprint(contents)\n\nhello this is something\nand this is on another line\n\n\nوسنتعلم كيفية التعامل مع الملفات النصية حفظًا وقراءة في باب الملف وكذلك في باب سَلسَلة البيانات. ولا بد عند ذلك من حدوث مسارات في البرنامج غير معتادة، ولذلك سنتعلم أيضًا التعامل مع الأخطاء في باب الأخطاء.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المدخل إلى بايثون</span>"
    ]
  },
  {
    "objectID": "01_intro.html#الشيء-المجموع",
    "href": "01_intro.html#الشيء-المجموع",
    "title": "2  المدخل إلى بايثون",
    "section": "2.3 الشيء المجموع",
    "text": "2.3 الشيء المجموع\nتعلمنا كيف نخزن قيمة عدد في x وقيمة عدد آخر في y. لكن لو أردنا التعامل مع الأرقام في مجموعة معًا لنحسب: مجموعها أو وسيطها أو متوسطها وغير ذلك سواءً كان بسيطًا أو معقَّدًا. فإننا نستعمل القوسين المربعين [] ونضع الأرقام مفصولة بعلامة الفاصلة، لتكون في مجموعة لها اسم يجمعها:\n\nmy_list = [20, 10, 30]\n\nولمجموعة الأرقام عدد من الإجراءات المضمَّنة في لغة بايثون مثل:\n\nالجمع: sum\nالقيمة العليا: max\nالقيمة الدنيا: min\nعد العناصر: len\n\nنستعرضها هنا:\n\nprint(sum(my_list))\nprint(max(my_list))\nprint(min(my_list))\n\navg = sum(my_list) / len(my_list)\nprint(avg)\n\n60\n30\n10\n20.0\n\n\nوكذلك المجموعة قد تتكون من عناصر نصية، ويمكن الاستعلام عن وجود عنصر فيها في جملة شرطية، وذلك على النحو التالي:\n\nfruits = ['Apple', 'Banana', 'Banana']\n\nif 'Apple' in fruits:\n    print(\"Keeps the doctor away!\")\n\nKeeps the doctor away!\n\n\nوسيأتي الكلام عن الجمل الشرطية في باب الشرط.\nأما المجموعات فتنقسم في بايثون بحسب خصائصها:\n\nأن يكون الشيء مجموعة (وما يترتب على ذلك من خصائص)\nأن يكون للمجموعة ترتيب\nأن تكون قابلة للحذف والإضافة والتعديل\nأن تكون منتهية أو غير منتهية\n\nوأفردنا لها الحديث في أبواب:\n\nالمتسلسلة\nالمجموعة الرياضية\nالربط\nسلسلة الأحرف\nاختصارات المجموعات",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المدخل إلى بايثون</span>"
    ]
  },
  {
    "objectID": "01_intro.html#ماذا-يترتب-على-اختلاف-الأنواع",
    "href": "01_intro.html#ماذا-يترتب-على-اختلاف-الأنواع",
    "title": "2  المدخل إلى بايثون",
    "section": "2.4 ماذا يترتب على اختلاف الأنواع؟",
    "text": "2.4 ماذا يترتب على اختلاف الأنواع؟\nصنف / نوع الشيء يترتب عليه قائمة العمليات الممكنة معه.\nفمثلاً: الأرقام يجوز بينها الجمع والطرح والضرب والقسمة والمقارنة:\n\nx = 10\ny = 5\n\nz = x + y\nprint(z)\n\nz = x &lt; y\nprint(type(z))\nprint('less than?', z)\n\nz = x == y\nprint(type(z))\nprint('equals?', z)\n\n15\n&lt;class 'bool'&gt;\nless than? False\n&lt;class 'bool'&gt;\nequals? False\n\n\nويجوز بين النصوص الدمج (باستعمال علامة +):\n\na = 'Hello'\nb = 'World'\n\nc = a + b\nprint(c)\n\nHelloWorld\n\n\nلكن لا يجوز جمع رقم ونص:\n\na = 'Adam'\nx = 10\nprint(a + x)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[15], line 3\n      1 a = 'Adam'\n      2 x = 10\n----&gt; 3 print(a + x)\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nويختلط على المبتدئين التفريق بين الرقم الذي هو في الحقيقة نص، والرقم الذي نوعه رقم (لاحظ وجود علامة التنصيص):\n\nx = '10'\ny = 10\nprint(x + y)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[16], line 3\n      1 x = '10'\n      2 y = 10\n----&gt; 3 print(x + y)\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\nفهذا الخطأ متوقع. وهنا لدينا احتمالان:\n\nتحويل x إلى رقم صحيح باستعمال عملية int\nتحويل y إلى نص باستعمال عملية str\n\nوانظر النتيجة في كلا الحالتين:\n\nprint(int(x) + y)\nprint(x + str(y))\n\n20\n1010\n\n\nبينما يجوز ضرب النص بالرقم؛ فيتكرر النص بعدد هذا الرقم:\n\na = 'Adam'\nprint(a * 3)\n\nAdamAdamAdam\n\n\nإذًا فما يجوز وما لا يجوز في الأنواع نفسها وبينها يحدده تعريفنا للعمليات عند تعريف الأصناف. ولذلك سنفرد لها بابين:\n\nباب تعريف الأصناف\nباب التخصيص والتركيب",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المدخل إلى بايثون</span>"
    ]
  },
  {
    "objectID": "01_intro.html#جملة-التوكيد",
    "href": "01_intro.html#جملة-التوكيد",
    "title": "2  المدخل إلى بايثون",
    "section": "2.5 جملة التوكيد",
    "text": "2.5 جملة التوكيد\nتُدرَج جُملَ التوكيد في ثنايا الكود للتحقق من صحَّة التسلسل المنطقي. فالتوكيد يُحدثُ خطأ إذا كانت القيمة التي نؤكدها خاطئة. مثلاً:\n\nassert False\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[19], line 1\n----&gt; 1 assert False\n\nAssertionError: \n\n\n\nفهذا الخطأ يظهر لأن حاصل التوكيد هو False، وهو عكس القيمة المطلوبة True.\nوإن أردنا أن نخبر بما نريد توكيده، فيمكننا توضيح ذلك في رسالة نصية بعض الفاصلة، على النحو التالي:\n\nx = 10\ny = 20\nassert x &gt; y, 'x should be greater than y'\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[20], line 3\n      1 x = 10\n      2 y = 20\n----&gt; 3 assert x &gt; y, 'x should be greater than y'\n\nAssertionError: x should be greater than y\n\n\n\nفهنا ظهر الخطأ مع الرسالة.\nأما إذا كانت العبارة صحيحة فلا يحصل خطأ:\n\nassert True\n\nلنأخذ مثالاً: نريد أن نتأكد أن عملية الأس ** تعادل عملية الأس pow:\n\nx = 2 ** 4\ny = pow(2, 4)\nassert x == y, 'x should be equal to y'\n\nتذكر أن هذه التوكيدات تساعد في فهم عمل الكود واختباره بسرعة، بالتالي للتحقق من صحة التسلسل المنطقي في الكود. فهي تغنينا عن كثيرٍ من عمليات print() التي تتطلب التحقق بالنظر بالعين.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المدخل إلى بايثون</span>"
    ]
  },
  {
    "objectID": "01_intro.html#نمو-اللغة",
    "href": "01_intro.html#نمو-اللغة",
    "title": "2  المدخل إلى بايثون",
    "section": "2.6 نمو اللغة",
    "text": "2.6 نمو اللغة\nتتكون لغة بايثون من مفردات تستعمل في جمل للتعبير عن معاني تترجم كعمليات مفصَّلة في اللغة المنطقية للآلة (CPU) بحسب معماريَّة الآلة.\nوهذه المفردات المبنية في أصل لغة بايثون هي:\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\nأما الجمل فتنقسم إلى قسمين:\n\nجملة بسيطة، وعادةً ما تكون في سطرٍ واحد. ومن أمثلتها:\n\nالتعيين (=)\nالحذف (del)\nالإرجاع (return)\n\nجملة مركبة وعادةً ما تكون على عدة أسطر، لكن -في بايثون- قد تكون مختصرة في سطرٍ واحد. ومن أمثلتها:\n\nالجملة الشرطية (if)\nجملة التكرار (while) و(for)\nجملة تعريف الإجراء (def) وجملة تعريف الصنف (class)\n\n\nوبنى مطوروا بايثون على ذلك الأساس (المفردات والجمل) تعريفات لإجراءات وأصناف ضمنوها مع اللغة وذلك لكثرة الحاجة إليها. فإنك عندما تثبِّت حزمة بايثون في جهازك فإنها تكون ضمن هذه الحزمة. تسمى: المكتبة الأساسية. وهي على قسمين:\n\nمضمَّنات أساسية، وفيها:\n\nإجراءات مضمَّنة مثل: print, sum, max, min, len\nأصناف مضمَّنة مثل: str, int, list\n\nوحدات أساسية، مثل:\n\nوحدة math التي تضم مجموعة إجراءات تعنى بالعمليات الرياضية على الأعداد\nوحدة datetime التي تضم مجموعة أصناف وإجراءات تعنى بالوقت والتاريخ\n\n\nويمكن استعمالها بعد جملة الاستيراد import على على النحو التالي:\n\nimport math\n\nsq = math.sqrt(16)\nprint(sq)\n\n4.0\n\n\nفهذه عملية الجذر التربيعي أتينا بها باستيراد الوحدة الأساسية math ثم أشرنا إلى الإجراء sqrt المعرَّف ضمنها عن طريق علامة النقطة ..\nثم يأتي دوْر المجتمع ليستعمل اللغة بمفرداتها وجملها ومكتبتها الأساسية، ليبني فوق ذلك ما يخدم أغراضه. فاستطاع كل فئة من الناس تركيب حزمة جديدة مكونة من أشياء مركبة وإجراءات مركبة يستفيدون هم في ذلك من حزم أناس آخرين ، ثم يوفرونها لغيرهم. وهكذا تنمو البرمجيات ، حزمةً تِلو الأخرى بحسب اهتمامات كل مجتمع برمجي. وتسمى هذه: مكتبات الطرف الثالث (Third-party Libraries).\nومن مكامن القوة في لغة بايثون: أنها متوافقة مع لغتي C/C++ إذْ يُمكن كتابة برمجيات عالية الأداء والكفاءة بهما مستفيدين من الحزم الموجودة فيهما، ثم لفُّ ذلك بحزمة سهلة الاستخدام للمطورين بلغة البايثون.\nفالمجتمعات البرمجية في بايثون كثيرة ومتعددة في اهتماماتها. منها على سبيل المثال:\n\nتطوير مواقع الشبكة:\n\nDjango - لبناء مواقع متصلة بقواعد بيانات\nFastAPI - حديث وسريع لبناء واجهات برمجية على الشبكة\n\nالذكاء الاصطناعي وتعلم الآلة:\n\nstatsmodels - للنماذج الإحصائية\nscikit-learn - لاكتشاف الأنماط والتنبؤ (تعلم الآلة)\nPyTorch - لبناء نماذج التعلم العميق\n\nتصوير البيانات:\n\nseaborn - تصور البيانات الإحصائية على أساس Matplotlib.\nmatplotlib - مكتبة شاملة لإنشاء تصورات ثابتة ومتحركة وتفاعلية.\n\nالتحليل الرياضي والهندسة:\n\nsympy - للرياضيات الرمزية.\nPySR - الانحدار الرمزي.\nSciPy - للرياضيات والعلوم والهندسة.\n\n\nوتصل عدد المشاريع (تقريبًا عدد الحزم) في قاعدة بيانات (PyPI) اليوم ما يزيد على 580,000 مشروع. وتجد الكود مشاعًا على أكبر منصة لإدارة الأكواد البرمجية: GitHub.\nاستعن بالله وابدأ الدرس القادم: الرقم.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>المدخل إلى بايثون</span>"
    ]
  },
  {
    "objectID": "02_number.html",
    "href": "02_number.html",
    "title": "3  الرقم",
    "section": "",
    "text": "3.1 وظيفة الأعداد في لغة البرمجة\nx = 5\ny = 3.0\nz = -10\nb = True\nc = 1 + 2j\nprint(type(x))\nprint(type(y))\nprint(type(z))\nprint(type(b))\nprint(type(c))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'int'&gt;\n&lt;class 'bool'&gt;\n&lt;class 'complex'&gt;",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "02_number.html#وظيفة-الأعداد-في-لغة-البرمجة",
    "href": "02_number.html#وظيفة-الأعداد-في-لغة-البرمجة",
    "title": "3  الرقم",
    "section": "",
    "text": "الأعداد الصحيحة (int)\n\nمثالها: ..., -2, -1, 0, 1, 2, ...\nوظيفتها: تستعمل في الفهرسة والعد والترتيب ونحو ذلك\n\nالقيم المنطقية (bool)\n\nمثالها: True, False\nوظيفتها: تستعمل في الجمل الشرطية وحلقات التكرار، والمقارنة بين الأشياء\n\nالأعداد العشرية (float)\n\nمثالها: 3.14, 2.718, 0.0, 15.0, -1.50\nوظيفتها: تمثيل الكميات مثل المال، المسافة، والوقت\n\nالأعداد المركبة (complex)\n\nمثالها: (1 + 2j), (1.0 - 2.0j)\nوظيفتها: تمثيل الأعداد التخيلية في الهندسة",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "02_number.html#العمليات-الحسابية",
    "href": "02_number.html#العمليات-الحسابية",
    "title": "3  الرقم",
    "section": "3.2 العمليات الحسابية",
    "text": "3.2 العمليات الحسابية\nوتسمى: Arithmetic operations.\n\nprint(x + y) # الجمع (Addition)\nprint(x - y) # الطرح (Subtraction)\nprint(x * y) # الضرب (Multiplication)\nprint(x / y) # القسمة (Division)\nprint(x % y) # باقي القسمة (Remainder)\nprint(x ** y) # الأس (Exponentiation)\n\n8.0\n2.0\n15.0\n1.6666666666666667\n2.0\n125.0",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "02_number.html#ماذا-تعني-صفة-العددية",
    "href": "02_number.html#ماذا-تعني-صفة-العددية",
    "title": "3  الرقم",
    "section": "3.3 ماذا تعني صفة العددية؟",
    "text": "3.3 ماذا تعني صفة العددية؟\nالاشتراك في صفة العددية يعني أنها تقبل العمليات الحسابية ، مع ملاحظة أن النوع الأقل دقة يتحول إلى النوع الأعلى دقة:\n\nفمثلاً: int + float = float\nوكذلك: int / int = float\nوأيضًا: bool * int = int\nوهكذا: int * complex = complex\n\n\nprint(x + z)\nprint(x + y)\nprint(y * z)\nprint(b * x)\nprint(c + x)\n\n-5\n8.0\n-30.0\n5\n(6+2j)\n\n\nلاحظ أن قسمة الصحيح تقوم بتقريب النتيجة إلى الأقرب:\n\nprint(7 / 2)\nprint(7 // 2)\n\n3.5\n3\n\n\n\nتمرين\nتحقق من نوع كل من التعبيرين السابقين باستخدام الدالة type(). هل يمكنك استخراج قاعدة من هذه الأمثلة؟\n\n7 / 2\n7 // 2\n7.0 / 2\n7 / 2.0\n\n# try it\nجرب الآتي حتى تستكشف ماذا يحصل لو:\n\nint + bool\nint * str\nstr * int\nstr + str\nint + str (لاحظ أن هذه العملية ستفشل)\n\n\ni = 5\nb = True\ns1 = '5'\ns2 = '11'\n\nprint(i + b)  # int + bool\n\n6",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "02_number.html#ترتيب-العمليات",
    "href": "02_number.html#ترتيب-العمليات",
    "title": "3  الرقم",
    "section": "3.4 ترتيب العمليات",
    "text": "3.4 ترتيب العمليات\nترتيب العمليات هو نفسه كما في الرياضيات:\n\nالأقواس: ()\nالأسس: **\nالضرب والقسمة: * و /\nالجمع والطرح: + و -\n\nللتفصيل الشامل انظر: ترتيب التقييم\n\nتمارين\nهذه تمارين للتحقق من فهمك لترتيب العمليات.\nأضف الأقواس لتغيير النتيجة لتطابق التوكيد:\n\nassert 3 + 2 * 5 == 25\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 assert 3 + 2 * 5 == 25\n\nAssertionError: \n\n\n\nالحل:\n\nassert (3 + 2) * 5 == 25\n\nمثال آخر:\n\nassert 8 - 4 / 2 == 2\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 assert 8 - 4 / 2 == 2\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n# try it\nمثال أخير:\n\nassert 2 ** 3 * 4 == 4096\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 assert 2 ** 3 * 4 == 4096\n\nAssertionError: \n\n\n\nما هو الحل؟ ضع الأقواس في مكانها الصحيح.\n# try it",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "02_number.html#التعيين-النسبي",
    "href": "02_number.html#التعيين-النسبي",
    "title": "3  الرقم",
    "section": "3.5 التعيين النسبي",
    "text": "3.5 التعيين النسبي\nيراجع: التعيين النسبي.\nلأن التعيين النسبي يستعمل بكثرة، فوجب علينا التعرف عليه، وأحيانًا نحتاج لاستعماله. فجمل التعيين التالية متكافئة:\n\ni = i + 1 تعادل i += 1\ni = i - 1 تعادل i -= 1\ni = i * 2 تعادل i *= 2\ni = i / 2 تعادل i /= 2\n\nجرب الكود أدناه لترى النتيجة:\n\ni = 0\nprint(i)\n\n0\n\n\n\ni = i + 1\nprint(i)\n\n1\n\n\n\ni += 1\nprint(i)\n\n2\n\n\nلاحظ أن i++ تعبير غير صالح في لغة بايثون، ليس مثل سي وجافا. فالكود التالي سيؤدي إلى خطأ:\n\ni++\nprint(i)\n\n\n  Cell In[14], line 1\n    i++\n       ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "02_number.html#وحدة-الرياضيات",
    "href": "02_number.html#وحدة-الرياضيات",
    "title": "3  الرقم",
    "section": "3.6 وحدة الرياضيات",
    "text": "3.6 وحدة الرياضيات\nتذكر أن المكتبة الأساسية توفر لنا وحدة الرياضيات math التي يمكن استيرادها والوصول للإجراءات التي فيها باستعمال النقطة . بعدها.\nفي هذا المثال نعرف نقطتين ثم نحسب المسافة بينهما. والمسافة الإقليدية بين نقطتين \\((x_1, y_1)\\) و \\((x_2, y_2)\\) تُحسب باستخدام الصيغة التالية:\n\\[\n\\text{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\n\\]\n\nimport math\n\nx1, y1 = 0, 0\nx2, y2 = 3, 4\ndistance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\nprint(distance)\n\n5.0\n\n\n\nimport math\n\nx = 5.4\nprint(math.floor(x)) # تقريب لأقرب عدد صحيح أصغر\nprint(math.ceil(x)) # تقريب لأقرب عدد صحيح أكبر\nprint(math.trunc(x)) # حذف ما بعد الفاصلة\nprint(round(x, 2)) # تقريب إلى رقمين بعد الفاصلة\n\n5\n6\n5\n5.4\n\n\nملاحظة: الدالة الأخيرة round ليست مستوردة من math وإنما هي مُضمَّنة في النطاق العام؛ لذا لا تحتاج لاستيراد شيء.\n\nتمرين\nاكتب برنامجًا ليعرف رقمين ثم اطبع مجموعهما، الفرق بينهما، حاصل ضربهما، خارج القسمة، وباقي القسمة. استخدم أسماء متغيرات وتعليقات مناسبة.\n# try it\n\n\nتمرين\nاحسب مساحة المكعب باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\text{width} \\times \\text{length} \\times \\text{height}\n\\]\n\nقم بتعيين العرض (width)، الطول (length)، والارتفاع (height) إلى متغيرات.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\n# try it\n\n\nتمرين\nاكتب برنامجًا يطلب من المستخدم إدخال عدد الساعات (hours) ومعدل الأجر لكل ساعة (rate per hour) لحساب الأجر الإجمالي (gross pay).\n# your code here\n\n\nتمرين\nاكتب برنامجًا يحسب مساحة الدائرة باستخدام الصيغة التالية:\n\\[\n\\text{area} = \\pi \\times \\text{radius}^2\n\\]\n\nقم بتعيين نصف القطر إلى متغير.\nاحسب المساحة باستخدام الصيغة.\nاطبع النتيجة.\n\nتلميح: يمكنك استخدام الثابت math.pi للحصول على قيمة \\(\\pi\\).\n# your code here\n\n\nتمرين\nاكتب برنامجًا لتحويل درجة الحرارة من السيليلوس إلى الفهرنهايت استخدم معادلة التحويل التالية:\n\\[\nF = \\frac{9}{5} \\times C + 32\n\\]\n# your code here",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "02_number.html#خلاصة",
    "href": "02_number.html#خلاصة",
    "title": "3  الرقم",
    "section": "3.7 خلاصة",
    "text": "3.7 خلاصة\nعرفنا الرقم والعمليات الممكنة عليه. لكننا سنتعرف على استعماله أكثر في الدروس القادمة، ولا يمكن حصر جميع ما يستفاد منه فيه في درس واحد، لأنه من أكثر الأمور شيوعًا في البرمجة.\nننتقل الآن لباب الشرط حيث الجمل الشرطية والتعيين المشروط.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>الرقم</span>"
    ]
  },
  {
    "objectID": "03_condition.html",
    "href": "03_condition.html",
    "title": "4  الشرط",
    "section": "",
    "text": "4.1 الجملة الشرطية\nالجملة الشرطية هي جملة مركَّبة من كلمة if وتعبير منطقي ثم الجمل التي يتعلق تنفيذها بناءً على هذا الشرط (وتكون داخل المحاذاة):\nif True:\n    print('Inside')\nprint('Outside')\n\nInside\nOutside",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الشرط</span>"
    ]
  },
  {
    "objectID": "03_condition.html#الجملة-الشرطية",
    "href": "03_condition.html#الجملة-الشرطية",
    "title": "4  الشرط",
    "section": "",
    "text": "تنبيه: المحاذاة العمودية\nلاحظ أن المحاذاة العمودية (Indentation) (المسافات البيضاء أسفل كلمة if) في الكود أعلاه ليست لمجرد تسهيل قراءة الكود، بل هي التي تحدد التعليمات المشروطة. عادةً ما تكون المحاذاة عبارة عن 4 مسافات أو 2 أو أكثر، لكن لابد أن تكون موحَّدة طوال الكود.\nلاحظ: بدون المحاذاة الصحيحة، سيظهر خطأ في الكود:\n\nif True:\nprint('Inside')\nprint('Outside')\n\n\n  Cell In[47], line 2\n    print('Inside')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\nإذا قمت بزيادة المحاذاة لكل من جملتي print()، فسوف يعمل الكود بتدفِّقٍ غيرِ الذي قصدناه ابتداءً. أي أنه سيطبع Outside عندما يكون في الواقع داخل اللَّبِنَة الشرطية.\n\nif True:\n    print('Inside')\n    print('Outside')\n\nInside\nOutside\n\n\nيؤدي الكود السابق إلى خطأ منطقي لن يظهر أبدًا كخطأ ولن يوقف البرنامج. لذا كن حذرًا مع المحاذاة في كتابة كود بايثون!",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الشرط</span>"
    ]
  },
  {
    "objectID": "03_condition.html#التعبيرات-المنطقية",
    "href": "03_condition.html#التعبيرات-المنطقية",
    "title": "4  الشرط",
    "section": "4.2 التعبيرات المنطقية",
    "text": "4.2 التعبيرات المنطقية\nأما الشروط فتستند إلى المنطق الرقمي الثنائي الذي نجد له في بايثون كلمتين من أصل اللغة هما:\n\nكلمة True (وتساوي الرقم 1) وتعبِّر عن تحقق الأمر\nكلمة False (وتساوي الرقم 0) وتعبِّر عن عدم التحقق الأمر\n\nوكلاهُما يندرج تحت نوع خاصّ من صنف الأرقام وهو النوع الثنائي (bool).\nأما الجملة الشرطية أو التعيين الشرطي ونحوه، فيتعلَّق بتحقق عبارة منطقية. فمن العبارات المنطقية: عبارة المقارنة:\n\n\n\nالعلامة\nالوصف\n\n\n\n\na == b\nيساوي\n\n\na != b\nلا يساوي\n\n\na &gt; b\nأكبر من\n\n\na &lt; b\nأصغر من\n\n\na &gt;= b\nأكبر من أو يساوي\n\n\na &lt;= b\nأصغر من أو يساوي\n\n\n\nهنا نستكشف عبارات تؤول إلى قيَم منطقية. العبارة الأولى: خمسة أكبر من تسعة؟\n\nb1 = 5 &gt; 9\nprint(type(b1))\nprint(b1)\n\n&lt;class 'bool'&gt;\nFalse\n\n\nالعبارة الثانية: هل طول كذا أكبر من طول كذا؟\n\nb2 = len('12345') &gt; len('123456789')\nprint(b2)\n\nFalse\n\n\n\nتركيب الشروط\nيمكنك دمج شروط متعددة باستخدام عمليات الجمع والتخيير والحصر والعكس، لأنها تنتج قيمة منطقية. كما هو موضح في الجدول التالي:\n\n\n\nA\nB\nAND\nOR\nXOR\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n\n\nالجمع: AND (و): تخرج 1 فقط إذا كان كلا المدخلين 1.\nالتخيير: OR (أو): تخرج 1 إذا كان أحد المدخلين على الأقل 1.\nالحصر: XOR (أو الحصرية): تخرج 1 إذا كان المدخلان مختلفين.\nالعكس: NOT (ليس): تخرج عكس المدخل (1 يصبح 0، و0 يصبح 1).\n\nعلى سبيل المثال:\n\nage = 20\nheight = 175\n\nif age &gt; 18 and height &gt; 170:\n  print(\"You are eligible to donate blood\")\n\nYou are eligible to donate blood\n\n\nيمكننا استخدام الأقواس لتجميع الشروط معًا. كما أنها تزيل أي غموض في ترتيب العمليات:\n\nage = 16\ntemperature = 15\nis_wearing_coat = True\n\nif age &lt; 16 or (temperature &lt; 20 and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\nيُنظَر للشرط بأكمله كقيمة منطقية واحدة تكون True أو False ولا بأس بتجزئته حينما يسهل بذلك الفهم:\n\nis_minor = age &lt; 16\nis_cold = temperature &lt; 20\n\nif is_minor or (is_cold and not is_wearing_coat):\n  print(\"I suggest you don't go outside\")\n\n\n\nالجملة الشرطية المتكاملة\nالصيغة المتكاملة للجملة الشرطية على النحو التالي:\nif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelif &lt;boolean expression&gt;:\n    &lt;code&gt;\nelse:\n    &lt;code&gt;\n\nكلمة if (إذا) تبدأ الجملة المركبة الشرطية\nقد توجد else (وإلا) مرة. وهي تعمل عند تخلُّف العبارة المنطقية السابقة لها سواءً كانت السابقة لها if أو elif.\nوقد توجد elif بينهما مرة أو أكثر (وهي اختصار لكلمة else if وتعني: وإلا فإن)، فتعمل مثل else معلَّقة بعبارة منطقية مثل if.\n\n\nجرب\nاستكشف المنطق التالي بتغيير قيمة x كل مرة للتبع ما يحصل في كل مرة:\n\nx = -5\nx = 0\nx = 1\nx = 5\n\n\nx = -5\n\nif x &lt; 0:\n    x = 0\n    print('Negative changed to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n\nprint(\"Always:\", x)\n\nNegative changed to zero\nAlways: 0\n\n\nوهذا تصوير لسير الأوامر لنفس الكود. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الفعلية:\n\n\nلاحظ أن العبارة الأخيرة خارج كل اللَّبِنات الشرطية لذا يتم تنفيذها دائمًا.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الشرط</span>"
    ]
  },
  {
    "objectID": "03_condition.html#جملة-التعيين-المشروط",
    "href": "03_condition.html#جملة-التعيين-المشروط",
    "title": "4  الشرط",
    "section": "4.3 جملة التعيين المشروط",
    "text": "4.3 جملة التعيين المشروط\nتستطيع في بايثون أن تجعل جملة التعيين تأخذ قيمتها بحسب شرطٍ معين. مثلاً:\n\nage = 18\nstatus = 'adult' if age &gt; 14 else 'child'\n\nprint(status)\n\nadult\n\n\nوهي مكافئة للكود التالي:\n\nage = 18\n\nif age &gt; 14:\n  status = 'adult'\nelse:\n  status = 'child'\n\nprint(status)\n\nadult\n\n\nويمكن أن يتسلسل التعيين المشروط بالصيغة التالية:\n\nscore = 75\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\"\nprint(grade)\n\nC",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الشرط</span>"
    ]
  },
  {
    "objectID": "03_condition.html#تضمين-الجمل-الشرطية",
    "href": "03_condition.html#تضمين-الجمل-الشرطية",
    "title": "4  الشرط",
    "section": "4.4 تضمين الجمل الشرطية",
    "text": "4.4 تضمين الجمل الشرطية\nجمل الشرط المضمنة هي جمل if داخل جمل if أخرى. على سبيل المثال:\nif &lt;boolean expression&gt;:\n    if &lt;boolean expression&gt;:\n        &lt;code&gt;\n    else:\n        &lt;code&gt;\nelse:\n    &lt;code&gt;\nننبه مرة أخرى أن المحاذاة مهمة. يجب أن تكون جملة if الداخلية ذات محاذاة أكثر من جملة if الخارجية.\n\nمثال\nافترض أننا نريد تعيين درجة لطالب بناءً على نتيجته، وفقًا للجدول التالي:\n\n\n\nMark\nGrade\n\n\n\n\n95-100\nA+\n\n\n90-94\nA\n\n\n85-89\nB+\n\n\n80-84\nB\n\n\n70-79\nC\n\n\n60-69\nD\n\n\n0-59\nF\n\n\n\n\nscore = 95\n\nif score &gt;= 90:\n  if score &gt;= 95:\n    print(\"Outstanding: A+\")\n  else:\n    print(\"Excellent: A\")\n\nelif score &gt;= 80:\n  if score &gt;= 85:\n    print(\"Very Good: B+\") \n  else:\n    print(\"Good: B\")\n\nelif score &gt;= 70:\n  print(\"Okay: C\")\n\nelif score &gt;= 60:\n  print(\"Poor: D\")\n\nelse:\n  print(\"Failed: F\")\n\nOutstanding: A+\n\n\nوهذا تصوير له:",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الشرط</span>"
    ]
  },
  {
    "objectID": "03_condition.html#خلاصة",
    "href": "03_condition.html#خلاصة",
    "title": "4  الشرط",
    "section": "4.5 خلاصة",
    "text": "4.5 خلاصة\nتعلمنا في هذا الدرس كيفية تعليق نفيذ بعض أجزاء الكود على حسب شروط محددة، وهذا يكاد يكون نصف البرمجة في الواقع!\nأما الدرس التالي فيتعلق بالتكرار المشروط والتكرار بمتوالية.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>الشرط</span>"
    ]
  },
  {
    "objectID": "04_iteration.html",
    "href": "04_iteration.html",
    "title": "5  التكرار",
    "section": "",
    "text": "5.1 التكرار بشرط\nنبدأ بالتكرار بالطريقة غير المحددة، وهي جُملة تبدأ بالكلمة while على النحو التالي. كأنها if متكررة إلى حين تخلُّف الشرط (أن يصبح False). وإن لم يتحقق الشرط أصلاً فلا ينفذ الكود المضمَّن أصلا:\nمثال:\nلنقم بتتبع الخطوات عندما تكون i = 0:\nوهذا تصوير لسير الأوامر لنفس الكود. ملاحظة: اضغط على الزر Prev أو Next للتنقل بين خطوات التنفيذ الفعلية:\nلاحظ أن نسيان جملة الزيادة (i += 1) يجعل الشرط دائمًا صحيح، فيدور البرنامج في حقلة لا نهيائة ولا يخرج أبدًا. ويعتبر هذا خطأ برمجيًّا لا يمكن للبرنامج أن يحله بنفسه؛ بل يجب على المبرمج أن يكتشفه.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>التكرار</span>"
    ]
  },
  {
    "objectID": "04_iteration.html#التكرار-بشرط",
    "href": "04_iteration.html#التكرار-بشرط",
    "title": "5  التكرار",
    "section": "",
    "text": "while &lt;boolean expression&gt;:\n    &lt;code&gt;\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\nprint('Done')\n\n\n0 &lt; 5 تؤول True، فنطبع 0 ونزيد i لتصبح 1\n1 &lt; 5 تؤول True، فنطبع 1 ونزيد i لتصبح 2\n2 &lt; 5 تؤول True، فنطبع 2 ونزيد i لتصبح 3\n3 &lt; 5 تؤول True، فنطبع 3 ونزيد i لتصبح 4\n4 &lt; 5 تؤول True، فنطبع 4 ونزيد i لتصبح 5\n5 &lt; 5 تؤول False،فنخرج من الحلقة\nنطبع Done\n\n\n\n\n\n\nالاستمرار في أخذ المعطيات من المستخدم\nتوفر بايثون إجراءات للتعامل مع المدخلات والمخرجات بالنسبة للبرنامج. ومن ذلك إجراء input الذي يأخذ مدخلات مباشرةً من لوحة الأوامر. فهو يقطع سير البرنامج ليمنح المستخدم الوقت بإدخال حروف للوحة الأوامر ويتنظر حتى تأتيه إشارة الإتمام (وذلك عندما يضغط المفتاح Enter) فتخزَّن هذه الحروف في معرَّف نوعه: نص؛ يمكن استعماله فيما بعد.\nنستطيع بناء لعبة تخمين بحيث نكرر الطلب من المستخدم إلى أن يُخمِّن الرقم الذي أضمره البرنامج له:\nnum = \"9\"\nguess = input(\"Guess the number (0-9): \")\nwhile guess != num:\n    guess = input(\"Try again: \")\nprint(\"You guessed it!\")\n\nالسطر الأول تعريف لقيمة نصية مكوَّنة من حرف واحد هو الرقم 9.\nالسطر الثاني هو الأمر الذي ينتظر فيه من المستخدم أن يُدخل أحرُفًا.\nالسطر الثالث والرابع هما جملة التكرار بشرط؛ فهي تتكرر إلى أن يطابق الحرف الذي أدخله المستخدم مع الحرف الذي في المعرَّف num. لاحظ أننا نعيد تعيين نفس المعرَّف guess إلى أن نخرج من هذه الحلقة.\nالسطر الأخير إذا وصلنا إليه علمنا أن الشرط انتفى (الحرف مطابق) وبالتالي نعرف أنه فعلاً قد خمَّنه.\n\nقد يبدو الأمر تافهًا؛ لكن هكذا تعمل برامج الخوادم التي تستقبل الطلبات بشكل مستمر. فإنها تدخل حلقة لانهائية تأخذ فيها الطلبات من المستخدمين ليتم معالجتها والرد عليهم.\nملاحظة جانبية: إذا كنت تريد أن تكون المدخلات من المستخدم سريَّة عند الإدخال فاستعمل getpass بدلاً من input وستظهر الحروف على شكل نجوم * وليست نفسها التي تظهر:\nimport getpass\n\nx = getpass.getpass()\nالآن المعرَّف x يحتوي على القيمة المدخلة. نجرب طباعته لنتحقق من ذلك.\nprint(x)\n\n\nالخروج من الحلقة\n\nتستخدم كلمة break لإيقاف عملية التكرار كلها.\nتستخدم كلمة continue للانتقال إلى الكرة التالية متخطيةً بقية الخطوات في الكرة الحالية.\n\nأولاً نمثل لاستعمال جملة break على النحو التالي:\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        break\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\nDone\n\n\n\n\nوهذا مثال لاستخدام عبارة continue للتخطي:\n\ni = 0\nwhile i &lt; 5:\n    if i == 3:\n        i += 1\n        continue\n    print(i)\n    i += 1\nprint('Done')\n\n0\n1\n2\n4\nDone\n\n\n\n\nأما جملة break المضمنة تحت طبقتين من التكرار فإن الذي يتوقف هو التكرار الداخلي فقط، ولا يتوقف الخارجي. وهذا مثال:\n\ni = 0\nwhile i &lt; 3:\n    j = 0\n    while j &lt; 3:\n        if i == 1:\n            break\n        print(i, j)\n        j += 1\n    i += 1\nprint('Done')\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\nDone",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>التكرار</span>"
    ]
  },
  {
    "objectID": "04_iteration.html#التكرار-بمتوالية",
    "href": "04_iteration.html#التكرار-بمتوالية",
    "title": "5  التكرار",
    "section": "5.2 التكرار بمتوالية",
    "text": "5.2 التكرار بمتوالية\nتعرف بايثون المتوالية (Iterable) بأنه الشيء الذي يُنتج عنصرًا في كل كرة، وذلك لأنه يطبق عملية __iter__. ويندرج تحته في لغة بايثون المُكَرِّر (Iterator) وهو الشيء الذي يتحكم بعملية التكرار، وذلك لأنه يطبق عملية __next__ .. وهذا يهمنا حين نريد أصناف تكون من جنس المتوالية أو المكرر. لكن الذي يهمنا الآن معرفة الأنواع الموجودة التي هي من جنسها.\nفمن المتوالياتا في المكتبة الأساسية:\n\nالمجموعة (Collection) وهي مجموعة محدودة من العناصر.\nالمولِّد (Generator) وهو ما يُنتج عناصر (قد يكون محدودًا وقد لا يكون).\n\nالمهم أن نعرف أن الشيء الذي يُساق في جملة التكرار المبتدأة بكلمة for هو متوالية. وجملة التكرار بمتوالية لها هذا الشكل:\nfor item in iterable:\n    ...\nوفي المثال التالي، لدينا مجموعة من الأرقام المرتبة، وضعناها للتكرار لتنتج لنا في كل كرة عنصرًا يتم تعيينه للمتغير x ليجري الكود في الداخل به:\n\nfor x in (30, 10, 20, 40, 50, 60):\n    print(x)\n\n30\n10\n20\n40\n50\n60\n\n\nوكل ما تراه في قطعة الكود التالية هو من جنس ما يقبل التكرار (متوالية):\n# list of 3 elements\nfor element in [10, 20, 30]:\n    print(element)\n\n# tuple of 3 elements\nfor element in (10, 20, 30):\n    print(element)\n\n# dictionary of 2 elements\nfor key in {'one': 100, 'two': 200}:\n    print(key)\n\n# string of 3 characters\nfor char in \"abc\":\n    print(char)\n\n# file of lines\nfor line in open(\"myfile.txt\"):\n    print(line, end='')\nلا تقلق فيما لم يتم تغطيته حتى الآن، فسيأتي الكلام عنه في وقته إن شاء الله.\nوهذا مثال آخر:\n\nنعرف قائمة أرقام، ثم نعرف قائمتين خاويتين، ثم نستعمل التكرار لترشيح الأرقام الزوجية في القائمة الزوجية، والأرقام الفردية في القائمة الفردية.\nأما علامة % فتعني باقي القسمة؛ فإذا كان باقي القسمة من العدد اثنان صفرًا فهو عدد زوجي، وإلا فهو عدد فردي.\n\n\nnumbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nevens = []\nodds = []\n\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\n    else:\n        odds.append(x)\n\nprint('list of evens:', evens)\nprint('list of odds:', odds)\n\nlist of evens: [12, 14, 16, 18, 20]\nlist of odds: [11, 13, 15, 17, 19]",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>التكرار</span>"
    ]
  },
  {
    "objectID": "04_iteration.html#النطاق",
    "href": "04_iteration.html#النطاق",
    "title": "5  التكرار",
    "section": "5.3 النطاق",
    "text": "5.3 النطاق\nيمثل النطاق (range) مولِّدًا لسلسلة أعداد في نطاق محدد ببداية ونهاية، وبين كل عدد والذي يليه مسافة محددة. فهي ثلاثة عوامل تحدده:\n\nالبداية (start): مشمول ، وقيمته الافتراضية 0.\nالنهاية (stop): غير مشمول ، وتم تعريف النطاق بحيث لا يُمكن إهمال النهاية.\nالخطوة (step): مقدار الزيادة أو النقص للعدد التالي ، وقيمته الافتراضية 1 (أي: الزيادة بواحد).\n\nدعونا الآن نلقي نظرة على التعريف كما هو موجود في وثائق بايثون، وذلك لنتعلم كيف نقرؤ التعريف. ادخل الرابط وتأمل معي ..\n\nclass range(stop)\nclass range(start, stop[, step])\n\nأولاً: نلاحظ كلمة class في الابتداء وهذا يعني أنه صِنف وليس إجراءً.\nثانيًا: نلاحظ أن لدينا تعريفان؛ وهما مختلفان، فأيهما تعمل به بايثون؟\nنجيب عن ذلك فنقول: التعريف الأوَّل يُعمل به إذا حددنا عاملاً واحدًا؛ فيكون العامل هو stop وتأخذ البداية والخطوة فيمتهما الافتراضية: start=0 و step=1 حسب ما كُتب:\n\nIf the step argument is omitted, it defaults to 1.\nIf the start argument is omitted, it defaults to 0\n\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nأما التعريف الثاني فيجب تفكيكه لنفهمه: class range(start, stop[, step]).\nوجود الأقواس المربعة [ ] يعني أجزاءً اختياريَّة. فإذًا؛ الجزء الإلزامي هو start, stop؛ فإن عينَّا قيمتين، فتكون الأولى البداية، والثانية النهاية، وتبقى الخطوة على قيمتها الافتراضية step=1.\n\nfor i in range(5, 10):\n    print(i)\n\n5\n6\n7\n8\n9\n\n\nأما إذا عينت الثلاثة جميعًا فسيكون الأول start والثاني stop والثالث step:\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\nولك أن تعكس النطاق بتعيين step بقيمة سالبة، لكن يجب حينها أن تجعل البداية أعلى من النهاية:\n\nfor i in range(10, 0, -1):\n    print(i)\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\nومن السياقات التي يستعمل فيها النطاق، أن تكرر على قائمة أرقام بخطوة معيَّنة، على النحو التالي:\n\nnumbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nfor i in range(1, len(numbers), 2):\n    print(numbers[i])\n\n20\n40\n60\n80\n100\n\n\n\nالسطر الأول: تعيين قائمة الأرقام للمعرَّف numbers.\nالسطر الثاني جملة مركَّبة من ثلاثة:\n\nأولاً من الداخل: len(numbers) يعطينا عدد العناصر في القائمة.\nثانيًا نخرج قليلاً إلى إنشاء النطاق: range(1, len(numbers), 2) فيها:\n\nالبداية 1\nوالنهاية len(numbers)\nوالخطوة 2\n\n\nالسطر الثالث: يأخذ من القائمة العنصر بالرقم الذي يتم تعيينه للمعرَّف i في كل كرة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>التكرار</span>"
    ]
  },
  {
    "objectID": "04_iteration.html#خلاصة",
    "href": "04_iteration.html#خلاصة",
    "title": "5  التكرار",
    "section": "5.4 خلاصة",
    "text": "5.4 خلاصة\nتعرفنا في الدرس على شيء هو من أقوى البُنى البرمجية وهو التكرار. تعلمنا كيف نستعمل جملة التكرار بنوعيها: التكرار بشرط والتكرا بمتوالية. وتعرفنا على النطاق المحدد واستعمالاته المختلفة. وأيضًا عرفنا كيف نوقف التكرار عند الحاجة لذلك بجملة break أو جلمة continue.\nيأتي في الدرس القادم الكلام عن الإجراء: وهي مجموعة جمل برمجيَّة لها اسم.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>التكرار</span>"
    ]
  },
  {
    "objectID": "05_function.html",
    "href": "05_function.html",
    "title": "6  الإجراء",
    "section": "",
    "text": "6.1 العوامل بين الترتيب والتسمية\nنفهم من تعريف الإجراء pow(base, exp, mod=None) أن لديها ثلاثة عوامل: base، exp، و mod بهذا الترتيب. لاحظ أن العامل mod اختياري (لوجود التعيين الافتراضي mode=None). هذا يعني أن الإجراء يمكن استعمالها بطرق مختلفة:\nprint(pow(2, 4))\nprint(pow(2, exp=4))\nprint(pow(base=2, exp=4))\nprint(pow(exp=4, base=2))\n\n16\n16\n16\n16\nفإن أردنا تعريف عوامل تستعمل بهذه الطريقة، فإننا نضعها في التعريف على النحو التالي:\ndef calculate_bmi(weight, height, unit='metric'):\n    \"\"\" Calculate the Body Mass Index (BMI)\n        \n        weight and height must be of the same unit.\n\n        unit is either 'metric' or 'imperial'.\n    \"\"\"\n    if unit == 'imperial':\n        weight *= 0.453592\n        height *= 0.0254\n    bmi = weight / (height ** 2)\n    return round(bmi, 2)\nالآن يمكننا استعمال الإجراء بطرق مختلفة. لاحظ أن استخدام assert هنا للتحقق من أن الإجراء تنتج نفس القيمة بغض النظر عن كيفية تمرير العوامل.\nw = 70   # kg\nh = 1.75 # meters\n\nprint(calculate_bmi(w, h))\n\nassert (\n    calculate_bmi(w, h) ==\n    calculate_bmi(w, height=h) ==\n    calculate_bmi(weight=w, height=h) ==\n    calculate_bmi(height=h, weight=w)\n)\n\n22.86\nونفس الأمر بالنسبة للعامل الذي عينت له قيمة افتراضية units='imperial':\nw = 154 # pounds\nh = 70  # inches\n\nprint(calculate_bmi(w, h, 'imperial'))\n\nassert (\n    calculate_bmi(w, h, 'imperial') ==\n    calculate_bmi(w, h, unit='imperial')\n)\n\n22.1",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الإجراء</span>"
    ]
  },
  {
    "objectID": "05_function.html#التعليق-في-مقدمة-الإجراء",
    "href": "05_function.html#التعليق-في-مقدمة-الإجراء",
    "title": "6  الإجراء",
    "section": "6.2 التعليق في مقدمة الإجراء",
    "text": "6.2 التعليق في مقدمة الإجراء\nتحتوي بايثون على إجراء أساسية تسمى help() تظهر معلومات عن إجراء ما:\n\nhelp(pow)\n\nHelp on built-in function pow in module builtins:\n\npow(base, exp, mod=None)\n    Equivalent to base**exp with 2 arguments or base**exp % mod with 3 arguments\n\n    Some types, such as ints, are able to use a more efficient algorithm when\n    invoked using the three argument form.\n\n\n\nكذلك يمكن استعمالها في أي إجراء مُعرَّفة، فهي تأخذ التعليق الذي يبدأ بثلاثة علامات تنصيص (\"\"\") بداية الإجراء (انظر كيف استعملناها في الإجراء calculate_bmi):\n\nhelp(calculate_bmi)\n\nHelp on function calculate_bmi in module __main__:\n\ncalculate_bmi(weight, height, unit='metric')\n    Calculate the Body Mass Index (BMI)\n\n    weight and height must be of the same unit.\n\n    unit is either 'metric' or 'imperial'.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>الإجراء</span>"
    ]
  },
  {
    "objectID": "06_sequences.html",
    "href": "06_sequences.html",
    "title": "7  المجموعة المرتبة",
    "section": "",
    "text": "7.1 استعمالات التسلسل\nلا تحزن إذا لم يكن الكود واضحًا بعد. فإن الغرض هنا استعراض حالات من الاستخدام. بعد ذلك سنبدأ بالفهم خطوة خطوة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#استعمالات-التسلسل",
    "href": "06_sequences.html#استعمالات-التسلسل",
    "title": "7  المجموعة المرتبة",
    "section": "",
    "text": "سلسلة أعداد\n\nxs = [10, 20, 30, 40, 50]\n\nإجراء لجمع الأعداد:\n\ndef summation(numbers):\n    total = 0\n    for n in numbers:\n        total += n\n    return total\n\nsummation(xs)\n\n150\n\n\nحساب المتوسط عن طريق إجراء الجمع ثم القسمة على عدد العناصر:\n\ndef average(numbers):\n    return summation(numbers) / len(numbers)\n\naverage(xs)\n\n30.0\n\n\nنرشح الأعداد الموجبة فقط:\n\ndef filter_positive(numbers):\n    result = []\n    for n in numbers:\n        if n &gt;= 0:\n            result.append(n)\n    return result\n\nنرشح الأعداد الموجبة ثم نجمعها هي فقط:\n\npositives = filter_positive(xs)\nsummation(positives)\n\n150",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#تفكيك-المركبات",
    "href": "06_sequences.html#تفكيك-المركبات",
    "title": "7  المجموعة المرتبة",
    "section": "7.2 تفكيك المركبات",
    "text": "7.2 تفكيك المركبات\nهذا مثال لشيء مركب (وهو النص المكتوب) نمثل هنا لشيء يكثر استعماله وهو تحويل أي شيء مركب إلى مجموعة من الأجزاء ليتم التعامل معها بشكل منفصل.\nمثلاً، نريد عد الكلمات في نص. لدينا الإجراء split() الذي يقوم بتقسيم النص إلى كلمات.\n\ns = \"this is five woooords long\"\nwords = s.split()\nprint(words)\n\n['this', 'is', 'five', 'woooords', 'long']\n\n\nالبحث عن أطول كلمة:\n\ndef longest_word(words):\n    longest = \"\"\n    for word in words:\n        if len(word) &gt; len(longest):\n            longest = word\n    return longest\n\nlongest_word(words)\n\n'woooords'\n\n\nويمكن تحويل الكلمات إلى حروف كبيرة:\n\ndef to_upper(words):\n    result = []\n    for word in words:\n        result.append(word.upper())\n    return result\n    \nto_upper(words)\n\n['THIS', 'IS', 'FIVE', 'WOOOORDS', 'LONG']\n\n\nيجدُر بالذكر أن النصوص نفسها هي تسلسلات من الحروف، لذا يمكن استعمال العمليات نفسها على النصوص. لكن لن استعجل الحديث عن ذلك، فلنتعمق أكثر في القوائم والصفوف أولاً.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#القائمة-list",
    "href": "06_sequences.html#القائمة-list",
    "title": "7  المجموعة المرتبة",
    "section": "7.3 القائمة (List)",
    "text": "7.3 القائمة (List)\nالقائمة (list) سلسلة مرتبة من الأشياء، يمكن التعديل على هذه السلسلة بالحذف والإضافة في الأول أو الأخير أو الوسط. كما يمكن أن تحتوي على عناصر من أنواع مختلفة، بما في ذلك قائمة داخل قائمة.\n\nl1 = []        # empty list\nl2 = [1]       # list with one item\nl3 = [1, 2, 3] # list with three items\nl4 = ['abb', 1, 2.0, True] # list with different types\n\nيمكن أيضًا تركيب القوائم عن طريق:\n\nالدمج: باستخدام معامل +\nالتكرار: باستخدام معامل *\n\n\nl5 = [1, 2, 3] + [4, 5]\nl6 = l5 * 2\nprint(l5)\nprint(l6)\n\n[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n\n\n\nجرب\n\nlen(l3) للحصول على طول القائمة l3\n'abb' in l4 للتحقق مما إذا كانت 'abb' عنصرًا في القائمة l4\n\nبعد ذلك، جرب 'abb' not in l4\n\nجرب min(l3), max(l3), sum(l3) وانظر ماذا يحدث\n\n\n\nالإشارة (Indexing)\nللوصول إلى عنصر من القائمة، استخدم عملية الإشارة []. يجب أن يكون المؤئر عددًا صحيحًا (int) في النطاق 0 &lt;= index &lt; len(s) - 1.\n\nl1 = [10, 20, 30, 40, 50]\nprint(l1[0])\n\n10\n\n\n\nجرب\nكذلك، جرب l1[1], l1[2], و l1[3].\n\nl2 = [\"Apple\", \"Banana\", \"Orange\", \"Lemon\"]\n\nفي القائمة l2، الفهرس على النحو التالي:\n0       1        2        3       4\n+-------+--------+--------+-------+\n| Apple | Banana | Orange | Lemon |\n+-------+--------+--------+-------+\n-4      -3       -2       -1\n\n\n\nجرب\n\nl[1]\nl[2]\nl[3]\n\nوجرب أيضًا:\n\nl[4] (لماذا هذا خطأ؟)\nl[-1] و l[len(l) - 1]; هل هما نفس الشيء؟\nl[-2]\n\n\n\nالتقطيع (Slicing)\n\nيأخذ التقطيع الشكل s[start : end : step]\nالقيم الافتراضية عند الإغفال هي:\n\nstart = 0\nend = len(list)\nstep = 1\n\n\n\nl1 = [10, 20, 30, 40, 50]\nprint(l1[1:3])\n\n[20, 30]\n\n\n\nجرب\n\nl1[1:4]\nl1[1:]\nl1[:3]\nl1[:]\nl1[::2]\nl1[::-1]\n\n\n\n\nالبحث .index()\nطريق .index() تخرج موقع أول ظهور للقيمة المحددة.\n\nl1 = ['A', 'A', 'B', 'A', 'B']\nidx = l1.index('B')\nprint(l1[idx], 'is at index', idx)\n\nB is at index 2\n\n\nإذا لم يكن العنصر موجودًا في القائمة، فإنه يخرج خطأ.\n\nl1 = [10, 20, 30, 40, 50]\nl1.index(4444)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[15], line 2\n      1 l1 = [10, 20, 30, 40, 50]\n----&gt; 2 l1.index(4444)\n\nValueError: 4444 is not in list\n\n\n\nرسالة الخطأ تخبرنا أن 4444 غير موجود في القائمة. دعنا نتعامل مع هذه الحالة في لبنة else، بدلاً من ترك البرنامج أن يتعطل.\n\nl1 = [10, 20, 30, 40, 50]\nif 4444 in l1:\n    idx = l1.index(4444)\n    print(l1[idx], 'is at index', idx)\nelse:\n    print('Item not found')\n\nItem not found\n\n\n\n\nالتغيير (Mutation)\nالقوائم قابلة للتغيير، مما يعني أنه يمكن تعديلها بعد إنشائها. يشمل التغيير:\n\nالإضافة: l.append(x) لإضافة عنصر إلى نهاية القائمة\nالإزالة: l.remove(x)\nالإدراج: l.insert(i, x) لإدراج عنصر في موضع محدد\nالاستبدال: l[i] = x\nالترتيب: l.sort()\n\nولأن القائمة متتالية قابلة للتغيير فهي تحقق جميع عمليات تسلسل. راجع ملحق عمليات تسلسل.\n\nl1 = [10, 20, 30, 40, 50]\nl1[0] = 100 # replace the first element\nprint(l1)\n\n[100, 20, 30, 40, 50]\n\n\n\nجرب\n\nl1.append(60)\nl1.remove(10)\nl1.insert(2, 300)\n\n\n\n\nاستبدال المقاطع\nاستبدال عنصرين بعنصرين:\n\nl1 = [10, 20, 30, 40, 50]\nl1[1:3] = [200, 300]\nprint(l1)\n\n[10, 200, 300, 40, 50]\n\n\n\nجرب\n\nاستبدال عنصرين بعنصرين: l1[1:3] = [200, 300]\nاستبدال عنصرين بثلاثة عناصر: l1[1:3] = [200, 300, 400]\nاستبدال عنصرين بعنصر واحد: l1[1:3] = [200]\nاستبدال عنصرين بصفر عناصر: l1[1:3] = []",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#عبور-التسلسل",
    "href": "06_sequences.html#عبور-التسلسل",
    "title": "7  المجموعة المرتبة",
    "section": "7.4 عبور التسلسل",
    "text": "7.4 عبور التسلسل\nنستخدم الجملة: for &lt;item&gt; in &lt;sequence&gt; لقراءة التسلسل. على سبيل المثال، هذا البرنامج يعبر العناصر واحدًا تلو الآخر بالترتيب ويطبعها:\n\nnumbers = [10, 20, 30, 40, 50]\nfor x in numbers:\n    print(x)\n\n10\n20\n30\n40\n50\n\n\nوهذا البرنامج ينتج من القائمة اثنين: إحداها زوجية والأخرى فدرية:\n\nnumbers = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nevens = []\nodds = []\n\nfor x in numbers:\n    if x % 2 == 0:\n        evens.append(x)\n    else:\n        odds.append(x)\n\nprint('list of evens:', evens)\nprint('list of odds:', odds)\n\nlist of evens: [12, 14, 16, 18, 20]\nlist of odds: [11, 13, 15, 17, 19]",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "06_sequences.html#الصف-tuple",
    "href": "06_sequences.html#الصف-tuple",
    "title": "7  المجموعة المرتبة",
    "section": "7.5 الصف (Tuple)",
    "text": "7.5 الصف (Tuple)\nالصف هو مثل القائمة (تسلسل)، لكن يفترق عنها في نقطة واحدة: أنه غير قابل للتغيير.\nعدا ذلك، كل ما ينطبق على القائمة ينطبق أيضًا على الصف؛ إذ كلاهما يشتركان في خاصية كونهما تسلسل.\nبدلاً من الأقواس المربعة []، يستخدم الصف الأقواس المنحنية ():\n\nt1 = ()        # empty tuple\nt2 = (1,)      # tuple with one item\nt3 = (1, 2, 3) # tuple with three items\nt4 = ('abb', 1, 2.0, True) # tuple with different types\n\nيمكن أيضًا إنشاء الصف بوسائل:\n\nالدمج: باستخدام معامل +\nالتكرار: باستخدام معامل *\n\n\nt5 = (1, 2, 3) + (4, 5)\nt6 = t5 * 2\nprint(t5)\nprint(t6)\n\n(1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n\nلو حاولت تغيير عنصر في الصف، ستحصل على خطأ\n\nt1 = (10, 20, 30, 40, 50)\nt1[0] = 100\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[23], line 2\n      1 t1 = (10, 20, 30, 40, 50)\n----&gt; 2 t1[0] = 100\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nرسالة الخطأ تخبرنا أننا لا نستطيع تغيير قيمة عنصر في هذا الجمع.\nكما ستلاحظ عدم وجود إجراءات الحذف والإضافة ونحوها.\n\nتحويل list &lt;-&gt; tuple\nيمكن تحويل القوائم إلى جموع والعكس باستخدام الإجراءات list() و tuple().\n\nl1 = [10, 20, 30, 40, 50]\nt1 = tuple(l1)\nl2 = list(t1)\nprint(t1)\nprint(l2)\n\n(10, 20, 30, 40, 50)\n[10, 20, 30, 40, 50]\n\n\nمن المهم ملاحظة أن الإجراءات tuple() و list() تُنشئ كائنًا جديدًا، ولا تقوم فعليًا بتحويل الكائن في مكانه. لذا، تبقى l1 قائمة وتبقى t1 صفًا.\nالقوائم أكثر قدرة، فأين نستخدم الصف؟ يستخدم المبرمجون الأنواع غير القابلة للتغيير عندما يريدون توصيل أن البيانات لا ينبغي تغييرها. هذا مفيد بشكل خاص عند تمرير البيانات في البرنامج، حيث يمكن تمريرها دون الخوف من تغييرها.\n\n\nإنتاج صف من نتيجة إجراء\nكما أن الإجراءات تأخذ مجموعة مدخلات، يمكن أيضًا أن تنتج مجموعة مخرجات، وذلك باستخدام النوع tuple (صف):\nعلى سبيل المثال، هذا الإجراء يقسم سلسلة إلى جزئين بناءً على نسبة معينة:\n\ndef split_data(seq, ratio):\n    idx = int(len(seq) * ratio)\n    return seq[:idx], seq[idx:]\n\nنختبر الإجراء ونلاحظ أن الناتج من نوع صف (tuple). فنستعمل التعيين المتعدد لاستخراج القيم من الصف:\n\nmy_data = list(range(1, 10 + 1))\nt = split_data(my_data, 0.80)\n\nprint(type(t))\na, b = t\nprint(a, b)\n\nassert a == [1, 2, 3, 4, 5, 6, 7, 8]\nassert b == [9, 10]\n\n&lt;class 'tuple'&gt;\n[1, 2, 3, 4, 5, 6, 7, 8] [9, 10]",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>المجموعة المرتبة</span>"
    ]
  },
  {
    "objectID": "07_sets.html",
    "href": "07_sets.html",
    "title": "8  المجموعة الرياضية",
    "section": "",
    "text": "المجموعة الرياضية (set) تحوي أشياء فريدة بغير ترتيب معيَّن. أما نظيرها غير القابل للتغيير فهو: (frozenset).\nتدعم المجموعة الرياضة لكونها مجموعة (Collection) العمليات التالية:\n\nمعرفة الطول: len(s)\nالتكرار: for x in s\nالعضوية: x not in s\n\nباعتبارها مجموعة غير مرتبة، فإن set لا تسجل موقع العنصر أو ترتيب إدراجه. وبالتالي، فإنها لا تدعم الإشارة (xs[i]) أو التقطيع (xs[i:j]) أو أي سلوك يشبه المتسلسلات. لاحظ الخطأ التالي:\n#| error: true\nxs = {10, 20, 30}\nxs[0]\nمثال لاستعمال العضوية:\nlanguages = {\"Arabic\", \"English\"}\nif 'Python' not in languages:\n    print('you need to add Python to your languages!')\nباعتبارها مجموعة قابلة للتغيير (Mutable Set)، فهي تدعم الإجراءات التالية:\n\nالإضافة: add\nالحذف: discard\nأخذ عنصر عشوائي: pop\nالمحو: clear\n\nسميناها رياضية لأنها تدعم عمليات:\n\nالتقاطع والاتحاد والفرق، والفرق التماثلي\nوكذلك تحقق: (الجزئية والشمول والانفاصل) .. المعروفة في الرياضيات.\n\nوهذا الكود مثال لجميع هذه العمليات:\n\nset1 = {1, 2, 3, 4, 5}\nset2 =          {4, 5, 6, 7, 8}\n\nunion = set1 | set2\nassert union == {1, 2, 3, 4, 5, 6, 7, 8}\n\nintersection = set1 & set2\nassert intersection == {4, 5}\n\ndiff1 = set1 - set2\nassert diff1 == {1, 2, 3}\n\ndiff2 = set2 - set1\nassert diff2 == {6, 7, 8}\n\nsymmetric_difference = set1 ^ set2\nassert symmetric_difference == {1, 2, 3, 6, 7, 8}\n\nنصيحة: من الأفضل استعمال اسم الإجراء بدلاً من العلامة التي تقابله حيث أنها تقبل أي نوع من المتكررات (Iterables) وليس المجموعات الرياضية فقط (set).\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nالاتحاد\nset1 | set2\nset1.union(set2)\n\n\nالتقاطع\nset1 & set2\nset1.intersection(set2)\n\n\nالفرق\nset1 - set2\nset1.difference(set2)\n\n\nالفرق التماثلي\nset1 ^ set2\nset1.symmetric_difference(set2)\n\n\n\nوكذلك لدينا إجراءات تحقق الجزئية والشمول والانفصال:\n\n\n\n\n\n\n\n\nالعملية\nالعلامة\nالإجراء المكافئ\n\n\n\n\nتحقق الجزئية\nset1 &lt;= set2\nset1.issubset(set2)\n\n\nتحقق الشمول\nset1 &gt;= set2\nset1.issuperset(set2)\n\n\nتحقق الانفصال\nlen(set1 & set2) == 0\nset1.isdisjoint(set2)\n\n\n\nوهذا مثال لاستعمالها:\n\nset1 = {'A', 'B', 'C'}\nset2 = {'A', 'B', 'C', 'D', 'E'}\nset3 = {'سين', 'جيم', 'قاف'}\n\nassert (set1 &lt;= set2) == set1.issubset(set2)\nassert (set2 &gt;= set1) == set2.issuperset(set1)\nassert (\n    set3.isdisjoint(set1 | set2) ==\n    (len(set3 & (set1 | set2)) == 0)\n)\n\nوتستعمل كذلك لإزالة العناصر المتكررة في أي مجموعة، نحو الكود التالي. فإننا نحول القائمة إلى مجموعة رياضية فتزول تلك العناصر تلقائيًّا، ثم نعيدها كما كانت:\n\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nunique_numbers = list(set(numbers))\nprint(unique_numbers)\n\n[1, 2, 3, 4, 5]\n\n\nوكذلك من الصف:\n\nt = (1, 2, 2, 3, 4, 4, 5)\nunique_t = tuple(set(t))\nprint(unique_t)\n\n(1, 2, 3, 4, 5)\n\n\nوكذلك لمعرفة الكلمات الفريدة في النص. فمعالجة النصوص أمر لابد منه لتحليلها، وهذا مثال على كيفية استخدام المجموعة الرياضية للعثور على الكلمات الفريدة في النص. كذلك نستعمل مجموعة الكلمات الوقفية (stop_words) لإزالتها من النص. ونقوم بتنظيف النص من العلامات الترقيمية باستعمال الإجراء .replace(). ونقوم بتحويل النص إلى حروف صغيرة بواسطة الإجراء .lower():\n\nstop_words = {'is', 'a', 'to', 'so', 'can', 'it', 'the', 'be', 'not'}\n\ntext = \"Python is a high-level computer programming language. Compared to human language, Python is unambiguous so a computer can interpret it one way.\"\n\n# clean the text\nxs = text.lower()\nxs = xs.replace('.', '')\nxs = xs.replace(',', '')\nclean_text = xs\n\nunique_words = set(clean_text.split())\nimportant_words = unique_words - stop_words\n\nfor w in sorted(important_words):\n    print(w)\n\ncompared\ncomputer\nhigh-level\nhuman\ninterpret\nlanguage\none\nprogramming\npython\nunambiguous\nway",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>المجموعة الرياضية</span>"
    ]
  },
  {
    "objectID": "08_mapping.html",
    "href": "08_mapping.html",
    "title": "9  الربط",
    "section": "",
    "text": "القاموس (dict) هو مجموعة مرتبة من المؤشرات الفريدة الدالة على أشياء. يمكن أن تكون المؤشرات من نوع: سلسلة نصية، أو رقم، أو صف وما هو قابل للتجزئة (Hashable). أما القيَم فتكون من أي نوع.\nيدعم القاموس العمليات التالية:\n\nمعرفة عدد المؤشرات: len(dict)\nالتكرار: for key in dict\nالعضوية: key not in dict\nالإشارة: dict[key] أو dict.get(key)\nنزع قيمة: dict.pop(key)\nإضافة أو تعديل رابط: dict[key] = value\nإضافة أو تعديل مجموعة روابط: dict.update(new_data)\nالحذف: del dict[key]\n\nيعرف القاموس على النحو التالي:\n\ndata = {'key1': 'value1', 'key2': 'value2'}\n\nلكن حين تكثر القيم نفردها على الأسطر لتكون أوضح للقراءة (وليس هذا بلازم):\n\ndata = {\n    'key1': 'value1',\n    'key2': 'value2',\n}\n\nوهنا نمثل لبعض العمليات:\n\nassert data['key1'] == 'value1'\ndel data['key1']\nassert 'key1' not in data\n\nوهنا نستعرض مجموعة من الاستعمالات لشكل القاموس. أولاً كقاموس بالمعنى الذي يشير إليه اللفظ (الكلمة ومعناها).\n\nالكلمة ومعناها\nنفترض أن لدينا قاموسًا يحتوي على ترجمة بعض الكلمات من الإنجليزية إلى العربية:\n\nenglish_to_arabic = {\n    'apple': 'تفاحة',\n    'banana': 'موزة',\n    'orange': 'برتقالة',\n}\n\nأو الاختصارات إلى الكلمة التامة:\n\nabbreviations = {\n    'SAR': 'Saudi Riyal',\n    'KSA': 'Kingdom of Saudi Arabia',\n    'ASAP': 'As Soon As Possible',\n    'FYI': 'For Your Information',\n}\n\n\n\nحفظ معلومات المستخدم\nوهذا مثال على استعمال القاموس لتخزين معلومات شخص. لاحظ أن القيمة المقابلة لكل مؤشر قد تكون من أي نوع في بايثون، تمامًا مثل ما تُسنِد قيَم لمعرَّفات. فلدين النص والرقم والقاموس (داخل القاموس) والقيَم الثنائية (True, False) والقائمة [ ] (داخل القاموس).\n\nperson = {\n    'name': 'Adam',\n    'language': 'Arabic',\n    'phone': '966xxxxxxxxx',\n    'last_updated': '2021-09-01',\n    'age': 25,\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\n\n\n\nسلة المشتريات\nنفترض أن لدينا سلة تحتوي على مشتريات العميل (basket)، ونريد حساب القيمة الإجمالية لها، ولدينا قائمة بأسعار الفواكه. فنعرف الأسعار على أنها قاموس prices بحيث يشير اسم الفاكهة إلى سعرها (قيمتها المالية).\n\nprices = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nbasket = ['apple', 'apple', 'banana', 'orange', 'banana']\n\nنحتاج أن نأتي على السلة عنصرًا عنصرًا، ونجمع قيمة كل فاكهة إلى المجموع الكلي:\n\ntotal = 0\n\nfor fruit in basket:\n    total += prices[fruit]\n\nprint(total)\n\n55\n\n\n\n\nالذاكرة القريبة (Cache)\nوهي الذاكرة التي تحتفظ بنتائج العمليات المتكررة (خصوصًا إذا كانت خوارزميات معقَّدة) حتى لا نحتاج لحسابها كل مرة؛ فنقتصد في موارد المعالجة في مقابل توظيف موارد الذاكرة (والتخزين).\n\nfactorial_table = {\n    0: 1,\n    1: 1,\n    2: 2,\n    3: 6,\n}\n\ndef factorial(n):\n    if n not in factorial_table:\n        factorial_table[n] = n * factorial(n - 1)\n    return factorial_table[n]\n\nبل إن بايثون توفر هذه الخاصية للدوال عن طريق المزيِّن (decorator) @functools.lru_cache، هكذا:\n\nimport functools\n\n@functools.lru_cache\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nلاحظ عدم الحاجة لتعريف القاموس factorial_table، بل يقوم المزيِّن هو بذلك تلقائيًّا.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>الربط</span>"
    ]
  },
  {
    "objectID": "09_strings.html",
    "href": "09_strings.html",
    "title": "10  النصوص",
    "section": "",
    "text": "10.1 تعريف النصوص\nقيمة النص تحدد:\nمثلاً:\nname = 'Adam'\naddress = \"Riyadh, Saudi Arabia\"\nولاحظ هذا النص الذي يبتدئ في السطر الأول ويتمد لأربعة أسطر:\nmessage = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\nprint(message)\n\nSalam everyone,\nI hope you are enjoying the course,\n\nThank you.\nولكون النص تسلسلاً فإنه يدعم جميع عمليات التسلسل السابقة ذكرها (انظر فصل التسلسل). وهو فوق ذلك يدعم عمليات خاصلة بتسلسل الأحرف.\ns = 'Arabian'\n\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_strings.html#تعريف-النصوص",
    "href": "09_strings.html#تعريف-النصوص",
    "title": "10  النصوص",
    "section": "",
    "text": "بعلامة اقتباس مفردة: 'السلام عليكم!'\nبعلامة اقتباس مزدوجة: \"السلام عليكم!\" وليس بينهما فرق تمامًا.\nبعلامة اقتاس مكررة ثلاثة مرات: \"\"\"السلام عليكم!\"\"\" وذلك للنصوص التي تمتد على أكثر من سطر.\n\n\n\n\n\n\n\nالإشارة: s[i]\nمعرفة موضع شيء (إن وجد): s.index(x)\nعد تكرارات شيء: s.count(x)\nمعرفة الطول: len(s)\nالتكرار: for x in s\nالعضوية: x not in s\n\n\n 0   1   2   3   4   5   6   7\n +---+---+---+---+---+---+---+\n | A | r | a | b | i | a | n |\n +---+---+---+---+---+---+---+\n-7  -6  -5  -4  -3  -2  -1\n\nجرب\n\ns[1:5]\ns[1:5:2]\ns[::2]\ns[::-1]\n\nلاحظ أن هذا يتحقق كما لو عرفنا صفًّا بالأحرف هذه نفسها:\n\ns = ('A', 'r', 'a', 'b', 'i', 'a', 'n')\nfirst = s[0]\nlast = s[-1]\nprint(first + last)\n\nAn\n\n\nفالنص ، مثل الصف وبخلاف القائمة، غير قابل للتغيير. فلو حاولت تغيير حرف في النص. ستحصل على خطأ:\n\ns = 'Arabian'\ns[0] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 s = 'Arabian'\n----&gt; 2 s[0] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nلكن يمكنك تعديل النص بإنشاء نص جديد:\n\ns = 'Arabian'\ns = 'a' + s[1:]\nprint(s)\n\narabian\n\n\nلاحظ أننا أسندنا النص الجديد إلى المتغير s، وهذا يعني أننا لم نعدل النص الأصلي بل أنشأنا نصًا جديدًا.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_strings.html#العمليات-الخاصة-بالنصوص",
    "href": "09_strings.html#العمليات-الخاصة-بالنصوص",
    "title": "10  النصوص",
    "section": "10.2 العمليات الخاصة بالنصوص",
    "text": "10.2 العمليات الخاصة بالنصوص\nلاستبدال جزء من النص، نستخدم إجراء .replace():\n\ns = 'Arabian'\ns = s.replace('ian', 'y')\nprint(s)\n\nAraby\n\n\nكما لدينا علميات .strip() لإزالة المسافات البيضاء من بداية ونهاية النص.\n\nassert '  Arabian  '.strip() == 'Arabian'\n\nوكذلك لدينا عمليات البحث:\n\nالتحقق من البدء والنهاية وما بينهما: .startswith(prefix) و .endswith(suffix) أو sub in string وهي أعم.\nلمعرفة موضع أول ظهور لسلسلة معيَّنة من الأحرف داخل النص .find()\n\n\ns = 'Arabian'\nassert s.startswith('A')\nassert not s.startswith('a')\nassert s.endswith('n')\nassert 'rabia' in s\nassert s.find('a') == 2\n\nانظر ملحق أنماط السلاسل للتعمق في علميات البحث والاستبدال بأنماط معقدة.\nالفصل والوصل:\n\nفصل النص لقائمة: list.split(seperator)\nدمج القائمة إلى نص: seperator.join(list)\n\n\ncsv = \"Adam,25,Riyadh\"\nassert csv.split(',') == ['Adam', '25', 'Riyadh']\n\n\ncsv = \"\"\"name,age,city\nAdam,25,Riyadh\nBelal,30,Jeddah\nCamal,35,Dammam\n\"\"\"\n\ncsv = csv.strip()\n\ndata = []\nfor line in csv.split(sep='\\n'):\n    d = line.split(sep=',')\n    data.append(d)\ndata\n\n[['name', 'age', 'city'],\n ['Adam', '25', 'Riyadh'],\n ['Belal', '30', 'Jeddah'],\n ['Camal', '35', 'Dammam']]\n\n\nوهذا مثال للوصل:\n\ndata = ['Adam', '25', 'Riyadh']\ncsv = ','.join(data)\nassert csv == 'Adam,25,Riyadh'\n\nتفسير الأرقام المكتوبة كسلسلة من الحروف، وهذا تكثر الحاجة إليه عندما نقرأ ملفات أو نتعامل مع بيانات مُدخلة من المستخدم، إذ دائمًا ما يكون الإدخال على شكل نصوص:\n\nint(x) لتحويل سلسلة نصية إلى عدد صحيح.\nfloat(x) لتحويل سلسلة نصية إلى عدد عشري.\n\nلاحظ ناتج عملية جمع رقمين مكتوبين كنصوص:\n\nx = '20'\ny = '40'\nprint(x + y)\n\n2040\n\n\nالواجب تحويلهما إلى أعداد أولاًً:\n\nx2 = float(x)\ny2 = float(y)\nprint(x2 + y2)\n\n60.0\n\n\nوهنا عمليات خاصة بالنصوص الإنجليزية:\n\nupper() لتحويل النص إلى حروف كبيرة.\nlower() لتحويل النص إلى حروف صغيرة.\ncapitalize() لتحويل الحرف الأول إلى كبير.\ntitle() لتحويل النص إلى حالة عنوان.\n\n\nname = 'Adam ibraheeM'\nprint(name.upper())\nprint(name.lower())\nprint(name.capitalize())\nprint(name.title())\n\nADAM IBRAHEEM\nadam ibraheem\nAdam ibraheem\nAdam Ibraheem\n\n\nوانظر مستندات النصوص لمعرفة كافة الإجراءات الممكنة على النصوص.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_strings.html#تنسيق-السلاسل-النصية",
    "href": "09_strings.html#تنسيق-السلاسل-النصية",
    "title": "10  النصوص",
    "section": "10.3 تنسيق السلاسل النصية",
    "text": "10.3 تنسيق السلاسل النصية\nنستعرض ثلاث طرق لدمج السلاسل النصية في بايثون:\n\nالأولى: تحويل الشيء إلى نص قبل دمجه مع النص..\nالثانية: استعمال فراغات {} مع الإجراء .format() لتمرير ما يحل فيها.\nالثالثة: استعمال f-string بأن تضع الحرف f قبل علامة التنصيص الأولى، ليقبل النص وضع القيم مباشرة داخل القواس المعكوفة {}. وهي الطريقة التي نفضلها.\n\n\nname = \"John\"\nlvl = 300\n\nx1 = \"I am \" + name + \" and I want to reach level \" + str(lvl) # + operator\nx2 = \"I am {} and I want to reach level {}\".format(name, lvl)  # .format() method\nx3 = f\"I am {name} and I want to reach level {lvl}\"            # f-strings\nassert x1 == x2 == x3\nprint(x1)\n\nI am John and I want to reach level 300\n\n\n\nجرب\nاطبع الجملة \"Hello, my name is John Doe. and I am 30 years old\". باستخدام المتغيرات first_name، last_name، و age عبر الطرق الثلاث المذكورة آنفًا:",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_strings.html#ترميز-الحروف",
    "href": "09_strings.html#ترميز-الحروف",
    "title": "10  النصوص",
    "section": "10.4 ترميز الحروف",
    "text": "10.4 ترميز الحروف\nترميز الحروف هي عملية تعيين أرقام للأحرف الرسومية مما يسمح بتخزينها ونقلها وتحويلها باستخدام الحواسيب الرقمية.\nرموز ASCII تحتوي على 128 حرف للغة الإنجليزية وبعض علامات الترقيم. منها 95 فقط هي أحرف قابلة للطباعة أما البقية فتسمى أحرف تحكُّم (مثل حرف السطر الجديد \\n ، وحرف الرجوع لبداية السطر \\r).\nثم امتدت عن طريق رموز ANSII لتغطي أحرف إضافية (من 128 إلى 255) وهي الأحرف الاتينية للغات الأخرى.\nلنستكشف السلاسل عن طريق حزمة من المكتبة الأساسية string. الآتي الأحرف اللاتينية الكبيرة والصغيرة، وعلامات الترقيم:\n\nimport string\n\nprint(string.ascii_letters)\nprint(string.punctuation)\n\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n!\"#$%&'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_strings.html#ترميز-unicode",
    "href": "09_strings.html#ترميز-unicode",
    "title": "10  النصوص",
    "section": "10.5 ترميز Unicode",
    "text": "10.5 ترميز Unicode\nواليوم رموز Unicode تحتوي على أكثر من مليون حرف لتغطية لغات العالم كافة: اللاتينية، اليونانية، السيريلية، الأرمنية، العبرية، العربية، السريانية، الثانا، الديفاناغارية، البنغالية، الجورموخية، الأورية، التاميلية، التيلوغوية، الكانادية، المالايالامية، السنهالية، التايلاندية، اللاوية، التبتية، الميانمارية، الجورجية، الهانغول، الإثيوبية، الشيروكية، الرموز الكندية الأصلية، الخميرية، المنغولية، الهان (الأيدوغراف الياباني، الصيني، الكوري)، الهيراغانا، الكاتاكانا، واليي. المصدر. وما يزال أول 128 حرف منها متطابق مع رموز ASCII.\n\nمثال\nماذا يحصل لو كتبنا حروف عربية ثم حاولنا حفظ الملف بترميز ASCII ولم نحفظه بترميز Unicode؟\n\n\n\nبرنامج نوتباد في وندوز بكلام عربي يظهر بشكل استفهامات\n\n\nالخطأ يقول: “This file contains characters in Unicode format which will be lost if you save this file as an ANSI encoded text file. To keep the Unicode information, click Cancel below and then select one of the Unicode options from the Encoding drop down list. Continue?”",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_strings.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "href": "09_strings.html#كيف-يتم-تمثيل-النصوص-في-بايثون",
    "title": "10  النصوص",
    "section": "10.6 كيف يتم تمثيل النصوص في بايثون؟",
    "text": "10.6 كيف يتم تمثيل النصوص في بايثون؟\nتمثيل النصوص في بايثون يكون عن طريق النوع str؛ يُعرَّف بكتابة سلسلة من الأحرف لكن في الواقع تتحول إلى سلسلة من رموز Unicode (أي: أرقام). هذا يعني أنها قد تكون سلسلة رموز لاتينية أو عربية أو صينية أو غير ذلك مما تحويه رموز Unicode.\nالدالة المدمجة ord() تقوم بتحويل الحرف إلى رقم الرمز. بينما chr() تعكس ذلك (من الرمز إلى الحرف).\nعلى النقيض من سي وجافا؛ لا يوجد نوع خاص بالحرف الواحد (char) في بايثون.\n\nprint(ord(\"A\"), ord(\"Z\"))\nprint(chr(65), chr(90))\nprint(ord(\"a\"), ord(\"z\"))\nprint(ord(\"0\"), ord(\"9\"))\n\n65 90\nA Z\n97 122\n48 57\n\n\nماذا عن الحروف العربية؟ أين تقع في أرقام ترميز Unicode؟\n\n# Arabic Unicode points are between 1536 and 1791\nprint(ord(\"أ\"), hex(ord(\"أ\")))\nprint(ord(\"ب\"), hex(ord(\"ب\")))\nprint(ord(\"ي\"), hex(ord(\"ي\")))\nprint(ord('َ'), hex(ord('َ')))\nprint(ord('ُ'), hex(ord('ُ')))\n\n1571 0x623\n1576 0x628\n1610 0x64a\n1614 0x64e\n1615 0x64f\n\n\nإذا أردنا أن نعرف أرقام الحروف في نصٍّ ما، فيمكن أن نستعمل التكرار على النحو التالي:\n\ndef get_unicode_points(s):\n    codes = []\n    for c in s:\n        codes.append(ord(c))\n    return codes\n\nprint(get_unicode_points('Arabian'))\nprint(get_unicode_points('السَّلَامُ عَلَيْكُمْ'))\n\n[65, 114, 97, 98, 105, 97, 110]\n[1575, 1604, 1587, 1614, 1617, 1604, 1614, 1575, 1605, 1615, 32, 1593, 1614, 1604, 1614, 1610, 1618, 1603, 1615, 1605, 1618]\n\n\nفهذه هي الحروف في الواقع، إلا أننا نتعامل مع شيء مجرَّد في لغات البرمجة العالية غالبًا ما يسمى str.\nراجع ويكيبيديا: النص العربي في Unicode لمزيد من التفاصيل.\n\nالأحرف البيضاء\nالأحرف في الأجهزة الرقمية على نوعين:\n\nأحرف مطبوعة: مثلاً: الأحرف اللاتينية والأرقام وعلامات الترقيم\nأحرف تحكُّم: مخفيَّة؛ والغرض منها التحكم بمعالج هذا النص\n\nلعرض الأحرف القابلة للطباعة في محارف آسكي (ASCII)، لدينا المعرَّف printable من مكتبة string:\n\nimport string\nstring.printable\n\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n\n\nكانت أحرف التحكُّم تستخدم لرن جرس الآلة الطابعة ، والتحكم بها ، لكن اليوم الذي يُستخدم منها غالبًا هو الأحرف البيضاء (Whitespace Characters) ويشمل ذلك الأحرف التالية:\n\nspace: \\s ويمثل المسافة التي بين الكلمات\ntab: \\t ويمثل المسافة التي بين أعمدة الجداول\nlinefeed: \\n تعليمة سطر جديد\nreturn: \\r تعليمة العودة لبداية السطر الجديد\nformfeed: \\f تعليمة الصفحة الجديدة\nvertical tab: \\v تعليمة العمود الجديد\nbackspace: \\b تعليمة عودة المؤشر بمقدار حرف واحد للكتابة فوق الحرف السابق\n\nأما الثلاثة الأخيرة فقد كانت تستخدم فيما مضى، لكن اليوم المستخدم هو الأربعة الأولى فقط. ويجدر بالذكر أن ملفات نصوص نظام ويندوز تستعمل \\r\\n للانتقال لسطر جديد بينما تستعمل الأنظمة الأخرى \\n فقط.\nتذكر أن بايثون تعتمد على space و tab للمسافة البادئة للسطر (indentation)، لتحديد نطاقات الكود بحسب المحاذاة العمودية.\n\nimport string\nstring.whitespace\n\n' \\t\\n\\r\\x0b\\x0c'\n\n\nيهمنا هنا الأحرف البيضاء لأنها تظهر في النصوص وقد تكون مزعجة عند معالجتها. لنلقي نظرة على ثلاثة من الأحرف البيضاء: المسافة (space)، التبويب (tab)، وتعليمة السطر الجديد (linefeed).\n\n# Tab character: \"\\t\"\nprint('A\\tB')\n\nA   B\n\n\n\n# Space character: \" \"\nprint('   A            B   ')\n\n   A            B   \n\n\n\n# Newline character: '\\n'\nprint('A\\nB')\n\nA\nB\n\n\nلاحظ أن طول السلسلة النصية هو عدد الأحرف في السلسلة، سواء كانت قابلة للطباعة (printable) أو أحرف بيضاء (whitespace).\n\nassert len('A B') == 3\nassert len('A\\tB') == 3\nassert len('A\\nB') == 3\n\n\n\n.strip()\nلاحظ أن هذه الدالة ستزيل الأحرف البيضاء من بداية ونهاية السلسلة النصية، ولكن ليس الأحرف البيضاء في منتصف السلسلة\nقبل:\n\ntext = '\\t hello    world \\n\\n\\n'\nprint(text)\n\n     hello    world \n\n\n\n\n\nبعد:\n\nprint(text.strip())\n\nhello    world\n\n\n\n\n.split()\nانظر: Splitlines\n\ntext = '''\nHello\nWorld\n\nHow are you?\n'''\n\nإذا تركنا الكود كما هو في السطر من غير print فإن ذلك يعرض السلسلة النصية كما هي (بما في ذلك أحرف المسافات البيضاء)\n\ntext\n\n'\\nHello\\nWorld\\n\\nHow are you?\\n'\n\n\nأما إذا وضعنا print فإنه يطبع الأحرف المرئية ، وينسِّقُ المظهر بناءً على أحرف التحكُّم المخفية:\n\nprint(text)\n\n\nHello\nWorld\n\nHow are you?\n\n\n\n\ntext.splitlines()\n\n['', 'Hello', 'World', '', 'How are you?']\n\n\nإذا لم نحدد محدد الفاصل فإن الفاصل الافتراضي هو المسافة.\n\nprint(\"Hello, world\".split())\n\n['Hello,', 'world']\n\n\nهنا نحدد الفاصل أنه الحرف \"l\":\n\nprint(\"Hello, world\".split(\"l\"))\n\n['He', '', 'o, wor', 'd']\n\n\nلإزالة الأحرف البيضاء جميعها، يمكن أن نستعمل التكرار على النحو التالي:\n\ntext = '\\t hello    world \\n\\n\\n'\nsp = text.split()\nprint('split:', sp)\nclean = ' '.join(sp)\nprint('clean:', clean)\n\nsplit: ['hello', 'world']\nclean: hello world\n\n\nالفصل في الداخل ينتج قائمة من النصوص، بعضها فارغ لوجود الأحرف البيضاء المتتالية، فلا تتضمن في القائمة الناتجة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "09_strings.html#الطباعة",
    "href": "09_strings.html#الطباعة",
    "title": "10  النصوص",
    "section": "10.7 الطباعة",
    "text": "10.7 الطباعة\n\nحروف التحكم بآلة الطباعة\nيسمّى الحرف \\r بالعودة للبداية لأنه يعني أمر يقوم بإرجاع المؤشر إلى بداية السطر.\nكانت آلة الطباعة قديمًا يتحرك رأس الطباعة فيها بعد طباعة كل حرف. ثم عندما ينتهي السطر، يجب على الشخص أن يقوم بعمليتين:\n\nالضغط على المفتاح الذي يرفع الورقة بمقدار سطر (ويرمز له بالحرف \\r)\nالضغط على المفتاح الذي يرجع رأس الطباعة لبداية السطر (ويرمز له بالحرف \\n)\n\nوهما مستخدمان اليوم فيما يُعرض على الشاشة.\nفإجراء print في الحقيقة يضع سطرًا جديدًا (حرف \\n) في الوضع الافتراضي. فإن أردنا ألا يضعه، فنحدد العامل end الذي فيه على النحو التالي:\n\nprint('Hello', end='')\nprint('World', end='')\n\nHelloWorld\n\n\nلاحظ أننا جعلنا (end='') أي: لا نريده أن يضع حرفًا بعد طباعة النص. ولذلك ظهرت الكلمتان في نفس السطر.\nولو أردت أن تعيد الكتابة على نفس السطر، يمكنك أن تضع الحرف (\\r) الذي يأمر رأس الطباعة بالرجوع لبداية السطر. على النحو التالي:\n\nprint('123', end='\\r')\nprint('45')\n\n12345\n\n\nلاحظ أن النتيجة هي طباعة الحرفين 45 فوق الحرفين 12 مع بقاء الحرف الأخير 3 في الأخير. وذلك لرجوع رأس الطباعة.\nتستعمل هذه اللطيفة في تحديث العداد حتى يظهر على الشاشة وكأنه يزيد شيئًا فشيئًا. وذلك على النحو التالي (لاحظ أننا نستعمل time.sleep(t) حتى نمثِّل وجود عمليَّة تأخذ وقتًا طويلاً فحسب):\n\nimport time\n\nfor x in range(10 + 1):\n    time.sleep(0.20)\n    print(f'[{x}/10] ' + '===' * x + '&gt;', end='\\r')\n\n[0/10] &gt;[1/10] ===&gt;[2/10] ======&gt;[3/10] =========&gt;[4/10] ============&gt;[5/10] ===============&gt;[6/10] ==================&gt;[7/10] =====================&gt;[8/10] ========================&gt;[9/10] ===========================&gt;[10/10] ==============================&gt;",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>النصوص</span>"
    ]
  },
  {
    "objectID": "10_comprehension.html",
    "href": "10_comprehension.html",
    "title": "11  التعبير المختصر",
    "section": "",
    "text": "مما يميز لغة بايثون اختصاراتها التي نراها كثيرًا ما تستعمل؛ وسنتعلم اليوم كيف نعبر بها. فهي ليسَت أمرًا أساسيًّا في اللغة إلا أن كثرة استعمالها يوجب علينا فهمها (في حال استعملها غيرنا) إضافةً إلى أن فيها قوة تعبيرية جميلة.\nافترض أننا نريد حساب مربع كل عدد في قائمة، نستطيع كتابة ذلك المنطق بالشكل التالي:\n\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nإذا أردنا تفكيك ذلك فنقول: المُدخل قائمة، والمخرج قائمة. إذًا يمكن كتابة ذلك باختصار في سطرٍ واحد على النحو: قوس مربع متبوعًا بعبارة ناتجة متبوعًا بقطعة for وقد يكون متبوعًا بمرة أو أكثر من قطع for (للتكرار أكثر) أو if (للترشيح). وهذا مثال:\n\nsquares = [x ** 2 for x in range(10)]\n\nلو أردنا ترشيح الأعداد الزوجية من القائمة، نستطيع استعمال قطعة if في الاختصار على النحو التالي:\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nevens = [x for x in numbers if x % 2 == 0]\n\nندمج القطعتين (عبارة الناتج من التكرار مع قطعة التشريح if) لنحصل على مربع الأعداد الزوجية فقط:\n\nsquared_evens = [x ** 2 for x in numbers if x % 2 == 0]\n\nفهذه فيها ثلاثة:\n\nعبارة الناتج من التكرار: x ** 2 in this case\nfor قطعة التكرار: for x in numbers\nif قطعة الترشيح: if x % 2 == 0\n\nوإليك بعضالأمثلة الإضافية:\n\nvec = [-4, -2, 0, 2, 4]\n\nترشيح الأعداد الموجبة (لاحظ أن عبارة الناتج تأخذ المكرر مثل ما هو: x ولا تعدل عليه):\n\n[x for x in vec if x &gt;= 0]\n\n[0, 2, 4]\n\n\nهنا عبارة الناتج تستعمل الإجراء abs(x) لأخذ القيمة المطلقة (بحيث تحول السالب إلى رديفه الموجب):\n\n[abs(x) for x in vec]\n\n[4, 2, 0, 2, 4]\n\n\nوفي هذا المثال استعمال الإجراء المتعلق بكل ناتج نصي من التكرار على قائمة من النصوص:\n\nfreshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n[weapon.strip() for weapon in freshfruit]\n\n['banana', 'loganberry', 'passion fruit']\n\n\nقطعة الناتج هنا هي صفّ مكوَّن من الرقم ومربعه ، وذلك من تكرارٍ على range(6) والذي يبدأ من 0 وينتهي عند 5 كما نعرف:\n\n[(x, x ** 2) for x in range(6)]\n\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n\n\nلاحظ أن العبارة مبهمة إذا لم تحدد القوسين لتحديد الصف في العبارة الناتجة:\n\n[x, x ** 2 for x in range(6)]\n\n\n  Cell In[10], line 1\n    [x, x ** 2 for x in range(6)]\n     ^\nSyntaxError: did you forget parentheses around the comprehension target?\n\n\n\n\nيمكن استعمال اختصار من اختصار على النحو التالي. في هذا المثال نفرد قائمة مكونة من قوائم عددية، فنحوِّلها لتكون قائمة واحدة مكوَّنة من جميع هذه الأرقام:\n\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nإذا كتبناها من غير اختصار فشكلها كالتالي (لاحظ استعملنا المعرف flat لتجميع القيَم المفردة):\n\nflat = []\nfor elem in vec:\n    for num in elem:\n        flat.append(num)\nflat\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nوهذا مثال لحاصل الضرب الديكارتي بين مجموعتين رياضيتين:\n\ncolors = ['red', 'green']\nshapes = ['circle', 'square']\ncartesian_product = [(color, shape) for color in colors for shape in shapes]\ncartesian_product\n\n[('red', 'circle'),\n ('red', 'square'),\n ('green', 'circle'),\n ('green', 'square')]\n\n\nيمكن استعمال التعبيرات المختصرة أيضًا مع المجموعات الرياضية والقواميس!\nهذا مثال لاستخراج الكلمات (من غير تكرار) من قاموس من العبارات (ثلاثة عبارات). هذه العملية تستعمل كثيرًا في تحليل النصوص إذ نريد أن نعرف جميع الكلمات الواردة في مجموعة من النصوص، ولا نريد الكلمات المعهودة جدًّا (هنا نسميها stopwords)، كما أننا نستعمل .lower() في التعبير الناتج حتى لا يفرق بين الحروف في حالتيها الإنجليزية:\n\nstopwords = {'is', 'and', 'the', 'be', 'not'}\ndocuments = {\n    'Python': \"python is great and Python is easy\",\n    'Java': \"Java is verbose and java is popular\",\n    'JavaScript': \"JavaScript is for the web and javascript is everywhere\"\n}\n\nunique_words = {word.lower() for doc in documents.values() for word in doc.split()}\nunique_words - stopwords\n\n{'easy',\n 'everywhere',\n 'for',\n 'great',\n 'java',\n 'javascript',\n 'popular',\n 'python',\n 'verbose',\n 'web'}\n\n\nعكس قاموس بحيث تصبح الدلائل هي القيم والقيم هي الدلائل:\n\nidx2label = {\n    0: 'cat',\n    1: 'dog',\n    2: 'bird',\n}\n\nlabel2idx = {label: idx for idx, label in idx2label.items()}\nlabel2idx\n\n{'cat': 0, 'dog': 1, 'bird': 2}\n\n\nهنا مثال لقاموس من الفواكه، نريد ترشيح ما قيمته أقل من 20:\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\nfiltered_menu = {key: value for key, value in menu.items() if value &lt; 20}\nfiltered_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5}\n\n\nوهذا مثال أكثر تعقيدًا. نطبق خصم 20% فقط على العناصر التي يكون سعرها أعلى من المتوسط، مع الحفاظ على بقية الأسعار كما هي. لاحظ أن التعبير هنا هو تعيين شرطي: value * (1 - discount) if value &gt; avg_price else value وليس هو قطعة الترشيح (if)؛ إذ تلك تأتي في نهاية الجملة، بعد قطعة التكرار (for).\n\nmenu = {\n    'apple': 15,\n    'banana': 10,\n    'orange': 5,\n    'cantaloupe': 40\n}\n\navg_price = sum(menu.values()) / len(menu)\ndiscount = 0.20\n\ndiscounted_menu = {\n    key: value * (1 - discount) if value &gt; avg_price else value\n    for key, value in menu.items()\n}\ndiscounted_menu\n\n{'apple': 15, 'banana': 10, 'orange': 5, 'cantaloupe': 32.0}\n\n\nربما تكون هذه الأمثلة صعبة في البداية ، لكنها مع الممارسة تكون أسهل وأسهل.\nنلخص الصِّيَغ في كتابة الاختصارات لثلاثة أنواع مجموعات أساسية في بايثون:\n\nعبارة الاختصار للقائمة: [expression for item in iterable if condition]\nعبارة الاختصار للمجموعة الرياضية: {expression for item in iterable if condition}\nعبارة الاختصار للقاموس: {key: value for item in iterable if condition}",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>التعبير المختصر</span>"
    ]
  },
  {
    "objectID": "11_files.html",
    "href": "11_files.html",
    "title": "12  الملفات",
    "section": "",
    "text": "12.1 الملف في بايثون\nيجرِّد الملف أمرين أساسيين: القراءة: .read() والكتابة: .write() وذلك بعد فتحه open() كما يجب بعد الفراغ منه أن تغلقه بالأمر close() فهذه الأربعة هي ما يشكل الملف وهي فلسفة نظام يونكس (Unix) ومن حذا حذوه مثل نظام ماك (MacOS) بخلاف نظام ويندوز (Windows) فإنه لا يلتزم بذلك دائمًا.\nوقد تقع الكتابة عيْنًا على أحد ثلاثة منافذ يمثلها الملف:\nأما عملية القراءة .read() فتقع عيْنًا:",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "11_files.html#الملف-في-بايثون",
    "href": "11_files.html#الملف-في-بايثون",
    "title": "12  الملفات",
    "section": "",
    "text": "إلى منفذ تخزين وهي الملفات التي اعتدنا رؤيتها والضغط على أشكالها المختلفة بحسب نوعها مثلاً: data.csv, my_code.py, configuration.yaml.\nإلى مخرَج لوحة الأوامر ليظهر على الشاشة. وهو فرعان:\n\nمنفذ العادة وهو الذي توجَّه إليه الأحرف عندما نستعمل الإجراء print() (أو عندما تكتب اسم المعرَّف كآخر أمر في دفتر جوبتر فهو يستعمل الأمر display() ضمنيًّا)\nمنفذ الأخطاء وهو الذي توجَّه إليه رسالة الخطأ عادةً\n\nإلى منفذ مِقْبَس (Socket) للتواصل مع برنامج آخر سواءً  كان البرنامج في نفس الجهاز أو عبر الشبكة.\n\n\n\nمن منفذ تخزين (قرص تخزين أو ذاكرة دائمة)\nمن منفذ مدخلات لوحة الأوامر والذي يمكن إدخاله مثلاً عن طريق إجراء input()\nمن منفذ مقبس (الشبكة)",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "11_files.html#قراءة-الملفات-وكتابتها",
    "href": "11_files.html#قراءة-الملفات-وكتابتها",
    "title": "12  الملفات",
    "section": "12.2 قراءة الملفات وكتابتها",
    "text": "12.2 قراءة الملفات وكتابتها\nانظر توثيق قراءة وكتابة الملفات.\nأبسط طريقة للتعامل مع الملفات قراءةً وكتابةً هي باستعمال open(). فهكذا نقرأ الملف باستعمال file.read() بعد فتح الملف بوضع القراءة 'r' في open(mode='r'):\n\nf = open(file='datasets/example_root/a/a.txt', mode='r')\ncontent = f.read()\nf.close()\n\nprint(content)\n\nlorem ipsum dolfet\nweilfur badem zelfur\n\n\nوهكذا نكتب في الملف باستعمال file.write()، بعد فتح الملف بوضع الكتابة 'w' في open(mode='w'):\n\ncontent = \"\"\"Salam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\"\"\"\n\nf = open(file='datasets/example_root/a/zzz.txt', mode='w')\nf.write(content)\nf.close()\n\nprint(content)\n\nSalam everyone,\nI hope you are enjoying the course,\n\nThank you.\n\n\n\n\nإذا كنت تريد قراءة الملفات وكتابتها بشكل بسيط انظر: open(). -وإذا كنت تريد التعامل مع الملفات المؤقتة فانظر: tempfile.\nوكثير من عمليات التعامل مع الملفات والمجلدات تجدها في: shutil.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "11_files.html#المسار",
    "href": "11_files.html#المسار",
    "title": "12  الملفات",
    "section": "12.3 المسار",
    "text": "12.3 المسار\nأما الآن فحديثنا عن الوصول إلى الملفات ، والبحث عنها ، وتركيب المسار إليها، وهذا ما تحققه مكتبة pathlib.\nيجدر بالذكر أن مكتبة pathlib جاءت متأخرة في إصدار Python 3.4 لمعالجة الملفات بأسلوب البرمجة الشيئية (OOP)، بينما تستعمل مكتبة os التي سبقتها لأغراض متعددة فيما يخص نظام التشغيل (os = Operating System) من ضمنها خُصِّصَت os.path للتتعامل مع نظام الملفات إلا أنها كُتِبَت بأسلوب إجرائي تأسيًّا بلغة سي (C)، فهي منخفضة المستوى (تتعامل مباشرة مع bytes و str) بالمقارنة بالبرمجة الشيئية الأعلى في التجريد؛ وهو ما نفضله. انظر مقارنة pathlib بوحدات os و os.path.\nلاستعراض عمليات المكتبة، أنشأنا مُسبقًا شجرة تبدأ من مجلد اسمه example_root تجدها داخل datasets في مستودع مشروع الكتاب على النحو التالي:\n\n\n\n\n\ngraph LR\n    A[example_root]\n    A --&gt; B[something.txt]\n    A --&gt; C[a]\n    A --&gt; D[b]\n    A --&gt; E[c]\n    C --&gt; F[\"a.txt\"]\n    C --&gt; G[\"A_domestic_cat.jpg\"]\n    C --&gt; I[\"zzz.txt\"]\n    D --&gt; J[\"A_yellow_and_white_cat.jpg\"]\n    D --&gt; L[b.txt]\n    D --&gt; M[\"DSC0532_(9120523417).jpg\"]\n    E --&gt; O[\"c.txt\"]\n    E --&gt; P[c_inner]\n    P --&gt; Q[\"inner.txt\"]\n\n\n\n\n\n\nالشيء الأساسي الذي نتعامل معه في هذه المكتبة هو المسار (Path):\n\nfrom pathlib import Path\n\nيُنشأ المسار من نص أو مجموعة نصوص بينها علامة / (وهي في الأصل علامة قسمة إذا وُضعت بين الأرقام) التي تعني ضم النص إلى المسار.\nلاحظ استعمال النص الخام r'' لكون الحرف \\ له معنىً خاص في نصوص بايثون، فهو يستعمل مثلا \\n للانتقال لسطر جديد. لكن حين نستعمل r'' فإن الحرف \\ لا يعني شيئًا خاصًا.\n\nassert (\n    Path('datasets/example_root/a/a.txt') ==\n    Path(r'datasets\\example_root\\a\\a.txt') ==\n    Path('datasets') / 'example_root' / 'a' / 'a.txt'\n)\n\nملاحظة، عند نسخ المسارات في نظام ويندوز (Windows)، يجب عليك إما استبدال الشرطات المائلة العكسية \\ بالشرطات المائلة الأمامية / أو استخدام السلاسل النصية الخام r'' لتجنب المشاكل (كما فعلنا أعلاه).\nوهكذا نستطيع استعمال الكائن Path في إجراء open(file=path) للتعامل مع الملفات:\n\np = Path('datasets/example_root/a/a.txt')\n\nf = open(file=p, mode='r')\ncontent = f.read()\nf.close()\n\nprint(content)\n\nlorem ipsum dolfet\nweilfur badem zelfur\n\n\nالمسار له شكلان: مسار مطلق (Absolute Path) ومسار نسبي (Relative Path).\nأما المسار المطلق فهو الذي يبدأ من الجذر (مثل /home/user/Downloads لاحظ علامة الخط المائل في بداية المسار) إذ يحدد المسار بشكل لا يقبل التأويل.\nأما المسار النسبي فيعود تأويله للمكان الذي يبتدأ البحث عنه منه (مثل datasets/example_root/a/a.txt لاحظ عدم وجود علىامة الخط المائل في بداية المسار)، ومثله. وقد تستعمل علامة ./ للإشارة للمجلد الحالي. أما علامة ../ فتشير إلى المجلد الأب.\nولأن الملف يعتبر مدير سياق (Context Manager) فيمكن استعمال قطعة with ليتم إغلاق المصدر المفتوح تلقائيًّا عند الخروج من القطعة (المحددة بالمحاذاة). وذلك على النحو التالي:\n\np = Path('datasets/example_root/a/a.txt')\n\ncontents = ''\nwith open(file=p, mode='r') as f:\n    contents = f.read()\nprint(contents)\n\nlorem ipsum dolfet\nweilfur badem zelfur\n\n\nبدلاً من قراءة الملف جملة واحدة .read() نستطيع القراءة سطرًا بسطر عن طريق الإجراء .readline() على النحو التالي:\n\np = Path('datasets/example_root/a/a.txt')\n\nwith open(file=p, mode='r') as f:\n    for i, line in enumerate(f, start=1):\n        line = line.rstrip()\n        print(f'Line {i}: {line}')\n\nLine 1: lorem ipsum dolfet\nLine 2: weilfur badem zelfur\n\n\nتستعمل .rstrip() لإزالة حرف انتقال السطر \\n .\n\nالمجلدات\nانظر قراءة المجلدات.\nلعرض قائمة بمحتوى المجلد، نستعمل المكرر الناتج من إجراء .iterdir() ونكرر عليه، وهو بدورِه يُنتج في كل كرةٍ مساراً (x). وهذا المسار يُمكن التحقق من أنه يشير إلى مجلد أو لا (x.is_dir()) على النحو التالي:\n\np = Path('datasets/example_root/')\ndirs = [x for x in p.iterdir() if x.is_dir()]\ndirs\n\n[WindowsPath('datasets/example_root/a'),\n WindowsPath('datasets/example_root/b'),\n WindowsPath('datasets/example_root/c')]\n\n\n\nجرب\nهل تريد أن تعرف حجم مجلد التنزيلات (Downloads) في جهازك؟. يمكننا استخدام الإجراء stat() للحصول على بيانات عن المجلَّد، والتي من ضمنها الحجم (st_size) على النحول التالي:\n\np = Path.home() / 'Downloads'\nsize = p.stat().st_size\nprint(size, 'bytes')\n\n655360 bytes\n\n\nثم هذا الإجراء لتحويل الوِحدة من البايت إلى الكيلو والميجا والقيقا:\n\ndef format_size(size):\n    size_kb = size / 1024\n    size_mb = size_kb / 1024\n    size_gb = size_mb / 1024\n    if size_gb &gt; 0.1:\n        return f'{size_gb:.2f} GB'\n    elif size_mb &gt; 0.1:\n        return f'{size_mb:.2f} MB'\n    return f'{size_kb:.2f} KB'\n\nprint(format_size(size))\n\n0.62 MB\n\n\n\n\n\nالبحث في الشجرة\nيستعمل الإجراء glob للبحث عن نمط معيَّن بدءًا من المسار، وهذا النمط قد يبحث في مستوىً واحد أو يتخلل الشجرة بأي طريقة تريد؛ ليطابق أسماء الملفات بنمط معيَّن فيستخرجها لك.\nانظر لغة الأنماط لتتعلم هذه اللغة الصغيرة.\nفي هذا المثال نبحث عن ملفات الصُّوَر التي بصيغة .jpg لنحسب حجم مجموع ملفات الصور لدينا داخل المسار datasets/pathlib وما يتفرع عن هذه الشجرة نزولاً إلى الأبد (وذلك بنمط: **/*.jpg):\n\ntotal_size = 0\nfor p in Path('datasets/example_root/').glob('**/*.jpg'):\n    total_size += p.stat().st_size\n\nprint('Total size:', total_size, 'bytes')\nprint('Total size:', format_size(total_size))\n\nTotal size: 999702 bytes\nTotal size: 0.95 MB\n\n\n\n\nالمشي على جميع ملفات الشجرة\nنستعمل الإجراء walk للسير على جميع ملفات الشجرة نزولاً أو صعودًا؛ على هذا النحو:\n\np = Path('datasets/example_root/')\nfor dirpath, dirnames, filenames in p.walk(top_down=True):\n    print(dirpath)\n    for file in filenames:\n        print(f'\\t{file}')\n        # print('\\tFULL PATH:', Path(dirpath) / file)\n\ndatasets\\example_root\n    something.txt\ndatasets\\example_root\\a\n    a.txt\n    A_domestic_cat.jpg\n    A_domestic_cat.jpgZone.Identifier\n    zzz.txt\ndatasets\\example_root\\b\n    A_yellow_and_white_cat.jpg\n    A_yellow_and_white_cat.jpgZone.Identifier\n    b.txt\n    DSC0532_(9120523417).jpg\n    DSC0532_(9120523417).jpgZone.Identifier\ndatasets\\example_root\\c\n    c.txt\ndatasets\\example_root\\c\\c_inner\n    inner.txt\n\n\nلاحظ أن .walk() تعطينا ثلاثة قيَم في كل كرة:\n\ndirpath: المسار الحالي للمجلد.\ndirnames: قائمة بأسماء المجلدات في المجلد الحالي.\nfilenames: قائمة بأسماء الملفات في المجلد الحالي.\n\nلإظهار كامل المسار؛ أزل علامة التعليق # من السطر الأخير لتنفيذه.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "11_files.html#تصنيف-عمليات-pathlib-في-بايثون",
    "href": "11_files.html#تصنيف-عمليات-pathlib-في-بايثون",
    "title": "12  الملفات",
    "section": "12.4 تصنيف عمليات pathlib في بايثون",
    "text": "12.4 تصنيف عمليات pathlib في بايثون\nوإليك تصنيف لعمليات مكتبة pathlib:\n\nعمليات المسار\n\nإنشاء وتعديل المسارات:\n\n.joinpath: دمج مكونات مسار.\n.parent: استخراج المجلد الأب.\n.name: استخراج الاسم الأساسي للملف.\n.stem: استخراج اسم الملف بدون الامتداد.\n.suffix: استخراج امتداد الملف.\n.with_name: إنشاء مسار جديد باسم مختلف.\n.with_suffix: إنشاء مسار جديد بامتداد مختلف.\nrelative_to: إنشاء مسار نسبي.\n\n\n\n\nعمليات على نظام الملفات\n\nاستعلام:\n\nis_absolute: هل هو مطلق؟.\nsamefile: هل مساران يشيران إلى نفس الملف؟.\nexists: هل هو مسار موجود؟.\nis_file: هل هو مسار ملف؟.\nis_dir: هل هو مسار مجلد؟.\nis_symlink: هل هو ارتباط رمزي؟.\nstat: سرد إحصائيات نظام الملفات.\nlstat: سرد إحصائيات نظام الملفات دون متابعة الارتباطات الرمزية.\n\nعمليات تغيير:\n\nopen: فتح ملف للقراءة أو الكتابة أو الإضافة.\nmkdir: إنشاء مجلد.\nrmdir: حذف مجلد فارغ.\nunlink: حذف ملف.\nrename: تعديل اسم ملف أو مجلد.\nreplace: تعديل اسم ملف أو مجلد مع الكتابة فوقه إذا لزم الأمر.\nchmod: تغيير أذونات الملف.\nlchmod: تغيير أذونات الملف دون متابعة الارتباطات الرمزية.\ntouch: تحديث الطابع الزمني للملف.\n\n\n\n\nالارتباطات الرمزية والصلبة\n\nsymlink_to: إنشاء ارتباط رمزي.\nhardlink_to: إنشاء ارتباط صلب.\nreadlink: قراءة الهدف من ارتباط رمزي.\n\n\n\nالتكرار والبحث\n\niterdir: تكرار على قائمة المجلد.\nglob: البحث عن الملفات المطابقة لنمط.\nrglob: البحث بشكل متكرر عن الملفات المطابقة لنمط.\nwalk: التنقل بشكل متكرر في شجرة المجلدات.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "11_files.html#النسخ-والحذف-والنقل-shutil",
    "href": "11_files.html#النسخ-والحذف-والنقل-shutil",
    "title": "12  الملفات",
    "section": "12.5 النسخ والحذف والنقل (shutil)",
    "text": "12.5 النسخ والحذف والنقل (shutil)\n\nshutil.copy2: نسخ ملف.\nshutil.copytree: نسخ شجرة المجلدات.\nshutil.rmtree: حذف شجرة المجلدات.\nshutil.move: نقل ملف أو مجلد.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>الملفات</span>"
    ]
  },
  {
    "objectID": "12_serialization.html",
    "href": "12_serialization.html",
    "title": "13  حفظ البيانات",
    "section": "",
    "text": "13.1 البيانات المرتبطة أو المضمنة\nصيغ حفظ الروابط كثيرة مثل XML وJSON وYAML. في هذا القسم، سنركز على ملفات JSON. توفر وحدة json وظائف لقراءة وكتابة ملفات JSON.\nimport json\nلنفترض أن لدينا user_preferences محفوظًا في القاموس، ونريد حفظه في ملف JSON:\nuser_preferences = {\n    'theme': 'dark',\n    'language': 'Arabic',\n    'notifications': {\n        'email': True,\n        'sms': False,\n        'push': True\n    },\n    'last_updated': '2021-09-01',\n    'emails': ['example1@domain.com', 'example2@domain.com']\n}\nلنكتبها إلى ملف json:\nwith open('datasets/user_preferences.json', mode='w') as file:\n    json.dump(user_preferences, file)\nلاحقًا عندما نريد تحميلها، يمكننا القيام بما يلي:\nwith open('datasets/user_preferences.json') as file:\n    data = json.load(file)\nprint(data)\n\n{'theme': 'dark', 'language': 'Arabic', 'notifications': {'email': True, 'sms': False, 'push': True}, 'last_updated': '2021-09-01', 'emails': ['example1@domain.com', 'example2@domain.com']}\nإذا كنت تتعامل مع صيغ أخرى، تحقق من: وثائق وحدة xml المدمجة لوثائق XML، أو مكتبة pyyaml لوثائق YAML.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>حفظ البيانات</span>"
    ]
  },
  {
    "objectID": "12_serialization.html#البيانات-الجدولية",
    "href": "12_serialization.html#البيانات-الجدولية",
    "title": "13  حفظ البيانات",
    "section": "13.2 البيانات الجدولية",
    "text": "13.2 البيانات الجدولية\nتأتي البيانات الجدولية في صيغ متعددة، مثل CSV وTSV وExcel وSQL. في هذا القسم، سنركز على ملفات CSV. فهي مكونة من ثلاثة أحرف:\n\nC: Comma\nS: Separated\nV: Values\n\nوتعني حرفيًّا: القيَم المفصولة بالفاصلة. وشكلها في الحقيقة عبارة عن صفوف من القيم بحيث يمثل كل سطر في هذا الملف صفًّا واحدًا يتكون من أعمدة بعدد الفواصل + 1، ويحدد ابتداء العمود القادم عند علامة الفاصلة في الصف، وذلك يتبين حينما تفتح الملف باستخدام محرر جداول مثل Excel أو Sheets ونحوهما.\nتوجد في بايثون وحدة csv فيها إجراءات للقراءة والكتابة على طريقة csv. فلدينا:\n\nكائن reader لعمليات القراءة\nوكائن آخر منفصل اسمه writer يحوي عمليات الكتابة\n\n\nimport csv\n\nلنكتب قائمة من الطلاب إلى ملف CSV. لاحظ، لدينا قائمة من قوائم، حيث تمثل كل قائمة داخلية صفًا لوحدها:\n\nheader = ['Name', 'Age', 'Grade']\nrows = [\n    ['Adam', 22, 90],\n    ['Belal', 23, 92],\n    ['Camal', 24, 91],\n]\n\nنكتبها على النحو التالي:\n\nwith open('datasets/students.csv', mode='w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(header)\n    writer.writerows(rows)\n\nملاحظة، يمكنك محاولة فتح الملف مباشرة من مستكشف الملفات. حاول فتحه باستخدام Excel أو Google Sheet أو أي برنامج جداول بيانات آخر. إذا فتحته باستخدام محرر نصوص، سترى البيانات كملف CSV؛ حرفيًا قيم مفصولة بفواصل.\nالآن، دعنا نقرأه كهيكل بيانات في بايثون: كقائمة من القوائم.\n\nwith open('datasets/students.csv') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)\n\n['Name', 'Age', 'Grade']\n['Adam', '22', '90']\n['Belal', '23', '92']\n['Camal', '24', '91']\n\n\nلنحاول حساب متوسط درجات الطلاب.\n\nstudents = []\nwith open('datasets/students.csv') as file:\n    reader = csv.reader(file)\n    next(reader) # skip the header\n    for row in reader:\n        students.append(row)\n\nالآن بعد أن حفظناها في القائمة students، دعونا نقوم ببعض العمليات الحسابية.\n\ngrades = [s[2] for s in students]\navg = sum(grades) / len(grades)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 2\n      1 grades = [s[2] for s in students]\n----&gt; 2 avg = sum(grades) / len(grades)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nهذا الخطأ متوقع عند قراءة الملفات لأنها دائمًا تعتبر من نوع str، ولذلك نضطر لتحويل القيَم العددية إلى int لإجراء عمليات رياضية:\n\ngrades = [int(s[2]) for s in students]\navg = sum(grades) / len(grades)\navg\n\n91.0\n\n\nيمكنك أيضًا قراءة وكتابة البيانات في شكل قاموس باستخدام الكائنات DictReader وDictWriter.\n\nwith open('datasets/students.csv') as file:\n    reader = csv.DictReader(file)\n    for row in reader:\n        print(row)\n\n{'Name': 'Adam', 'Age': '22', 'Grade': '90'}\n{'Name': 'Belal', 'Age': '23', 'Grade': '92'}\n{'Name': 'Camal', 'Age': '24', 'Grade': '91'}\n\n\nالطريقة الموصى بها للتعامل مع البيانات الجدولية (مثل ملفات CSV) هي استخدام مكتبة pandas. توفر هذه المكتبة هيكل بيانات سريع ومرن لمعالجة البيانات وتحليلها. في هذا المستوى، أشجعك على الاطلاع على دليل البدء السريع لمكتبة pandas بنفسك.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>حفظ البيانات</span>"
    ]
  },
  {
    "objectID": "13_errors.html",
    "href": "13_errors.html",
    "title": "14  الأخطاء",
    "section": "",
    "text": "14.1 الأخطاء النحوية\nالأخطاء النحوي تتعلق بتركيب اللغة لا أكثر ولا أقل. إليك ثلاثة أمثلة.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "13_errors.html#الأخطاء-النحوية",
    "href": "13_errors.html#الأخطاء-النحوية",
    "title": "14  الأخطاء",
    "section": "",
    "text": "فقدان النقطتين :\n\nif (x &gt; 5)\n    print(\"x\")\n\n\n  Cell In[114], line 1\n    if (x &gt; 5)\n              ^\nSyntaxError: expected ':'\n\n\n\n\n\n\nعلامات اقتباس غير متوازنة\n\nprint(\"x\n\n\n  Cell In[115], line 1\n    print(\"x\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\nاسم متغير غير صالح\n\nmy-variable = 10\n\n\n  Cell In[116], line 1\n    my-variable = 10\n    ^\nSyntaxError: cannot assign to expression here. Maybe you meant '==' instead of '='?\n\n\n\n\n\n\nأخطاء المحاذاة\nمن الأخطاء النحوية الشائعة في بايثون: أخطاء المحاذاة (Indentation Error).\nوذلك أن بايثون تقبل نوعين من المسافات البادئة للسطر؛ إما بحرف المسافة التي بين الكلمات \\s أو بحرف المسافة بين الأعمدة \\t. وقد يستعمل بعض الناس هذه وبعضهم ذلك، ثم تأخذ كودًا من هنا وكودًا من هناك، فترى الكود عنك لا يعمل، والسبب هو الخلط بينهما في نفس الكود. وبايثون لا تقبل ذلك. فيجب توحيد النوع. إما هذه أو هذه. لذلك يضبط VS Code ومحررات الأكواد الأخرى تحويل البادئة تلقائيًا إلى مسافة أو العكس.\nإليك بعض الأمثلة لما يحصل من أخطاء في المحاذاة:\nعدم وجود مسافة بادئة، عندما تكون متوقعة:\n\nif True:\nprint(\"x\")\n\n\n  Cell In[117], line 2\n    print(\"x\")\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\nعدم تطابق المحاذاة:\n\nif True:\n    print(\"x\")\n     print('y')\n\n\n  Cell In[118], line 3\n    print('y')\n    ^\nIndentationError: unexpected indent",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "13_errors.html#أخطاء-وقت-التشغيل",
    "href": "13_errors.html#أخطاء-وقت-التشغيل",
    "title": "14  الأخطاء",
    "section": "14.2 أخطاء وقت التشغيل",
    "text": "14.2 أخطاء وقت التشغيل\nخطأ وقت التشغيل هو ما يكتشفه البرنامج عند تنفيذه. ويُعرف بالاستثناء (Exception).\nعند إهمال هذه الأخطاء يحصل أمران عند تنفيذ سببها:\n\nيتوقف البرنامج\nتظهر رسالة خطأ عن طريق منفذ الخطأ (stderr)\n\nتسمى الاستثناءات بهذا الاسم لأنها تقطع التدفق المثالي السعيد للبرنامج. والحقيقة أنها ليست استثناءات من حيث نُدرتها؛ بل هي شائعة جدًّا ويجب التنبه إليها مثل أي حالة أخرى من البرنامج. مثلاً: عند قراءة ملف، يجب أن نتعامل مع حالة ما لو كان الملف غير موجودًا.\nهناك آليتان في لغات البرمجة للتعبير عن حدوث خطأ:\n\nالاستثناء (Exceptions): لغات مثل C++ (1979)، Java (1998)، Python (1991) و JavaScript (1995) ترمي/ترفع الاستثناءات باستعمال عبارة مثلة raise أو عبارة throw على حسب اللغة.\nالإرجاع (Return): اللغات الحديثة مثل Go (2009) و Rust (2015) ببساطة تعيد الخطأ كشيء (قيمة) عند حدوثه باستعمال جملة return التي في الإجراء.\n\nلنأخذ مثالًا لنرى كيف يتم التعامل مع الاستثناءات في Python.\n\nمثال\nافترض في بداية البرنامج، نحتاج إلى قراءة ملف تكوين config.json لتهيئة حالة البرنامج:\n\nfile = open('config.json')\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[119], line 1\n----&gt; 1 file = open('config.json')\n\nFile ~\\miniconda3\\envs\\bookenv\\Lib\\site-packages\\IPython\\core\\interactiveshell.py:310, in _modified_open(file, *args, **kwargs)\n    303 if file in {0, 1, 2}:\n    304     raise ValueError(\n    305         f\"IPython won't let you open fd={file} by default \"\n    306         \"as it is likely to crash IPython. If you know what you are doing, \"\n    307         \"you can use builtins' open.\"\n    308     )\n--&gt; 310 return io_open(file, *args, **kwargs)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'config.json'\n\n\n\nالملف غير موجود لذا يعرف إجراء open() استثناءً من نوع FileNotFoundError. فنعالج هذا الاستثناء باستخدام جملة try-except. دعونا نطبع رسالة تخبر المستخدم بإنشاء الملف. أو الأفضل من ذلك، دعونا نشير إلى ملف تكوين افتراضي: default.json:\ntry:\n    file = open('config.json')\n    # code that does something ...\n    # ...\nexcept FileNotFoundError:\n    file = open(DEFAULT_CONFIG_PATH)\nexcept Exception as e:\n    print(\"something unexpected happened:\", e)\nالفقرة الأخيرة except Exception as e هي عبارة عن استثناء شامل، وذلك في حال حصول استثناء آخر لم نتوقعه. والغرض من ذلك ألا يتوقف البرنامج.\n\n\nمثال آخر\nدعونا نلقي نظرة على مثال آخر، قد يحصل فيه حالة خطأ بسبب تنوع مدخلات المستخدم:\n\nchoices = ['bus', 'train', 'plane', 'boat'] \nprint(\"\"\"Choose an option:\n1. Go by bus\n2. Go by train\n3. Go by plane\n4. Go by boat\n\"\"\")\n# choice = input(\"Choose a number from 1 to 4: \")\n\nChoose an option:\n1. Go by bus\n2. Go by train\n3. Go by plane\n4. Go by boat\n\n\n\nما هي حالات الخطأ الممكنة؟:\n\nقد يدخل المستخدم رقمًا خارج النطاق: 0 أو 9\nقد يدخل المستخدم قيمة غير صحيحة: three\n\nنحتاج إلى التعامل مع هذه الاستثناءات. يمكننا استخدام كتلة try-except للتعامل مع الاستثناءات.\nدعونا نرى ما هو الاستثناء الذي يتم رفعه في الحالة الأولى:\n\nchoices[9]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[121], line 1\n----&gt; 1 choices[9]\n\nIndexError: list index out of range\n\n\n\nالاستثناء هو IndexError.\nماذا عن الحالة الثانية؟ لنرى:\n\nchoices['three']\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[122], line 1\n----&gt; 1 choices['three']\n\nTypeError: list indices must be integers or slices, not str\n\n\n\nالاستثناء هو TypeError.\nالآن بعد أن عرفنا الحالات، دعونا نتعامل معها.\n\nc = '9'\n\nretry_message = \"Please enter a digit between 1 and 4\"\n\ntry:\n    c = int(c)\n    print('User chooses to:', choices[c-1])\nexcept IndexError:\n    print(retry_message)\nexcept ValueError:\n    print(retry_message)\n\nPlease enter a digit between 1 and 4\n\n\nيمكن تجميع الاستثناءات على النحو التالي:\n\ntry:\n    c = int(c)\n    print('User chooses to:', choices[c-1])\nexcept (IndexError, ValueError):\n    print(retry_message)\n\nPlease enter a digit between 1 and 4",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "13_errors.html#رفع-الاستثناءات",
    "href": "13_errors.html#رفع-الاستثناءات",
    "title": "14  الأخطاء",
    "section": "14.3 رفع الاستثناءات",
    "text": "14.3 رفع الاستثناءات\nإذا كنت تريد رفع استثناء، يمكنك استخدام الكلمة raise.\n\nإذا كان نوع العامل خاطئًا، يجب رفع TypeError\nوإلا، فتحقق من القيمة؛ فإن كانت خارج نطاق الإدخال المقبول، يجب رفع ValueError\n\nملاحظة: كان علينا استيراد numbers للتحقق من نوع الإدخال x باستخدام الإجراء المضمَّن: isinstance(x, numbers.Number) على النحو التالي:\n\nimport numbers\n\ndef square_root(x):\n    # Validation\n    if not isinstance(x, numbers.Number):\n        raise TypeError(\"Argument must be a number\")\n    if x &lt; 0:\n        raise ValueError(\"Cannot calculate square root of a negative number\")\n    # Now that we have checked the input, we can calculate the square root\n    result = x ** 0.5\n    return result\n\nلنختبر حالتي الخطأ:\n\nsquare_root('16')\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[126], line 1\n----&gt; 1 square_root('16')\n\nCell In[125], line 6, in square_root(x)\n      3 def square_root(x):\n      4     # Validation\n      5     if not isinstance(x, numbers.Number):\n----&gt; 6         raise TypeError(\"Argument must be a number\")\n      7     if x &lt; 0:\n      8         raise ValueError(\"Cannot calculate square root of a negative number\")\n\nTypeError: Argument must be a number\n\n\n\n\nsquare_root(-99)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[127], line 1\n----&gt; 1 square_root(-99)\n\nCell In[125], line 8, in square_root(x)\n      6     raise TypeError(\"Argument must be a number\")\n      7 if x &lt; 0:\n----&gt; 8     raise ValueError(\"Cannot calculate square root of a negative number\")\n      9 # Now that we have checked the input, we can calculate the square root\n     10 result = x ** 0.5\n\nValueError: Cannot calculate square root of a negative number\n\n\n\nلنختبر الآن المسار السعيد:\n\nsquare_root(16)\n\n4.0",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "13_errors.html#أنواع-الأخطاء-الشائعة-وأسبابها-وحلولها",
    "href": "13_errors.html#أنواع-الأخطاء-الشائعة-وأسبابها-وحلولها",
    "title": "14  الأخطاء",
    "section": "14.4 أنواع الأخطاء الشائعة وأسبابها وحلولها:",
    "text": "14.4 أنواع الأخطاء الشائعة وأسبابها وحلولها:\nفيما يلي بعض أنواع الأخطاء الشائعة وكيفية إصلاحها:\n\n\nTypeError\n\nالسبب: يحدث عندما يتم تنفيذ عملية على كائن من نوع غير مناسب، أو عند استدعاء دالة بعدد أو نوع غير صحيح من الوسائط.\n\nالحل: استخدم type() أو isinstance() للتحقق من تطابق أنواع البيانات المستخدمة مع متطلبات العملية (على سبيل المثال، int+int صحيحة بينما str+int غير صحيحة).\n\nValueError\n\nالسبب: يتم رفع هذا الخطأ عندما تستقبل دالة وسيطاً من النوع الصحيح ولكنه ذو قيمة غير مناسبة (مثل تمرير عدد سالب إلى مكان يُتوقع فيه أعداد موجبة فقط).\n\nالحل: تأكد من أن القيم الممررة إلى الدوال صحيحة وتتطابق مع النطاق أو المجال المتوقع.\n\nIndexError\n\nالسبب: يتم رفع هذا الخطأ عند محاولة الوصول إلى عنصر في موقع خارج حدود قائمة أو سلسلة.\n\nالحل: تحقق من طول التسلسل (مثل استخدام len()) قبل الوصول إلى الفهارس. يمكنك أيضاً استخدام كتل try-except للتعامل مع استثناءات IndexError بأمان. فكّر في التكرار على القائمة أو استخدام طرق آمنة مثل enumerate().\n\nKeyError\n\nالسبب: يحدث عند محاولة الوصول إلى مفتاح غير موجود في القاموس.\n\nالحل: تحقق من وجود المفتاح باستخدام in قبل الوصول إليه (مثل if key in dict). بدلاً من ذلك، يمكنك استخدام الطريقة .get() التي تُرجع None (أو قيمة افتراضية) إذا لم يتم العثور على المفتاح بدلاً من رفع خطأ.\n\nAttributeError\n\nالسبب: يحدث عند محاولة الوصول إلى خاصية أو دالة غير صالحة لكائن معين (مثل استدعاء دالة غير موجودة على الكائن).\n\nالحل: تحقق مما إذا كان الكائن يحتوي على الخاصية أو الدالة التي تحاول استخدامها. تحقق من وجود أخطاء إملائية أو من كون نوع الكائن صحيحاً.\n\nModuleNotFoundError\n\nالسبب: يحدث عندما لا يستطيع Python العثور على الوحدة (module) التي تحاول استيرادها.\n\nالحل: تحقق من اسم الوحدة للتأكد من خلوه من الأخطاء الإملائية. تأكد من تثبيت الوحدة في بيئة Python الخاصة بك.\n\nSyntaxError\n\nالسبب: يحدث عندما يعترض المفسّر (Python parser) على خطأ في بناء الجملة.\n\nالحل: تحقق من وجود أي أحرف مفقودة أو زائدة، أو مشاكل في التنسيق، أو أي أخطاء في بناء الجملة.\n\nNameError\n\nالسبب: يحدث عندما يتم استخدام متغير قبل تعريفه.\n\nالحل: تأكد من تعريف المتغير قبل استخدامه. تحقق أيضاً من وجود أخطاء إملائية في اسم المتغير.\n\n\n\nكيفية إصلاح الأخطاء الأكثر تعقيدًا؟\nقد تتطلب الأخطاء الأكثر تعقيدًا المزيد من التصحيح وفهم الكود. لذا، من المهم تعلم كيفية قراءة رسالة الخطأ التي تنتجها Python. يتكون الخطأ من ثلاثة أجزاء: نوع الخطأ، رسالة الخطأ، و سلسلة النداءات (stack trace).\nأولاً، اقرأ السطر الأخير. فذلك يخبرك بأمرين:\n\nErrorType الذي يمكنك استخدامه في كتلة try-catch إذا لزم الأمر\nيتبعه رسالة خطأ بلغة إنجليزية بسيطة توضح ما حدث\n\nتدرج سلسلة النداءات (stack trace) الاستدعاءات (الدوال التي تستدعي دوال أخرى). وبالتالي، فإن الكود الذي رفع الخطأ سيكون الأخير (في الأسفل)، في حين أن الدالة التي بدأت ذلك ستكون الأولى (في الأعلى).\nاعتبر سلسلة الاستدعاءات حيث تستدعي func_app الدالة func_library_1 التي تستدعي الدالة func_library_2. يُفترض أن الدالتين الأخريين هما مكتبات مستوردة. مثال: نعرّف دوال في تطبيقنا تستدعي مكتبة pandas التي تستدعي مكتبة numpy.\nقد يتم رفع استثناء في مكان ما، ونريد تطبيق ما تعلمناه أعلاه لقراءته وإصلاحه.\n\ndef func_library_2(c):\n    if len(c) == 0:\n        raise ValueError(\"Empty input\")\n    z = c\n    return z\n\ndef func_library_1(b, c):\n    if not isinstance(c, str):\n        raise TypeError(\"c must be a string\")\n    y = func_library_2(c)\n    return b + y\n\ndef func_app(a, b, c):\n    x = func_library_1(b, c)\n    return a + x\n\nfunc_app('a', 'b', '')\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[129], line 17\n     14     x = func_library_1(b, c)\n     15     return a + x\n---&gt; 17 func_app('a', 'b', '')\n\nCell In[129], line 14, in func_app(a, b, c)\n     13 def func_app(a, b, c):\n---&gt; 14     x = func_library_1(b, c)\n     15     return a + x\n\nCell In[129], line 10, in func_library_1(b, c)\n      8 if not isinstance(c, str):\n      9     raise TypeError(\"c must be a string\")\n---&gt; 10 y = func_library_2(c)\n     11 return b + y\n\nCell In[129], line 3, in func_library_2(c)\n      1 def func_library_2(c):\n      2     if len(c) == 0:\n----&gt; 3         raise ValueError(\"Empty input\")\n      4     z = c\n      5     return z\n\nValueError: Empty input\n\n\n\nلنقرأ رسالة الخطأ. تقول: \"ValueError: Empty input\". حسنًا، ما الذي تسبب في ذلك؟ دعونا نلقي نظرة على سلسلة النداءات (stack trace) من الأعلى (للعثور على دوالنا الخاصة). نجد:\nFile c:\\Users\\thund\\OneDrive\\3-Teach\\DS-AI\\2. Py\\book\\11_errors.qmd:17\n     14     x = func_library_1(b, c)\n     15     return a + x\n---&gt; 17 func_app('a', 'b', '')\nهي أول استدعاء في سلسلة السببية. لنقرأ ماذا يأتي بعدها:\nFile c:\\Users\\thund\\OneDrive\\3-Teach\\DS-AI\\2. Py\\book\\11_errors.qmd:14\n     13 def func_app(a, b, c):\n---&gt; 14     x = func_library_1(b, c)\n     15     return a + x\nالآن هذه هي الاستدعاء الثاني، والأخير في تطبيقنا. بعد هذه النقطة، يكون خارج نطاق سيطرتنا. بما أننا نحافظ على كودنا الخاص func_app، فمن الأرجح أننا ارتكبنا الخطأ. يمكننا إصلاحه عن طريق التحقق من الإدخال قبل أن يغادر كودنا إلى func_library_1.\n\nfunc_app('a', 'b', 'c')\n\n'abc'\n\n\nتم الإصلاح. انتهى.\nإذا كان الخطأ في الواقع في func_library_1، فعلينا التواصل مع القائمين على صيانة المكتبة لإصلاحه. ربما يمكننا إصلاحه بأنفسنا وتقديم طلب سحب (pull request) على GitHub. هكذا تتحسن البرمجيات مفتوحة المصدر.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "13_errors.html#الأخطاء-المنطقية",
    "href": "13_errors.html#الأخطاء-المنطقية",
    "title": "14  الأخطاء",
    "section": "14.5 الأخطاء المنطقية",
    "text": "14.5 الأخطاء المنطقية\nالأخطاء المنطقية صامتة. لا يتم اكتشافها بواسطة المترجم، ومع ذلك تتسبب في تصرف البرنامج بشكل غير صحيح. الأخطاء المنطقية هي الأصعب في العثور عليها وإصلاحها لأنها ليست واضحة دائمًا. يمكن أن تكون ناجمة عن:\n\nافتراضات غير صحيحة\nتطبيق غير صحيح للخوارزمية أو\nتحضير غير صحيح للبيانات\n\n\nاستخدام الإجراء الخاطئ\n\nimport math\n\nsquare = math.sqrt(4) # should use math.pow(4, 2) instead\n\n\n\nاستعمال العامل الخاطئ\n\nx = 16\nif (x == \"16\"):\n    print('equal')\n\n\n\nمستوى محاذاة خاطئ\nهنا كانت النية تقتضي أن تكون print(j) داخل الحلقة الداخلية:\n\nfor i in range(2):\n    for j in range(3):\n        print(i)  \n    print(j)\n\n0\n0\n0\n2\n1\n1\n1\n2\n\n\n\n\nخطأ الحافَّة (Off-by-one error)\nيكاد يكون أشهر الأخطاء في البرمجة: خطأ الحافَّة.\nنشرحه بمثال: النية هنا هي طباعة الأرقام من 5 إلى 0 بما في ذلك 0، ولكن الحلقة تتوقف عند 1.\n\nfor i in range(5, 0, -1):\n    print(i)\n\n5\n4\n3\n2\n1",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "13_errors.html#كيفية-حل-الأخطاء-المنطقية",
    "href": "13_errors.html#كيفية-حل-الأخطاء-المنطقية",
    "title": "14  الأخطاء",
    "section": "14.6 كيفية حل الأخطاء المنطقية؟",
    "text": "14.6 كيفية حل الأخطاء المنطقية؟\nقد تستعين بعبارة assert هنا وهناك للتحقق من منطق الكود، أو تنتقل لكتابة مجموعة اختبارات أكبر. سيأتيي الكلام عن كتابة الاختبارات.\nالتتبع. أفضل طريقة لحل الأخطاء المنطقية هي تنفيذ الكود والنظر في الناتج، وتتبع المنطق مرة أخرى إلى الكود سطرًا بسطر. يمكنك استخدام عبارات الطباعة print لتصحيح الأخطاء وفهم تدفق البرنامج.\nمراجعة الأقران: بحيث يطلع على الكود شخص آخر، فإنه قد يرى منه ما لم تر.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "13_errors.html#المراجع",
    "href": "13_errors.html#المراجع",
    "title": "14  الأخطاء",
    "section": "14.7 المراجع",
    "text": "14.7 المراجع\n\nhttps://docs.python.org/3.13/tutorial/errors.html",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>الأخطاء</span>"
    ]
  },
  {
    "objectID": "14_classes.html",
    "href": "14_classes.html",
    "title": "15  الأصناف",
    "section": "",
    "text": "سبق لدينا تعريف مُعرَّفات وإجراءات تأخذ عوامل وتعمل عليها. وكان ذلك عن طريق كتابة اسم المعرَّف ثم تعيين قيمة له، وكذلك بتعريف الإجراء بكتابة كلمة def ثم اسم الإجراء وما يعمل عليه من عوامل ثم تطبيق هذا الإجراء. واستعملنا أشياء من أصناف معرَّفة في المكتبة الأساسية مثل: str, int, list ونحوها. أما الآن فسنرى كيف نعرِّف نحن مثل هذه الأصناف.\nالفكرة تدور حول إسناد معرَّفات وإجراءات إلى صِنف (Class) مجرَّد بحيث يكون لأي شيء (Object) مشتق منه الأمران:\n\nخصائصه وهي المعرَّفات (Attributes)\nسلوكياته وهي الإجراءات (Behaviors)\n\nلاحظ التعريف التالي:\n\nوجود كلمة class الدالة على تعريف صنف جديد\nوجود إجراءات مضمَّنة تتبع كلمة def (وهما إجراءان)\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n\nلاحظ وجود طريقة التعيين على النحو self.x = x وكذلك self.y = y هما تعيينان لخاصيَّتيْن: x,y للشيء المعيَّن self. وجود العامل self في الابتداء في جميع الإجراءات المضمَّنة يشير لمعيَّن من هذا الصنف (نرى تعيينهما في المثال التالي).\nوالآن نستطيع إنشاء معيَّنات من هذا الصنف ونمرر القيم x, y بحسب ما هو موجود في الإجراء الخاص بالإنشاء: __init__ على النحو التالي:\n\np1 = Point(3, 4)\np2 = Point(7, 1)\n\nللوصول إلى خاصيَّة للشيء، فإننا نحددها بعد ذكر اسم المعيَّن على النحو التالي: Object.Attribute، وهذا مثال للوصول لخصائص كل من النقطتين وإجراء عملية على ذلك:\n\nx_diff = abs(p1.x - p2.x)\ny_diff = abs(p1.y - p2.y)\nprint(f\"The difference between the x-coordinates is {x_diff} and between the y-coordinates is {y_diff}.\")\n\nThe difference between the x-coordinates is 4 and between the y-coordinates is 3.\n\n\nلاحظ أن السلوكيات إجراءات متعلِّقة بمعيَّن؛ فيمكن استدعاؤها بذكر اسمه متبوعًا باسم الإجراء بعد النقطة على النحو ()Object.Method، وهذا مثال:\n\np1.move(4, 4)\nprint(p1.x, p1.y)\n\n7 8\n\n\nإذا أردنا تخصيص طريقة عرض الصنف، بحيث لو ذكرناه في آخر السطر يظهر بشكل منسَّق، يمكن تخصيص الإجراءء ءالخاص __repr__ ويعني: Representation أي: التمثيل .. وذلك على النحو التالي:\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\nوالآن إن عرفنا نقطة جديدة، ووضعناها على السطر لوحدها ، ستظهر لنا الإحداثيات، لا عنوانها الذاكري:\n\np = Point(3, 4)\np.move(7, 6)\np\n\nPoint(10, 10)\n\n\nيمكن أن نعرف إجراءات تكون بين الأشياء من نفس النوع، فيمكن استعمال المزيِّن @staticmethod ليكون الإجراء متعلِّقًا بالصنف نفسه لا بالأعيان (لاحظ عدم وجود self في الإجراء الجديد distance):\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n                \n    @staticmethod\n    def distance(p1, p2):\n        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n\nالآن يمكن حساب المسافة بذكر اسم الصنف متبوعًا بنقطة ، متبوعةً باسم الإجراء، على النحو التالي:\n\na = Point(0, 1)\nb = Point(1, 0)\n\nPoint.distance(a, b)\n\n1.4142135623730951\n\n\nكما أضفنا إجراءً عامًّا متعلقًا بالأصناف لا بالأعيان ، يمكن أيضًا إضافة معرَّف وإسناد قيمة له نحو distance_type كما في المثال (ولاحظ استعماله في الإجراء distance في جملة if-else من غير استعمال self لأننا لا نشير إلى معيَّن):\n\nclass Point:\n    distance_type = 'euclidean'\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2):\n        if Point.distance_type == 'euclidean':\n            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n        elif Point.distance_type == 'manhattan':\n            return abs(p1.x - p2.x) + abs(p1.y - p2.y)\n\nماذا عن العمليات التي تكون بين الأشياء من نفس النوع، وتكون مثل الجمع والطرح ونحوه؟ (انظر توثيق بايثون لمحاكاة العمليات الرقمية):\n\nclass Point:\n    distance_type = 'euclidean'\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2):\n        if Point.distance_type == 'euclidean':\n            return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n        elif Point.distance_type == 'manhattan':\n            return abs(p1.x - p2.x) + abs(p1.y - p2.y)\n    \n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\nتبحث بايثون عن __add__ كلما وجدت علامة الجمع +، وكذلك تبحث عن __sub__ كلما وجدت علامة الطرح -. فلنجرب الآن. لاحظ أن نتيجة الجمع نقطة جديدة، وكذلك نتيجة الطرح.\n\np1 = Point(0, 1)\np2 = Point(1, 0)\nprint(p1 + p2)\nprint(p1 - p2)\n\nPoint(1, 1)\nPoint(-1, 1)",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>الأصناف</span>"
    ]
  },
  {
    "objectID": "15_extend.html",
    "href": "15_extend.html",
    "title": "16  التخصيص والتركيب",
    "section": "",
    "text": "16.1 التخصيص\nيكثر استعمال الطابور (Queue) كهيكل بيانات لحل مجموعة من المسائل بطريقة سهلة. نستعرض في هذا المثال كيفية تخصيص القائمة (list) حتى نكون منها صنف جديد هو: queue حيث تدخل العناصر من “الخلف” وتخرج من “الأمام” دائمًا، ولا يمكن الوصول للعناصر التي بينهما.\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the end of the queue\"\"\"\n        self.items.append(item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the front of the queue\"\"\"\n        if not self.is_empty():\n            return self.items.pop(0)\n        return None\n\n    def peek(self):\n        \"\"\"Return the item at the front without removing it\"\"\"\n        if not self.is_empty():\n            return self.items[0]\n        return None\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return len(self.items) == 0\n\n    def __repr__(self):\n        \"\"\"Return the underlying list representation\"\"\"\n        return repr(self.items)\nنختبر ذلك الآن:\nq = Queue()\n\nq.enqueue(1)\nq.enqueue(2)\nq.enqueue(3)\n\nprint(q)\n\n[1, 2, 3]\nq.dequeue()\nprint(q)\n\n[2, 3]\nهل يمكننا معرفة عدد العناصر؟:\nlen(q)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 len(q)\n\nTypeError: object of type 'Queue' has no len()\nلتطبيق هذه العملية، يجب إضافة الإجراء الخاص __len__ للصنف حتى يقبلها، على النحو التالي (انظر في الأخير):\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.pop(0)\n        return None\n\n    def peek(self):\n        if not self.is_empty():\n            return self.items[0]\n        return None\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def __repr__(self):\n        return repr(self.items)\n    \n    def __len__(self):\n        return len(self.items)\nالآن يمكن معرفة الطول:\nq = Queue()\nq.enqueue(10)\nlen(q)\n\n1\nيعمل الطول الآن كما لو أن هذا الصنف الذي عرَّفناه للتو منسجم مع list و set و str وغيرها. وهذه الخاصية تسمى تعدد الأشكال (Polymorphism).\nصحيح أن القائمة أكثر قدرة (إذْ تتضمن عمليات أكثر)، إلا أن الطابور مخصص لخدمة وظيفة محددة؛ مما يجعل التعامل معه واضحًا. فأحيانًا يكون التقييد مفيدًا.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>التخصيص والتركيب</span>"
    ]
  },
  {
    "objectID": "15_extend.html#التخصيص",
    "href": "15_extend.html#التخصيص",
    "title": "16  التخصيص والتركيب",
    "section": "",
    "text": "طابور (الداخل أولاً خارجٌ أولاً)\n\n\n\n\nلاحظ الإنشاء بقائمة فارغة\nثم الإجراء enqueue نطبقه عن طريق الإجراء list.append ..\nوالإجراء dequeue نطبقه عن طريق الإجراء list.pop(0) ..",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>التخصيص والتركيب</span>"
    ]
  },
  {
    "objectID": "15_extend.html#التركيب",
    "href": "15_extend.html#التركيب",
    "title": "16  التخصيص والتركيب",
    "section": "16.2 التركيب",
    "text": "16.2 التركيب\nلو كان عندنا تعريف صنف نقطة ..\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    @staticmethod\n    def distance(p1, p2):\n        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n\nيمكننا تركيب شيء مكون من النقاط، وهو المضلَّع، على النحو التالي:\n\nيأخذ إجراء الإنشاء __init__ سلسلة من النقاط ويعيِّنُها لمعرَّف اسمه points\nيعرض إجراء التمثيل __repr__ كلمة Polygon وداخل أقواسها يضع تمثيل النقاط\nالإجراء الأخير لحساب قُطر المضلَّع، وذلك يعتمد على قياس المسافة بين سلسلة النقاط المتتابعة كما نرى\n\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def __repr__(self):\n        return f\"Polygon({self.points})\"\n\n    def perimeter(self):\n        n = len(self.points)\n        s = 0\n        for i in range(n):\n            s += Point.distance(self.points[i], self.points[(i+1)%n])\n        return s\n\nلاحظ أن إنشاء المضلَّع يتطلَّب إنشاء نقاط. ولاحظ أننا جعلنا كل نقطة في سيطر، لكنها في الحقيقة كلها عناصر لقائمة، وذلك بالنظر إلى القوسين المربعين [ ] على النحو التالي:\n\npoly = Polygon([\n    Point(0, 0),\n    Point(5, 0),\n    Point(5, 5),\n    Point(0, 5),\n])\npoly\n\nPolygon([Point(0, 0), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nالمحيط:\n\npoly.perimeter()\n\n20.0\n\n\nولأن هذا المركَّب مكوَّن من أفراد، فنريد أن يكون لدينا عمليات مثل:\n\nمعرفة الطول: len(s)\nالإشارة: s[i]\nالتعيين: s[i] = p\nالحذف: del s[i]\n\nانظر التوثيق الرسمي لبايثون حول محاكاة أنواع الحاويات لمزيد من المعلومات.\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def __repr__(self):\n        return f\"Polygon({self.points})\"\n\n    def __len__(self):\n        return len(self.points)\n    \n    def __getitem__(self, i):\n        return self.points[i]\n\n    def __setitem__(self, i, p):\n        self.points[i] = p\n\n    def __delitem__(self, i):\n        del self.points[i]\n    \n    def perimeter(self):\n        n = len(self.points)\n        s = 0\n        for i in range(n):\n            s += Point.distance(self.points[i], self.points[(i+1)%n])\n        return s\n\n\npoly = Polygon([\n    Point(0, 0),\n    Point(5, 0),\n    Point(5, 5),\n    Point(0, 5),\n])\npoly\n\nPolygon([Point(0, 0), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nعدد النقاط:\n\nlen(poly)\n\n4\n\n\nالأخذ بالرقم أو بالشريحة:\n\nprint(poly[0])\nprint(poly[-1])\nprint(poly[1:3])\nprint(poly[::-1])\n\nPoint(0, 0)\nPoint(0, 5)\n[Point(5, 0), Point(5, 5)]\n[Point(0, 5), Point(5, 5), Point(5, 0), Point(0, 0)]\n\n\nالتعيين:\n\npoly[0] = Point(10, 10)\npoly\n\nPolygon([Point(10, 10), Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nالحذف:\n\ndel poly[0]\npoly\n\nPolygon([Point(5, 0), Point(5, 5), Point(0, 5)])\n\n\nتبين بهذا محاكاة بعض إجراءات الحاويات الأساسية مثل list وset وtuple وstr وdict.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>التخصيص والتركيب</span>"
    ]
  },
  {
    "objectID": "16_modules.html",
    "href": "16_modules.html",
    "title": "17  الوحدات",
    "section": "",
    "text": "17.1 تثبيت حزم\nلتثبيت حزمة من قاعدة بيانات الحزم PyPI نستعمل الأمر pip (إذْ تم تثبيته مع حزمة بايثون) على النحو التالي:\nوبعد تثبيت الحزمة ، نستوردها هكذا ونستعملها:\nimport pandas as pd\n\ndf = pd.read_csv('datasets/students.csv')\ndf\n\n\n\n\n\n\n\n\nName\nAge\nGrade\n\n\n\n\n0\nAdam\n22\n90\n\n\n1\nBelal\n23\n92\n\n\n2\nCamal\n24\n91",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>الوحدات</span>"
    ]
  },
  {
    "objectID": "16_modules.html#تثبيت-حزم",
    "href": "16_modules.html#تثبيت-حزم",
    "title": "17  الوحدات",
    "section": "",
    "text": "pip install pandas",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>الوحدات</span>"
    ]
  },
  {
    "objectID": "16_modules.html#تغليف-مشاريع-بايثون",
    "href": "16_modules.html#تغليف-مشاريع-بايثون",
    "title": "17  الوحدات",
    "section": "17.2 تغليف مشاريع بايثون",
    "text": "17.2 تغليف مشاريع بايثون\nيرشدك دليل حزم مشاريع بايثون لكيفية تغليف المشاريع لترفعها في قاعدة بيانات الحزم. فيه توضيح كيفية إضافة الملفات والبنية اللازمة لإنشاء الحزمة، وكيفية بناء الحزمة، وكيفية تحميلها إلى Python Package Index (PyPI) حتى يمكن تثبيتها باستخدام pip install your-package كما تفعل مع الحزم الأخرى.",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>الوحدات</span>"
    ]
  },
  {
    "objectID": "16_modules.html#تنفيذ-الوحدة-بمدخلات",
    "href": "16_modules.html#تنفيذ-الوحدة-بمدخلات",
    "title": "17  الوحدات",
    "section": "17.3 تنفيذ الوحدة بمدخلات",
    "text": "17.3 تنفيذ الوحدة بمدخلات\nيمكنك تمرير مدخلات لوحدة مكتوبة بالبايثون عن طريق كتابتها بعد اسم البرنامج، على النحو التالي: python my_program.py arg1 arg2 arg3.\nستوفر لك مكتبة sys هذه المدخلات في معرَّف sys.argv وهو قائمة من النصوص، حيث أوَّل عنصر هو اسم البرنامج، ويتبعه بعد ذلك المدخلات: arg1, arg2, arg3 التي تم تمريرها.\nألق نظرة على الملف main2.py. تجد إجراء جمع رقمين، نريد أن يكونا من مدخلات المستخدم:\ndef add_two(a, b):\n    return a + b\nنقوم بتشغيل البرنامج وتمرير المدخلات هكذا:\npython main2.py 10 20\nبعدها نأخذ المدخلات (بدءًا من العنصر الثاني في القائمة) ، ونحولها إلى عدد ، ثم نمررها للدالة ونعرض النتيجة:\na = int(sys.argv[1])\nb = int(sys.argv[2])\nresult = add_two(a, b)\nprint(result)",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>الوحدات</span>"
    ]
  },
  {
    "objectID": "16_modules.html#نقاط-أخيرة",
    "href": "16_modules.html#نقاط-أخيرة",
    "title": "17  الوحدات",
    "section": "17.4 نقاط أخيرة",
    "text": "17.4 نقاط أخيرة\nمن المعتاد (ولكن ليس مطلوبًا) وضع جميع عبارات import في أول الكود.\nمن الجيد أن تستورد الوحدات بالترتيب التالي:\n\nوحدات المكتبة المضمَّنة - على سبيل المثال sys، os، argparse، re\nالوحدات التي تم تثبيتها - على سبيل المثال: dateutil وrequests وPIL.Image\nوحدات محلية",
    "crumbs": [
      "الأصل",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>الوحدات</span>"
    ]
  },
  {
    "objectID": "zz_time.html",
    "href": "zz_time.html",
    "title": "18  الوقت",
    "section": "",
    "text": "18.1 مقدمة",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "zz_time.html#مقدمة",
    "href": "zz_time.html#مقدمة",
    "title": "18  الوقت",
    "section": "",
    "text": "الساعات والأيام\nتذكر بعض المصادر أن الأولين كانوا يقسمون الوقت على 12 ساعة ليلية (تبدأ بعد غروب الشمس) تتلوها 12 ساعة نهارية (تبدأ بعد شروق الشمس). وهي ساعات متغيرة؛ ففي الصيف تزيد طول ساعة النهار لتصل إلى 70 دقيقة معتدلة بينما تقصر ساعة الليل إلى 50 دقيقة معتدلة، ويحصل العكس في الشتاء (فيكون الليل أطول والنهار أقصر). أما عند اعتدال الشمس في أشهر معيَّنة في خط الاستواء فإن ساعات الليل والنهار 60 دقيقة (وهو مقياس الاعتدال). والمرجع في ذلك الساعة الشمسية (المزوَّلة). ولحساب الفترة الزمنية كانوا يستعملون ما يُحرَق كالشمع، أو ثقب في وعاء مدرَّج من ماء أو رمل.\nانظر كتاب فقه اللغة للثعالبي:\n\nالفصل السابع عشر “في تَعْدِيدِ سَاعَاتِ النَّهارِ واللَّيل على أربع وعشرين لفظة”.\nعن حمزة بن الحسن وعليه عهدتها:\nسَاعَاتُ النَّهارِ: الشُرُوقُ. ثُمَّ البكورُ. ثُمَّ الغُدْوَةُ. ثُمَّ الضُّحَى. ثُمَّ الهاجِرَةُ. ثُمَّ الظَهِيرَةُ. ثُمَّ الرَّوَاحُ. ثُمَّ العَصْرُ. ثُمَّ القَصْرُ. ثُمَّ الأصِيلُ. ثُمَّ العَشِيُّ. ثُمَّ الغُروبُ. سَاعَاتُ اللَّيلِ: الشَّفَقُ. ثُمَّ الغَسَقُ. ثُمَّ العَتَمَةُ. ثُمَّ السُّدْفَة. ثُمَّ الفَحْمَةُ. ثُمَّ الزُّلَّةُ. ثُمَّ الزُّلْفةُ. ثُمَّ البُهْرَةُ. ثُمَّ السَّحَرُ. ثُمَّ الفَجْرُ. ثُمَّ الصُّبْحُ. ثُمَّ الصَّباحُ\n\nثم جاءت الساعات الميكانيكية الثابتة التي تعمل وكأن جميع الساعات 60 دقيقة (وكأنها على خط الاستواء وفي وقت اعتدال الشمس عليه)؛ ولا تعتبر شتاءً ولا صيْفًا، ولا نهارًا ولا ليلاً .. لكنها أصبحت هي المتداولة. وقد مرَّ ضبط الساعة (حتى لا تحيد) بمستويات متطورة من الدقة، فبدأت من الساعة المتأرجحة (1657) إلى الكرونومتر (1762) إلى مذبذب الكوارتز (1927) إلى الساعة الذرية (1949) إلى ساعة شعاع السيزيوم (1955) إلى ساعة نافورة السيزيوم (1993) إلى الساعة الضوئية (Optical Clock: 2006) والتي تحيد بمقدار ثانية بعد كل 30 مليار سنة.\n\n\nالتوقيت العالمي\nلتسهيل التعامل بين الدول والتواصل عبر القارات، ظهر نظام التوقيت العالمي المنسق (UTC: Coordinated Universal Time) حوالي سنة 1967، يعتمد على خطوط الطول الأرضية، تقسَّم فيه المناطق الزمنية بحسب بعدها عن خط طول جرينيتش وجُعل هو هو نقطة الصفر. فما يكون شرقيها يكون الفارق فيه بالموجب، وما يكون غربيَّها يكون الفارق فيه بالسالب.\nوكل منطقة زمنية لها توقيت محلي تعتمده في معاملاتها اليومية فيما يتعلق بالوقت من تواصل وتنسيق ومواعيد ونحو ذلك. في الخريطة أدناه نرى تقسيم المناطق الزمنية:\n\n\n\nخريطة تظهر تقسيم المناطق الزمنية\n\n\nلاحظ أولاً أن الخطوط ليست طوليَّة بالفعل، انظر إلى الألوان فليست هي مستطيلات بل تتعرَّج بحسب حدود الدُّول في الغالب. فالأمر ليس بالبساطة التي قد نعتقدها: فليس الوقت المحلي هو فقط زيادة أو نقص من الوقت العالمي .. بل هناك عدة اعتبارات تجعل يجب أن توضع في الحسبان عند التحويل بينهما:\n\nبعض المناطق الزمنية تقدِّم الوقت ساعة عند الربيع (أو نهاية الشتاء) ثُم تعيدُه في الخريف، وذلك لتنظيم جدوَل الناس بحيث يتعرضوا للشمس أكثر. وهذا يسمونه (Daylight Saving).\nفي سنة من السنين بعض المناطق الزمنية حوَّلت نسبتها من التوقيت العالمي .. فلا يمكن إذاً اعتبار أن المنطقة الزمنية لها نسبة ثابتة عبر كل السنين (فالأمر أصعب عندما نريد حساب تواريخ قديمة).\nتوجد مناطق عريضة جغرافيًّا كالصين فإنها تمتد لتغطي مجموعة خطوط طول أرضية، إلا أنها تعتمد توقيتًا واحدًا (وكأنها منطقة زمنية واحدة)\nجانب التنسيق في التوقيت العالمي المنسق هو: أنه يضع في الحسبان الاختلاف اليسير بسبب الثواني الكبسية، فتعاد ضبط الأوقات لاعتبارها.\n\n\n\nبيانات المناطق الزمنية\nنخلص من ذلك أن التعامل مع الوقت له اعتبارات كثيرة بسبب ظروف تاريخية وسياسية وليس خاضعًا لقوانين فيزيائية أو أرضية أو فلكية بحتة. ولذلك ظهرت قاعدة بيانات للمناطق الزمنية (بمجهود جماعي) تتضمن معلومات الدول بشكل مستمر تسمى: (tz database) وتضمَّن هذه المعلومات في المكتبات التي تعتني بالتعامل مع التواريخ والأوقات عبر السنين، وتتضمن معلومات عن التغييرات التاريخي التي طرأت، ويتم تحديثها عند التغيرات الجديدة.",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "zz_time.html#الزمن-في-الحاسوب",
    "href": "zz_time.html#الزمن-في-الحاسوب",
    "title": "18  الوقت",
    "section": "18.2 الزمن في الحاسوب",
    "text": "18.2 الزمن في الحاسوب\nيتمثل الزمن في الأنظمة الحاسوبية بطريقتين:\nالأولى: وقت النظام (system or Unix time) وهو رقم يمثل عدد الثواني منذ نقطة صفرية جُعلت في الساعة 00:00:00 UTC بتاريخ أول يوم من أول شهر (يناير) من سنة 1970 (وذلك لأن نظام Unix كان يطوَّر في تلك الفترة) وسمي ذلك الزمن المرجعي (Unix Epoch).\nمثال: لنشير إلى سنة واحدة تمامًا بعد النقطة الصفرية، أي: الساعة 00:00:00 بتاريخ 1 يناير1971 فإن السنة الواحدة 31,536,000 ثانية ، وبالتالي يكون هذا الرقم هو الذي يمثل الوقت.\nالثانية: وقت التقويم (calendar time) وهو التمثيل الأقرب للقراءة للبشر، ويمكن التحويل بينه وبين وقت النظام. على سبيل المثال، نترجم وقت النظام 1,000,000,000 (ثانية منذ النقطة الصفرية) إلى وقت التقويم 9 سبتمبر 2001 01:46:40 بالتوقيت العالمي المنسق (UTC).\n\nمشكلة سنة 2038\nتمثل التواريخ في الأنظمة ذات 32-بت برقم 32-بت ذي إشارة (أي: قد يكون سالبًا للتواريخ السابقة). وهذا يعني:\n\nفيما يسبق النقطة الصفرية: أقل تاريخ ووقت يمكن تمثيله هو الساعة 20:45:52 UTC بتاريخ 1901-12-13\nفيما يلحق النقطة الصفرية: أعلى تاريخ ووقت يمكن تمثيله هو الساعة 03:14:07 UTC بتاريخ 2038-01-19\n\nما هو الحل؟ نقل البرنامج لجهاز 64-بت.",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "zz_time.html#الوقت-في-بايثون",
    "href": "zz_time.html#الوقت-في-بايثون",
    "title": "18  الوقت",
    "section": "18.3 الوقت في بايثون",
    "text": "18.3 الوقت في بايثون\nننتقل الآن إلى الوقت والتاريخ في بايثون، حيث يوجد لدينا المفاهيم التالية:\nأولاً: datetime.date وهو تاريخ مثالي يفترض أن التقويم الغريغوري يمتد إلى ما لا نهاية في المستقبل والماضي (رغم أنه في الحقيقة حل مكان التاريخ الجولياني سنة 1582). سمات هذا الكائن: السنة والشهر واليوم.\nثانيًا: datetime.time هو وقت مثالي يفترض 86,400 ثانية في اليوم (بدون ثوانٍ كبيسة). سمات هذا الكائن: الساعة والدقيقة والثانية والميكروثانية وtzinfo (معلومات المنطقة الزمنية).\nثالثًا: datetime.datetime وهو التاريخ والوقت معًا؛ فلديه سمات كلا الجزئين.\nرابعًا: datetime.timedelta وهو فترة زمنية. ولكننا سنستبدله بـ dateutil.relativedelta إذ هي كذلك فترة زمنية إلا أن نطاقها أوسع (تستوعب السنين والأشهر، وتعتبر السنوات الكبيسة في الحسبان).\nالوقت الصحيح لا بد له من نسبة إلى منطقة زمنيَّة (كأن تقول الساعة 04:00:00 صباحًا بتوقيت UTC+03)؛ فهذا تسميه بايثون وقت واع (Aware)، وأما الوقت الذي لم تحدد منطقته الزمنية (كما لو قُلت في الساعة 04:00:00 صباحًا) فهذا غير منسوب لمنطقة زمنية وبالتالي فهو ساذج (Naive) على تعبيرهم.\nويرشدنا توثيق المكتبة للتوسع في استعمال قاعدة بيانات المناطق الزمنية، والقدرة على تفسير التواريخ والأوقات بمرونة لاستخدام مكتبة dateutil المتوفرة في PyPI.\nلتثبيت المكتبة نستعمل pip على النحو التالي:\npip install python-dateutil\nالآن نستورد المكتبة الأساسية datetime ومكتبة dateutil:\n\nfrom datetime import date, time, datetime, timedelta\nfrom dateutil import tz\n\nنريد الآن معرفة الوقت العالمي والمحلي، وكذلك الوقت في القاهرة، وكذلك الوقت في لندن (هنا قائمة بالأسماء):\n\nprint(datetime.now(tz=tz.tzutc()))\nprint(datetime.now(tz=tz.tzlocal()))\nprint(datetime.now(tz=tz.gettz('Africa/Cairo')))\nprint(datetime.now(tz=tz.gettz('Europe/London')))\n\n2024-11-19 11:52:06.856096+00:00\n2024-11-19 14:52:06.856235+03:00\n2024-11-19 13:52:06.919488+02:00\n2024-11-19 11:52:06.919854+00:00\n\n\nلاحظ أن شكل الوقت كاملاً على النحو التالي:\n    2024-11-19 11:32:35.355104+03:00\n    YYYY-MM-DD HH:MM:SS.ssssss+HH:MM\nنفكك ذلك:\n\nYYYY-MM-DD هو التاريخ (يبدأ بالسنة ثم الشهر ثم اليوم)\nHH:MM:SS.ssssss هو الوقت (بالساعات والدقائق والثواني والميكروثواني)\n+HH:MM هو الفرق بين الوقت المحلي لتلك المنطقة الزمنية والوقت العالمي المنسق (UTC).\n\n\nالتفسير: تحويل النص إلى تاريخ ووقت\nومما تدعمه مكتبة dateutil أفضل بكثير من المكتبة الأساسية، قراءة التواريخ إذ نحتاج لذلك عند استقبال معلومات من الشبكة أو من ملفات أو من المستخدمين:\n\nfrom dateutil.parser import parse\n\nهنا نحدد وقتًا افتراضيًّا عند القراءة، بحيث لو لم توجد المعلومة عند القراءة فإنها تستعمل القيم الافتراضية:\n\nDEFAULT = datetime(2003, 9, 25)\nparse(\"Thu Sep 25 10:36:28\", default=DEFAULT)\n\ndatetime.datetime(2003, 9, 25, 10, 36, 28)\n\n\nونرى كيف أن المفسر يحاول معرفة المعلومات ولو كانت ناقصة:\n\nدون السنة\nدون الشهر\nدون الثواني\nدون اليوم\n\n\nprint(parse(\"Thu Sep 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36:28\", default=DEFAULT))\nprint(parse(\"Thu 10:36\", default=DEFAULT))\nprint(parse(\"10:36\", default=DEFAULT))\n\n2003-09-25 10:36:28\n2003-09-25 10:36:28\n2003-09-25 10:36:00\n2003-09-25 10:36:00\n\n\n\n\nالحسابات الزمنية\n\nfrom dateutil.relativedelta import relativedelta\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nحساب الزمن المنقضي\n\ntoday = datetime.now(tz=tz.tzlocal())\nbirthday = datetime(1970, 1, 1, tzinfo=tz.tzlocal())\nage = relativedelta(today, birthday)\nprint(f'You are {age.years} years and {age.months} months old')\n\nYou are 54 years and 10 months old\n\n\n\n\nحساب الزمن لموعد\n\ntoday = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2025, 1, 15, tzinfo=tz.tzlocal())\ndiff = relativedelta(exam_date, today)\nprint(f'There are {diff.days} days and {diff.hours} hours remaining')\n\nThere are 26 days and 9 hours remaining\n\n\n\n\nمقارنة الوقت\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=9, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif now &gt; exam_date:\n    print('The exam has passed')\nelif now &lt; exam_date:\n    print('The exam is coming')\n\nThe exam has passed\n\n\n\n\nمقارنة الفترة\n\nnow = datetime.now(tz=tz.tzlocal())\nexam_date = datetime(2024, 11, 19, hour=15, minute=30, second=0, tzinfo=tz.tzlocal())\n\nif relativedelta(now, exam_date).hours &lt; 1:\n    print('Hurry up!')\nelif relativedelta(now, exam_date).hours &lt; 4:\n    print(f'Remember you have an exam today at {exam_date:%H:%M}')\nelse:\n    print(f'You have plenty of time to prepare for the exam')\n\nHurry up!\n\n\n\n\nالجمعة القادمة\n\ntoday = datetime.now(tz=tz.tzlocal())\nnext_friday = today + relativedelta(days=+1, weekday=FR)\nprint(f'The next Friday is {next_friday:%Y-%m-%d}')\n\nThe next Friday is 2024-11-22\n\n\n\n\nالجمعة الفائتة\n\nlast_friday = today - relativedelta(days=+1, weekday=FR(-1))\nprint(f'The last Friday is {last_friday:%Y-%m-%d}')\n\nThe last Friday is 2024-11-15\n\n\n\n\nحساب الوقت باعتبار منطقتين زمنيتين\nلديك اجتماع في وقت محدد بتوقيت لندن، وتريد معرفة وقت الوصول بالطائرة إن كانت الرحلة تستغرق 4 ساعات والإقلاع من القاهرة في الساعة 01:00:00 صباحًا والوجهة لندن:\n\ndeparture_tz = tz.gettz('Africa/Cairo')\narrival_tz = tz.gettz('Europe/London')\n\ndeparture_time = datetime(2024, 11, 19, hour=1, tzinfo=departure_tz)\n\narrival_time = departure_time + relativedelta(hours=4)\n\nprint(f'You leave at {departure_time.astimezone(departure_tz)} in Cairo time')\nprint(f'You arrive at {arrival_time.astimezone(arrival_tz)} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz)} in Cairo time')\n\nYou leave at 2024-11-19 01:00:00+02:00 in Cairo time\nYou arrive at 2024-11-19 03:00:00+00:00 in London time\nwhich corresponds to 2024-11-19 05:00:00+02:00 in Cairo time\n\n\n\n\n\nتنسيق التاريخ والوقت\nوانظر الجدول لتنسيق مظهر التاريخ والوقت:\n\nprint(f'Departure time: {departure_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\nprint(f'Arrival time: {arrival_time.astimezone(arrival_tz):%d %b, %X %Z} in London time')\nprint(f'which corresponds to {arrival_time.astimezone(departure_tz):%d %b, %X %Z} in Cairo time')\n\nDeparture time: 19 Nov, 01:00:00 EET in Cairo time\nArrival time: 19 Nov, 03:00:00 GMT in London time\nwhich corresponds to 19 Nov, 05:00:00 EET in Cairo time\n\n\n\n\nالتكرار\nتكرار التواريخ يتم في هذه المكتبة باستعمال rrule ويحدد على النحو التالي:\n\nfrom dateutil.rrule import rrule\nfrom dateutil.rrule import DAILY, WEEKLY, MONTHLY, YEARLY, HOURLY, MINUTELY, SECONDLY\nfrom dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n\nيوم ويوم\nتكرار أوقات بأخذ يوم وترك يوم، ابتداءً من وقت معين في الساعة العاشرة صباحًا:\n\nlist(\n    rrule(DAILY, interval=2, count=10, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 21, 10, 0),\n datetime.datetime(2024, 11, 23, 10, 0),\n datetime.datetime(2024, 11, 25, 10, 0),\n datetime.datetime(2024, 11, 27, 10, 0),\n datetime.datetime(2024, 11, 29, 10, 0),\n datetime.datetime(2024, 12, 1, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 5, 10, 0),\n datetime.datetime(2024, 12, 7, 10, 0)]\n\n\n\n\nأسبوعي\n\nlist(\n    rrule(WEEKLY, interval=1, count=4, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 26, 10, 0),\n datetime.datetime(2024, 12, 3, 10, 0),\n datetime.datetime(2024, 12, 10, 10, 0)]\n\n\n\n\nشهريًّا إلى وقت محدد\n\nlist(\n    rrule(MONTHLY, interval=1,\n        dtstart=datetime(2024, 8, 1),\n        until=datetime(2025, 4, 1),\n    )\n)\n\n[datetime.datetime(2024, 8, 1, 0, 0),\n datetime.datetime(2024, 9, 1, 0, 0),\n datetime.datetime(2024, 10, 1, 0, 0),\n datetime.datetime(2024, 11, 1, 0, 0),\n datetime.datetime(2024, 12, 1, 0, 0),\n datetime.datetime(2025, 1, 1, 0, 0),\n datetime.datetime(2025, 2, 1, 0, 0),\n datetime.datetime(2025, 3, 1, 0, 0),\n datetime.datetime(2025, 4, 1, 0, 0)]\n\n\n\n\nكل 15 دقيقة لمدة 6 مرات\n\nlist(\n    rrule(MINUTELY, interval=15, count=6, dtstart=datetime(2024, 11, 19, hour=10))\n)\n\n[datetime.datetime(2024, 11, 19, 10, 0),\n datetime.datetime(2024, 11, 19, 10, 15),\n datetime.datetime(2024, 11, 19, 10, 30),\n datetime.datetime(2024, 11, 19, 10, 45),\n datetime.datetime(2024, 11, 19, 11, 0),\n datetime.datetime(2024, 11, 19, 11, 15)]\n\n\nوندعوك للاطلاع على المزيد من الأمثلة على مكتبة dateutil.",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "zz_time.html#التاريخ-الهجري-في-بايثون",
    "href": "zz_time.html#التاريخ-الهجري-في-بايثون",
    "title": "18  الوقت",
    "section": "18.4 التاريخ الهجري في بايثون",
    "text": "18.4 التاريخ الهجري في بايثون\nتوفر مكتبة hijridate التعامل مع التاريخ الهجري والتحويل بينه وبين الجريجوري (الميلادي):\n\nfrom hijridate import Hijri, Gregorian\n\ng = Hijri(1446, 5, 17).to_gregorian()\nh = Gregorian(2024, 11, 19).to_hijri()\n\nprint(g)\nprint(h)\n\n2024-11-19\n1446-05-17",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>الوقت</span>"
    ]
  },
  {
    "objectID": "zz_format.html",
    "href": "zz_format.html",
    "title": "19  تنسيق الطباعة",
    "section": "",
    "text": "19.1 المحاذاة والحشو (Alignment and Padding)\nname = 'Adam'\nprint(name.ljust(15)) \nprint(name.center(15))\n\nAdam           \n      Adam\nطريقة ممتعة لتزيين سلسلة نصية باستخدام دالة center:\nprint('*' * 20)\nprint('Adam'.center(20, \"*\"))\nprint('*' * 20)\n\n********************\n********Adam********\n********************",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>تنسيق الطباعة</span>"
    ]
  },
  {
    "objectID": "zz_format.html#المحاذاة-والحشو-alignment-and-padding",
    "href": "zz_format.html#المحاذاة-والحشو-alignment-and-padding",
    "title": "19  تنسيق الطباعة",
    "section": "",
    "text": "جرب\nقم بصياغة الكود السابق لتعريف ثلاثة متغيرات واستخدامها في تزيين الاسم:\n\nname\nwidth\ndecorator",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>تنسيق الطباعة</span>"
    ]
  },
  {
    "objectID": "zz_format.html#تنسيق-الأرقام",
    "href": "zz_format.html#تنسيق-الأرقام",
    "title": "19  تنسيق الطباعة",
    "section": "19.2 تنسيق الأرقام",
    "text": "19.2 تنسيق الأرقام\n\nمحاذاة الأرقام\n\nprint(f'{100:10}')\nprint(f'{1000:10}')\nprint(f'{10000:10}')\n\n       100\n      1000\n     10000\n\n\nيمكننا أيضًا جعل كل من العدد n والتعبئة p متغيرات:\n\nn = 100\np = 5\nprint(f'{n:{p}}')\n\n  100\n\n\nبشكل افتراضي، يتم محاذاة الرقم إلى اليمين. يمكننا محاذاته إلى اليسار بإضافة &lt;. لاحظ الفرق بين التعبيرين أدناه:\n\nprint(f'{n:&gt;{p}}')\nprint(f'{n:&lt;{p}}')\n\n  100\n100  \n\n\n\n\nفاصل الآلاف\n\nbig_num = 10000\nprint(f'{big_num}')\nprint(f'{big_num:,}')\n\n10000\n10,000\n\n\n\n\nالترميز العلمي (Scientific Notation)\n\nsmall_num = 1e-4\nprint(f\"{small_num:.2e}\")\n\n1.00e-04\n\n\n\n\nالأعداد العشرية (Decimals)\n\nnum = 10.5689\nprint(f'{num}')\nprint(f'{num:.4f}')\nprint(f'{num:.2f}')\nprint(f'{num:.0f}')\n\n10.5689\n10.5689\n10.57\n11\n\n\n\nمثال: تنسيق الكم المالي\nهنا نستخدم مكونين داخل الأقواس المعقوفة وعلامة $ في البداية: - يتم إضافة علامة $ قبل الرقم (ليست جزءًا من الرقم المنسق على الإطلاق) - , تضيف فاصل الآلاف - .2f يقوم بتقريب الرقم إلى منزلتين عشريتين\n\nprice = 2978.95\nprint(f\"${price:,.2f}\")\n\n$2,978.95\n\n\n\n\n\nتنسيق كتابة القيَم العددية الثابتة (Number literal formats)\nالحروفيَّة هي رموز للقيم الثابتة لبعض الأنواع المدمجة. مثال: 42 هو حرفيُّ عدد صحيح و 3.14 هو حرفيُّ عدد عشري.\nتسمح بايثون بطرق أكثر قابلية للقراءة في كتابة الحروفية العددية:\n\nيمكن استخدام الشرطة السفلية _ في الأرقام لفصلها لتحسين القراءة\nيمكن استخدام e أو E لتمثيل الترميز العلمي\n0b أو 0B للأرقام الثنائية\n0o أو 0O للأرقام الثمانية\n0x أو 0X للأرقام الست عشرية\nj أو J للأعداد المركبة\n\nوإليك تطبيق ذلك:\n\nassert 1e-4 == 0.0001\nassert 1_000_000 == 1000000\nassert 0b1010 == 10\nassert 0o10 == 8\nassert 0x10 == 16\nassert 1 + 2j == 2j + 1",
    "crumbs": [
      "فروع",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>تنسيق الطباعة</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Appendix A — المصطلحات",
    "section": "",
    "text": "A.1 Tuple",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>المصطلحات</span>"
    ]
  },
  {
    "objectID": "glossary.html#tuple",
    "href": "glossary.html#tuple",
    "title": "Appendix A — المصطلحات",
    "section": "",
    "text": "Etymology. The term originated as an abstraction of the sequence: single, couple/double, triple, quadruple, quintuple, sextuple, septuple, octuple, …, n‑tuple, …, where the prefixes are taken from the Latin names of the numerals. The unique 0-tuple is called the null tuple or empty tuple. Wikipedia",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>المصطلحات</span>"
    ]
  },
  {
    "objectID": "glossary.html#parameter",
    "href": "glossary.html#parameter",
    "title": "Appendix A — المصطلحات",
    "section": "A.2 Parameter",
    "text": "A.2 Parameter\n\nA parameter (from Ancient Greek παρά (pará) ‘beside, subsidiary’ and μέτρον (métron) ‘measure’), generally, is any characteristic that can help in defining or classifying a particular system (meaning an event, project, object, situation, etc.). Wikipedia",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>المصطلحات</span>"
    ]
  }
]